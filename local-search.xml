<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++:ObjectSlicing和多态</title>
    <link href="/2022/07/17/C-objectSlicing%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2022/07/17/C-objectSlicing%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="ObjectSlicing和多态"><a href="#ObjectSlicing和多态" class="headerlink" title="ObjectSlicing和多态"></a>ObjectSlicing和多态</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>多态不过多介绍，在之前写的文章中有讲到,主要从这两方面理解到多态即可:</p><p>1.<a href="https://chillstepp.github.io/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/#%E8%99%9A%E6%8C%87%E9%92%88-vptr-%E5%92%8C%E8%99%9A%E8%A1%A8-vtbl">虚指针(vptr)和虚表(vtbl)</a></p><p>2.<a href="https://chillstepp.github.io/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A">动态绑定和静态绑定</a></p><h2 id="ObjectSlicing对象切片"><a href="#ObjectSlicing对象切片" class="headerlink" title="ObjectSlicing对象切片"></a>ObjectSlicing对象切片</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">string</span> pname;<br><span class="hljs-keyword">public</span>:<br>    Pet(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name):pname(name)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"this is a pet"</span>;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span><span class="hljs-keyword">public</span> Pet<br>&#123;<br>    <span class="hljs-built_in">string</span> act;<br><span class="hljs-keyword">public</span>:<br>    Dog(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; movement):Pet(name), act(movement)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"this is a dog"</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">describe_obj</span><span class="hljs-params">(Pet x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;x.description()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">describe_ptr</span><span class="hljs-params">(Pet* x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;x-&gt;description()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">describe_ref</span><span class="hljs-params">(Pet&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;x.description()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pet* x1 = <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">"why"</span>);<br>    Dog* x2 = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"shy"</span>, <span class="hljs-string">"eating"</span>);<br>    <span class="hljs-comment">//最基本的多态:</span><br>    describe_ptr(x1);<span class="hljs-comment">//this is a pet</span><br>    describe_ptr(x2);<span class="hljs-comment">//this is a dog</span><br><br>    <span class="hljs-comment">//发生object slicing</span><br>    describe_obj(*x1);<span class="hljs-comment">//this is a pet</span><br>    describe_obj(*x2);<span class="hljs-comment">//this is a pet</span><br><br>    <span class="hljs-comment">//引用的底层就是指针，所以引用肯定可以做到多态，因此和结果一保持一致</span><br>    describe_ref(*x1);<span class="hljs-comment">//this is a pet</span><br>    describe_ref(*x2);<span class="hljs-comment">//this is a dog</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个例子告诉我们一些事情：</p><ul><li>这就是必须使用指针或者引用来实现多态的原因，值传递会造成ObjectSlicing</li><li>指针可以做到多态的原因是指针可以动态绑定其他类型，比如pet指针可以动态绑定dog对象，那么此时这个指针的动态类型就是dog了，静态类型是pet。<code>Pet* p = new Dog()</code></li><li>虚函数绑定的是对象的动态类型</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 理解智能指针(手写一个简单的智能指针)</title>
    <link href="/2022/07/17/%E7%90%86%E8%A7%A3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/07/17/%E7%90%86%E8%A7%A3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>简单手写一个智能指针，不会过多关注具体功能上的实现，而是思想上的实现。</p><p>比如指针上的诸多行为<code>++，--</code>这里不会多次提到，而使一些关于智能指针特性和思想的实现。</p><h1 id="RAII与手写智能指针"><a href="#RAII与手写智能指针" class="headerlink" title="RAII与手写智能指针"></a>RAII与手写智能指针</h1><h2 id="RAII准则，封装指针"><a href="#RAII准则，封装指针" class="headerlink" title="RAII准则，封装指针"></a>RAII准则，封装指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape_wrapper</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shape_wrapper</span><span class="hljs-params">(shape* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br>    ~shape_wrapper()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">shape* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    shape* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    shape_wrapper(<span class="hljs-keyword">new</span> shape());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们继续扩展：</p><ul><li>让智能指针不止受限于shape</li><li>添加指针行为</li></ul><h2 id="模板封装"><a href="#模板封装" class="headerlink" title="模板封装"></a>模板封装</h2><p>首先让智能指针不止受限于shape，利用模板即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;(<span class="hljs-keyword">new</span> shape());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="运算符重载模拟指针行为"><a href="#运算符重载模拟指针行为" class="headerlink" title="运算符重载模拟指针行为"></a>运算符重载模拟指针行为</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-comment">//指针行为</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr_;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;ptr(<span class="hljs-keyword">new</span> shape());<br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="添加拷贝构造和赋值"><a href="#添加拷贝构造和赋值" class="headerlink" title="添加拷贝构造和赋值"></a>添加拷贝构造和赋值</h2><p>这是个很难定义行为的问题：</p><p>我们是否应该禁用这种行为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">smart_ptr&lt;shape&gt; ptr1&#123;<span class="hljs-keyword">new</span> shape()&#125;;<br>smart_ptr&lt;shape&gt;ptr2&#123;ptr1&#125;;<br></code></pre></div></td></tr></table></figure><p>这会导致ptr2 ptr1释放同一片区域的内存两次造成崩溃，因此我们暂时考虑禁用这种行为：delete掉拷贝构造和赋值构造即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br>    <span class="hljs-comment">//删除拷贝构造函数和赋值构造函数</span><br>    smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    smart_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> smart_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">//析构函数释放指针</span><br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-comment">//指针行为</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr_;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;ptr(<span class="hljs-keyword">new</span> shape());<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也许我们可以更好的解决这个问题，不再禁用拷贝构造和赋值构造，而是转交指针的的所有权。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//拷贝构造函数和赋值构造函数 转交 指针拥有权</span><br>smart_ptr(smart_ptr&amp; other)<br>&#123;<br>    ptr_ = other.<span class="hljs-built_in">release</span>();<br>&#125;<br>smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">//下面这一句话做了两件事情:</span><br>    <span class="hljs-comment">//1. smart_ptr(rhs) ,拷贝构造出一个匿名变量，rhs的资源被release掉，rhs的指针拥有权转交给了这个匿名变量</span><br>    <span class="hljs-comment">//2. 匿名变量调用了swap函数，this获得了这个所有权，匿名变量走出作用域，自己消失了。</span><br>    smart_ptr(rhs).swap(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这有个疑问： 赋值函数中不都会加上 <code>if (this != &amp;rhs)</code>吗？</p><p>那种用法更啰嗦，而且异常安全性不够好，如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。<br><strong>目前这种惯用法(<a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550" target="_blank" rel="noopener">参考资料</a>)则保证了强异常安全性：</strong>赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br>    <span class="hljs-comment">//拷贝构造函数和赋值构造函数 转交 指针拥有权</span><br>    smart_ptr(smart_ptr&amp; other)<br>    &#123;<br>        ptr_ = other.<span class="hljs-built_in">release</span>();<br>    &#125;<br>    smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr&amp; rhs)<br>    &#123;<br>        <span class="hljs-comment">//下面这一句话做了两件事情:</span><br>        <span class="hljs-comment">//1. smart_ptr(rhs) ,拷贝构造出一个匿名变量，rhs的资源被release掉，rhs的指针拥有权转交给了这个匿名变量</span><br>        <span class="hljs-comment">//2. 匿名变量调用了swap函数，this获得了这个所有权，匿名变量走出作用域，自己消失了。</span><br>        smart_ptr(rhs).swap(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>    &#125;<br><br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        T* ptr = ptr_;<br>        ptr_ = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;<br>        swap(ptr_, rhs.ptr_);<br>    &#125;<br>    <span class="hljs-comment">//指针行为</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr_;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;ptr(<span class="hljs-keyword">new</span> shape());<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到此为止，这就是C++98给出<code>auto_ptr</code>的定义。 不过在C++17已经把<code>auto_ptr</code>删除掉了, 因为这个有很大的问题就是：程序员常常会不小心把<code>smart_ptr</code>传送给另一个，你就不在拥有这个对象了。这里的问题就是你赋值/拷贝时到底希不希望移交所有权，如果不希望移交，只希望多个同时拥有那就是<code>shared_ptr</code>,如果希望移交那就是<code>unique_ptr</code>，那怎么在<code>unique_ptr</code>移交时给一个程序员提醒呢？ 利用左右值，当右值时才可以移交权力。</p><h2 id="添加移动语义-unque-ptr-雏形"><a href="#添加移动语义-unque-ptr-雏形" class="headerlink" title="添加移动语义: unque_ptr() 雏形"></a>添加移动语义: unque_ptr() 雏形</h2><ul><li><p>把拷贝构造函数中的参数类型<code>smart_ptr&amp;</code>改成了 <code>smart_ptr&amp;&amp;</code>, 现在它成了移动构造函数</p></li><li><p>把赋值函数中的参数类型 <code>smart_ptr&amp;</code> 改成了<code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">smart_ptr(smart_ptr&amp;&amp; other)<br>&#123;<br>    ptr_ = other.<span class="hljs-built_in">release</span>();<br>&#125;<br>smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs)<br>&#123;<br>    rhs.swap(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用, 因此我们可以得到一个基本的<code>unique_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br><br>    smart_ptr(smart_ptr&amp;&amp; other)<br>    &#123;<br>        ptr_ = other.<span class="hljs-built_in">release</span>();<br>    &#125;<br>    smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs)<br>    &#123;<br>        rhs.swap(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        T* ptr = ptr_;<br>        ptr_ = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;<br>        swap(ptr_, rhs.ptr_);<br>    &#125;<br>    <span class="hljs-comment">//指针行为</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr_;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;ptr1(<span class="hljs-keyword">new</span> shape());<br><br>    smart_ptr&lt;shape&gt;ptr2&#123;ptr1&#125;;<span class="hljs-comment">// error: use of deleted function 'constexpr smart_ptr&lt;shape&gt;::smart_ptr(const smart_ptr&lt;shape&gt;&amp;)'|</span><br><br>    smart_ptr&lt;shape&gt;ptr3;<br>    ptr3 = ptr1;<span class="hljs-comment">// error: use of deleted function 'constexpr smart_ptr&lt;shape&gt;::smart_ptr(const smart_ptr&lt;shape&gt;&amp;)'|</span><br><br>    ptr3 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(ptr1);<span class="hljs-comment">//ok</span><br>    <br>    smart_ptr&lt;shape&gt; ptr4&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(ptr3)&#125;;<span class="hljs-comment">//ok</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="小细节：子类指针向基类指针的转换"><a href="#小细节：子类指针向基类指针的转换" class="headerlink" title="小细节：子类指针向基类指针的转换"></a>小细节：子类指针向基类指针的转换</h2><p>一个<code>circle*</code> 是可以隐式转换成<code>shape*</code>的，但上面的<code>smart_ptr&lt;circle&gt;</code>却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。这个行为显然还是不够“自然”。</p><p>我们只需要改变一下移动构造函数即可：再加一个模板即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)<br>&#123;<br>ptr_ = other.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们自然而然利用了指针的转换特性：现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给<code>smart_ptr&lt;shape&gt;</code>，但不能移动给<code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    shape()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new shape"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">circle</span>()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"new circle"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span>:<span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span>&#123;&#125;<br><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br>    smart_ptr(smart_ptr&lt;U&gt;&amp;&amp;other)<br>    &#123;<br>        ptr_ = other.<span class="hljs-built_in">release</span>();<br>    &#125;<br><br>    smart_ptr&amp; <span class="hljs-keyword">operator</span>=(smart_ptr rhs)<br>    &#123;<br>        rhs.swap(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~smart_ptr()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr_;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"delete ptr_"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        T* ptr = ptr_;<br>        ptr_ = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;<br>        swap(ptr_, rhs.ptr_);<br>    &#125;<br>    <span class="hljs-comment">//指针行为</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr_;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> ptr_;&#125;<br><span class="hljs-keyword">private</span>:<br>    T* ptr_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//采用RAII帮助我们封装指针，当离开作用域自动调用析构函数，防止内存泄漏</span><br>    smart_ptr&lt;shape&gt;ptr1(<span class="hljs-keyword">new</span> shape());<br><br>    smart_ptr&lt;<span class="hljs-built_in">circle</span>&gt;circle_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">circle</span>());<br>    ptr1 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(circle_ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到此一个有基本功能<code>unique_ptr</code>就完成了</p><h2 id="shared-ptr引用计数实现"><a href="#shared-ptr引用计数实现" class="headerlink" title="shared_ptr引用计数实现"></a><code>shared_ptr</code>引用计数实现</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220715112222225.png" srcset="/img/loading.gif" alt="image-20220715112222225"></p><p>我们需要搞一个类表示共享计数模块：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_count</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    shared_count():count_(<span class="hljs-number">1</span>) &#123;&#125;<br>    void add_count() ++count_;<br>    long long reduce_count() --count_;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count_;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> count_;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>初始化<code>shared_ptr</code>需要构造一个<code>shared_count</code> </p><p>析构函数在看到 <code>ptr_</code>非空时（此时根据代码逻辑，<code>shared_count</code>也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>      shared_count_ =<br>        <span class="hljs-keyword">new</span> shared_count();<br>    &#125;<br>  &#125;<br>  ~smart_ptr()<br>  &#123;<br>    <span class="hljs-keyword">if</span> (ptr_ &amp;&amp;<br>      !shared_count_<br>         -&gt;reduce_count()) &#123;<br>      <span class="hljs-keyword">delete</span> ptr_;<br>      <span class="hljs-keyword">delete</span> shared_count_;<br>    &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  T* ptr_;<br>  shared_count* shared_count_;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>同理swap函数也应该swap掉引用计数模块：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;<br>  swap(ptr_, rhs.ptr_);<br>  swap(shared_count_,<br>       rhs.shared_count_);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>赋值函数可以跟前面一样，保持不变(这是因为赋值函数就是利用拷贝构造和swap实现的)，但拷贝构造和移动构造函数是需要更新一下：更新计数功能</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp; other)<br>&#123;<br>  ptr_ = other.ptr_;<br>  <span class="hljs-keyword">if</span> (ptr_) &#123;<br>    other.shared_count_<br>      -&gt;add_count();<br>    shared_count_ =<br>      other.shared_count_;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)<br>&#123;<br>  ptr_ = other.ptr_;<br>  <span class="hljs-keyword">if</span> (ptr_) &#123;<br>    other.shared_count_<br>      -&gt;add_count();<br>    shared_count_ =<br>      other.shared_count_;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)<br>&#123;<br>  ptr_ = other.ptr_;<br>  <span class="hljs-keyword">if</span> (ptr_) &#123;<br>    shared_count_ =<br>      other.shared_count_;<br>    other.ptr_ = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拷贝构造函数为什么有一个泛型版本 还有一个非泛型版本 但是函数体内容又一模一样 不是代码冗余的吗 是有什么特殊设计意图吗？</p><p><strong>这是一个很特殊的、甚至有点恼人的情况。如果没有非泛型版本，编译器看到没有拷贝构造函数，会生成一个缺省的拷贝构造函数。这样，同样类型的<code>smart_ptr</code>的拷贝构造会是错误的。“子类指针向基类指针的转换”这一节里我也提到了这点。这不是我讲智能指针想讲的内容，所以就淡化了。</strong></p><h2 id="shared-ptr去除release-改用use-count"><a href="#shared-ptr去除release-改用use-count" class="headerlink" title="shared_ptr去除release(),改用use_count()"></a><code>shared_ptr</code>去除<code>release()</code>,改用<code>use_count()</code></h2><p><code>release()</code>是<code>unique_ptr</code>特有的产物，我们不需要在<code>shared_ptr</code>中存在这种东西，我们更需要的是看下引用计数器有多少个： 添加<code>use_count()</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (ptr_) &#123;<br>    <span class="hljs-keyword">return</span> shared_count_<br>      -&gt;get_count();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="shared-ptr最终实现"><a href="#shared-ptr最终实现" class="headerlink" title="shared_ptr最终实现"></a><code>shared_ptr</code>最终实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;  // std::swap</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shared_count</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  shared_count() <span class="hljs-keyword">noexcept</span><br>    : count_(<span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    ++count_;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">reduce_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> --count_;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> count_;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">long</span> count_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">smart_ptr</span>;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">smart_ptr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">    : <span class="hljs-title">ptr_</span><span class="hljs-params">(ptr)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>      shared_count_ =<br>        <span class="hljs-keyword">new</span> shared_count();<br>    &#125;<br>  &#125;<br>  ~smart_ptr()<br>  &#123;<br>    <span class="hljs-keyword">if</span> (ptr_ &amp;&amp;<br>      !shared_count_<br>         -&gt;reduce_count()) &#123;<br>      <span class="hljs-keyword">delete</span> ptr_;<br>      <span class="hljs-keyword">delete</span> shared_count_;<br>    &#125;<br>  &#125;<br><br>  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&amp; other)<br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      other.shared_count_<br>        -&gt;add_count();<br>      shared_count_ =<br>        other.shared_count_;<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other) <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      other.shared_count_-&gt;add_count();<br>      shared_count_ = other.shared_count_;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    ptr_ = other.ptr_;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      shared_count_ =<br>        other.shared_count_;<br>      other.ptr_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  smart_ptr(<span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other,<br>            T* ptr) <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    ptr_ = ptr;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      other.shared_count_<br>        -&gt;add_count();<br>      shared_count_ =<br>        other.shared_count_;<br>    &#125;<br>  &#125;<br>  smart_ptr&amp;<br>  <span class="hljs-keyword">operator</span>=(smart_ptr rhs) <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    rhs.swap(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> ptr_;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr_) &#123;<br>      <span class="hljs-keyword">return</span> shared_count_<br>        -&gt;get_count();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&amp; rhs)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;<br>    swap(ptr_, rhs.ptr_);<br>    swap(shared_count_,<br>         rhs.shared_count_);<br>  &#125;<br><br>  T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> *ptr_;<br>  &#125;<br>  T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> ptr_;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> ptr_;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  T* ptr_;<br>  shared_count* shared_count_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(smart_ptr&lt;T&gt;&amp; lhs,</span></span><br><span class="hljs-function"><span class="hljs-params">          smart_ptr&lt;T&gt;&amp; rhs)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  lhs.swap(rhs);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">static_pointer_cast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  T* ptr = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(other.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">reinterpret_pointer_cast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  T* ptr = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(other.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">const_pointer_cast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  T* ptr = <span class="hljs-keyword">const_cast</span>&lt;T*&gt;(other.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">smart_ptr&lt;T&gt; <span class="hljs-title">dynamic_pointer_cast</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">const</span> smart_ptr&lt;U&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  T* ptr = <span class="hljs-keyword">dynamic_cast</span>&lt;T*&gt;(other.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">return</span> smart_ptr&lt;T&gt;(other, ptr);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101(1-4):图形学数学基础和Transformation</title>
    <link href="/2022/06/26/GAMES101-1-4-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8CTransformation/"/>
    <url>/2022/06/26/GAMES101-1-4-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8CTransformation/</url>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-现代计算机图形学入门"><a href="#GAMES101-现代计算机图形学入门" class="headerlink" title="GAMES101-现代计算机图形学入门"></a>GAMES101-现代计算机图形学入门</h1><h1 id="Lec1-Overview"><a href="#Lec1-Overview" class="headerlink" title="Lec1: Overview"></a>Lec1: Overview</h1><p>本课包含的几个基本的tipic：</p><ul><li><strong>光栅化 Rasterization</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224131034495.png" srcset="/img/loading.gif" alt="image-20220224131034495"></p><ul><li><p><strong>曲线/曲面Curves and Meshes</strong> </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224131112365.png" srcset="/img/loading.gif" alt="image-20220224131112365"></p></li><li><p><strong>光线追踪 Ray Tracing</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224131123501.png" srcset="/img/loading.gif" alt="image-20220224131123501"></p></li><li><p><strong>动画/模拟 Animation/Simulation</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224131243765.png" srcset="/img/loading.gif" alt="image-20220224131243765"></p></li></ul><h1 id="Lec2-Review-of-Linear-Algebra"><a href="#Lec2-Review-of-Linear-Algebra" class="headerlink" title="Lec2: Review of Linear Algebra"></a>Lec2: Review of Linear Algebra</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul><li>$\vec{a}$，代表一个方向，因此向量平移后还代表原向量。</li><li>单位向量：</li></ul><script type="math/tex; mode=display">\begin{align}\hat{a} & = \vec{a} /\|\vec{a}\|\end{align}</script><ul><li>向量求和：平行四边形法则/三角形法则</li></ul><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><ul><li><p>点乘：常用于<strong>计算夹角/向量投影</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224135804807.png" srcset="/img/loading.gif" alt="image-20220224135804807"></p></li><li><p>点乘: 符合 结合律/分配律/交换律</p></li></ul><script type="math/tex; mode=display">\begin{align}\vec{a} \cdot \vec{b} & = \vec{b} \cdot \vec{a} \\\vec{a} \cdot(\vec{b}+\vec{c}) & = \vec{a} \cdot \vec{b}+\vec{a} \cdot \vec{c} \\(k \vec{a}) \cdot \vec{b} & = \vec{a} \cdot(k \vec{b}) \end{align}</script><ul><li><p>点乘还可以用于<strong>区分前后</strong>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224140942497.png" srcset="/img/loading.gif" alt="image-20220224140942497"></p></li></ul><p>​    例如 $\vec{b}，\vec{c}$ 和 $\vec{a}$做点乘，大于0说明在前方，小于0在后方 </p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224141347094.png" srcset="/img/loading.gif" alt="image-20220224141347094"></p><ul><li><p>叉乘出的向量垂直于两个向量 </p></li><li><p>方向：右手定则 (四指从$\bold{a}$绕到$\bold{b}$)  可依法向</p></li><li><script type="math/tex; mode=display">\begin{align}a \times b & = -b \times a \\\|a \times b\| & = \|a\||b| \mid \sin \phi\end{align}</script></li><li><p>一个右手坐标系： $\bold{x} \cross\bold{y} = \bold{z}$</p><p>一个左手坐标系： $\bold{x} \cross\bold{y} = \bold{-z}$</p></li><li><p>基本运算法则：自己叉乘自己是0向量，有分配律</p><script type="math/tex; mode=display">\begin{align}\vec{a} \times \vec{a} & = \overrightarrow{0} \\\vec{a} \times(\vec{b}+\vec{c}) & = \vec{a} \times \vec{b}+\vec{a} \times \vec{c} \\\vec{a} \times(k \vec{b}) & = k(\vec{a} \times \vec{b})\end{align}</script></li><li><p>叉乘可以写成矩阵形式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224142204507.png" srcset="/img/loading.gif" alt="image-20220224142204507"></p></li></ul><ul><li><p>叉乘作用： </p><ul><li><p><strong>判定左/右：</strong> </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224142542031.png" srcset="/img/loading.gif" alt="image-20220224142542031" style="zoom:50%;" /></p><p>如何判断$\bold{b}$是否在$\bold{a}$的左侧？ 用$\bold{a}\cross\bold{b}$即可，判断叉乘是否为正，若为正说明在左侧，反之在右侧。</p></li><li><p><strong>判断一个点是否在一个图形内部：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224142707131.png" srcset="/img/loading.gif" alt="image-20220224142707131" style="zoom:50%;" /></p><p>用$\vec{AB}\cross\vec{AP}$ 若为正说明在$\vec{AB}$左侧，同理计算$\vec{BA}\cross\vec{BP}$ 和$\vec{CA}\cross\vec{CP}$  发现都为正，那么说明这个点 $p$ 都在首位相接的向量的左侧，那么说明在这个首位相接向量构成的图形的内部。</p><p>若这三条边是一个顺时针的呢？同理，会发现都在右边。</p></li></ul></li></ul><h2 id="正交坐标系"><a href="#正交坐标系" class="headerlink" title="正交坐标系"></a>正交坐标系</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224143644277.png" srcset="/img/loading.gif" alt="image-20220224143644277"></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><strong>矩阵乘法：</strong> 第一个矩阵的列数必须等于第二个矩阵的行数</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224144022646.png" srcset="/img/loading.gif" alt="image-20220224144022646"></p><p>矩阵乘法<strong>不符合交换律， 符合结合律/分配律</strong>：</p><script type="math/tex; mode=display">\begin{align}(A B) C & = A(B C) \\A(B+C) & = A B+A C \\(A+B) C & = A C+B C\end{align}</script><p><strong>矩阵-向量乘法：</strong></p><p>把向量当成一个$m*1$的矩阵即可</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224144412666.png" srcset="/img/loading.gif" alt="image-20220224144412666"></p><p><strong>矩阵转置：</strong> </p><script type="math/tex; mode=display">\begin{align}(A B)^{T} & = B^{T} A^{T}\end{align}</script><p><strong>单位矩阵和逆矩阵：</strong></p><script type="math/tex; mode=display">\begin{align}I_{3 \times 3} & = \left(\begin{array}{ccc}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1\end{array}\right) \\A A^{-1} & = A^{-1} A  = I \\(A B)^{-1} & = B^{-1} A^{-1}\end{align}</script><p><strong>点乘叉乘转换成矩阵形式：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224144804908.png" srcset="/img/loading.gif" alt="image-20220224144804908"></p><h1 id="Lec3-变换Transformation"><a href="#Lec3-变换Transformation" class="headerlink" title="Lec3: 变换Transformation"></a>Lec3: 变换Transformation</h1><p>三维到二维投影：三维世界到二维平面</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224145803837.png" srcset="/img/loading.gif" alt="image-20220224145803837"></p><h2 id="Scale-Transform-尺度变换"><a href="#Scale-Transform-尺度变换" class="headerlink" title="Scale Transform/尺度变换"></a>Scale Transform/尺度变换</h2><p><strong>均匀缩放：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150031734.png" srcset="/img/loading.gif" alt="image-20220224150031734"></p><p>写成矩阵形式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150044275.png" srcset="/img/loading.gif" alt="image-20220224150044275" style="zoom:50%;" /></p><p><strong>非均匀缩放：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150204724.png" srcset="/img/loading.gif" alt="image-20220224150204724"></p><p><strong>图像反转：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150413044.png" srcset="/img/loading.gif" alt="image-20220224150413044"></p><h2 id="shear-错切变换-："><a href="#shear-错切变换-：" class="headerlink" title="shear/错切变换 ："></a>shear/错切变换 ：</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150529166.png" srcset="/img/loading.gif" alt="image-20220224150529166"></p><p>相当于y方向大小不变，向右拉扯。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224150852666.png" srcset="/img/loading.gif" alt="image-20220224150852666"></p><h2 id="Rotate-旋转变换-逆时针旋转-theta"><a href="#Rotate-旋转变换-逆时针旋转-theta" class="headerlink" title="Rotate/旋转变换(逆时针旋转$\theta$)"></a>Rotate/旋转变换(逆时针旋转$\theta$)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224151117524.png" srcset="/img/loading.gif" alt="image-20220224151117524" style="zoom:80%;" /></p><p>推导过程(下面推导是针对顺时针旋转$\theta$)：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220626201650342.png" srcset="/img/loading.gif" alt="image-20220626201650342"></p><p>考虑顺时针旋转：顺时针旋转$\theta$相当于逆时针旋转$-\theta$，那么带入后会发现$\R<em>{-\theta}$的结果就等于$R</em>{\theta}^T$ 即顺时针旋转的逆矩阵。同时会发现</p><script type="math/tex; mode=display">R_{\theta}^T = R_{\theta}^{-1}</script><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225121214687.png" srcset="/img/loading.gif" alt="image-20220225121214687" style="zoom:80%;" /></p><p>因<strong>此如果想让一个坐标顺时针旋转，左乘$R<em>{\theta}^T $或者$ R</em>{\theta}^{-1}$都是可以的。</strong></p><h2 id="homogeneous-coordinates-齐次坐标"><a href="#homogeneous-coordinates-齐次坐标" class="headerlink" title="homogeneous coordinates/齐次坐标"></a>homogeneous coordinates/齐次坐标</h2><p>齐次坐标常用来做平移。</p><p>因为原来的二维矩阵乘坐标后总会含有x/y，无法表示一个常数项的偏移，不妨<strong>给变换矩阵加一个维度表示偏移</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224152846438.png" srcset="/img/loading.gif" alt="image-20220224152846438"></p><p><strong>但是对于一个向量：由于它具有平移不变性，加的齐次坐标只能是0</strong>，为的是如果有一个向量也经过这个平移变换矩阵后不会影响他。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224152954024.png" srcset="/img/loading.gif" alt="image-20220224152954024"></p><p><strong>同时齐次坐标的做法还保证了下面的性质：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224153242497.png" srcset="/img/loading.gif" alt="image-20220224153242497"></p><p>最后一个点+点一般认为是没意义的，我们也可以这么理解：</p><p>我们总是保证第三位的齐次坐标是1，那么<strong>点+点就是中点</strong>。</p><h2 id="Affine-Transformation-仿射变换"><a href="#Affine-Transformation-仿射变换" class="headerlink" title="Affine Transformation/仿射变换"></a>Affine Transformation/仿射变换</h2><p>我们可以把以上总结为仿射变换：同时包含平移和缩放变换。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224153616680.png" srcset="/img/loading.gif" alt="image-20220224153616680"></p><h2 id="变换的顺序问题"><a href="#变换的顺序问题" class="headerlink" title="变换的顺序问题"></a>变换的顺序问题</h2><p><strong>先平移后旋转</strong>  和 <strong>先旋转后平移</strong> 是不同的(矩阵是不满足交换律的)。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224154214905.png" srcset="/img/loading.gif" alt="image-20220224154214905"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224154221144.png" srcset="/img/loading.gif" alt="image-20220224154221144"></p><p><strong>组合变换：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224154621912.png" srcset="/img/loading.gif" alt="image-20220224154621912"></p><p>矩阵虽然没有交换律但有结合律：我们可以提前把$M = A_n…A_2A_1$先算出来，那么对于其他点也做同样的变换时：我们可以直接让他乘上这个矩阵，<strong>提高了效率</strong>。</p><p><strong>分解变换：</strong></p><p>组合变换的逆过程</p><p>假如我们希望绕原点旋转：首先需要移到原点，然后旋转，再移动回去。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224155024689.png" srcset="/img/loading.gif" alt="image-20220224155024689"></p><h1 id="Lec4-Transformation-Cont"><a href="#Lec4-Transformation-Cont" class="headerlink" title="Lec4: Transformation Cont."></a>Lec4: Transformation Cont.</h1><h2 id="模型变换-modeling-transformation"><a href="#模型变换-modeling-transformation" class="headerlink" title="模型变换(modeling transformation)"></a>模型变换(modeling transformation)</h2><h3 id="3D-transformation"><a href="#3D-transformation" class="headerlink" title="3D transformation"></a>3D transformation</h3><p>和二维没有什么区别，多了一维$z$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224155444030.png" srcset="/img/loading.gif" alt="image-20220224155444030"></p><p>现在的仿射变换矩阵就是4*4的矩阵：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224155531007.png" srcset="/img/loading.gif" alt="image-20220224155531007"></p><p><strong>缩放和平移：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225122353414.png" srcset="/img/loading.gif" alt="image-20220225122353414"></p><h3 id="3D-旋转"><a href="#3D-旋转" class="headerlink" title="3D 旋转"></a>3D 旋转</h3><p>一个旋转可以分解成三部分：绕x轴转，绕y轴转，绕z轴转。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225122415119.png" srcset="/img/loading.gif" alt="image-20220225122415119"></p><p>对于绕x，绕z，发现只需要把会动的对应坐标轴对应写成二维旋转的形式即可。</p><p>但是<strong>对于绕y轴旋转会发现，他对应的矩阵中包含$\alpha$的地方都变成了相反的(观察橙色部分)。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225123106720.png" srcset="/img/loading.gif" alt="image-20220225123106720" style="zoom:80%;" /></p><p>但这是正确的，通过右手螺旋定则发现:</p><ul><li>绕$x$轴转动时，$y \cross z$的方向就是$x$的方向</li><li>绕$z$轴转动时，$x \cross y$的方向就是$z$的方向</li><li><strong>而绕$y$轴转动时，$x \cross z$的方向却是$-y$的方向，因此想要逆时针转应该加上转置或者取逆。</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225123643571.png" srcset="/img/loading.gif" alt="image-20220225123643571"></p><p>因此:</p><ul><li><p><strong>任何一个旋转都可以看成绕$x$轴转，绕$y$轴转，绕$z$轴转的合成.</strong></p></li><li><p><strong>$\alpha,\beta,\gamma$叫做欧拉角</strong></p></li></ul><p><strong>罗德里格斯旋转公式：</strong></p><p>我们还有一种常用的方式是：<strong>绕着某一个轴旋$\bold{n}$转一个角度$\alpha$，这会利用到罗德里格斯旋转公式</strong>。<strong>(在这里我们默认旋转轴过的是原点)</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225124140174.png" srcset="/img/loading.gif" alt="image-20220225124140174"></p><p>如果有需要让他绕着非过原点的旋转轴怎么办？ <strong>先平移再旋转再平移回来即可。</strong></p><h2 id="相机变换-Camera-transformation"><a href="#相机变换-Camera-transformation" class="headerlink" title="相机变换(Camera transformation)"></a>相机变换(Camera transformation)</h2><p>这一部分本质就是找一个位置放置照相机。</p><p>因此我们需要这几个要素：</p><ul><li>相机的位置 $\vec{e}$</li><li>向哪儿里看 $\hat{g}$</li><li>相机向上朝向的方向 $\hat{t}$  （注意有相机位置和朝向后并不能确定的排除一个照片，因为相机还可以绕着$\hat{g}$旋转，造成找出的照片角度不同）</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225125219638.png" srcset="/img/loading.gif" alt="image-20220225125219638"></p><p>首先我们规定一个相机标准位置：位于原点，相机上方方向为$y$轴，相机朝向为$-z$方向。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225125904181.png" srcset="/img/loading.gif" alt="image-20220225125904181"></p><p>其中前三部做到，第四步就自然而然做到了，<strong>因此我们只需要对前三部操作即可</strong>。下面考虑把以上这些操作写成一个矩阵：</p><ul><li><p>首先需要移到原点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225130457579.png" srcset="/img/loading.gif" alt="image-20220225130457579"></p></li><li><p>随后需要做旋转，把一个向量旋转到 $-z$或是$y$都是不容易的，不妨考虑他的逆过程，从$x$轴到$g\cross t$ ，$y$轴到$t$，$z$轴到$-g$ 是有公式可用的，即$R_{view}^{-1}$ 。 </p><p>这里的$R_{view}^{-1}$ 怎么得来的呢？</p><p>我们希望把向量$x(1,0,0,0)$ 向量$y(0,1,0,0)$ 向量$z(0,0,1,0)$ 转移到 $t,-g,g × t$构成的新坐标系。简单来说我们希望：从$x$轴到$g\cross t$ ，$y$轴到$t$，$z$轴到$-g$ 的映射被矩阵$R<em>{view}^{-1}$表达出来，我们可以把向量$x(1,0,0,0)$ 向量$y(0,1,0,0)$ 向量$z(0,0,1,0)$ 左乘$R</em>{view}^{-1}$发现：得到的正好是对应的新轴的x的坐标。下面我举个例子，以x:$(1,0,0,0)^T$为例，左乘$ R_{view}^{-1} $得到：</p><script type="math/tex; mode=display">\left(x_{\hat{g} \times \hat{t}}, y_{\hat{g} \times \hat{t}}, z_{\hat{g} \times \hat{t}}\right)</script><p>说明这个旋转矩阵可以把x向量经过旋转成为了$g\cross t$ 向量，也就是我们希望对应上的向量。我们可以发现这种旋转矩阵的构造十分自然美妙。</p><p>在上一节提到了旋转矩阵的逆矩阵等价于转置矩阵，因此$R<em>{view}$ 等价于 ${R</em>{view}^{-1}}^T$ 。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225130939027.png" srcset="/img/loading.gif" alt="image-20220225130939027"></p></li></ul><p>到此完成了基本的视图变换。</p><h2 id="投影变换-projection-transformation"><a href="#投影变换-projection-transformation" class="headerlink" title="投影变换(projection transformation)"></a>投影变换(projection transformation)</h2><p><strong>透视投影 vs. 正交投影：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225132014391.png" srcset="/img/loading.gif" alt="image-20220225132014391"></p><p>我们看左图的透视投影，远近不同，球大小也有区别，而正交投影没有这个特点。</p><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p>如何做一个正交投影？</p><ul><li>平移到原点</li><li>尺度变换：缩小长高宽到2，这样可以使得一个长方体变成$[-1,1]^3$的标准立方体。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225133356723.png" srcset="/img/loading.gif" alt="image-20220225133356723"></p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>一组平行线在透视投影中是可能相交的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225133902112.png" srcset="/img/loading.gif" alt="image-20220225133902112" style="zoom:50%;" /></p><p><strong>怎么做透视投影？</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225134258762.png" srcset="/img/loading.gif" alt="image-20220225134258762"></p><ul><li>把截头锥体压扁成一个长方体</li><li>做正交投影</li></ul><p>正交投影我们会做，那么现在只需要如何压扁一个截头锥体：</p><p>不妨先考虑在$yz$平面上如何变化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225134946865.png" srcset="/img/loading.gif" alt="image-20220225134946865"></p><p>同理在$xz$平面上也是这样：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225135058817.png" srcset="/img/loading.gif" alt="image-20220225135058817"></p><p>因此我们直接分别对x和y进行变换压缩至x’,y’处(注：此时z轴变换暂时不考虑)：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225140504415.png" srcset="/img/loading.gif" alt="image-20220225140504415"></p><p>那么什么矩阵可以做一个这样的变化呢？我们设这个矩阵为$M_{persp \to ortho}$, 即希望找出下面这样的一个矩阵：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225140749406.png" srcset="/img/loading.gif" alt="image-20220225140749406"></p><p>这个矩阵的1，2，4行是很容易确认的，即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225140859407.png" srcset="/img/loading.gif" alt="image-20220225140859407"></p><p>现在只需填上第三层即可，透视投影的一个特性是：<strong>截头锥体的前后面变换之后z坐标不变</strong>，因此我们可以找出两个特殊的点：</p><ul><li>近平面上任何一点通过投影变换后z坐标不会变(即坐标(x,y,n))</li><li>远平面上任何一点通过投影变换后z坐标不会变(即坐标(x,y,f))</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225141309646.png" srcset="/img/loading.gif" alt="image-20220225141309646"></p><p>我们希望 坐标(x,y,n) 变换后的z轴还是n：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225141626393.png" srcset="/img/loading.gif" alt="image-20220225141626393"></p><p>只需要让$M_{persp \to ortho}$ 的第三行符合下式(0 0 A B)的形式，并满足和近平面坐标相乘后等于$n^2$：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225141800386.png" srcset="/img/loading.gif" alt="image-20220225141800386"></p><p>但此时AB还是没有具体求出来，不妨再考虑一下原平面，同理得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225142010096.png" srcset="/img/loading.gif" alt="image-20220225142010096"></p><p>因此就可以解出AB分别为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220225142029733.png" srcset="/img/loading.gif" alt="image-20220225142029733"></p><p>那么现在做透视投影就可以直接这么运算： 先将透视投影转换为正交投影，然后再做正交投影。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220626225733597.png" srcset="/img/loading.gif" alt="image-20220626225733597"></p><p><strong>在透视投影转正交投影的变换中有个反常识的现象：</strong> 也就是截头锥体的中间一点(x,y,z) 其中f&gt;z&gt;n, 这样的一点在经过透视投影转正交投影变换矩阵时，会变得更加接近f面, 更远离n，也就是变换后的坐标回会比z更小。证明如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220626234122473.png" srcset="/img/loading.gif" alt="image-20220626234122473"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/J(D" srcset="/img/loading.gif" alt="img">0~VJ@7QRIZ%X{}RS9KK.png)</p><h2 id="视口变换-ViewPort-Transformation"><a href="#视口变换-ViewPort-Transformation" class="headerlink" title="视口变换(ViewPort Transformation)"></a>视口变换(ViewPort Transformation)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627200006332.png" srcset="/img/loading.gif" alt="image-20220627200006332"></p><p>我们希望把$[-1,1]^3$的拉伸成$[0,  width]×[0,height]$, <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627200150126.png" srcset="/img/loading.gif" alt="image-20220627200150126"></p><p>我们直接做scale+偏移：宽度上原来是-1，1扩大到$[-width/2，+width/2]$, height同理，同时我们还需要做完后做一个偏移，让范围变到$[0,width]*[0,height]$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627200423868.png" srcset="/img/loading.gif" alt="image-20220627200423868"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>GAMES101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101(5-6):Rasterization和反走样</title>
    <link href="/2022/06/26/GAMES101-5-6-Rasterization%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/"/>
    <url>/2022/06/26/GAMES101-5-6-Rasterization%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-5-6-Rasterization和反走样"><a href="#GAMES101-5-6-Rasterization和反走样" class="headerlink" title="GAMES101(5-6):Rasterization和反走样"></a>GAMES101(5-6):Rasterization和反走样</h1><h2 id="Rasterization-Triangles"><a href="#Rasterization-Triangles" class="headerlink" title="Rasterization(Triangles)"></a>Rasterization(Triangles)</h2><p>简单来说光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程，因为我们的物体其实都是一个个顶点数据来表示的，如何表这些蕴含几何信息的数据转化为屏幕上的像素就是光栅化所考虑的东西。比如说一条直线，究竟该用哪些像素点去逼近它，一个三角形，又用哪些像素集合表示它，这都是光栅化的过程。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627201503729.png" srcset="/img/loading.gif" alt="image-20220627201503729"></p><p>采样的方法：也就是判断每个点是不是再三角形内。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627201537420.png" srcset="/img/loading.gif" alt="image-20220627201537420"></p><p>怎么计算是否在三角形内？叉积，看是不是在同一侧。我们也需要注意下在三角形边上的处理，即叉积等于0的情况，可以认为在三角形内/也可以认为在三角形外。</p><p>如何加速这个过程，对于一些一定不可能的点无需判断是否在三角形内：<strong>包围盒</strong>！</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627201958345.png" srcset="/img/loading.gif" alt="image-20220627201958345"></p><p>更快的方法？可以对每一行进行扫描，出了范围就不再考虑到下一行，具体如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627202032627.png" srcset="/img/loading.gif" alt="image-20220627202032627"></p><h2 id="Rasterzation-Antialiasing-and-Z-Buffer-，反走样和深度缓冲"><a href="#Rasterzation-Antialiasing-and-Z-Buffer-，反走样和深度缓冲" class="headerlink" title="Rasterzation(Antialiasing and Z-Buffer)，反走样和深度缓冲"></a>Rasterzation(Antialiasing and Z-Buffer)，反走样和深度缓冲</h2><h3 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h3><p>采样的方法会产生Artifacts(瑕疵/不真实)，如锯齿和摩尔纹</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627203211900.png" srcset="/img/loading.gif" alt="image-20220627203211900"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627203250868.png" srcset="/img/loading.gif" alt="image-20220627203250868"></p><p>反走样的技术：</p><ul><li>模糊后再采样：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627203603753.png" srcset="/img/loading.gif" alt="image-20220627203603753"></p><p>先采样再模糊效果远不如先模糊再采样：</p><p>左图：先采样在模糊  右图：先模糊再采样</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627203655313.png" srcset="/img/loading.gif" alt="image-20220627203655313"></p><p>傅里叶变换可以帮助我们描述一个复杂的函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627204724323.png" srcset="/img/loading.gif" alt="image-20220627204724323"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627204800289.png" srcset="/img/loading.gif" alt="image-20220627204800289"></p><p>通过对下面不同频率的函数采样可以发现：</p><ul><li>采样频率高可以更好的反应函数的情况</li><li>函数频率高采样不容易反应出函数的情况</li><li>因此我们需要让 <strong>采样的频率  跟的上 函数的频率</strong></li><li>走样本质就是 采样无法分开两种频率的函数</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220627204950010.png" srcset="/img/loading.gif" alt="image-20220627204950010"></p><h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><p>我们对一张图片做傅里叶变换，亮的地方表示低频信号，暗的地方表示高频信号。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630120118953.png" srcset="/img/loading.gif" alt="image-20220630120118953"></p><p>高通滤波：把低频信号抹去，留下高频。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630120230975.png" srcset="/img/loading.gif" alt="image-20220630120230975"></p><p>低通滤波：把高频信息抹去</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630120427981.png" srcset="/img/loading.gif" alt="image-20220630120427981"></p><p>下面利用卷积实现了模糊的操作，可以发现滤波器的频域主要是保留低频信息： 在频域上表现为 图像的频域和卷积的频域相乘。</p><p><strong>时域的卷积等于频域的乘积，反之亦然，时域的乘积等于频域的卷积</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630120747997.png" srcset="/img/loading.gif" alt="image-20220630120747997"></p><p>平均滤波器的size越大，其实会越模糊，表现在频域上为低频滤波减少(白点变小)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630122012669.png" srcset="/img/loading.gif" alt="image-20220630122012669"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630121953019.png" srcset="/img/loading.gif" alt="image-20220630121953019"></p><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p>采样就是重复频域上的内容</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630134110852.png" srcset="/img/loading.gif" alt="image-20220630134110852"></p><p>冲激函数相当于采样，冲激函数(c)和(a)相乘得到(e), 可以发现相当于对a进行了采样，反映在频域上，时域上的乘积等于频域上的卷积，得到(f)，那么采样在频域上就是重复频谱。</p><p>在下图，采样频率过低会导致采样的频域间距大，频谱间隔小，导致频谱的混合，导致了走样</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630134612296.png" srcset="/img/loading.gif" alt="image-20220630134612296"></p><h3 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630134903533.png" srcset="/img/loading.gif" alt="image-20220630134903533"></p><p>首先可以提高采样频率：即分辨率更高的显示器，像素点高，采样频率高。但是这种物理方法不是我们关注的方向。</p><p>还记得我们前面说的反走样方法吗？<strong>先模糊，再采样。</strong></p><p>模糊可以把高频信息拿走，频谱覆盖的面小一些。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630135224063.png" srcset="/img/loading.gif" alt="image-20220630135224063"></p><p>我们用低通滤波器对三角形做卷积即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630135358262.png" srcset="/img/loading.gif" alt="image-20220630135358262"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630135439549.png" srcset="/img/loading.gif" alt="image-20220630135439549"></p><p>我们希望计算一个像素里三角形部分占多少，然后算一个颜色。但实际上这件事很难。这会消耗大量时间</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630135651582.png" srcset="/img/loading.gif" alt="image-20220630135651582"></p><h3 id="SSAA-SuperSampling-AntiAliasing-超采样反走样"><a href="#SSAA-SuperSampling-AntiAliasing-超采样反走样" class="headerlink" title="SSAA(SuperSampling AntiAliasing)超采样反走样"></a>SSAA(SuperSampling AntiAliasing)超采样反走样</h3><p>SSAA首先是模糊，然后把一个像素分成多份(比如$2*2$四份)，会对每一个pixel的subpixel都进行shading(着色计算)。 最后这个pixel的颜色等于四个subpixel的颜色的加权和。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630173620785.png" srcset="/img/loading.gif" alt="image-20220630173620785"></p><h3 id="MSAA-MultiSampling-Anti-Aliasing-多重采样反走样"><a href="#MSAA-MultiSampling-Anti-Aliasing-多重采样反走样" class="headerlink" title="MSAA(MultiSampling Anti-Aliasing)多重采样反走样"></a>MSAA(MultiSampling Anti-Aliasing)多重采样反走样</h3><p><strong>SSAA缺点</strong>很明显就是<strong>太慢</strong>，<strong>每个pixel需要计算4次(假设$2*2$情况时)shading</strong>。</p><p>MSAA最大的特点就是per pixel shading而不是per subpixel shading，这样对gpu的压力就减少很多。</p><p>下面介绍MSAA详细操作，体会下他的优势：</p><p>同样第一步需要先模糊, 然后我们把一个像素分成多份：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630140419631.png" srcset="/img/loading.gif" alt="image-20220630140419631"></p><p>原三角形</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630140441479.png" srcset="/img/loading.gif" alt="image-20220630140441479"></p><p>$2*2$超采样</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630140503622.png" srcset="/img/loading.gif" alt="image-20220630140503622"></p><p>计算加权颜色时：</p><p>这里SSAA则会在pixel shader着色阶段对pixel的每个subpixel进行计算，以上面图为例子就是需要计算4次。</p><p>而MSAA则只对pixel计算颜色，然后算subpixel有多少在三角形里(设为x)，$(包含的个数x/4)*pixel颜色$，然后一次pixel shading即可。</p><blockquote><p>作者：文刀秋二<br>链接：<a href="https://www.zhihu.com/question/20236638/answer/44821615" target="_blank" rel="noopener">https://www.zhihu.com/question/20236638/answer/44821615</a></p><p>拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，<strong>光栅化和着色的计算负荷都比原来多了4倍</strong>，render target的大小也涨了4倍。</p><p>MSAA（Multi-Sampling AA）则很聪明的<strong>只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本</strong>（Coverage sample），<strong>但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630140534332.png" srcset="/img/loading.gif" alt="image-20220630140534332"></p><p>更多的 反走样/超采样 方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220630141703852.png" srcset="/img/loading.gif" alt="image-20220630141703852"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>GAMES101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/2022/05/27/C-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/05/27/C-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="ariadic-Templates数量不定的模板参数"><a href="#ariadic-Templates数量不定的模板参数" class="headerlink" title="ariadic Templates数量不定的模板参数"></a>ariadic Templates数量不定的模板参数</h2><p>下面是一个数量不定的模板参数的例子，<code>print()</code>函数做得是一个将一堆参数输出的动作。</p><p>每次取出第一个参数输出，剩下的参数包递归下去每次输出参数的第一个。但请不要忘记写<code>void print(){ }</code>，因为当参数空的时候，你需要一个无参的<code>print</code>来结束print的递归。</p><p>如果你想知道 后面那一部分参数包有几个，你可以使用<code>sizeof...(args)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;firstArg&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"123"</span>,<span class="hljs-string">"456"</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面考虑这样一个函数可以和上面的<code>void print(const T&amp; firstArg,const Types&amp;... args)</code>函数共存吗？一般来说答案是否定的，但是在Variadic Templates中是允许的, 即C++不认为这是有歧义的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这两者的谁更泛化，谁更特化？当然是第一种的<code>void print(const T&amp; firstArg,const Types&amp;... args)</code>更特化。</p><p>标准库中有一个很好的例子如下图，<code>hash_val</code>有三个版本，分别是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>&amp; seed, <span class="hljs-keyword">const</span> T&amp; val, <span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span><br>template&lt;typename... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>&amp; seed, <span class="hljs-keyword">const</span> T&amp; val)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506124336704.png" srcset="/img/loading.gif" alt="image-20220506124336704"></p><p>如上图②会一直调用自己本身，直到<code>args...</code>只剩下一个时则会调用③。</p><p>而③由于第一参数不是<code>size_t&amp;</code>没有其他人特化，所以一直没有被调用。当第一参数不是<code>size_t&amp;</code>时的函数调用时他这个更泛化的版本才会被调用到。</p><p>Tuple的实现也利用了Variadic Template来做递归继承。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506130058768.png" srcset="/img/loading.gif" alt="image-20220506130058768"></p><h2 id="Spaces-in-Template-Expressions"><a href="#Spaces-in-Template-Expressions" class="headerlink" title="Spaces in Template Expressions"></a>Spaces in Template Expressions</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-comment">//C++11 before</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;  <span class="hljs-comment">//C++11 now</span><br></code></pre></div></td></tr></table></figure><p>原来编译器不够智能会导致<code>&gt;&gt;</code>被认为是流操作符，现在已经可以这么使用了</p><h2 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a><code>nullptr</code> and <code>std::nullptr_t</code></h2><p>在nullptr出现之前，我们一直使用NULL代表指针的空，其实NULL定义就是0，这会带来一些问题：<br><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506131109845.png" srcset="/img/loading.gif" alt="image-20220506131109845"></p><p><code>f(NULL)</code>会带来歧义，为了解决这个歧义，C++11提出了<code>nullptr</code>关键字，他的类型是：<code>std::nullptr_t</code></p><p>这个类型是如何定义的呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506131438319.png" srcset="/img/loading.gif" alt="image-20220506131438319"></p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>使用它来做自动类型推导，可以和其他操作符<code>（&amp;，*，const）</code>，一般来说<code>auto</code> 是<strong>根据变量的初始值来推导出变量类型的</strong>，比如一些容器的迭代器完整写下来就很长，使用auto就很方便</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span> , b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span>* pointer = &amp;b;<span class="hljs-comment">//和*一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;*pointer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">auto</span>&amp; refer = a;<span class="hljs-comment">//和&amp;一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;refer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> ConstVar = b;<span class="hljs-comment">//和const一起用</span><br>ConstVar = <span class="hljs-number">2</span>;<span class="hljs-comment">//报错:ConstVar是read-only的</span><br></code></pre></div></td></tr></table></figure><p>auto只建议在类型过长时使用，例如lambda表达式的类型，迭代器等…，而不该滥用auto</p><h3 id="auto-trick"><a href="#auto-trick" class="headerlink" title="auto trick"></a>auto trick</h3><ul><li><strong><code>=</code>右边是一个引用类型时<code>auto</code>会自动把引用抛弃，推导出原始类型：这是符合直觉的，我们希望引用与否掌握在程序员手上，因此这种帮助了我们根据意志自由决定。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;ref = x;<br><span class="hljs-keyword">auto</span> test = ref;<span class="hljs-comment">//tesr推导出的类型为test</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</strong></li><li><strong>当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</strong></li></ul><p>对于上边两条做出解释：</p><p>1.当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> y = x;<span class="hljs-comment">//y是int类型，会抛弃const</span><br></code></pre></div></td></tr></table></figure><p>2.当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> t = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a = t;<br><span class="hljs-keyword">auto</span> test1 = a;<span class="hljs-comment">//test1推导出int类型,给程序员自由</span><br><span class="hljs-keyword">auto</span> &amp;test2 = a;<span class="hljs-comment">//test2推导出const int&amp;类型，其中auto为const int</span><br></code></pre></div></td></tr></table></figure><p>这么做的原因是为了安全，如果你的auto推出的是int，那么也就是说可以通过这个引用去修改一个const的变量，这是不合理的(编译器会禁止这样做)。因此为了合理性、安全性，推导出<code>const int</code>是最好的选择。</p><ul><li><strong>auto 不能在函数的参数中使用 (版本低于C++20)</strong></li></ul><p>如果为了减少代码重复，模板是一个更好的替代方法</p><p><strong>注意：C++20已经允许auto在函数参数中使用了</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"123"</span>;<br>    <span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"345"</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;fun(s1,s2)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">auto</span> x;<span class="hljs-comment">//error: non-static data member declared with placeholder 'auto'|</span><br>    <span class="hljs-keyword">auto</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.x = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>auto 关键字不能定义数组 （char[]不行，用char*的可以）</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a[<span class="hljs-number">4</span>] = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//error:'a' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span> b[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//error:'b' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span>* c = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//ok</span><br></code></pre></div></td></tr></table></figure><p>Reference : <a href="https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables" target="_blank" rel="noopener">https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables</a></p><p>虽然<code>auto x[4] ={ ....}</code>是一个错误的用法，但是<code>auto x = {1,2,3,4}</code>会推出<code>x</code>是一个<code>std::initializer_list&lt;int&gt;</code>类型。</p><ul><li><strong>auto 不能作用于模板参数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A&lt;<span class="hljs-keyword">int</span>&gt; C1;<br>    A&lt;<span class="hljs-keyword">auto</span>&gt; C2 = C1;  <span class="hljs-comment">//错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Uniform-Initialization一致性初始化"><a href="#Uniform-Initialization一致性初始化" class="headerlink" title="Uniform Initialization一致性初始化"></a>Uniform Initialization一致性初始化</h2><p>在C++11之前初始化一个东西的方式各种各样，为了解决这个问题:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506132934801.png" srcset="/img/loading.gif" alt="image-20220506132934801"></p><p>C++11提出了<code>Uniform Initialization</code>, 即变量后边设置花括号来初始化:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506133023489.png" srcset="/img/loading.gif" alt="image-20220506133023489"></p><p>编译器可以通过<code>&lt;T&gt;</code>来获取模板中的类型，然后看到<code>{t1,t2,t3...}</code>便做出一个<code>initializer_list&lt;T&gt;</code>，他背后本质是<code>array&lt;T,n&gt;</code>，其中n代表花括号中的个数，调用函数(比如构造函数)时，array内的元素可以被编译器分解注意传送给函数。</p><p>那如果一个类就有接受<code>initializer_list&lt;T&gt;</code>类型的构造函数呢？那么就会把<code>initializer_list&lt;T&gt;</code>直接作为参数传递，而无需分解。标准库中的容器都有 带有这种参数的构造函数。</p><p>因此<code>initializer_list&lt;T&gt;</code>是有两种方法来被函数解析的：一种是直接作为整体传入函数，另一种是通过背后的array分解成n个元素一个一个传给构造函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506134418097.png" srcset="/img/loading.gif" alt="image-20220506134418097"></p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer_list"></a>Initializer_list</h2><p>花括号可以用来设初值：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509130925182.png" srcset="/img/loading.gif" alt="image-20220509130925182"></p><p>Initializer_list的初始化方法和原来小括号的初始化在一些地方是有区别的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509131052216.png" srcset="/img/loading.gif" alt="image-20220509131052216"></p><p>Initializer_list不允许窄化的转型，例如float转int是不允许的，而用7初始化char是允许的。在某些编译器上只会给出警告，有些编译器会给出error。</p><p>当存在两个版本的构造函数：分别为普通的方法和<code>Initializer_list</code>的方法，那么调用时如果使用了花括号就调<code>Initializer_list</code>的版本，如果使用了<code>()</code>初始化的方式就会调用普通的构造函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509132106296.png" srcset="/img/loading.gif" alt="image-20220509132106296"></p><p>那么<strong>当没有<code>Initializer_list</code>版本②的存在时，只存在普通版本①时，<code>{}</code>依然可以初始化，编译器会帮我们拆解开<code>{}</code>里的内容，然后再调用到版本①。</strong></p><p>观察下面的代码红框中，编译器可以调用一个私有的<code>Initializer_list</code>的构造函数，因此编译器会构造出来他，给他分配一个array的头的迭代器，array中存有初始化花括号中的数据，这验证了前面我们所说的，<code>Initializer_list</code>的内部实现有array在支持。这也提示我们在拷贝<code>Initializer_list</code>时要小心，这会导致多个迭代器指向同一片区域，他们共有array这一片区域，而非独占，因为这是浅拷贝。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509132858898.png" srcset="/img/loading.gif" alt="image-20220509132858898"></p><p><code>Initializer_list</code>给了我们更多符合直觉的方法，比如min在<code>Initializer_list</code>的支持下，可以在底层用min_element改进一下，从而可以同时比较多个数，同理vector中的insert函数也可以一次insert多个。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509134553763.png" srcset="/img/loading.gif" alt="image-20220509134553763"></p><h2 id="Explicit-for-ctors-taking-more-than-one-arguement"><a href="#Explicit-for-ctors-taking-more-than-one-arguement" class="headerlink" title="Explicit for ctors taking more than one arguement"></a>Explicit for ctors taking more than one arguement</h2><p>首先要理解什么是Explicit：<a href="https://chillstepp.github.io/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0non-explicit-one-argument-ctor">原来的博文有详细介绍Explict和non-Explict</a></p><p>Explicit中文译为明白的明确的，简单来说就是不要隐式调用构造函数，如下图。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509192940333.png" srcset="/img/loading.gif" alt="image-20220509192940333"></p><p>在C++11以前，隐式调用只存在于单一实参的构造函数(Non-Explict One Arguement)，如上图Complex的<code>Complex(int re,int im=0)</code>只存在一个实参，第二个为默认参数，因此它可以发生隐式调用。这很符合直觉，因为<code>c1+5</code>的时候参数就5一个，参数多的时候似乎在C++11前是没有意义的。但是在<code>Initializer_list</code>出现后，好像也可以出现这种用法：<code>t + {1，2，3}</code> ，<code>{1,2,3}</code>去隐式调用了构造函数。那么<code>explicit</code>就有必要做出扩展，表示 多参数的构造函数也不允许被隐式调用。</p><p>下面例子: 加上explicit禁止多参数隐式调用的用法。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"explicit P(int a,int b,int c)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>    P <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> P&amp; rhs)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P operator+(const P&amp; rhs)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> P&amp; arg)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    P p1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//显式调用构造  ok</span><br>    P p2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//隐式调用构造  no</span><br>    <span class="hljs-function">P <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//显式调用构造 ok</span><br><br>    fun(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//隐式调用构造  no</span><br>    fun(P&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//显式调用构造 yes</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Range-based-for-statement"><a href="#Range-based-for-statement" class="headerlink" title="Range-based for statement"></a>Range-based for statement</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509195854595.png" srcset="/img/loading.gif" alt="image-20220509195854595"></p><p>编译器对range-based的解释如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509200147325.png" srcset="/img/loading.gif" alt="image-20220509200147325"></p><p>同理explict也可以禁止range-based中的隐式转换：</p><p>vs中的每个string赋值给C会触发隐式调用，而<code>explicit</code>禁止了这种隐式调用。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509200501615.png" srcset="/img/loading.gif" alt="image-20220509200501615"></p><h2 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    P(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P(int a,int b,int c)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>    P <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> P&amp; rhs)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P operator+(const P&amp; rhs)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> P&amp; arg)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    P p1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-function">P <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//ok, 但是如果P的定义加上P(const P&amp;) = delete;则失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>五大(Big Five)默认实现的：</p><p>拷贝构造，移动构造，拷贝复制，移动赋值，析构函数。 其实还有一个默认的Zoo()编译器也会帮我们实现，但是当有一个构造函数自己写出来后，这个空的构造函数便不能使用了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509201551845.png" srcset="/img/loading.gif" alt="image-20220509201551845"></p><p>下面例子：</p><p><strong>1.构造函数如果签名不同是可以同时存在的，因为构造函数可以有多个版本。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509202536252.png" srcset="/img/loading.gif" alt="image-20220509202536252"></p><p><strong>2.对于编译器可以默认生成的函数(拷贝构造函数/赋值构造函数/移动构造函数/移动赋值函数)，如果你自己已经定义了，那就不可以再用default/delete声明</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509202615380.png" srcset="/img/loading.gif" alt="image-20220509202615380"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509203129701.png" srcset="/img/loading.gif" alt="image-20220509203129701"></p><p><strong>3.普通函数没有=default的操作，但是可以=delete：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509203210387.png" srcset="/img/loading.gif" alt="image-20220509203210387"></p><p><strong>4.析构函数不能=delete，但是可以=default</strong></p><p>析构函数必须存在进行内存回收，因此不可以delete。=default默认是ok的，符合逻辑直觉。</p><p><strong>总结一下：</strong></p><p><strong>1.=default只用于BIg-Five(拷贝构造，移动构造，拷贝复制，移动赋值，析构函数)</strong></p><p><strong>2.=delete可以用于任何函数身上，除了virtual虚函数(虚函数也有一个=的用法，叫做=0表示纯虚函数)</strong></p><p>因此一个空的class在C++处理过后不在是空，会有默认生成的Big-five。</p><p>一般来说对于数据成员有指针的类，我们如果希望是深拷贝，那么最好不要用默认default，default只会帮我们做浅拷贝。</p><h2 id="Alias-Template模板别名"><a href="#Alias-Template模板别名" class="headerlink" title="Alias Template模板别名"></a>Alias Template模板别名</h2><p>考虑这样的一个用法：利用Vec这个别名可以帮助我们减少模板的定义，比如原来vector需要<code>std::vector&lt;T,MyAlloc&lt;T&gt;&gt;</code>的方法来声明一个vector，现在我们仅仅需要<code>Vec&lt;T&gt;</code>即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220511205543482.png" srcset="/img/loading.gif" alt="image-20220511205543482"></p><p>这是原来的宏定义无法做到给模板一个别名的，无论是define还是typedef：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220511205807638.png" srcset="/img/loading.gif" alt="image-20220511205807638"></p><p><strong>因此这个方法给模板定义了一个别名，叫做模板别名。但是模板别名是无法做到模板偏特化和特化的</strong></p><p><strong>考虑如何写一个支持输入容器名字和容器内元素的类型就可以实现对容器遍历？</strong></p><p>下面是第一种方法：通过萃取机<code>iterator_traits</code>萃取出容器内元素的类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::value_type TYPE;<br>    c.insert(c.<span class="hljs-built_in">end</span>(), TYPE());<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"&#123;"</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">typename</span> Container::iterator it = c.<span class="hljs-built_in">begin</span>(); it!=c.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        <span class="hljs-keyword">typename</span> Container::iterator it_copy = it;<br>        it_copy ++;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;(it_copy!=c.<span class="hljs-built_in">end</span>()?<span class="hljs-string">","</span>:<span class="hljs-string">""</span>);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"&#125;"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还有一种方法需要用到模板模板参数(template template parameter)。</p><h2 id="template-template-parameter，模板的模板参数"><a href="#template-template-parameter，模板的模板参数" class="headerlink" title="template template parameter，模板的模板参数"></a>template template parameter，模板的模板参数</h2><p>模板的模板参数就是：模板中还存在模板作为的参数。<strong>注意:函数模板不支持模板的模板参数,类模板才支持这种操作</strong></p><p>这个的应用场景是，比如我们想这么用:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">list</span>&gt;mylist1;<br></code></pre></div></td></tr></table></figure><p>此时希望list自动辨别出来我们要用的是string，并把list自己的容纳元素类型绑定成string。一个简单的方法就是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">typename</span> T&gt;&gt;<br>考虑到想让容器也可以变化，适应多种容器，不妨写成:<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215220706952.png" srcset="/img/loading.gif" alt="image-20211215220706952"></p><p>这样可以达到我们想要的效果吗？</p><p>奇怪的是并不可以：这是因为XCLs中的<code>Container&lt;T&gt;c</code>这部分的T填入的是类型T(string)，然而我们平时可以这么用<code>list&lt;string&gt;</code>是因为string填入后，其实<code>&lt;&gt;</code>后面还会有一些默认参数，比如：allocator分配器等….。</p><p>但是如果你用<code>T</code>表示，c++就会认为你没有填入后面的默认参数(语言的规定)。简单来说如果你用了T做容器的参数，那么容器的后面的默认参数会失效，你需要自己补上这些参数。</p><p>因此我们可以这么用(c++2.0新特性（c++11/14）)，使得第二种是对的：<strong>即利用<code>using</code>定义模板别名</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215221628613.png" srcset="/img/loading.gif" alt="image-20211215221628613"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT&lt;T&gt;c;<br>&#125;;<br><br><span class="hljs-comment">//利用using 给这个模板定义了别名: Lst</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,Lst&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个模板推导过程是：<code>T</code>推出<code>string</code>，然后从<code>CONT&lt;T&gt;c</code>推出<code>U</code>是<code>string</code>，然后从<code>U</code>再推到<code>T2</code>是<code>string</code>。</p><p>下面这并<strong>不叫做一个模板模板参数</strong>，因为<code>XCLs&lt;string,set&lt;string&gt;&gt;mylist1;</code>中的<code>set&lt;string&gt;</code>就已经绑定好容器的元素类型了，使得<code>class CONT</code>变成<code>set&lt;string&gt;</code>根本没有模板进行推导。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>=<span class="hljs-title">list</span>&lt;T,allocator&lt;T&gt;&gt;&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT c;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Alias-Type类型别名-补充一些函数指针的知识）"><a href="#Alias-Type类型别名-补充一些函数指针的知识）" class="headerlink" title="Alias Type类型别名(补充一些函数指针的知识）"></a>Alias Type类型别名(补充一些函数指针的知识）</h2><p>我们经常可以在标准库看到<code>typedef T value_type</code>的用法，现在利用using也可以做到：<code>using value_Type = T</code>，其实这种看起来更容易阅读一些，在模板别名。</p><p>但是他的易读性在函数指针中更凸显，首先介绍一下函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;   <span class="hljs-comment">// 函数原型(prototype)</span><br><span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>);   <span class="hljs-comment">// 声明一个函数指针pf，他指向输入参数为int,返回值为double的函数 </span><br>pf = cal;    <span class="hljs-comment">// 指针赋值</span><br></code></pre></div></td></tr></table></figure><p>既然<code>double (*pf)(int)</code>是一个函数指针，那么这个指针的类型就是<code>double (*pf)(int)</code>去掉变量名即可，即：<code>double (*)(int)</code></p><p>现在我们已经补充了一些什么是函数指针的知识，下面利用alias type来替代一下试试：</p><p>可以直接用<code>func_pointer</code>指代函数指针</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> func_pointer = <span class="hljs-keyword">void</span>(*)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_pointer fn = <span class="hljs-built_in">exp</span>;<br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也可以指代函数原型，然后声明的时候自己加上指针符。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> func = <span class="hljs-keyword">void</span> (<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func* fn = <span class="hljs-built_in">exp</span>;<br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>值得一提的是：在alias type上，using和typedef没任何区别，只是更易读而已。</strong>下面是typedef等效的写法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*func_pointer)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(func)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_pointer fn = <span class="hljs-built_in">exp</span>; <span class="hljs-comment">//ok</span><br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br><br>    func* fn2 = <span class="hljs-built_in">exp</span>; <span class="hljs-comment">//ok</span><br>    fn2(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结using"><a href="#总结using" class="headerlink" title="总结using"></a>总结using</h2><p>我们总结一下using：</p><ul><li><p>using在namespace(<code>using namespace std</code>)和namespace member(<code>using std::cout</code>)。</p></li><li><p>using在class member中</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512201804869.png" srcset="/img/loading.gif" alt="image-20220512201804869"></p><p>如果你写了using了上面这些，那么在类中你就可以不写namespace <code>_Base::</code>，直接写函数成员名字即可</p></li><li><p>Alias type和Alias template</p></li></ul><h2 id="noexcept-和-vector扩容中如何利用移动语义扩容-的关联"><a href="#noexcept-和-vector扩容中如何利用移动语义扩容-的关联" class="headerlink" title="noexcept 和 vector扩容中如何利用移动语义扩容 的关联"></a>noexcept 和 vector扩容中如何利用移动语义扩容 的关联</h2><p>noexcept表示保证不会出现异常：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-built_in">exp</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>exp里面若为true，则需要保证foo函数noexcept，反之无需保证。</p><p>当不写<code>(exp)</code>, 则表示永远不会出现异常：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br>    等价于<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>noexcept这个保证不出现异常有什么意义呢？</p><p>在可成长的容器，即会发生内存重分配，比如vector和deque，以vector为例子，当扩容时不是原地扩容，而是重新开辟一片内存，然后让之前的内容搬移过来，在搬移时有两种方法，一种是拷贝构造函数，另一种是移动构造函数。</p><p>他们有什么区别呢？</p><blockquote><p>What does the copy constructor and move constructor look like behind the scenes, in terms of memory usage?</p></blockquote><p>If <em>any</em> constructor is being called, it means a new object is being created in memory. So, the only difference between a <em>copy</em> constructor and a <em>move</em> constructor is whether the source object that is passed to the constructor will have its member fields <em>copied</em> or <em>moved</em> into the new object.</p><p>拷贝构造会把对象的拷贝到另一块内存，包括他的成员变量。而移动构造中，源对象的成员变量不会被复制，而是直接通过指针的方式直接指向原来的内存，直接重复利用这些成员变量，接管源对象的内存，因此无需对成员变量进行复制。</p><p><strong>那如果我自己声明了一个Mystring类，我想让他在vector存储的时候，扩容时调用Mystring的移动构造函数怎么办呢？这时就需要我们在MyString的移动构造函数和移动赋值函数上添加noexcept，vector才会利用MyString移动语义。</strong></p><h2 id="Override-与-final"><a href="#Override-与-final" class="headerlink" title="Override 与 final"></a>Override 与 final</h2><p>当我们想重载<code>vfunc(float)</code>，但是不小心重载成了<code>void vfun(int)</code>，那么也没人告诉我们这不对，因为编译器会完全认为这是一个全新的函数  。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512205816115.png" srcset="/img/loading.gif" alt="image-20220512205816115"></p><p>我们可以在写重载函数时加上一个override函数，表示这个函数是重载的，这样在我们在写错函数签名的时候就会提示我们：这个函数在基类中没有，没法重载，而此时的编译器就不会把他认作新的函数通过编译。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512205911885.png" srcset="/img/loading.gif" alt="image-20220512205911885"></p><p>final就是表示这个函数不会被重载，如果子类重载了这个函数就会提示你这是错误的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512210342567.png" srcset="/img/loading.gif" alt="image-20220512210342567"></p><p>这两种关键字都是为了减少 低级错误的发生 而产生的。</p><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>前要阅读: <a href="https://chillstepp.github.io/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/#decltype">https://chillstepp.github.io/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/#decltype</a></p><p>以前写过这个特性相关的内容，这一次只写他的应用：</p><p>auto和decltype除了在细节上的差异外（比如是否完美保留<code>const，&amp;</code>等），auto只可以帮助我们不用写这个类型，类似于一个语法糖，而比如我们想把一个类型定义出来，那么还是需要decltype来做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">decltype</span><span class="hljs-params">(xxx)</span> NewType</span><br></code></pre></div></td></tr></table></figure><p>那么decltype除了简单的获取类型外，更重要的意义是在元编程上：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220516210044839.png" srcset="/img/loading.gif" alt="image-20220516210044839"></p><p>如上图，我们可以用decltype获取出模板容器的迭代器。</p><p>在lambda表达式中常用的是auto来表达lambda类型，而在某些容器例如set中，需要指定比较方式的函数类型，因此decltype可以很好的解决这个问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220517090641450.png" srcset="/img/loading.gif" alt="image-20220517090641450"></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><a href="https://chillstepp.github.io/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/">https://chillstepp.github.io/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/</a></p><h2 id="再谈Variadic-Template"><a href="#再谈Variadic-Template" class="headerlink" title="再谈Variadic Template"></a>再谈Variadic Template</h2><p>Variadic Template变化的是模板参数，即：</p><ul><li>参数个数—参数个数逐一减少，通过函数递归调用实现</li><li>参数类型—参数类型变化</li></ul><p>这也是Variadic Template的使用场景。</p><p>我们自己实现一个如下函数发现，当调用到最后<code>1 + 1</code>形式的时候，即args只剩下一个的时候会调用 <code>maximum(int n)</code>而不会调用 <code>maximum(int n, Types... args)</code>拆成<code>1+0</code>的形式</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum(int n)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum()"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Types... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum(int n, Types... args)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(n, maximum(args...));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    maximum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220523203944157.png" srcset="/img/loading.gif" alt="image-20220523203944157"></p><p><strong>如何输出一个tuple？</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220523205359391.png" srcset="/img/loading.gif" alt="image-20220523205359391"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> IDX,<span class="hljs-keyword">int</span> MAX, <span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PRINT_TUPLE</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        os&lt;&lt;<span class="hljs-built_in">get</span>&lt;IDX&gt;(t);<br>        <span class="hljs-keyword">if</span>(IDX+<span class="hljs-number">1</span>!=MAX) os&lt;&lt;<span class="hljs-string">","</span>;<br>        PRINT_TUPLE&lt;IDX+<span class="hljs-number">1</span>, MAX, args...&gt;::<span class="hljs-built_in">print</span>(os, t);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> MAX, <span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PRINT_TUPLE</span>&lt;MAX,MAX,args...&gt;&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... args&gt;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)<br>&#123;<br>    os&lt;&lt;<span class="hljs-string">"["</span>;<br>    PRINT_TUPLE&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>...(args), args...&gt;::<span class="hljs-built_in">print</span>(os, t);<br>    os&lt;&lt;<span class="hljs-string">"]"</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;make_tuple(<span class="hljs-number">2</span>,<span class="hljs-built_in">string</span>(<span class="hljs-string">"123"</span>))&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码有两个版本的<code>struct PRINT_TUPLE</code>，其中第二个做了参数上的偏特化，第二个版本是为了终止循环调用print。</p><p><strong>递归继承，以tuple为例：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220524132623412.png" srcset="/img/loading.gif" alt="image-20220524132623412"></p><p>how to fix？</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Values&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&#123;</span>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&lt;&gt; &#123;</span>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&lt;Head,Tail...&gt; :</span> <span class="hljs-keyword">private</span> mytuple&lt;Tail...&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> inherited = mytuple&lt;Tail...&gt;;<br><span class="hljs-keyword">public</span>:<br>    mytuple() &#123;&#125;<br>    mytuple(Head v, Tail... vtail): m_head(v), inherited(vtail...) &#123;&#125;<br>    <span class="hljs-function">Head <span class="hljs-title">head</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_head;<br>    &#125;<br>    <span class="hljs-function">inherited&amp; <span class="hljs-title">tail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mytuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt;tp(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"123"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>递归复合：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525132645667.png" srcset="/img/loading.gif" alt="image-20220525132645667"></p><h2 id="右值引用-移动语义"><a href="#右值引用-移动语义" class="headerlink" title="右值引用/移动语义"></a>右值引用/移动语义</h2><h3 id="前要："><a href="#前要：" class="headerlink" title="前要："></a>前要：</h3><p><a href="https://chillstepp.github.io/2022/02/15/C-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8Cstd-move%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++左值右值/左右值引用/std::move()</a></p><p>在本节将终点怎么写一个好的移动语义，前置基础知识在上方链接。</p><h3 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值/右值"></a>左值/右值</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525194649565.png" srcset="/img/loading.gif" alt="image-20220525194649565"></p><p>简单来说左值可以出现在<code>operator =</code>左边也可以出现在<code>operator =</code>右边，而右值只可以出现在<code>operator =</code>的右边。临时对象是右值。</p><p>其中<strong>右值只可以出现在<code>operator =</code>的右边</strong>这个说法可能会引发歧义，因为上图中临时对象也出现了<code>operator =</code>左边，也就是说C++为什么要允许给临时对象赋值呢？</p><p>解释如下：简单来说算一个历史遗留问题</p><p>C++为什么允许给临时对象赋值？ - 暮无井见铃的回答 - 知乎 <a href="https://www.zhihu.com/question/533946012/answer/2495821727" target="_blank" rel="noopener">https://www.zhihu.com/question/533946012/answer/2495821727</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525195045773.png" srcset="/img/loading.gif" alt="image-20220525195045773"></p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>函数的返回值也是一个右值，<strong>右值没有一个确定的地址</strong>，因此右值是不可以取地址的，需要右值引用这种新的产物来引用右值：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525195320012.png" srcset="/img/loading.gif" alt="image-20220525195320012"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>&amp;&amp; x = fun();<span class="hljs-comment">// ok ，右值引用</span><br>    <span class="hljs-keyword">int</span>&amp; x = fun();<span class="hljs-comment">// no, error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'</span><br>    <span class="hljs-keyword">int</span>* p = &amp;fun();<span class="hljs-comment">// no , 右值不能取地址</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="如何在调用端-被调用端-告知-右值这个概念"><a href="#如何在调用端-被调用端-告知-右值这个概念" class="headerlink" title="如何在调用端/被调用端 告知 右值这个概念"></a>如何在调用端/被调用端 告知 右值这个概念</h3><p><strong>如何解决这个问题呢？</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525200348793.png" srcset="/img/loading.gif" alt="image-20220525200348793"></p><ul><li>如何在调用段告诉我是右值：<ul><li>1.自己本身就是右值：函数返回值，临时变量等…</li><li>2.自己本身是左值：<code>move()</code>函数转成右值</li></ul></li><li>如何在被调用端专门出一个处理右值的移动函数:<ul><li><code>fun(...,...,Type&amp;&amp; x)</code>,用右值引用来接着即可。</li></ul></li></ul><h3 id="移动语义是怎么节省开销的"><a href="#移动语义是怎么节省开销的" class="headerlink" title="移动语义是怎么节省开销的"></a>移动语义是怎么节省开销的</h3><p>移动构造就是接管了 右值的内存空间，把 右值内的指针成员变量 置为空这个操作可以帮助我们使得右值不调用析构函数，从而延续了右值的生命。</p><p>怎么写一个移动语义的构造/赋值函数呢？下面微软的文档讲的很好。</p><p><strong>reference:</strong><a href="https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170</a></p><p>简单来说，首先下面是一个类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// MemoryBlock.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryBlock</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>   <span class="hljs-comment">// Simple constructor that initializes the resource.</span><br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemoryBlock</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> length)</span></span><br><span class="hljs-function">      : _<span class="hljs-title">length</span><span class="hljs-params">(length)</span></span><br>      , _data(new int[length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(size_t). length = "</span><br>                &lt;&lt; _length &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Destructor.</span><br>   ~MemoryBlock()<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In ~MemoryBlock(). length = "</span><br>                &lt;&lt; _length &lt;&lt; <span class="hljs-string">"."</span>;<br><br>      <span class="hljs-keyword">if</span> (_data != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" Deleting resource."</span>;<br>         <span class="hljs-comment">// Delete the resource.</span><br>         <span class="hljs-keyword">delete</span>[] _data;<br>      &#125;<br><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Copy constructor.</span><br>   MemoryBlock(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>      : _length(other._length)<br>      , _data(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[other._length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>   &#125;<br><br>   <span class="hljs-comment">// Copy assignment operator.</span><br>   MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In operator=(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>      &#123;<br>         <span class="hljs-comment">// Free the existing resource.</span><br>         <span class="hljs-keyword">delete</span>[] _data;<br><br>         _length = other._length;<br>         _data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[_length];<br>         <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>      &#125;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Retrieves the length of the data resource.</span><br>   <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">Length</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">return</span> _length;<br>   &#125;<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">size_t</span> _length; <span class="hljs-comment">// The length of the resource.</span><br>   <span class="hljs-keyword">int</span>* _data; <span class="hljs-comment">// The resource.</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这是他的<strong>移动构造函数/移动赋值函数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// Move constructor.</span><br>MemoryBlock(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>   : _data(<span class="hljs-literal">nullptr</span>)<br>   , _length(<span class="hljs-number">0</span>)<br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Moving resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>   <span class="hljs-comment">// source object.</span><br>   _data = other._data;<br>   _length = other._length;<br><br>   <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>   <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>   other._data = <span class="hljs-literal">nullptr</span>;<br>   other._length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Move assignment operator.</span><br>MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In operator=(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>   &#123;<br>      <span class="hljs-comment">// Free the existing resource.</span><br>      <span class="hljs-keyword">delete</span>[] _data;<br><br>      <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>      <span class="hljs-comment">// source object.</span><br>      _data = other._data;<br>      _length = other._length;<br><br>      <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>      <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>      other._data = <span class="hljs-literal">nullptr</span>;<br>      other._length = <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来比较下： Copy constructor和Move constructor</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">   <span class="hljs-comment">// Copy constructor.</span><br>   MemoryBlock(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>      : _length(other._length)<br>      , _data(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[other._length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>   &#125;<br><br><br><span class="hljs-comment">// Move constructor.</span><br>MemoryBlock(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>   : _data(<span class="hljs-literal">nullptr</span>)<br>   , _length(<span class="hljs-number">0</span>)<br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Moving resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>   <span class="hljs-comment">// source object.</span><br>   _data = other._data;<br>   _length = other._length;<br><br>   <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>   <span class="hljs-comment">//上面这句话很重要，释放指针(指针=nullptr)可以保证source object不被析构，这帮助我们延长了右值声明，同时不用再拷贝一份_data了。</span><br>   <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>   other._data = <span class="hljs-literal">nullptr</span>;<br>   other._length = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>总结下：</strong></p><ul><li>如果你的类没有指针那就没必要搞移动语义，也就是说用户自定义类型且内部存在指针类型移动构造才有意义。而互联网上大量的例子都没有指针类型在内部的类也在用移动语义，这是没有意义的。</li><li>移动语义的函数请把<code>noexcept</code>加上。</li><li>在写移动语义时请把source obejct中的所有pointer释放掉(如上代码中的<code>other._data = nullptr;</code>)，释放指针(<code>指针=nullptr</code>)可以保证source object不被析构。</li></ul><h3 id="完美转发-Perfect-Forwarding"><a href="#完美转发-Perfect-Forwarding" class="headerlink" title="完美转发(Perfect Forwarding)"></a>完美转发(Perfect Forwarding)</h3><p>基本的用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">process</span>(a);<span class="hljs-comment">//void process(int&amp; i)</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//void process(int&amp;&amp; i)</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">move</span>(a));<span class="hljs-comment">//move把左值转右值，void process(int&amp;&amp; i)</span><br></code></pre></div></td></tr></table></figure><p>不完美的转发：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">forwd(<span class="hljs-number">2</span>);<span class="hljs-comment">//forwd(int&amp;&amp; i), process(int&amp; i),第二次右值变成了左值：这是因为int&amp;&amp; i是一个左值(右值引用是一个左值)，这导致了调用了左值的版本。</span><br><br><br>forwd(<span class="hljs-built_in">move</span>(a));<span class="hljs-comment">//forwd(int&amp;&amp; i), process(int&amp; i),第二次右值变成了左值：这是因为int&amp;&amp; i是一个左值(右值引用是一个左值)，这导致了调用了左值的版本，这是一个不完美的转发。</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">forwd(a);<span class="hljs-comment">//error: cannot bind rvalue reference of type 'int&amp;&amp;' to lvalue of type 'int'|</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">process</span>(b);<span class="hljs-comment">//error: 没有对应的process版本</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">move</span>(b));<span class="hljs-comment">//error: const int&amp;&amp; 没有对应的process版本</span><br><span class="hljs-comment">//关于常量右值引用有没有用：https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511</span><br></code></pre></div></td></tr></table></figure><p>上面出现了一个常量右值引用，关于常量右值引用有没有用：<a href="https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511" target="_blank" rel="noopener">https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526195035129.png" srcset="/img/loading.gif" alt="image-20220526195035129"></p><p><strong>如何完美转发？   利用<code>std::forward</code></strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526195715327.png" srcset="/img/loading.gif" alt="image-20220526195715327"></p><p>更多的细节，forward的实现等看这个文章:</p><p>谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward：<a href="https://zhuanlan.zhihu.com/p/369203981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369203981</a></p><p>再来一个侯捷老师的例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526201539306.png" srcset="/img/loading.gif" alt="image-20220526201539306"></p><h3 id="一些很好的相关资料"><a href="#一些很好的相关资料" class="headerlink" title="一些很好的相关资料"></a>一些很好的相关资料</h3><ul><li>C++高阶知识：深入分析移动构造函数及其原理 ： <a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">https://avdancedu.com/a39d51f9/</a></li><li>聊聊C++中的完美转发：<a href="https://zhuanlan.zhihu.com/p/161039484" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161039484</a></li><li>谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward：<a href="https://zhuanlan.zhihu.com/p/369203981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369203981</a></li></ul><h2 id="万能引用-引用折叠-完美转发"><a href="#万能引用-引用折叠-完美转发" class="headerlink" title="万能引用/引用折叠/完美转发"></a>万能引用/引用折叠/完美转发</h2><p>作者：ReFantasy<br>链接：<a href="https://zhuanlan.zhihu.com/p/50816420" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50816420</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a><strong>引用折叠</strong></h3><p>我们把 <strong>引用折叠</strong> 拆解为 <strong>引用</strong>和 <strong>折叠</strong> 两个短语来解释。</p><p>首先，<strong>引用</strong>的意思众所周知，当我们使用某个对象的别名的时候就好像直接使用了该对象，这也就是引用的含义。在C++11中，新加入了右值的概念。所以引用的类型就有两种形式：左值引用<code>T&amp;</code>和右值引用<code>T&amp;&amp;</code>。</p><p>其次，解释一下折叠的含义。所谓的折叠，就是多个的意思。上面介绍引用分为左值引用和右值引用两种，那么将这两种类型进行排列组合，就有四种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">- 左值-左值 T&amp; &amp;<br>- 左值-右值 T&amp; &amp;&amp;<br>- 右值-左值 T&amp;&amp; &amp;<br>- 右值-右值 T&amp;&amp; &amp;&amp;<br></code></pre></div></td></tr></table></figure><p><strong>这就是所谓的引用折叠！引用折叠的含义到这里就结束了。</strong></p><p><strong>但是</strong>，当我们在IDE中敲下类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#x2F;&#x2F; ...<br>int a &#x3D; 0;<br>int &amp;ra &#x3D; a;<br>int &amp; &amp;rra &#x3D; ra;  &#x2F;&#x2F; 编译器报错：不允许使用引用的引用！<br>&#x2F;&#x2F; ...<br></code></pre></div></td></tr></table></figure><p><strong>既然不允许使用，为啥还要有引用折叠这样的概念存在 ？</strong>  </p><p><strong>原因就是：引用折叠的应用场景不在这里，引用折叠在模板中的应用：完美转发</strong>。</p><p>在介绍完美转发之前，我们先介绍一下万能引用。</p><h3 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a><strong>万能引用</strong></h3><p>所谓的<strong>万能引用</strong>并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。</p><p>万能引用的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ReturnType <span class="hljs-title">Function</span><span class="hljs-params">(T&amp;&amp; parem)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 函数功能实现</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来，我们看一下为什么上面这个函数能<strong>万能引用</strong>不同类型的参数。</p><p>为了更加直观的看到效果，我们借助<code>Boost</code>库的部分功能，重写我们的万能引用函数：</p><p><em>如果不了解Boost库也没关系，Boost库主要是为了帮助大家看到模板里参数类型）</em></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/type_index.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;  <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用Boost库打印模板推导出来的 T 类型</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"T type："</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; <span class="hljs-built_in">endl</span>; <br>    <br>    <span class="hljs-comment">// 利用Boost库打印形参的类型</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"param type:"</span> &lt;&lt; type_id_with_cvr&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().pretty_name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 左值</span><br>PrintType(a);                           <span class="hljs-comment">// 传入左值</span><br><br><span class="hljs-keyword">int</span> &amp;lvalue_refence_a = a;              <span class="hljs-comment">// 左值引用</span><br>PrintType(lvalue_refence_a);            <span class="hljs-comment">// 传入左值引用</span><br><br>PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>));                      <span class="hljs-comment">// 传入右值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过上面的代码可以清楚的看到，<code>void PrintType(T&amp;&amp; param)</code>可以接受任何类型的参数。嗯，真的是万能引用！<strong>到这里的话，万能引用的介绍也就结束了。</strong>但是我们只看到了这个东西可以接受任何的参数，却不知道为什么它能这么做。</p><p>下面，我们来仔细观察并分析一下<code>main</code>函数中对<code>PrintType()</code>的各个调用结果。</p><p><strong>1.传入左值</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 左值</span><br>PrintType(a);                           <span class="hljs-comment">// 传入左值</span><br><span class="hljs-comment">/***************************************************/</span><br>输出：T type      : <span class="hljs-keyword">int</span> &amp;<br>      param type  : <span class="hljs-keyword">int</span> &amp;<br></code></pre></div></td></tr></table></figure><p>我们将T的推导类型<code>int&amp;</code>(为什么推导<code>int&amp;</code>这个下面会解释)带入模板，得到实例化的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; &amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>重点来了！编译器将T推导为 int&amp; 类型。当我们用 int&amp; 替换掉 T 后，得到 int &amp; &amp;&amp;。</strong></p><p><strong>MD，编译器不允许我们自己把代码写成int&amp; &amp;&amp;，它自己却这么干了 =。=</strong> </p><p><strong>那么 int &amp; &amp;&amp;到底是个什么东西呢？它就是是引用折叠，刚开始就说了啊</strong></p><p>下面，就是<strong>引用折叠的精髓了</strong>。</p><blockquote><p>《Effective Modern C++》</p><p><strong>所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。</strong></p><p>规则就是：</p><p><strong>如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</strong></p></blockquote><p>也就是说，<code>int&amp; &amp;&amp;</code>等价于<code>int &amp;</code>。<code>void PrintType(int&amp; &amp;&amp; param)</code> == <code>void PrintType(int&amp; param)</code></p><p>所以传入右值之后，函数模板推导的最终版本就是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以，它能接受一个左值<code>a</code>。</p><p><strong>现在我们重新整理一下思路：</strong>编译器不允许我们写下类似<code>int &amp; &amp;&amp;</code>这样的代码，但是它自己却可以推导出<code>int &amp; &amp;&amp;</code>代码出来。它的理由就是：编译器虽然推导出<code>T</code>为<code>int&amp;</code>，但是我在最终生成的代码中，<strong>利用引用折叠规则</strong>，将<code>int &amp; &amp;&amp;</code>等价生成了<code>int &amp;</code>。推导出来的<code>int &amp; &amp;&amp;</code>只是过渡阶段，最终版本并不存在。所以也不算破坏规定。</p><blockquote><p>关于有的人会问，我传入的是一个左值a,并不是一个左值引用，为什么编译器会推导出T 为<code>int &amp;</code>呢。</p><p>首先，模板函数参数为<code>T&amp;&amp; param</code>,也就是说，不管T是什么类型，T&amp;&amp;的最终结果必然是一个引用类型。</p><p>如果T是<code>int</code>, 那么<code>T&amp;&amp;</code> 就是 <code>int &amp;&amp;</code>；</p><p>如果T为<code>int &amp;</code>，那么 <code>T &amp;&amp;,即int&amp; &amp;&amp;</code>就是<code>int &amp;</code></p><p>如果T为<code>int&amp;&amp;</code>,那么<code>T &amp;&amp;(&amp;&amp; &amp;&amp;)</code>就是<code>int &amp;&amp;</code>。</p><p>很明显，接受左值的话，T只能推导为<code>int &amp;</code>。</p><p><strong>抛开上面这种分析，更直观的来说，你把一个左值扔给万能引用不就是希望他被引用吗，左值的引用那就是左值引用<code>int&amp;</code></strong></p><p>因此在下面<code>2.明白传入左值的推导结果，剩下的几个调用结果就很明显了：</code>部分中的例子你也可以看到：左值引用(也就是左值) 会被引用成 左值引用，右值会被引用成右值引用，同理右值引用(左值)也会被引用成左值引用</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220527135903858.png" srcset="/img/loading.gif" alt="image-20220527135903858"></p></blockquote><p><strong>2.明白传入左值的推导结果，剩下的几个调用结果就很明显了：</strong></p><p>whysb:下面这些要多考虑下，目前还有问题和误解</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;lvalue_refence_a = a;              <span class="hljs-comment">//左值引用</span><br>PrintType(lvalue_refence_a);            <span class="hljs-comment">// 传入左值引用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int &amp;</span><br><span class="hljs-comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int &amp;</span><br><span class="hljs-comment">*/</span><br><br>PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>));                      <span class="hljs-comment">// 传入右值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int</span><br><span class="hljs-comment"> * T &amp;&amp;        : int &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int &amp;&amp;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>&amp;&amp; x = <span class="hljs-number">5</span>;<br>PrintType(x);                          <span class="hljs-comment">//传入右值引用(左值)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int&amp;&amp;</span><br><span class="hljs-comment"> * T &amp;&amp;        : int&amp; &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int&amp;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><ol><li><strong>以上就是万能引用的全部了。总结一下，万能引用就是利用模板推导和引用折叠的相关规则，生成不同的实例化模板来接收传进来的参数。</strong></li></ol><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a><strong>完美转发</strong></h3><p>好了，有了万能引用。当我们既需要接收左值类型，又需要接收右值类型的时候，再也不用分开写两个重载函数了。那么，什么情况下，我们需要一个函数，既能接收左值，又能接收右值呢？</p><p>答案就是：转发的时候。</p><p>于是，我们马上想到了万能引用。又于是兴冲冲的改写了以上的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Boost库在这里已经不需要了，我们将其拿掉，可以更简洁的看清楚转发的代码实现</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 万能引用，转发接收到的参数 param</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>f(param);  <span class="hljs-comment">// 将参数param转发给函数 void f()</span><br>&#125;<br><br><span class="hljs-comment">// 接收左值的函数 f()</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T &amp;)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f(T &amp;)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">// 接收右值的函数f()</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T &amp;&amp;)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f(T &amp;&amp;)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>PrintType(a);<span class="hljs-comment">//传入左值</span><br>PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>));<span class="hljs-comment">//传入右值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们执行上面的代码，按照预想，在main中我们给 PrintType  分别传入一个左值和一个右值。PrintType将参数转发给 f() 函数。f()有两个重载，分别接收左值和右值。</p><p>正常的情况下,<code>PrintType(a);</code>应该打印<code>f(T&amp;)</code>,<code>PrintType(int());</code>应该打印<code>f(T&amp;&amp;)</code>。</p><p><strong>但是</strong>，真实的输出结果是</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(T &amp;);<br>f(T &amp;);<br></code></pre></div></td></tr></table></figure><p>为什么明明传入了不同类型的值，但是<code>void f()</code>函数只调用了<code>void f(int &amp;)</code>的版本。这说明，不管我们传入的参数类型是什么，在<code>void PrintType(T&amp;&amp; param)</code>函数的内部，<code>param</code>都是一个左值引用！</p><p><strong>没错，事实就是这样。当外部传入参数给 PrintType 函数时，param既可以被初始化为左值引用，也可以被初始化为右值引用，取决于我们传递给 PrintType 函数的实参类型。但是，当我们在函数 PrintType 内部，将param传递给另一个函数的时候，此时，param是被当作左值进行传递的。</strong> <em>应为这里的 param 是个具名的对象。我们不进行详细的探讨了。大家只需要记住，任何的函数内部，对形参的直接使用，都是按照左值进行的。</em></p><p><strong>WTF，万能引用内部形参都变成了左值！那我还要什么万能引用啊！直接改为左值引用不就好了！！</strong></p><p><strong>别急，我们可以通过一些其它的手段改变这个情况，比如使用 std::forward 。</strong></p><p>在万能引用的一节，我们应该有所感觉了。使用万能引用的时候，如果传入的实参是个右值(包括右值引用)，那么，模板类型 T 被推导为 实参的类型（没有引用属性），如果传入实参是个左值，T被推导为左值引用。<strong>也就是说，模板中的 T 保存着传递进来的实参的信息，我们可以利用 T 的信息来强制类型转换我们的 param 使它和实参的类型一致。</strong></p><p>具体的做法就是，将模板函数<code>void PrintType(T&amp;&amp; param)</code>中对<code>f(param)</code>的调用，改为<code>f(std::forward&lt;T&gt;(param));</code>然后重新运行一下程序。输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(T &amp;);<br>f(T &amp;&amp;);<br></code></pre></div></td></tr></table></figure><p><strong>嗯，完美的转发！</strong></p><p>那么，<code>std::forward</code>是怎么利用到 T 的信息的呢。</p><p><code>std::forward</code>的源码形式大致是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span><br><span class="hljs-comment"> */</span> <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(T &amp;param)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来仔细分析一下这段代码：</p><p><strong>我们可以看到，不管T是值类型，还是左值引用，还是右值引用，T&amp;经过引用折叠，都将是左值引用类型。也就是forward 以左值引用的形式接收参数 param, 然后 通过将param进行强制类型转换 static_cast<T&&> （），最终再以一个 T&amp;&amp;返回</strong></p><p>所以，我们分析一下传递给 PrintType 的实参类型，并将推导的 T 类型代入 forward 就可以知道转发的结果了。</p><p><strong>1.传入 PrintType  实参是右值类型：</strong><br>根据以上的分析，可以知道T将被推导为值类型，也就是不带有引用属性，假设为 int 。那么，将T = int 带入forward。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;param)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>param</code>在forward内被强制类型转换为<code>int &amp;&amp;(static_cast&lt;int&amp;&amp;&gt;(param))</code>, 然后按照int &amp;&amp; 返回，两个右值引用最终还是右值引用。最终<strong>保持了实参的右值属性，转发正确。</strong></p><p><strong>2.传入 PrintType  实参是左值类型：</strong></p><p>根据以上的分析，可以知道T将被推导为左值引用类型，假设为int&amp;。那么，将T = int&amp; 带入forward。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">int&amp; &amp;&amp; forward(int&amp; &amp;param)<br>&#123;<br>return static_cast&lt;int&amp; &amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>引用折叠一下就是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看到这里，我想就不用再多说什么了。传递给 PrintType  左值，forward返回一个左值引用，保留了实参的左值属性，转发正确。</p><p><strong>到这里，完美转发也就介绍完毕了。</strong> </p><p><strong>总结一下他们三者的关系就是：通过引用折叠，我们实现了万能模板。在万能模板内部，利用forward函数，本质上是又利用了一遍引用折叠，实现了完美转发。其中，模板推导扮演了至关重要的角色。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda函数-用法/实现/广义捕获</title>
    <link href="/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/"/>
    <url>/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda函数-用法-实现-广义捕获"><a href="#Lambda函数-用法-实现-广义捕获" class="headerlink" title="Lambda函数-用法/实现/广义捕获"></a>Lambda函数-用法/实现/广义捕获</h1><h2 id="Lambda函数用法"><a href="#Lambda函数用法" class="headerlink" title="Lambda函数用法"></a>Lambda函数用法</h2><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">[捕获列表] <span class="hljs-function"><span class="hljs-params">(参数)</span> <span class="hljs-title">mutable</span> <span class="hljs-title">noexcept</span>/<span class="hljs-title">throw</span><span class="hljs-params">()</span> -&gt;</span> 返回值类型<br>&#123;<br>  函数体;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>1.[捕获列表]</strong><br>    [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p><blockquote><p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">捕获列表</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">[&amp;]</td><td style="text-align:left">只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td></tr><tr><td style="text-align:left">[&amp;val1,&amp;val2,…]</td><td style="text-align:left">表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td style="text-align:left">[=,&amp;val1,…]</td><td style="text-align:left">表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td style="text-align:left">[=]</td><td style="text-align:left">只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td></tr><tr><td style="text-align:left">[]</td><td style="text-align:left">空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td></tr><tr><td style="text-align:left">[this]</td><td style="text-align:left">表示以值传递的方式导入当前的 this 指针。</td></tr><tr><td style="text-align:left">[val1,val2,…]</td><td style="text-align:left">表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td style="text-align:left">[val,&amp;val2,…]</td><td style="text-align:left">以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr></tbody></table></div><p>case1：不导入任何变量，[ ]为空即可，因此无法访问/修改任何外部变量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [=](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">// error: 'a' is not captured|, error: 'b' is not captured|</span><br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br>fun(a,b);<br><span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p>case2:  引用 导入外部a,b变量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [=](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)  -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    a++;<br>    b++;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br>fun(a,b);<br><span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 输出: 1 2</span><br></code></pre></div></td></tr></table></figure><p>case3: 值捕获外部a，b变量时，a,b变量变成只读，不能被修改因此下面程序出错：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [=](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    a++;<br>    b++;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br>fun(a,b);<br><span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//error: 'a' was not declared in this scope|</span><br><span class="hljs-comment">//error: 'b' was not declared in this scope|</span><br></code></pre></div></td></tr></table></figure><p>case4：值捕获外部a,b变量，a,b变成只读，但加上mutable即可以修改</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [=](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    a++;<br>    b++;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br>fun(a,b);<br><span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p><strong>2.(参数)</strong><br>    和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，<strong>如果不需要传递参数，可以连同 () 小括号一起省略；(使用noexcept/throw 和 mutable时除外)</strong>，为了减少这种不必要的记忆和困扰，建议一直加上</p><p><strong>3.mutable</strong><br>    此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p><p>​    <strong>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</strong></p><p><strong>4.noexcept/throw()</strong><br>    可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p><p>​    值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。</p><p><strong>5.-&gt; 返回值类型</strong><br>    指明 lambda 匿名函数的返回值类型。<strong>值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</strong></p><p><strong>6. 函数体</strong><br>    和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p><p>​    需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p><h2 id="Lambda内部实现"><a href="#Lambda内部实现" class="headerlink" title="Lambda内部实现"></a>Lambda内部实现</h2><p>Lambda实际上就是一个仿函数：即是函数是一个类，类中重载了operator ()，捕获列表中的变量会作为类的private变量</p><p><strong>举一个值捕获的例子</strong>，并添加有mutable (值捕获不能修改，修改必须加上mutable，修改的也是copy的那一份，如果想真正修改请使用引用捕获)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [=](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">int</span><br>  &#123;<br>      a++;<br>      b++;<br>      <span class="hljs-keyword">return</span> x+y;<br>  &#125;;<br><br>  fun(a,b);<br>  <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>    <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_7_31</span> //<span class="hljs-title">lambda</span>类的定西</span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>      a++;<br>      b++;<br>      <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">// inline /*constexpr */ __lambda_7_31(const __lambda_7_31 &amp;) noexcept = default;</span><br>    <span class="hljs-comment">// inline /*constexpr */ __lambda_7_31(__lambda_7_31 &amp;&amp;) noexcept = default;</span><br>    __lambda_7_31(<span class="hljs-keyword">int</span> &amp; _a, <span class="hljs-keyword">int</span> &amp; _b)<br>    : a&#123;_a&#125;<br>    , b&#123;_b&#125;<br>    &#123;&#125;<br>    <br>  &#125;;<br>  <br>  function&lt;<span class="hljs-keyword">int</span> (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; fun = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span> (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt;(__lambda_7_31&#123;a, b&#125;);<span class="hljs-comment">//初始化__lambda_7_31，并传进去a，b的值</span><br>  fun.<span class="hljs-keyword">operator</span>()(a, b);<span class="hljs-comment">//调用lambda类中operator()(int x, int y)函数</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(a), <span class="hljs-string">" "</span>).<span class="hljs-keyword">operator</span>&lt;&lt;(b).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>如果我们采用引用方式捕获：</strong>那么会发现a，b都变成了引用，其他无区别</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_7_31</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">public</span>: <br>  <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    a++;<br>    b++;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span>: <br>  <span class="hljs-keyword">int</span> &amp; a;<span class="hljs-comment">//引用</span><br>  <span class="hljs-keyword">int</span> &amp; b;<span class="hljs-comment">//引用</span><br>  <span class="hljs-keyword">public</span>: <br>  <span class="hljs-comment">// inline /*constexpr */ __lambda_7_31(const __lambda_7_31 &amp;) noexcept = default;</span><br>  <span class="hljs-comment">// inline /*constexpr */ __lambda_7_31(__lambda_7_31 &amp;&amp;) noexcept = default;</span><br>  __lambda_7_31(<span class="hljs-keyword">int</span> &amp; _a, <span class="hljs-keyword">int</span> &amp; _b)<span class="hljs-comment">//引用</span><br>  : a&#123;_a&#125;<br>  , b&#123;_b&#125;<br>  &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="初始化捕获-广义捕获（generalized-lambda-capture）"><a href="#初始化捕获-广义捕获（generalized-lambda-capture）" class="headerlink" title="初始化捕获/广义捕获（generalized lambda capture）"></a>初始化捕获/广义捕获（generalized lambda capture）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;fun = [&amp;a,&amp;b](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">int</span><br>  &#123;<br>      a++;<br>      b++;<br>      <span class="hljs-keyword">return</span> x+y;<br>  &#125;;<br><br>  fun(a,b);<br>  <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中这段<code>function&lt;int(int,int)&gt;fun = [&amp;a,&amp;b](int x,int y) mutable -&gt; int</code>中的<code>[&amp;a,&amp;b]</code>可以替换为：<code>[&amp;a = a,&amp;b = b]</code>  ，这样看似是多此一举的,原因是这个场景中广义捕获的优势没有显现出来，考虑下面一个场景：<strong>捕获的时候直接进行move操作，得到move后的右值引用x</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;b = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">auto</span> fun = [x = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(b)](<span class="hljs-keyword">int</span> t = <span class="hljs-number">5</span>)<br>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;*x&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;;<br>fun();<br></code></pre></div></td></tr></table></figure><p>看一下它内部的细节, 初始化列表的操作时是这样操作的<code>x{std::move(_x)}</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; b = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">5</span>);<br>    <br>  <span class="hljs-class"><span class="hljs-keyword">class</span> __<span class="hljs-title">lambda_8_12</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>.<span class="hljs-keyword">operator</span>&lt;&lt;(x.<span class="hljs-keyword">operator</span>*()).<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::default_delete&lt;<span class="hljs-keyword">int</span>&gt; &gt; x;<br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">// inline __lambda_8_12(const __lambda_8_12 &amp;) = delete;</span><br>    <span class="hljs-comment">// inline __lambda_8_12 &amp; operator=(const __lambda_8_12 &amp;) = delete;</span><br>    __lambda_8_12(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::default_delete&lt;<span class="hljs-keyword">int</span>&gt; &gt; &amp;&amp; _x)<br>    : x&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(_x)&#125;<br>    &#123;&#125;<br>    <br>  &#125;;<br>  <br>  __lambda_8_12 fun = __lambda_8_12&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::default_delete&lt;<span class="hljs-keyword">int</span>&gt; &gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(b))&#125;;<br>  fun.<span class="hljs-keyword">operator</span>()(<span class="hljs-number">5</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类型推导：auto和decltype</title>
    <link href="/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/"/>
    <url>/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/</url>
    
    <content type="html"><![CDATA[<h1 id="类型推导：auto和decltype"><a href="#类型推导：auto和decltype" class="headerlink" title="类型推导：auto和decltype"></a>类型推导：auto和decltype</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>使用它来做自动类型推导，可以和其他操作符<code>（&amp;，*，const）</code>，一般来说<code>auto</code> 是<strong>根据变量的初始值来推导出变量类型的</strong>，比如一些容器的迭代器完整写下来就很长，使用auto就很方便</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span> , b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span>* pointer = &amp;b;<span class="hljs-comment">//和*一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;*pointer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">auto</span>&amp; refer = a;<span class="hljs-comment">//和&amp;一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;refer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> ConstVar = b;<span class="hljs-comment">//和const一起用</span><br>ConstVar = <span class="hljs-number">2</span>;<span class="hljs-comment">//报错:ConstVar是read-only的</span><br></code></pre></div></td></tr></table></figure><h3 id="auto-trick"><a href="#auto-trick" class="headerlink" title="auto trick"></a>auto trick</h3><ul><li><strong><code>=</code>右边是一个引用类型时<code>auto</code>会自动把引用抛弃，推导出原始类型：这是符合直觉的，我们希望引用与否掌握在程序员手上，因此这种帮助了我们根据意志自由决定。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;ref = x;<br><span class="hljs-keyword">auto</span> test = ref;<span class="hljs-comment">//tesr推导出的类型为test</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</strong></li><li><strong>当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</strong></li></ul><p>对于上边两条做出解释：</p><p>1.当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> y = x;<span class="hljs-comment">//y是int类型，会抛弃const</span><br></code></pre></div></td></tr></table></figure><p>2.当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> t = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a = t;<br><span class="hljs-keyword">auto</span> test1 = a;<span class="hljs-comment">//test1推导出int类型,给程序员自由</span><br><span class="hljs-keyword">auto</span> &amp;test2 = a;<span class="hljs-comment">//test2推导出const int&amp;类型，其中auto为const int</span><br></code></pre></div></td></tr></table></figure><p>这么做的原因是为了安全，如果你的auto推出的是int，那么也就是说可以通过这个引用去修改一个const的变量，这是不合理的(编译器会禁止这样做)。因此为了合理性、安全性，推导出<code>const int</code>是最好的选择。</p><ul><li><strong>auto 不能在函数的参数中使用 (版本低于C++20)</strong></li></ul><p>如果为了减少代码重复，模板是一个更好的替代方法</p><p><strong>注意：C++20已经允许auto在函数参数中使用了</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"123"</span>;<br>    <span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"345"</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;fun(s1,s2)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">auto</span> x;<span class="hljs-comment">//error: non-static data member declared with placeholder 'auto'|</span><br>    <span class="hljs-keyword">auto</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.x = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>auto 关键字不能定义数组 （char[]不行，用char*的可以）</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a[<span class="hljs-number">4</span>] = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//error:'a' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span> b[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//error:'b' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span>* c = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//ok</span><br></code></pre></div></td></tr></table></figure><p>Reference : <a href="https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables" target="_blank" rel="noopener">https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables</a></p><p>虽然<code>auto x[4] ={ ....}</code>是一个错误的用法，但是<code>auto x = {1,2,3,4}</code>会推出<code>x</code>是一个<code>std::initializer_list&lt;int&gt;</code>类型。</p><ul><li><strong>auto 不能作用于模板参数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A&lt;<span class="hljs-keyword">int</span>&gt; C1;<br>    A&lt;<span class="hljs-keyword">auto</span>&gt; C2 = C1;  <span class="hljs-comment">//错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>decltype</code>和<code>auto</code>不同，他使用<code>exp表达式</code>进行类型推导 （<code>decltype(10.8) x = 5.5 ;</code>  <code>x</code>被推导成了 <code>double</code>）</p><p><strong>值得一提的是，<code>decltype</code>并不会计算表达式，因此不用担心<code>decltype(fun())或decltype(a+b+c+d+e+f...)</code> 执行函数、表达式造成的耗费空间/时间。</strong></p><h3 id="decltype-变量"><a href="#decltype-变量" class="headerlink" title="decltype + 变量"></a>decltype + 变量</h3><p>当使用<code>decltype(var)</code>的形式时，decltype会直接返回变量的类型，包括const 和 &amp;，这是一种<strong>完美的保留</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b = a;<br><span class="hljs-keyword">decltype</span>(a) x = <span class="hljs-number">0</span>;<span class="hljs-comment">//x是const int类型</span><br><span class="hljs-keyword">decltype</span>(b) y = x;<span class="hljs-comment">//y是const int&amp; 类型</span><br></code></pre></div></td></tr></table></figure><p>decltype和数组组合时：结果是一个数组</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">decltype</span>(a) b; <span class="hljs-comment">//等价于int b[5];</span><br></code></pre></div></td></tr></table></figure><p>decltype和指针组合</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span>* pa = &amp;a;<br><span class="hljs-keyword">decltype</span>(pa) b = &amp;a; <span class="hljs-comment">//int* b</span><br></code></pre></div></td></tr></table></figure><h3 id="decltype-表达式"><a href="#decltype-表达式" class="headerlink" title="decltype+表达式"></a>decltype+表达式</h3><p>当使用<code>decltype(expr)</code>的形式时，decltype会返回表达式结果对应的类型。一个<strong>表达式不是左值就是右值</strong>，因此，<code>decltype(expr)</code>的结果根据expr的结果不同而不同：  <strong><code>expr</code>返回左值，得到该类型的左值引用；<code>expr</code>返回右值，得到该类型。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">decltype</span>(i+<span class="hljs-number">4</span>) a;<span class="hljs-comment">//i+4是一个表达式，因此这是一个右值，得到该类型：int  </span><br><span class="hljs-keyword">int</span>* p = &amp;i;<br><span class="hljs-keyword">decltype</span>(*p) b;<span class="hljs-comment">//*p返回对象的左值，*p是int类型，因此这是int&amp;，即int的左值引用。</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">decltype</span>(a[<span class="hljs-number">1</span>]) c;<span class="hljs-comment">//a[1]要看operator[]的实现，数组这里[]的返回值为T&amp;，即返回的是左值引用，左值引用是一个左值，所以推断出c的类型为int&amp;。</span><br></code></pre></div></td></tr></table></figure><p>当一个变量作为表达式时，即<code>decltype((var))</code>会推断出左值引用“</p><p><code>decltype</code>单独作用于对象，没有使用对象的表达式的属性，而是直接获得了变量的类型。要想获得变量作为表达式的类型，可以加一个括号：<code>decltype((var))</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">decltype</span>((i)) di = i;<span class="hljs-comment">//(i)得到的是p的左值，因此一个左值返回的是左值的类型：int&amp;</span><br></code></pre></div></td></tr></table></figure><h3 id="decltype-函数："><a href="#decltype-函数：" class="headerlink" title="decltype+函数："></a>decltype+函数：</h3><p><strong>decltype作用于函数名会得到函数类型</strong>，注意这里<strong>是函数名</strong>，<strong>不是函数调用</strong>，函数调用返回的是一个变量，因此属于上面decltype+变量的部分。</p><p>C++中通过函数的返回值和形参列表，定义了一种名为<strong>函数类型</strong>的东西。它的作用主要是为了<strong>定义函数指针</strong></p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> FunType = <span class="hljs-keyword">int</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;,<span class="hljs-keyword">int</span>);<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;y&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FunType *pf = fun;<br>    pf(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以从过<code>decltype</code>获得<code>fun</code>的类型：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(fun) *pf2 = fun;<span class="hljs-comment">//即FunType *pf = fun;</span><br></code></pre></div></td></tr></table></figure><h2 id="学会查看推导结果"><a href="#学会查看推导结果" class="headerlink" title="学会查看推导结果"></a>学会查看推导结果</h2><ul><li><p>第一种方法就是通过IDE来查看</p></li><li><p>第二种通过编译器报错来查看：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> FunType = <span class="hljs-keyword">int</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;,<span class="hljs-keyword">int</span>);<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;y&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TD</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TD&lt;<span class="hljs-keyword">decltype</span>(fun)&gt;xtype;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>报错：<code>error: aggregate &#39;TD&lt;int(const int&amp;, int)&gt; xtype&#39; has incomplete type and cannot be defined|</code>,可以得知：<code>fun</code>是<code>int(const int&amp;, int)</code>类型。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ shared_ptr循环引用问题/解决方法</title>
    <link href="/2022/02/24/C-shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/24/C-shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="C-shared-ptr循环引用问题-解决方法"><a href="#C-shared-ptr循环引用问题-解决方法" class="headerlink" title="C++ shared_ptr循环引用问题/解决方法"></a>C++ shared_ptr循环引用问题/解决方法</h1><h2 id="关于shared-ptr-weak-ptr"><a href="#关于shared-ptr-weak-ptr" class="headerlink" title="关于shared_ptr/weak_ptr"></a>关于shared_ptr/weak_ptr</h2><p>首先可以看一下这篇文章</p><p><a href="https://chillstepp.github.io/2022/02/15/C-11%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">C++的智能指针-unique_ptr,shared_ptr,weak_ptr</a></p><h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><p>shared_ptr存在循环引用问题：</p><p>考虑下面这样一个代码</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220224204433703.png" srcset="/img/loading.gif" alt="image-20220224204433703"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> _data;<br><span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; next;<br><span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; prev;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt;sp1 = make_shared&lt;Node&gt;();<br>    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt;sp2 = make_shared&lt;Node&gt;();<br>    sp1-&gt;next = sp2;<br>    sp2-&gt;prev = sp1;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sp1</code>，<code>sp2</code>，<code>next</code>，<code>prev</code>均为<code>shared_ptr</code>类型的智能指针 :</p><ul><li><p><code>sp1</code>与<code>sp2-&gt;prev</code>都指向<code>Node1</code>，所以<code>sp1</code>的引用计数为2</p></li><li><p><code>sp1-&gt;next</code>与<code>sp2</code>都指向<code>Node2</code>，所以<code>sp2</code>的引用计数也为2</p></li></ul><p>当我们想销毁这个链表或者说销毁一个结点的时候，我们需要将引用计数置为1，假如，我们要delete sp2这块空间，我们需要将sp2的引用计数置为1，就是说我们需要将sp1-&gt;_next这个指针销毁掉。把sp2-&gt;_next销毁， 就意味着先要把sp1销毁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++拷贝构造函数和operator =的区别</title>
    <link href="/2022/02/15/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Coperator-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/02/15/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Coperator-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C-拷贝构造函数和operator-的区别"><a href="#C-拷贝构造函数和operator-的区别" class="headerlink" title="C++拷贝构造函数和operator =的区别"></a>C++拷贝构造函数和operator =的区别</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前感觉拷贝构造函数和<code>operator =</code>作用很相似，也没有细察他们的区别，今天看了一些文章实验了一下：</p><p>比如我创造了一个Base的class，我同时编写了拷贝构造函数和<code>operator=</code>，那么对于下面这个代码有几个疑问:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Base a;<br>Base b = a;<br></code></pre></div></td></tr></table></figure><p><code>Base b = a;</code> 调用拷贝构造函数 还是 <code>operator =</code>呢? 是两者都可以，还是必须是其中一种?</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先我们了解他们的调用时机:</p><ul><li><p><strong>构造函数调用时机：</strong>该类对象初始化</p></li><li><p><strong><code>operator=</code> 调用时机：</strong>该类对象被赋值 <code>=</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Base()<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"constructor"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    Base(<span class="hljs-keyword">const</span> Base &amp;copy)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"copy constructor"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> Base &amp;<span class="hljs-keyword">operator</span>=(Base &amp;copy)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"operator="</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Base a;     <span class="hljs-comment">// 该类对象初始化，constructor</span><br>    Base b = a; <span class="hljs-comment">// 该类对象初始化，copy constructor，并且只能用copy constructor，不能用operator =</span><br>    <span class="hljs-comment">// 因为删除拷贝构造函数(Base(const Base &amp;copy) = delete;)后</span><br>    <span class="hljs-comment">// 提示了 error: use of deleted function 'Base::Base(const Base&amp;)'</span><br><br><br>    Base d;     <span class="hljs-comment">// 该类对象初始化，constructor</span><br>    d = a;      <span class="hljs-comment">// 该类对象被赋值，operator= ,并且只能用operator=</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>个人认为这样的设计十分合理，从<strong>调用时机</strong>很好的区分了两者的区别。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/yiii/p/5328889.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiii/p/5328889.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的decltype关键字</title>
    <link href="/2022/02/15/C-%E7%9A%84decltype%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/02/15/C-%E7%9A%84decltype%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> C++左值右值/左右值引用/std::move()</title>
    <link href="/2022/02/15/C-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8Cstd-move%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/02/15/C-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8Cstd-move%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-左值右值-左右值引用-std-move"><a href="#C-左值右值-左右值引用-std-move" class="headerlink" title="C++左值右值/左右值引用/std::move()"></a>C++左值右值/左右值引用/std::move()</h1><h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值/右值"></a>左值/右值</h2><ul><li><strong>左值(lvalue)</strong>是放在赋值语句左边可以被赋值的<strong>值(不是变量！)</strong>，<strong>左值必须在内存中有一个确定的地址</strong>。</li><li><strong>右值(rvalue)</strong>用来放在赋值语句右边，将自己的值取出赋给别的变量，<strong>右值没有一个确定的地址</strong>。</li></ul><p>也可以这么理解：</p><ul><li><p><strong>左值</strong>是指表达式结束后依然存在的<strong>持久化对象</strong></p></li><li><p><strong>右值</strong>是指<strong>表达式结束时就不再存在的临时对象</strong>。所有的具名变量或者对象都是左值，而右值不具名（所以匿名变量是一个右值）。</p></li></ul><p>《C++ Primer（第5版）》中描述左值和右值：</p><ul><li>当对象被用作<strong>左值</strong>的时候，用的是对象的身份（在内存中的位置）</li><li>当一个对象被用作<strong>右值</strong>的时候，用的是对象的值（内容）</li></ul><p>以上三个说法都是非常容易理解的，下面我们举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span>* px = &amp;x;<br></code></pre></div></td></tr></table></figure><ul><li><code>int x</code>中的<code>x</code>是一个左值，因为他是赋值语句<code>=</code>左边的值，表达式结束后依然存在的持久化对象，用的是对象的身份（在内存中的位置，向内存写入0）</li><li><code>&amp;x</code>是返回一个右值，它指向了对象x的地址，通过赋值运算符<code>=</code>，将对象<code>x</code>的地址（右值）赋值给了一个新定义的左值对象<code>px</code>。</li></ul><p><strong>常见的右值：</strong>“abc”,123这种字面值常量和表达式求值过程中创建的<strong>临时对象</strong>，还有<code>typename()</code>这种匿名变量/匿名对象。</p><h3 id="访问关系上来看"><a href="#访问关系上来看" class="headerlink" title="访问关系上来看"></a>访问关系上来看</h3><p><strong>一般来说：</strong>右值可以读，不可以写；左值既可以读，也可以写。</p><p>当然有一些<strong>例外情况</strong>： </p><ul><li><p>即使它是左值，也不可以被修改，比如<code>const</code>限定符，<code>const int a = 3</code>,<code>a</code>是不可以被修改的。</p></li><li><p>右值在某些情况下也可以写，就是右值引用</p><ul><li>```c++<br>int a = 0;<br>int &amp;&amp;temp = a + 3;<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><br>### 从替代关系上来看<br><br>**一般来说：**需要右值的地方，都可以使用左值来替代。<br><br>当然有一些**例外情况**： <br><br>- 右值引用接收右值，拒绝左值<br><br>  - ```c++<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> &amp;&amp;temp = a + <span class="hljs-number">3</span>;<span class="hljs-comment">//yes 右值引用接受 a + 3这个表达式(右值)</span><br>    <span class="hljs-built_in">int</span> &amp;&amp;temp1 = a; <span class="hljs-comment">// no 右值引用不接受a这个左值</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h2 id="左值引用-右值引用"><a href="#左值引用-右值引用" class="headerlink" title="左值引用/右值引用"></a>左值引用/右值引用</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    <strong>引用是变量的别名</strong>，必初始化，C++引入的，C语言只有指针，没有引用。引用操作从反汇编层面看可以说完全指针一样，从使用层面来说的确降低大家都指针的理解成本，传参时引用本意减少拷贝，提高性能，但由于是编译器的内部转为为指针，有时比指针的灵活性弱一点点，像原来拷贝构造函数<code>const T&amp;</code>左引用存在一定的缺陷，右值引用带来的移动语义就是来弥补。</p><p>​    <strong>指向左值的引用就是左引用</strong>，我们单个<code>&amp;</code>来表示，C++11前一直使用的;<strong>对右值的引用是右引用</strong>，我们用<code>&amp;&amp;</code>来表示，如下面代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a1 = <span class="hljs-number">100</span>;<br><br><br><span class="hljs-comment">// c1对左值a1引用，左引用</span><br><span class="hljs-keyword">int</span>&amp; c1 = a1;<br><br><span class="hljs-comment">// b1对右值200的引用，右引用</span><br><span class="hljs-keyword">int</span>&amp;&amp; b1 = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// rkTA1对右值TestClassA(1000)进行右引用(匿名变量是左值！)</span><br>TestClassA&amp;&amp; rkTA1 = TestClassA(<span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 无法对右值( a1++)进行左引用，编译失败</span><br><span class="hljs-keyword">int</span>&amp; c2 = a1++; <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 无法对左值a1进行直接右引用，编译失败</span><br><span class="hljs-keyword">int</span>&amp;&amp; b2 = a1; <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 无法对右值TestClassA(1000)进行左引用，编译失败</span><br>TestClassA&amp; rkTA2 = TestClassA(<span class="hljs-number">1000</span>); <span class="hljs-comment">// error</span><br></code></pre></div></td></tr></table></figure><p><strong>注意：虽然右值引用只能引用右值，但是右值引用本身却是左值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr_1 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;&amp;rr_2 = rr_1;  <span class="hljs-comment">// 编译错误 error: cannot bind rvalue reference of type 'int&amp;&amp;' to lvalue of type 'int'|</span><br></code></pre></div></td></tr></table></figure><p>因此<code>rr_1</code>单独使用，是一个表达式——一个没有运算符的表达式，它返回的是左值；因此不可以将右值引用绑定到左值<code>rr_1</code>上。</p><h3 id="一种特殊的常量左值引用"><a href="#一种特殊的常量左值引用" class="headerlink" title="一种特殊的常量左值引用"></a>一种特殊的常量左值引用</h3><p><strong>有没有直接对右值进行左引用的？</strong></p><p>还真有，那就是<strong><code>const T&amp;</code></strong>，<strong>常量左值引用，能接受右值</strong>，对右值进行这种形式左引用写法也不少，其生命周期被延续。</p><p><strong>这个<code>const T&amp;</code>最大的好处就是：</strong></p><p><strong>工业界实践</strong>的时候，如果C++中，函数传参，不改变参数时，尤其是大数据，尽量使用<code>const T&amp;</code>。我们常用的<strong>拷贝构造函数T(const T&amp;)参数是这个形式，vector容器的函数push_back(const value_type&amp; val)参数也是</strong>，有没有注意到，这类函数<strong>同时接受右值和左值</strong>。</p><h2 id="左右值转换：std-move"><a href="#左右值转换：std-move" class="headerlink" title="左右值转换：std::move"></a>左右值转换：std::move</h2><p>既然是左/右值引用数据类型，就存在转换关系。</p><p>我们可以使用标准库函数<code>std::move</code>得到左值的右值引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;&amp;rr_1 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;&amp;rr_2 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(rr_1);<br></code></pre></div></td></tr></table></figure><p><code>move</code>调用告诉编译器，我们有一个左值<code>rr_1</code>，但是我希望像一个右值一样处理它。我们必须保证，接下来除了对<code>rr_1</code>赋值或销毁它，我们不再使用它。我们不能对<code>rr_1</code>的值作任何假设。</p><p>《C++ Primer（第5版）》推荐使用<code>std::move</code>而不是<code>move</code>，可以避免潜在的命名冲突。</p><p><strong>std::move的定义：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/v2-2ed58d5f5802817edbbf0008dffc7715_r.jpg" srcset="/img/loading.gif" alt="img"></p><p>​    这里，<code>T&amp;&amp;</code>是通用引用，需要注意和右值引用（比如<code>int&amp;&amp;</code>）区分。通过<code>move</code>定义可以看出，<strong>move并没有”移动“什么内容</strong>，<strong>只是将传入的值转换为右值</strong>，此外没有其他动作。<code>std::move</code><strong>+移动构造函数或者移动赋值运算符</strong> ，也就是两者合力才起到这样的作用，才能充分起到减少不必要拷贝的意义。<br><strong>std::move使用前提：</strong></p><ul><li><p>定义的类使用了资源并定义了移动构造函数和移动赋值运算符 (右值和移动构造函数/移动赋值函数配合使用才能起到资源直接转移的作用，减少不必要的拷贝)  </p></li><li><p>该变量即将不再使用 (很容易理解：move后就会变成右值，右值不再具有资源，而单纯作为一个值，不再作为一个对象)</p></li></ul><p><strong>关于move到底是怎么做到左右值转换的请看这篇文章：</strong></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/88371948" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/88371948</a></p><p>简单总结下来就是：我们通过<code>static_cast&lt;&gt;</code>进行强制类型转换返回<code>T&amp;&amp;</code>右值引用，而<code>static_cast</code>之所以能使用类型转换，是通过<code>remove_refrence::type</code>的偏特化模板移除T&amp;&amp;，T&amp;的引用，获取具体类型T（模板偏特化）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的智能指针-unique_ptr,shared_ptr,weak_ptr</title>
    <link href="/2022/02/15/C-11%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/15/C-11%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的智能指针-unique-ptr-shared-ptr-weak-ptr"><a href="#C-的智能指针-unique-ptr-shared-ptr-weak-ptr" class="headerlink" title="C++的智能指针-unique_ptr,shared_ptr,weak_ptr"></a>C++的智能指针-unique_ptr,shared_ptr,weak_ptr</h1><h2 id="智能指针基本介绍和特点"><a href="#智能指针基本介绍和特点" class="headerlink" title="智能指针基本介绍和特点"></a>智能指针基本介绍和特点</h2><p>​    C++11以后出现了智能指针这个新东西，他的出现主要是为了<strong>更方便的进行资源内存管理</strong>。程序员使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理，例如<code>new</code>一个对象，<code>delete</code>一个对象。</p><p>​    他的底层实现方法就是通过一个class来实现，把指针封装成了一个类。<strong>这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。</strong>智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放，即智能指针的析构函数会delete它所指向的对象从而自动回收内存。</p><p>​    总的来说智能指针有以下几个特点：</p><ol><li>智能指针是利用了一种叫做RAII（资源获取即初始化）的技术<strong>对普通的指针用类进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</strong></li><li><strong>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。</strong>另外指针的释放时机也是非常有考究的, 多次释放同一个指针会造成程序崩溃（注：因为一旦一个内存空间被释放后，如果后续程序没有结束，继续申请内存，很可能申请到之前释放了的内存。那么，这时候如果通过之前没有清除干净的指针进行了删除等的操作，就会对现在本来有用的内存造成影响。），这些都可以通过智能指针来解决。</li><li><strong>智能指针还有一个作用是把值语义转换成引用语义。</strong></li></ol><p>​        什么是值语义？<code>object a; object b = a;</code> a和b是两个对象。</p><p>​        什么是引用语义? <code>object a; object b = a;</code> a和b是同一个对象(Java中是这样的)。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>都包含在头文件<code>&lt;memory&gt;</code>中</p><h3 id="unique-ptr和make-unique"><a href="#unique-ptr和make-unique" class="headerlink" title="unique_ptr和make_unique"></a><code>unique_ptr</code>和<code>make_unique</code></h3><p><code>unique_ptr</code><strong>“唯一地”</strong>拥有其所指对象，唯一地占有所拥有地资源，同一时刻只能有一个<code>unique_ptr</code>指向给定对象<strong>（通过禁止拷贝语义、只有移动语义来实现）</strong>，下面是一个小例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">//绑定动态对象</span><br>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能赋值，若赋值成功，则uptr2和uptr都可以对指针指向的同一块地址写东西。</span><br>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷贝，同理和上面一样。</span><br>        <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; uptr2 = <span class="hljs-built_in">move</span>(uptr); <span class="hljs-comment">//转换所有权</span><br>        uptr2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所有权</span><br>    &#125;<br>    <span class="hljs-comment">//超过uptr的作用域，內存释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>同时这里我们提出一个<strong>建议：请优先选用std::make_unique和std::make_shared,而非直接new：</strong></p><p>​    c++14加入了<code>std::make_unique</code>,它可以取代<code>new</code>并且无需<code>delete pointer</code>，有助于代码管理。同时在《Effective Modern C++》条款21写到：请优先选用std::make_unique和std::make_shared,而非直接new。更多请看下面的文章</p><blockquote><p>《Effective Modern C++》学习笔记之条款二十一：优先选用std::make_unique和std::make_shared,而非直接new - 知乎 <a href="https://zhuanlan.zhihu.com/p/355238160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355238160</a></p></blockquote><p><strong><code>std::make_unique()</code>用法如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceType</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"fun called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//绑定对象方法1 : 上面我们一开始用的方法，但我们更建议用下面三种(方法2，3，4)利用make_unique绑定的方法，原因在上面有提到;</span><br>        <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;ResourceType&gt; <span class="hljs-title">uptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ResourceType)</span></span>;<br><br>        <span class="hljs-comment">//绑定对象方法2: 注意这是一个移动构造函数，而并非拷贝构造函数,拷贝构造函数在unique_ptr中已经禁用掉了</span><br>        <span class="hljs-function"><span class="hljs-built_in">unique_ptr</span>&lt;ResourceType&gt; <span class="hljs-title">uptr2</span><span class="hljs-params">(make_unique&lt;ResourceType&gt;())</span></span>;<br>        <span class="hljs-comment">//绑定对象方法3: 注意这是一个移动构造函数，而并非拷贝构造函数,拷贝构造函数在unique_ptr中已经禁用掉了</span><br>        <span class="hljs-built_in">unique_ptr</span>&lt;ResourceType&gt; uptr3 = make_unique&lt;ResourceType&gt;();<br>        <span class="hljs-comment">//绑定对象方法4 : 方法2,3中的unique_ptr&lt;int&gt;可以用一个语法糖auto代替，以减少代码量。</span><br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">uptr4</span><span class="hljs-params">(make_unique&lt;ResourceType&gt;())</span></span>;<br>        <span class="hljs-keyword">auto</span> uptr5 = make_unique&lt;ResourceType&gt;();<br>        <br>    &#125;<br>    <span class="hljs-comment">//超过uptr的作用域，內存释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>既然<code>unique_ptr</code>中禁用掉了拷贝构造函数，那么怎么把一个<code>unique_ptr</code>A的所有权转交给另一个<code>unique_ptr</code>B，并使得A不再指向原来所指的东西呢？</strong></p><p>通过<strong>std::move()</strong>  ，<strong>即把A的内存空间直接交给B</strong>，如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceType</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"fun called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-built_in">unique_ptr</span>&lt;ResourceType&gt;uptrA(make_unique&lt;ResourceType&gt;());<br>    <span class="hljs-built_in">unique_ptr</span>&lt;ResourceType&gt;uptrB = <span class="hljs-built_in">move</span>(uptrA);<span class="hljs-comment">//转换所有权</span><br>uptrB.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所有权</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同理，如果你想用<code>vector&lt;unique_ptr&lt;ResourceType&gt;&gt;ResourceVec</code>,那么可以使用<code>ResourceVec.push_back(move(...))</code>来向里面塞<code>unique_ptr</code>智能指针。</p><h3 id="shared-ptr和make-shared"><a href="#shared-ptr和make-shared" class="headerlink" title="shared_ptr和make_shared"></a><code>shared_ptr</code>和<code>make_shared</code></h3><p><code>shared_ptr</code>是多个指针指向相同的对象。<code>shared_ptr</code>使用引用计数，每一个<code>shared_ptr</code>的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。<code>shared_ptr</code>内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><ul><li><strong>初始化:</strong>  智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用<code>make_shared</code>函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如<code>std::shared_ptr&lt;int&gt; p4 = new int(1);</code>的写法是错误的，但是<code>std::shared_ptr&lt;int&gt; p4(new int(1));</code>是正确的。</li><li><strong>拷贝和赋值。</strong>拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。</li><li><p><strong><code>get()</code>函数获取原始指针</strong></p></li><li><p><strong><code>use_count()</code>引用计数次数</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptra1 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(a);<br>    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptra2</span><span class="hljs-params">(ptra1)</span></span>; <span class="hljs-comment">//这个是拷贝构造函数实现的</span><br>    <span class="hljs-comment">//use_count()</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; ptra1.use_count() &lt;&lt; ptra2.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出引用计数都是:2 , shared_ptr存着ptra1和ptra2。</span><br>    <span class="hljs-comment">//get()</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; ptra2.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">" "</span>&lt;&lt; ptra1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ptra2 &lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出: 0x1f17a0 0x1f17a0 0x1f17a0，因为这是一个shared_ptr，所以他们指向同一片地址，即指针相同。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong><code>reset()</code>函数删除调用者的引用</strong></li></ul><p>​    首先我们要清楚这个是干嘛的，当一个<code>shared_ptr</code>调用这个函数，那么<code>shared_ptr</code>就会引用减去1。代码例子在下面：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220216012011270.png" srcset="/img/loading.gif" alt="image-20220216012011270"></p><p>查阅cpp reference，可以看出这个<code>shared_ptr</code>类有3个偏特化的模板：</p><p>其中提到了第2，3，4种模板在<code>use_count</code>为1时调用<code>reset</code>函数，且函数里含有指针，可以使得：</p><p>1.引用计数减1，引用计数为0</p><p>2.将参数里的新指针交给智能指针</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Person(<span class="hljs-keyword">int</span> v) &#123;<br>        value = v;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cons"</span> &lt;&lt;value&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~Person() &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Des"</span> &lt;&lt;value&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> value;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Person&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>))</span></span>;<span class="hljs-comment">// Person(1)的引用计数为1</span><br><br>    p1.reset(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>));<span class="hljs-comment">// 首先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1)</span><br>                            <span class="hljs-comment">// 最后将新对象的指针交给智能指针</span><br><br>    <span class="hljs-built_in">shared_ptr</span>&lt;Person&gt; p3 = p1;<span class="hljs-comment">//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2</span><br><br>    p1.reset();<span class="hljs-comment">//Person(3)的引用计数为1</span><br>    p3.reset();<span class="hljs-comment">//Person(3)的引用计数为0，析构Person(3)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong><code>shared_ptr</code>的需要注意的点/缺点：</strong></p><ul><li><p>注意不要用一个原始指针初始化多个<code>shared_ptr</code>，否则会造成二次释放同一内存。这是因为多个<code>shared_ptr</code>互不相关，当一个<code>shared_ptr</code>的引用计数为0时，调用<code>delete</code>使得释放一次内存，如果其他的<code>shared_ptr</code>同样指向了这片内存，当其他的<code>shared_ptr</code>引用次数为0时就会再次调用<code>delete</code>释放内存，导致二次释放同一内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Person(<span class="hljs-keyword">int</span> v) &#123;<br>        value = v;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cons"</span> &lt;&lt;value&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~Person() &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Des"</span> &lt;&lt;value&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> value;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    Person* a = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//一个原始指针a初始化多个shared_ptr</span><br>    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Person&gt; <span class="hljs-title">p1</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Person&gt; <span class="hljs-title">p2</span><span class="hljs-params">(a)</span></span>;<br>    p1.reset();<span class="hljs-comment">//释放了a的内存</span><br>    p2.reset();<span class="hljs-comment">//再次释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>注意避免循环引用，<code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在<code>weak_ptr</code>中介绍。</p></li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h3><p>　<code>weak_ptr</code>是为了配合<code>shared_ptr</code>而引入的一种智能指针，因为它不具有普通指针的行为，没有重载<code>operator*</code>和<code>-&gt;,</code>它的最大作用在于协助<code>shared_ptr</code>工作，像旁观者那样观测资源的使用情况。<code>weak_ptr</code>可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的<strong>构造不会引起指针引用计数的增加</strong>。使用<code>weak_ptr</code>的成员函数<code>use_count()</code>可以观测资源的引用计数，另一个成员函数<code>expired()</code>的功能等价于<code>use_count()==0</code>,但更快，表示被观测的资源(也就是<code>shared_ptr</code>的管理的资源)已经不复存在。<code>weak_ptr</code>可以使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象， 从而操作资源。但当<code>expired()==true</code>的时候，<code>lock()</code>函数将返回一个存储空指针的<code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; sh_ptr = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 输出: 1</span><br><br>    <span class="hljs-function">weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sh_ptr)</span></span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 输出: 1</span><br><br>    <span class="hljs-keyword">if</span>(!wp.expired())<span class="hljs-comment">//如果 shared_ptr的引用次数不是0 </span><br>    &#123;<br>        <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; sh_ptr2 = wp.lock(); <span class="hljs-comment">//从被观测的shared_ptr获得一个可用的shared_ptr对象</span><br>        *sh_ptr2 = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">// 输出: 2</span><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="技术-实现细节"><a href="#技术-实现细节" class="headerlink" title="技术/实现细节"></a>技术/实现细节</h2><p>这里暂时不谈，不过这里有一个对<code>shared_ptr</code>简单的实现可以看一下，但是它还没有对<code>reset()</code>进行实现：</p><p>​    下面是一个简单智能指针的demo。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -&gt; 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPointer</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    T* _ptr;<br>    <span class="hljs-keyword">size_t</span>* _count;<br><span class="hljs-keyword">public</span>:<br>    SmartPointer(T* ptr = <span class="hljs-literal">nullptr</span>) :<br>            _ptr(ptr) &#123;<br>        <span class="hljs-keyword">if</span> (_ptr) &#123;<br>            _count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">size_t</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">size_t</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    SmartPointer(<span class="hljs-keyword">const</span> SmartPointer&amp; ptr) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br>            <span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>            (*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>        &#125;<br>    &#125;<br><br>    SmartPointer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SmartPointer&amp; ptr) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) &#123;<br>            (*<span class="hljs-keyword">this</span>-&gt;_count)--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br>        <span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>        (*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        assert(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br><br>    &#125;<br><br>    T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        assert(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>    &#125;<br><br>    ~SmartPointer() &#123;<br>        (*<span class="hljs-keyword">this</span>-&gt;_count)--;<br>        <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;_count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">SmartPointer&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>        <span class="hljs-function">SmartPointer&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp)</span></span>;<br>        <span class="hljs-function">SmartPointer&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">20</span>))</span></span>;<br>        sp2 = sp3;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; sp3.use_count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-comment">//delete operator</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector容器内存释放技巧:swap()</title>
    <link href="/2022/02/11/vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%8A%80%E5%B7%A7-swap/"/>
    <url>/2022/02/11/vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%8A%80%E5%B7%A7-swap/</url>
    
    <content type="html"><![CDATA[<h1 id="vector容器内存释放技巧-swap"><a href="#vector容器内存释放技巧-swap" class="headerlink" title="vector容器内存释放技巧:swap()"></a>vector容器内存释放技巧:swap()</h1><p>​    <code>.clear()</code>方法并不会释放内存，他只会清空内容，但是容器内存依然占据着，因此我们需要用一种swap trick来解决这个问题：</p><p>​    下面是一个利用swap trick来修整空间的例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v;<br>v.push_back(<span class="hljs-number">1</span>);<br>v.push_back(<span class="hljs-number">2</span>);<br>v.push_back(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(v).swap(v);<br></code></pre></div></td></tr></table></figure><p>我们指导vector的扩容每次会扩大出大于我们所需要的额外的空间，但是如果后面我们暂时不会向vector中添加东西时，想要删除掉多余的额外空间，也就是修整空间，该怎么办呢？</p><p><strong>vector有一个特点就是：容器的拷贝构造函数不会开辟扩容出的空间</strong></p><p>即容器A赋值容器B时，即<strong>调用容器的拷贝构造函数</strong>时，容器B只会开辟正好可以容下容器A所有元素的容量，而不会开辟 <strong>容器A扩容出的空间</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>&#123;<br>v1.push_back(i);<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1的容量："</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1的大小："</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>v1.resize(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1的容量："</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1的大小："</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v2(v1);<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2的容量："</span> &lt;&lt; v2.capacity() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v2的大小："</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/20191121225536754.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如图容量只为3，而不是138255。同时上图的例子告诉我们<strong>resize也不能修整空间</strong>。</p><p>我们可以充分利用<strong>容器的拷贝构造函数不会开辟扩容出的空间</strong>这个特点，同时利用匿名容器会自动析构这个特点：使用这个技巧<code>vector&lt;int&gt;(v).swap(v);</code></p><p>即 我们首先创造出一个匿名的容器<code>vector&lt;int&gt;()</code> ，给他附上了v的所有元素，即<code>vector&lt;int&gt;(v)</code>，此时他的容量等于他的大小。我们将这个匿名的容器和v进行swap()后，v的容量就被修正了，同时匿名函数自动触发析构函数释放空间。</p><p>clear()可以清空所有元素。<strong>但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收</strong>。因此同样的技巧可以用于释放vector的所有空间：</p><p>用一个空的vector去和我们想要清空的vector pointVec进行swap。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;Point&gt;().swap(pointVec);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RB-tree红黑树</title>
    <link href="/2022/02/09/RB-tree/"/>
    <url>/2022/02/09/RB-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="RB-tree红黑树"><a href="#RB-tree红黑树" class="headerlink" title="RB-tree红黑树"></a>RB-tree红黑树</h1><h2 id="一些基本性质："><a href="#一些基本性质：" class="headerlink" title="一些基本性质："></a>一些基本性质：</h2><p>1.根节点一定是黑色</p><p>2.所有叶子结点(叶子结点都是空节点)都是黑色</p><p>3.<strong>红色</strong>结点的两个子结点一定是<strong>黑色</strong></p><p>4.从任一个节点，到它每个叶子结点的路径都包含相同数目的黑色节点。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220207222448091.png" srcset="/img/loading.gif" alt="image-20220207222448091"></p><h2 id="红黑树插入："><a href="#红黑树插入：" class="headerlink" title="红黑树插入："></a>红黑树插入：</h2><p>分三大类情况</p><p>1.<strong>被插入的节点是根节点</strong>，直接把此节点涂黑</p><p>2.<strong>被插入的节点的父节点是黑色</strong>，直接插进去并且把节点变成红色(这是因为变成红色就不会影响上述的 基本性质4)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220207225303265.png" srcset="/img/loading.gif" alt="image-20220207225303265"></p><p>3.<strong>被插入的节点的父节点是红色</strong>，(由于红色只能挨着黑色，所以不能简单的插入后变红。)</p><ul><li><p>3.1 叔叔节点也是红色(叔叔节点就是父节点的父节点的另一个儿子节点)</p><p>​    父节点设为黑色，叔叔节点设为黑色，祖父节点设为红色，将祖父节点设为当前节点，之后对当前节点进行操作。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220207230629066.png" srcset="/img/loading.gif" alt="image-20220207230629066"></p></li><li><p>3.2 叔叔节点也是黑色，且当前点是父节点的右孩子</p><p>​    将父节点作为新的当前节点，以新的当前节点为支点进行左旋：</p><p>   操作完后就会转化到3.3的情况</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220207232442426.png" srcset="/img/loading.gif" alt="image-20220207232442426"></p></li><li><p>3.3 叔叔节点也是黑色，且当前点是父节点的左孩子</p></li></ul><p>​            将父节点变为黑色，将祖父节点设为红色，然后以祖父节点为支点右旋。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220207233330608.png" srcset="/img/loading.gif" alt="image-20220207233330608"></p><h2 id="红黑树删除："><a href="#红黑树删除：" class="headerlink" title="红黑树删除："></a><strong>红黑树删除：</strong></h2><p>这里我们先解释一下在<strong>AVL中是如何删除</strong>的：</p><p>1.假如要删除的节点只有1个儿子，那么直接把儿子提上来即可。</p><p>2.假如要删除的节点有2个儿子，那么把<strong>右儿子的最左边节点</strong>提上来即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220208142819636.png" srcset="/img/loading.gif" alt="image-20220208142819636"></p><p>红黑树中删除和AVL的区别是还<strong>需要维护黑色平衡的性质：</strong></p><p><strong>1.如果删除的是红色点</strong>，那么我们什么也不需要做，因为这不会影响黑色平衡的性质，和AVL一样重新调整平衡即可。</p><p><strong>2.如果删除的是黑色点：</strong>先提上来的结点颜色变为混合色：<strong>黑(要删除节点的颜色)+黑/红(提上来结点颜色)</strong> 的混合颜色。</p><ul><li><p><strong>2.1</strong> <strong>黑+提上来的红色 ：</strong>结点设为黑色即可（因为提上来是的红色没了也不影响黑色平衡性，原来的黑色结点被删除后补上新的黑色保持了黑色平衡性）</p></li><li><p><strong>2.2 根节点的黑(根节点一定为黑色)+提上来的黑色：</strong>结点设为黑色即可（因为从根节点开始，只是相当于从根节点开始的所有路径到叶子结点的黑色结点数全部减一，但不影响黑色平衡性）。</p></li><li><p><strong>2.3 普通的黑色节点+提上来的黑色：</strong></p><p>设x为当前要删除的黑色节点。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220209010529063.png" srcset="/img/loading.gif" alt="image-20220209010529063"></p></li></ul><h2 id="红黑树和AVL比较："><a href="#红黑树和AVL比较：" class="headerlink" title="红黑树和AVL比较："></a>红黑树和AVL比较：</h2><ol><li>红黑树不追求”完全平衡”，即不像AVL那样要求节点的 <code>|balFact| &lt;= 1</code>，它只要求部分达到平衡，但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。</li><li>插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)。</li><li>删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡(注意:但是恢复红黑树的颜色性质需要少量logn的操作)，只需O(1)，所以说<strong>RB-Tree删除节点的rebalance的效率更高</strong>！</li><li><strong>AVL的结构相较于RB-Tree更为平衡</strong>，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于<strong>AVL高度平衡，因此AVL的Search效率更高</strong>。</li><li>针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较”简单”的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.</li></ol><h2 id="总结：引入RB-Tree是功能、性能、空间开销的折中结果。"><a href="#总结：引入RB-Tree是功能、性能、空间开销的折中结果。" class="headerlink" title="总结：引入RB-Tree是功能、性能、空间开销的折中结果。"></a><strong>总结：</strong>引入RB-Tree是功能、性能、空间开销的折中结果。</h2><ol><li>AVL更平衡，结构上更加直观，<strong>search快一些；维护稍慢</strong>(因为AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN) )，<strong>空间开销较大</strong>(每个节点需要额外两比特来表示左斜、平衡、右斜三种状态,红黑树的每个节点只需要额外一比特来表示红、黑两种颜色)。</li><li>实际应用上，红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。</li></ol><h2 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h2><p><a href="https://zhuanlan.zhihu.com/p/93369069" target="_blank" rel="noopener">关于AVL树和红黑树的一点看法</a></p><p><a href="https://www.bilibili.com/video/BV1Ar4y1Q7Js?from=search&amp;seid=13164802402125540668" target="_blank" rel="noopener">视频-红黑树</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const关键字修饰 相关问题</title>
    <link href="/2022/01/24/const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/24/const%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="const关键字修饰-相关问题"><a href="#const关键字修饰-相关问题" class="headerlink" title="const关键字修饰 相关问题"></a>const关键字修饰 相关问题</h1><p>const修饰问题很麻烦，一个不错的识别方式是：<strong>const默认作用于其左边的东西，否则作用于其右边的东西：</strong></p><h2 id="辨别方法"><a href="#辨别方法" class="headerlink" title="辨别方法"></a>辨别方法</h2><blockquote><p>const int* </p></blockquote><p><code>const</code>只有右边有东西，所以<code>const</code>修饰<code>int</code>成为常量整型，然后<code>*</code>再作用于常量整型。所以这是<code>a pointer to a constant integer</code>（指向一个整型，不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址）</p><blockquote><p>int const *</p></blockquote><p>再看这个，<code>const</code>左边有东西，所以<code>const</code>作用于<code>int</code>，<code>*</code>再作用于<code>int const</code>所以这还是<code>a pointer to a constant integer</code>（同上）</p><p>因此上面两个是同一个东西</p><blockquote><p>int* const </p></blockquote><p>这个<code>const</code>的左边是<code>*</code>，所以<code>const</code>作用于指针（不可改变指向的地址），所以这是<code>a constant pointer to an integer</code>，可以通过指针改变其所指向的内容但只能指向该地址，不可指向别的地址。</p><blockquote><p>const int* const</p></blockquote><p>这里有两个<code>const</code>。左边的<code>const</code>的左边没东西，右边有<code>int</code>那么此<code>const</code>修饰<code>int</code>。右边的<code>const</code>作用于<code>*</code>使得指针本身变成<code>const</code>（不可改变指向地址），那么这个是<code>a constant pointer to a constant integer</code>，不可改变指针本身所指向的地址也不可通过指针改变其指向的内容。</p><blockquote><p>int const * const</p></blockquote><p>这里也出现了两个<code>const</code>，左边都有东西，那么左边的<code>const</code>作用于<code>int</code>，右边的<code>const</code>作用于<code>*</code>，于是这个还是是<code>a constant pointer to a constant integer</code></p><blockquote><p>int const <em> const </em></p></blockquote><p>左边的<code>const</code>：它左边有<code>int</code>，因此这个<code>const</code>修饰<code>int</code>变为常量整型</p><p>右边的<code>const</code>：它左边有个<code>*</code>，因此这个<code>const</code>修饰<code>*</code>，因此这个<code>const</code>作用于指针（不可改变指向的地址）。</p><p>此时我们发现现在还剩下一个<code>*</code>，表示是<code>int const * const</code>的指针</p><p>因此这就是一个<code>a pointer to (a constant pointer to a constant integer)</code>，其实就是指向上边那个的东西的指针。</p><blockquote><p>int const <em> const </em> const</p></blockquote><p>分析同上：这是一个<code>a (constant) pointer to (a constant pointer to a constant integer)</code>，就是int const <em> const </em>不可改变指向地址的形式。</p><h2 id="常见的-引用-指针-变量-的例子："><a href="#常见的-引用-指针-变量-的例子：" class="headerlink" title="常见的 引用/指针/变量 的例子："></a>常见的 引用/指针/变量 的例子：</h2><h3 id="int-const-amp-p-和const-int-amp-p"><a href="#int-const-amp-p-和const-int-amp-p" class="headerlink" title="int const &amp;p 和const int &amp;p"></a><code>int const &amp;p</code> 和<code>const int &amp;p</code></h3><ul><li><p><code>int const &amp;p</code> ：左边有东西，作用的就是 <code>(int const) &amp;p</code>，代表<code>a reference to a constant integer</code>, 即p的值不可以被修改(即不能出现<code>p = 5</code>这种操作);  </p></li><li><p><code>const int &amp;p</code> : 它的<code>const</code>左边没东西，因此和右边结合，就是<code>(const int) &amp;p</code>，<code>const</code>修饰<code>int</code>表示<code>a const integer</code>类型的引用。代表<code>a reference to a const integer</code>,因此和上面的是一回事。</p></li></ul><h3 id="int-const-a和int-const-a和const-int-a"><a href="#int-const-a和int-const-a和const-int-a" class="headerlink" title="int const *a和int* const a和const int* a"></a><code>int const *a</code>和<code>int* const a</code>和<code>const int* a</code></h3><ul><li><code>int const *a</code>：<code>const</code>和<code>int</code>结合因此这是一个<code>constant integer</code>, 因此这是一个 <code>a pointer to a constant integer</code>，即指针a可以变，但是所指向的那个值不能变。</li><li><code>int* const a</code>：<code>const</code>作用于<code>*</code>，说明是一个<code>a constant pointer to a integer</code>,这就表示<code>a</code>所保存的地址是不可以变的，但是这个地址指向的值是可以变的。</li><li><code>const int* a</code>：<code>const</code>左边没东西，因此只能作用于int，说明只是一个<code>a pointer to a constant integer</code>，即指针a可以变，但是所指向的那个值不能变，因此和第一个是一回事。</li></ul><h3 id="int-const-a和int-const-a"><a href="#int-const-a和int-const-a" class="headerlink" title="int const a和int const a"></a><code>int const a</code>和<code>int const a</code></h3><p>这俩很简单，分析方法同上：</p><ul><li><code>int const a</code>：<code>a constant integer</code></li><li><code>const int a</code> ：<code>a constant integer</code>  </li></ul><p>完全一致</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>C++里 const int<em> 与 int const</em> 有什么区别？ - 王国潇的回答 - 知乎 <a href="https://www.zhihu.com/question/443195492/answer/1723886545" target="_blank" rel="noopener">https://www.zhihu.com/question/443195492/answer/1723886545</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode第 277 场周赛题解</title>
    <link href="/2022/01/24/Leetcode%E7%AC%AC-277-%E5%9C%BA%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/01/24/Leetcode%E7%AC%AC-277-%E5%9C%BA%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5989-元素计数"><a href="#5989-元素计数" class="headerlink" title="5989. 元素计数"></a><a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/" target="_blank" rel="noopener">5989. 元素计数</a></h1><p>不等于最大或最小元素 统计一下有多少个即可：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        sort(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]!=a[<span class="hljs-number">0</span>]&amp;&amp;a[i]!=a[n<span class="hljs-number">-1</span>]) ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5991-按符号重排数组"><a href="#5991-按符号重排数组" class="headerlink" title="5991. 按符号重排数组"></a><a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/" target="_blank" rel="noopener">5991. 按符号重排数组</a></h1><p>双指针即刻，复杂度O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rearrangeArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>        <span class="hljs-keyword">while</span>(ans.<span class="hljs-built_in">size</span>()!=n)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(l&lt;n)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[l]&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    ans.push_back(nums[l]);<br>                    l++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> l++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(r&lt;n)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[r]&lt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    ans.push_back(nums[r]);<br>                    r++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5990-找出数组中的所有孤独数字"><a href="#5990-找出数组中的所有孤独数字" class="headerlink" title="5990. 找出数组中的所有孤独数字"></a><a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/" target="_blank" rel="noopener">5990. 找出数组中的所有孤独数字</a></h1><p>遍历一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findLonely</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;v2cnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:a)<br>        &#123;<br>           <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;endl;</span><br>            v2cnt[x]++;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [val,cnt]:v2cnt)<br>        &#123;<br>            <span class="hljs-comment">//cout&lt;&lt;val&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl;</span><br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>&amp;&amp;v2cnt[val+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;v2cnt[val<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>) res.insert(val);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:res) ans.push_back(x);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5992-基于陈述统计最多好人数"><a href="#5992-基于陈述统计最多好人数" class="headerlink" title="5992. 基于陈述统计最多好人数"></a><a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/" target="_blank" rel="noopener">5992. 基于陈述统计最多好人数</a></h1><p>简单题，直接二进制枚举然后O(n^2)check枚举的正确性即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumGood</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<br>        &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;p(n);<br>            <span class="hljs-keyword">int</span> odd = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                p[n-j<span class="hljs-number">-1</span>] = (i&gt;&gt;j)%<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(p[n-j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>) odd++;<br>            &#125;<br>            <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;n;x++)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;n;y++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(p[x]==<span class="hljs-number">1</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(s[x][y]==<span class="hljs-number">1</span>&amp;&amp;p[y]==<span class="hljs-number">0</span>) &#123;ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<br>                        <span class="hljs-keyword">if</span>(s[x][y]==<span class="hljs-number">0</span>&amp;&amp;p[y]==<span class="hljs-number">1</span>) &#123;ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!ok) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!ok) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(ans, odd);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode第 70 场双周赛题解</title>
    <link href="/2022/01/23/leetcode%E7%AC%AC-70-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/01/23/leetcode%E7%AC%AC-70-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="5971-打折购买糖果的最小开销"><a href="#5971-打折购买糖果的最小开销" class="headerlink" title="5971. 打折购买糖果的最小开销"></a><a href="https://leetcode-cn.com/problems/minimum-cost-of-buying-candies-with-discount/" target="_blank" rel="noopener">5971. 打折购买糖果的最小开销</a></h1><p>从大到小排序，三个三个买(2个花钱，1个赠送)，剩余的不够三个就直接花钱买下剩余全部的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumCost</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        sort(cost.<span class="hljs-built_in">begin</span>(),cost.<span class="hljs-built_in">end</span>(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>        <span class="hljs-keyword">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++)<br>        &#123;<br>            ans += cost[i];<br>            i++;<br>            <span class="hljs-keyword">if</span>(i&lt;n) ans += cost[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            i++;<br>            <span class="hljs-keyword">if</span>(i&lt;n) ans += <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5972-统计隐藏数组数目"><a href="#5972-统计隐藏数组数目" class="headerlink" title="5972. 统计隐藏数组数目"></a><a href="https://leetcode-cn.com/problems/count-the-hidden-sequences/" target="_blank" rel="noopener">5972. 统计隐藏数组数目</a></h1><p>设第一个元素为x，差分数组的前缀和最小值为minnd，最大为maxxd，那么x + minnd 就是数组最小的元素l(此时x是下界)，x + maxxd就是数组中最大的元素r(此时x是上界)。</p><p>所以x的范围是 l - minnd 到r - maxxd。</p><p>但是需要注意的是: l - minnd 可能会小于l，因此左边界为max(l - minnd, 1ll*l);</p><p>同理右边界为: min(r - maxxd,1ll*r); </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; d, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = d.<span class="hljs-built_in">size</span>();<br>        ll minnd = <span class="hljs-number">1e9</span>;<br>        ll maxxd = <span class="hljs-number">-1e9</span>;<br>        ll now = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            now = now + <span class="hljs-number">1l</span>l*d[i];<br>            minnd = <span class="hljs-built_in">min</span>(minnd,now);<br>            maxxd = <span class="hljs-built_in">max</span>(maxxd,now);<br>        &#125;<br>        ll x  = <span class="hljs-built_in">max</span>(l - minnd, <span class="hljs-number">1l</span>l*l);<br>        ll y = <span class="hljs-built_in">min</span>(r - maxxd,<span class="hljs-number">1l</span>l*r);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">max</span>(y - x + <span class="hljs-number">1</span>,<span class="hljs-number">1l</span>l*<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5973-价格范围内最高排名的-K-样物品"><a href="#5973-价格范围内最高排名的-K-样物品" class="headerlink" title="5973. 价格范围内最高排名的 K 样物品"></a><a href="https://leetcode-cn.com/problems/k-highest-ranked-items-within-a-price-range/" target="_blank" rel="noopener">5973. 价格范围内最高排名的 K 样物品</a></h1><p>恶心的马力题，bfs处理出所有距离 ，按照鬼畜的偏序判断方法排序即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">map</span>&lt;pii,<span class="hljs-keyword">int</span>&gt;dis;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">highestRankedKItems</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = g.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> m = g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">queue</span>&lt;pii&gt;q;<br>        q.push(&#123;s[<span class="hljs-number">0</span>],s[<span class="hljs-number">1</span>]&#125;);<br>        dis[&#123;s[<span class="hljs-number">0</span>],s[<span class="hljs-number">1</span>]&#125;] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            pii f = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">int</span> x = f.first, y = f.second;<br>            <span class="hljs-keyword">if</span>(dis.count(f))<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>                &#123;<br>                    <span class="hljs-keyword">int</span> xx = x + di[i];<br>                    <span class="hljs-keyword">int</span> yy = y + dj[i];<br>                    <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">0</span>&amp;&amp;xx&lt;n&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;g[xx][yy]!=<span class="hljs-number">1</span>&amp;&amp;(!dis.count(&#123;xx,yy&#125;)))<br>                    &#123;<br>                        dis[&#123;xx,yy&#125;] = dis[f] + <span class="hljs-number">1</span>;<br>                        q.push(&#123;xx,yy&#125;);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(g[i][j]&gt;=p[<span class="hljs-number">0</span>]&amp;&amp;g[i][j]&lt;=p[<span class="hljs-number">1</span>])<br>                &#123;<br>                    res.push_back(&#123;dis[&#123;i,j&#125;], g[i][j], i, j&#125;);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dis[&#123;i,j&#125;] &lt;&lt;<span class="hljs-string">" "</span>&lt;&lt; g[i][j]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt; j&lt;&lt;<span class="hljs-built_in">endl</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        sort(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            ans.push_back(&#123;res[i][<span class="hljs-number">2</span>],res[i][<span class="hljs-number">3</span>]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="5974-分隔长廊的方案数"><a href="#5974-分隔长廊的方案数" class="headerlink" title="5974. 分隔长廊的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-divide-a-long-corridor/" target="_blank" rel="noopener">5974. 分隔长廊的方案数</a></h1><p>每两个s划分一次，找到中间植物的数量，把这些数乘起来即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfWays</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        ll ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> beg = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(beg=<span class="hljs-number">0</span>;beg&lt;n;beg++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[beg]==<span class="hljs-string">'S'</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ed = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(ed=n<span class="hljs-number">-1</span>;ed&gt;=<span class="hljs-number">0</span>;ed--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[ed]==<span class="hljs-string">'S'</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> scnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = beg;i &lt;= ed; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(scnt&lt;<span class="hljs-number">2</span>&amp;&amp;s[i]==<span class="hljs-string">'S'</span>) scnt++;<br>            <span class="hljs-keyword">if</span>(scnt==<span class="hljs-number">2</span>)<br>            &#123;<br>                ok = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">int</span> pcnt = <span class="hljs-number">0</span>;<br>                i++;<br>                <span class="hljs-keyword">while</span>(i&lt;=ed&amp;&amp;s[i]!=<span class="hljs-string">'S'</span>)<br>                &#123;<br>                    pcnt++;<br>                    i++;<br>                &#125;<br>                ans = ans*(pcnt+<span class="hljs-number">1</span>)%MOD;<br>                scnt = <span class="hljs-number">0</span>;<br>                i--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(!ok||scnt!=<span class="hljs-number">0</span>) ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Global Round 18(A-E)</title>
    <link href="/2022/01/23/Codeforces-Global-Round-18-A-E/"/>
    <url>/2022/01/23/Codeforces-Global-Round-18-A-E/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Closing-The-Gap"><a href="#A-Closing-The-Gap" class="headerlink" title="A - Closing The Gap"></a><a href="https://codeforces.com/contest/1615/problem/A" target="_blank" rel="noopener">A - Closing The Gap</a></h2><p>签到：加起来模n即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">int</span> a[MAXN];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>            sum += <span class="hljs-number">1l</span>l*a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum%(<span class="hljs-number">1l</span>l*n)==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"0"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-And-It’s-Non-Zero"><a href="#B-And-It’s-Non-Zero" class="headerlink" title="B - And It’s Non-Zero"></a><a href="https://codeforces.com/contest/1615/problem/B" target="_blank" rel="noopener">B - And It’s Non-Zero</a></h2><p>前缀和处理前1-x中第i位有多少0和1得到 $cnt1，cnt0$两个数组。对于每个询问$l,r$ ，只需要$cnt0[r][i] - cnt0[l-1][i]$即可得到$l$到$r$有的第$i$位有多少$0$。对每一位便利找出0最少的数量作为答案即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-keyword">int</span> cnt1[<span class="hljs-number">200000</span>+<span class="hljs-number">5</span>][<span class="hljs-number">30</span>];<br><span class="hljs-keyword">int</span> cnt0[<span class="hljs-number">200000</span>+<span class="hljs-number">5</span>][<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;num&lt;=<span class="hljs-number">200000</span>;num++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((num&gt;&gt;(i<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>            &#123;<br>                cnt1[num][i] = cnt1[num<span class="hljs-number">-1</span>][i] + <span class="hljs-number">1</span>;<br>                cnt0[num][i] = cnt0[num<span class="hljs-number">-1</span>][i];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cnt1[num][i] = cnt1[num<span class="hljs-number">-1</span>][i];<br>                cnt0[num][i] = cnt0[num<span class="hljs-number">-1</span>][i] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l,r;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;l&gt;&gt;r;<br><br>        <span class="hljs-keyword">int</span> ans = INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt1[r][i] - cnt1[l<span class="hljs-number">-1</span>][i]!=<span class="hljs-number">0</span>) ans = <span class="hljs-built_in">min</span>(ans,cnt0[r][i] - cnt0[l<span class="hljs-number">-1</span>][i]);<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Menorah"><a href="#C-Menorah" class="headerlink" title="C - Menorah"></a><a href="https://codeforces.com/contest/1615/problem/C" target="_blank" rel="noopener">C - Menorah</a></h2><p>首先不难想到，对于一个串，交换值为0和1的两个位置需要<strong>2次操作</strong>。</p><p>当两个串的<strong>01个数分别相等时</strong>，最小次数就是直接进行两个位置01交换的次数，设对应位不相等的数量为dif，答案就是dif/2*2，其中dif一定为偶数；</p><p>当<strong>不相等时</strong>，考虑如何使得他们01个数先相等，例如对于： 00000111 ，对其中一个1进行操作，得到11111001，可以发现奇数次变换可以改变01的数量，且只能使得1的个数多一个。因此当$n -a串中1的个数  == b串中1的个数 -1$时 可以使得01个数恢复相等，即转化为了第一种情况。</p><p>其他情况都是不可能存在的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        <span class="hljs-built_in">string</span> a,b;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">999999</span>, dif = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a1 = count(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-string">'1'</span>);<br>        <span class="hljs-keyword">int</span> b1 = count(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-string">'1'</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) dif += (a[i]!=b[i]);<br><br>        <span class="hljs-keyword">if</span>(a1 == b1) ans = <span class="hljs-built_in">min</span>(ans, dif);<br>        <span class="hljs-keyword">if</span>(n -a1  == b1 <span class="hljs-number">-1</span>) ans = <span class="hljs-built_in">min</span>(ans, (n - dif - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">999999</span>) ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">'\n'</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-X-or-mas-Tree"><a href="#D-X-or-mas-Tree" class="headerlink" title="D - X(or)-mas Tree"></a><a href="https://codeforces.com/contest/1615/problem/D" target="_blank" rel="noopener">D - X(or)-mas Tree</a></h2><p>对于一个数的parity的奇偶性可以只改变最后一位来进行奇偶的转换，所有我们赋值只需要考虑0和1两个数即可。</p><p>我们首先定义点u的权值$value(u)$为$u$到树根的路径上所有路径异或的奇偶性(0/1)。</p><p>那么对于两个点u到v的路径奇偶性：</p><ul><li><p>如果题目规定他们的奇偶性是1(也就是奇数)，我们可以得到他们两者的$value(u)$ 和$value(v)$ 奇偶性是不同的。</p></li><li><p>如果题目规定他们的奇偶性是0(也就是偶数)，我们可以得到他们两者的$value(u)$ 和$value(v)$ 奇偶性是相同的。</p></li></ul><p>不难想到，我们可以首先用种类并查集维护这个东西，他们之间的关系可以看作约束条件(constraints)。</p><p>因此最后根据上述的约束条件对每个未知的边赋值，对于一个点$u$，如果$u$和$u+n$(拓展域并查集写法)相连说明自己和自己奇偶性不同(这是不可能的)，则无解输出NO。否则有解输出YES。</p><p>最后，<strong>对于给出的未知权重一条边：</strong></p><ul><li><p>若这条边两点的$value$不同，说明这条边是值为1，经过这条边奇偶变化。</p></li><li><p>若这条边两点的$value$可以相同或已给出的约束未对这两点出约束，说明这条边是值为0，经过这条边不影响奇偶。</p></li></ul><p><strong>总结一下：这题难点在于定义权值value为$u$到树根的路径上所有路径异或的奇偶性</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">int</span> p[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x] = fd(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mrge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fax = fd(x), fay = fd(y);<br>    <span class="hljs-keyword">if</span>(fax!=fay) p[fax] = fay;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n,m;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>,3&gt;&gt;edge;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">2</span>;i++) p[i] = i;<span class="hljs-comment">//init</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x,y,v;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>            edge.push_back(&#123;x,y,v&#125;);<br>            <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(__builtin_parity(v))<span class="hljs-comment">//num of 1 is odd,x and y are different</span><br>                &#123;<br>                    mrge(x,y+n);<br>                    mrge(x+n,y);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                &#123;<br>                    mrge(x,y);<br>                    mrge(x+n,y+n);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x,y,v;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>            <span class="hljs-keyword">if</span>(v==<span class="hljs-number">1</span>)<br>            &#123;<br>                mrge(x,y+n);<br>                mrge(x+n,y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)<br>            &#123;<br>                mrge(x,y);<br>                mrge(x+n,y+n);<br>            &#125;<br>        &#125;<br><br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edge)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[<span class="hljs-number">2</span>]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(fd(e[<span class="hljs-number">0</span>])==fd(e[<span class="hljs-number">1</span>]+n)) <span class="hljs-comment">//constraints make e[0] e[1] value different</span><br>            &#123;<br>                e[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//constraints make e[0] e[1] value same</span><br>            &#123;<br>                e[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>                mrge(e[<span class="hljs-number">0</span>],e[<span class="hljs-number">1</span>]);<br>                mrge(e[<span class="hljs-number">0</span>]+n,e[<span class="hljs-number">1</span>]+n);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ok = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fd(i)==fd(i+n))<br>            &#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!ok) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edge)<br>            &#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;e[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;e[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;e[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E-Purple-Crayon"><a href="#E-Purple-Crayon" class="headerlink" title="E - Purple Crayon"></a><a href="https://codeforces.com/contest/1615/problem/E" target="_blank" rel="noopener">E - Purple Crayon</a></h2><p>把$w$替换为$n-r-b$得到： $r⋅(n−r)−b⋅(n−b). $</p><p>首先要想到：当红色涂完后，蓝色可以最多涂x个，那么蓝色涂色时对于小于等于x个都是可以实现的。</p><p>那么如何让 $goal = r⋅(n−r)−b⋅(n−b) $最小呢？ </p><p>首先我们如果可以选择的x个红色(x是一个确定值，即我就选择x这么多个)，此时最佳的选择方法肯定是选择后让b最多可选的值maxb 越小越好(实现方法是：x个树叶的所有祖先节点构成的子树的节点越多越好，因为这些点不能染蓝色，其他都可以,也就是让蓝色最少)，因为如果其$maxb&gt;=n/2$ 那么maxb一定会选择$n/2$使得$b⋅(n−b)$最大。如果$maxb&lt; n/2$那么我们也是选择maxb，所以RED肯定想让BLUE的maxb越小越好。</p><p>现在遍历$r = 1,2,3…k$， 我们只要可以算出每个$r$ 对应的maxb，那么对于BLUE, 我们知道最优的b = min(n/2,minb)，带入goal算出结果，对于每个r取最大值更新即是RED的最优的开局策略。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><br>pii dep[MAXN];<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;point2dep;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[MAXN];<br><span class="hljs-keyword">int</span> vis[MAXN];<br><span class="hljs-keyword">int</span> g_re[MAXN];<br><span class="hljs-built_in">vector</span>&lt;pii&gt;leaves;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    g_re[u] = fa;<br>    dep[u] = &#123;d,u&#125;;<br>    point2dep[u] = d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dfs(v,u,d+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> vis_d = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(vis[u]) &#123;vis_d = point2dep[u];<span class="hljs-keyword">return</span>;&#125;<br><br>    vis[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u == <span class="hljs-number">1</span>)<br>    &#123;<br>        vis_d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> v = g_re[u];<br>    dfs2(v,u);<br><br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-comment">//cin&gt;&gt;T;</span><br>    T = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n,k;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x,y;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>            g[x].push_back(y);<br>            g[y].push_back(x);<br>        &#125;<br>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>        sort(dep+<span class="hljs-number">1</span>,dep+<span class="hljs-number">1</span>+n,greater&lt;pii&gt;());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(g[dep[i].second].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>            &#123;<br>                vis_d = <span class="hljs-number">-1</span>;<br>                dfs2(dep[i].second,<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">int</span> cover_leaves = dep[i].first - vis_d;<br>                leaves.push_back(&#123;cover_leaves,i&#125;);<br>            &#125;<br>        &#125;<br><br>        sort(leaves.<span class="hljs-built_in">begin</span>(),leaves.<span class="hljs-built_in">end</span>(),greater&lt;pii&gt;());<br>        <span class="hljs-keyword">int</span> leaves_cnt = leaves.<span class="hljs-built_in">size</span>();<br>        ll ans = <span class="hljs-number">-1e12</span>;<br><br>        <span class="hljs-keyword">int</span> red_cover_leaves = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> half = n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;leaves_cnt)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(k&lt;=half) ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-number">1l</span>l*k*(n-k));<span class="hljs-comment">//k half</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leaves_cnt&lt;=half) ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-number">1l</span>l*half*(n-half)); <span class="hljs-comment">//lea half k</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            red_cover_leaves += leaves[i<span class="hljs-number">-1</span>].first;<br>            <span class="hljs-keyword">int</span> blue_cover_leaves = n - red_cover_leaves;<br>            <span class="hljs-keyword">if</span>(blue_cover_leaves&gt;=n/<span class="hljs-number">2</span>) blue_cover_leaves = n/<span class="hljs-number">2</span>;<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-number">1l</span>l*i*(n-i) - <span class="hljs-number">1l</span>l*blue_cover_leaves*(n-blue_cover_leaves));<br>        &#125;<br><br><br><br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象高级编程-下</title>
    <link href="/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/"/>
    <url>/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象高级编程-下"><a href="#C-面向对象高级编程-下" class="headerlink" title="C++面向对象高级编程(下)"></a>C++面向对象高级编程(下)</h1><h2 id="Conversion-function转换函数"><a href="#Conversion-function转换函数" class="headerlink" title="Conversion function转换函数"></a>Conversion function转换函数</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214154138982.png" srcset="/img/loading.gif" alt="image-20211214154138982"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<br></code></pre></div></td></tr></table></figure><p>对于<code>double d = 4 + f;</code>这一条语句编译器的动作是:</p><p>1.对于上面的操作<code>4+f</code>有没有一个<code>operator+</code>可以使得  <code>double + fraction</code>的函数（不存在，那么下一种方法）</p><p>2.是否存在可以让4转换为double的函数(默认存在)和让fraction转换为double的函数(存在)，因此没有问题通过。</p><p><strong>以上的动作不存在谁比较好/谁先谁后，超过一个可行都会被认为是ambiguous的。</strong></p><h2 id="隐式转换构造函数non-explicit-one-argument-ctor"><a href="#隐式转换构造函数non-explicit-one-argument-ctor" class="headerlink" title="隐式转换构造函数non-explicit-one-argument ctor"></a>隐式转换构造函数non-explicit-one-argument ctor</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214155947325.png" srcset="/img/loading.gif" alt="image-20211214155947325"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d = f + <span class="hljs-number">4</span>;<br></code></pre></div></td></tr></table></figure><p>Fraction d = f + 4; 这个函数的意义是 f调用operator+ 参数为4 ,而接受端会发现4被<code>隐式转换</code>成 Fraction。这个隐式转换是<code>non-explicit ctor</code>做得，他将4转换为了Fraction类型。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214161205084.png" srcset="/img/loading.gif" alt="image-20211214161205084"></p><p>上述代码会造成的<strong>歧义：</strong></p><p>1.f + 4 先调用<code>operator+</code> ，由于加法的参数需要fraction，因此将4隐式转换为Fraction类型，执行完成加法操作。</p><p>2.f首先变成double类型，随后再和4相加，最后整体作为一个数字通过隐式转换转换为Fraction类型</p><p>以上两种都可以发生且合理。</p><p><strong>如果你不希望那种隐式转换(<code>non-explicit</code>)出现，那么可以加上<code>explict</code>关键字，防止通过构造函数进行隐式转换：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214161820508.png" srcset="/img/loading.gif" alt="image-20211214161820508"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214162126280.png" srcset="/img/loading.gif" alt="image-20211214162126280"></p><p>虽然此时还是会出现错误的，因为上面我们所提到两种歧义的方法都会用到隐式转换：一种是4隐式转换为Fraction类型，另一种是答案通过通过隐式转换转换为Fraction类型。但由于此时我们加上了explicit关键字，这里不允许通过他的构造函数发生这种的隐式转换。</p><h2 id="标准库中的一个利用转换函数的例子"><a href="#标准库中的一个利用转换函数的例子" class="headerlink" title="标准库中的一个利用转换函数的例子"></a>标准库中的一个利用转换函数的例子</h2><p>这是一个<strong>模板偏特化</strong>的例子，也是标准库中的一段代码：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214162711966.png" srcset="/img/loading.gif" alt="image-20211214162711966"></p><p>这里用<code>reference</code>来代替了返回的类型，那么就一定要利用转换函数将返回结果的类型(<code>bool</code>)转换为<code>reference</code>的类型，而这类的<code>reference</code>通过就是<code>__bit_reference</code>类型，那么也就是说<code>__bit_reference</code>这个类里一定有一个转换为<code>bool</code>类型的转换函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163200746.png" srcset="/img/loading.gif" alt="image-20211214163200746"></p><p>发现确实如此。</p><h2 id="pointer-like-classes，关于智能指针"><a href="#pointer-like-classes，关于智能指针" class="headerlink" title="pointer-like classes，关于智能指针"></a>pointer-like classes，关于智能指针</h2><p>这是一个类似指针，但比普通指针更智能的写法，是c++写的一个类。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163446733.png" srcset="/img/loading.gif" alt="image-20211214163446733"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163700753.png" srcset="/img/loading.gif" alt="image-20211214163700753" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt;sp(<span class="hljs-keyword">new</span> Foo);<br></code></pre></div></td></tr></table></figure><p>首先new一个<code>Foo</code>类型的指针当成初值赋值给<code>shared_ptr</code>的对象sp，这个赋初值的过程毫无疑问调用的是<code>shared_ptr</code>的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(*sp)</span></span>;<br></code></pre></div></td></tr></table></figure><p>这一步由于重载运算符<code>operator*()</code>,把sp指针中的px指针所指的值取出来。</p><p>以上两部都很符合直觉，但是当我们调用sp这个智能指针所指对象的method方法时，我们理希望 调用方法肯定和普通指针一样：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sp-&gt;method()<br></code></pre></div></td></tr></table></figure><p>我们所希望的操作是：sp-&gt;method() 转换为 px-&gt;method() 然后再得到结果，但是-&gt;被重载过了，因此sp-&gt; 会转换为 px ，此时因为重载运算符已经消耗了一个箭头，那么问题就来了，好像少了一个箭头？</p><p>其实不然，这属于c++的特性，语言设计者唯独对这种操作符加了一些不同于其他操作符的东西，即：<strong>重载后依然会保留-&gt;的操作符</strong>。 </p><h2 id="pointer-like-classes，关于迭代器"><a href="#pointer-like-classes，关于迭代器" class="headerlink" title="pointer-like classes，关于迭代器"></a>pointer-like classes，关于迭代器</h2><p>迭代器多了++,—这一类操作，因为迭代器可以用来遍历容器。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214165709044.png" srcset="/img/loading.gif" alt="image-20211214165709044"></p><p>我们单独讨论一下 dereference和-&gt;两个重载运算符函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214170021566.png" srcset="/img/loading.gif" alt="image-20211214170021566"></p><p> 我们希望迭代器like 指针，那么也就是希望支持这两种操作：</p><p>1.<code>*</code>取值操作符</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">*ite<br></code></pre></div></td></tr></table></figure><p>这个完全可以通过 <code>operator*</code>完成，即<code>return (*node).data</code></p><p>2.-<code>&gt;</code>操作符</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ite-&gt;method()<br></code></pre></div></td></tr></table></figure><p><strong>如何实现ite类型-&gt;操作符重载？</strong></p><p>这个操作可以先通过 <code>operator*</code>获得一个对象(注意 这里的<code>operator *</code>可不是普通的，而是我们已经重写后的了，它可以对迭代器这种<code>pointer-like-class</code>直接获取对象)，然后再通过<code>&amp;</code>获得这个对象的指针，然后再通过这个指针完成调用<code>Foo</code>的<code>method()</code>函数。</p><p>还记的上面所说的关于<code>-&gt;</code>一个语言特性吗？ 重载运算符已经消耗了一个箭头，但箭头还会存在，这属于c++的特性，语言设计者唯独对这种操作符加了一些不同于其他操作符的东西，即：<strong>重载后依然会保留-&gt;的操作符</strong>。 </p><p>因此重载后，<code>ite-&gt;method()</code> 变成了<code>&amp;(*ite) -&gt; method()</code> ， </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214171013860.png" srcset="/img/loading.gif" alt="image-20211214171013860"></p><h2 id="function-like-classed，仿函数-通过重载operator-实现仿函数"><a href="#function-like-classed，仿函数-通过重载operator-实现仿函数" class="headerlink" title="function-like classed，仿函数/通过重载operator ()实现仿函数"></a>function-like classed，仿函数/通过重载operator ()实现仿函数</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214174029746.png" srcset="/img/loading.gif" alt="image-20211214174029746"></p><p>这里面的重载<code>()</code>就是仿函数的主要特点，希望类像函数一样可以使用。</p><p>因此我们可以通过重载operator ()实现仿函数。</p><p>一个简单的例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214175751956.png" srcset="/img/loading.gif" alt="image-20211214175751956"></p><h2 id="再谈namespace"><a href="#再谈namespace" class="headerlink" title="再谈namespace"></a>再谈namespace</h2><p>对标准库里的东西全部打开，以后不用写<code>std::cin</code>等 直接写<code>cin</code>即可</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001343326.png" srcset="/img/loading.gif" alt="image-20211211001343326"></p><p>也可以<strong>部分展开namespace：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001503678.png" srcset="/img/loading.gif" alt="image-20211211001503678"></p><p><strong>namespace简单来说就是防止命名冲突。</strong></p><h2 id="function-template，函数模板"><a href="#function-template，函数模板" class="headerlink" title="function template，函数模板"></a>function template，函数模板</h2><p><strong>编译器会对function template进行模板推导：</strong>也就是说要进行两次编译，第一次你的函数如果调用了这个模板才能推导出模板的类型stone，第二次找＜操作符的重载函数：如下</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">minn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; a,<span class="hljs-keyword">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b&lt;a?b:a;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stone</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> v;<br>    stone(<span class="hljs-keyword">int</span> _v):v(_v)&#123;&#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> stone&amp; rhs) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;v &lt; rhs.v;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">stone <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">stone <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    stone c= minn(a,b);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;c.v&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你把&lt;操作符重载删除是无法通过编译，因为调用minn时首先推导出了stone类型，第二次编译发现没有stone的比较符号，因此会报错.</p><p>但是如果你并没有调用minn函数，那么就还可以通过编译。因为根本没有模板进行推导，因此编译器也不会发现你没有写重载<code>&lt;</code>运算符函数。</p><h2 id="member-template，成员模板"><a href="#member-template，成员模板" class="headerlink" title="member template，成员模板"></a>member template，成员模板</h2><p>成员模板即 class里的成员利用模板编写。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214183405544.png" srcset="/img/loading.gif" alt="image-20211214183405544"></p><p>首先外面的T1,T2是允许变化的，在确定后，里面的U1,U2也是允许变换的。</p><p>有了这样的技术，我们就可以把 &lt;鲫鱼，麻雀&gt;这一对pair用来初始化 &lt;鱼类，鸟类&gt;这一对pair。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184059791.png" srcset="/img/loading.gif" alt="image-20211214184059791"></p><p>这个在<strong>c++有一些实际的应用：</strong></p><p>比如智能指针中的<code>shared_ptr</code>:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184513758.png" srcset="/img/loading.gif" alt="image-20211214184513758"></p><p>父类指针可以指向子类的对象，这是我们c++所支持的up-cast，因此我们希望智能指针也可以做到的up-cast，具体怎么做呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184838976.png" srcset="/img/loading.gif" alt="image-20211214184838976"></p><p>首先<code>shared_ptr</code>这个智能指针利用模板特性可以完成<code>up-cast</code>操作, 比如：你想完成<code>shared_ptr&lt;Base1&gt;sptr(new Derived1)</code>这个操作:</p><p>1.此时<code>__shared_ptr&lt;&gt;</code>就会被绑定为<code>Base1</code>类型，即<code>_Tp</code>推导出类型为<code>Base1</code>，</p><p>2.<code>new Derived</code>形成的指针推导出<code>_Tp1</code>的类型为<code>Derived</code>，即<code>_p</code>会被绑定为 <code>Derived*</code>类型</p><p>3.因为<code>Derived</code>是<code>Base</code>的子类，因此可以进行初始化父类指针指向子类，这一步的操作是通过<code>explicit shared_ptr(Derived1* __p):__shared_ptr&lt;Base1&gt;(__p){}</code>这个含有初始化列表的构造函数实现的，其中的初始化列表就相当于给<code>shared_ptr</code>中的<code>__shared_ptr&lt;Base1&gt;</code>赋值为<code>__p(Derived类型)</code>，这一步就是实现了up-cast。</p><p>我们发现通过<strong>模板特性，我们可以将这样的up-cast操作完美完成。</strong></p><h2 id="specialization，模板特化"><a href="#specialization，模板特化" class="headerlink" title="specialization，模板特化"></a>specialization，模板特化</h2><p>模板特化就是指对模板进行特征化，模板是一个泛化的概念，也就是可以接受多种类型变量，但是我们可以特征化 模板的接收各类型变量的动作，也就是说 编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么你自己写：</p><p>如下图，我们在用模板特性写完<code>struct hash</code>后，开始特化三个类型的<code>struct hash</code>，分别是<code>char，int，long</code>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215204743489.png" srcset="/img/loading.gif" alt="image-20211215204743489"></p><p>一个完整的例子：<a href="https://www.cnblogs.com/xiangtingshen/p/11157198.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangtingshen/p/11157198.html</a></p><h2 id="partial-specialization，模板偏特化-全特化"><a href="#partial-specialization，模板偏特化-全特化" class="headerlink" title="partial specialization，模板偏特化/全特化"></a>partial specialization，模板偏特化/全特化</h2><p>通过特化可以对某一种特定类型的进行自定义实现。编译器认为，对于特定的类型，如果你能对某一功能更好的实现或想法，那么你自己实现。</p><p><strong>特化可以分为:</strong></p><p><strong>全特化</strong>就是全部特化，即针对所有的模板参数进行特化。《c++ primer》<br><strong>偏特化</strong>就是部分特化，即针对部分模板参数进行特化。《c++ primer》</p><p>可以看出特化无论是<strong>全/偏</strong>都是对模板参数的解读。</p><p><strong>函数模板，却只有全特化，不能偏特化:即函数模板必须提前指定好所有的参数类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T1 a,T2 b)</span></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"模板函数"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//全特化</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)</span></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"全特化"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//函数不存在偏特化，以下代码是错误的</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">template&lt;typename T2&gt;</span><br><span class="hljs-comment">void fun(char a,T2 b)&#123;</span><br><span class="hljs-comment">    cout&lt;&lt;"偏特化"&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>偏特化的偏有两种：</strong></p><p>一个是参数个数上的偏，另一个是范围上的偏</p><p><strong>1.一个是参数个数上的偏</strong></p><p>如下图，绑定第一个参数为bool类型进行偏特化。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215213918484.png" srcset="/img/loading.gif" alt="image-20211215213918484"></p><p><strong>2.另一个是范围上的偏</strong></p><p>我们有时候会<strong>希望对于模板的T在作为指针类型时执行特定的规则，否则按照模板泛化的规则来执行。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215214836534.png" srcset="/img/loading.gif" alt="image-20211215214836534"></p><p><strong>范围上偏的简单例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    T v;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pt</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;T*&gt;</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    T* v;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pt</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>&#125;;<br><br><span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>] = <span class="hljs-string">"1234"</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    C&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>&gt;obj1;<br>    C&lt;<span class="hljs-keyword">char</span>*&gt;obj2;<br>    C&lt;<span class="hljs-built_in">string</span>&gt;obj3;<br>    obj1.v = <span class="hljs-number">1000000000000</span>;<br>    obj2.v = s;<br>    obj3.v = <span class="hljs-string">"hello!"</span>;<br>    obj1.pt();<br>    obj2.pt();<br>    obj3.pt();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="template-template-parameter，模板的模板参数"><a href="#template-template-parameter，模板的模板参数" class="headerlink" title="template template parameter，模板的模板参数"></a>template template parameter，模板的模板参数</h2><p>模板的模板参数就是：模板中还存在模板作为的参数。<strong>注意:函数模板不支持模板的模板参数,类模板才支持这种操作</strong></p><p>这个的应用场景是，比如我们想这么用:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">list</span>&gt;mylist1;<br></code></pre></div></td></tr></table></figure><p>此时希望list自动辨别出来我们要用的是string，并把list自己的容纳元素类型绑定成string。一个简单的方法就是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">typename</span> T&gt;&gt;<br>考虑到想让容器也可以变化，适应多种容器，不妨写成:<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215220706952.png" srcset="/img/loading.gif" alt="image-20211215220706952"></p><p>这样可以达到我们想要的效果吗？</p><p>奇怪的是并不可以：这是因为XCLs中的<code>Container&lt;T&gt;c</code>这部分的T填入的是类型T(string)，然而我们平时可以这么用<code>list&lt;string&gt;</code>是因为string填入后，其实<code>&lt;&gt;</code>后面还会有一些默认参数，但是如果你用<code>T</code>表示，c++就会认为你没有填入后面的默认参数(语言的规定)。简单来说如果你用了T做容器的参数，那么容器的后面的默认参数会失效，你需要自己补上这些参数。</p><p>因此我们可以这么用(c++2.0新特性（c++11/14）)，使得第二种是对的：<strong>即利用<code>using</code>定义模板别名</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215221628613.png" srcset="/img/loading.gif" alt="image-20211215221628613"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT&lt;T&gt;c;<br>&#125;;<br><br><span class="hljs-comment">//利用using 给这个模板定义了别名: Lst</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,Lst&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个模板推导过程是：<code>T</code>推出<code>string</code>，然后从<code>CONT&lt;T&gt;c</code>推出<code>U</code>是<code>string</code>，然后从<code>U</code>再推到<code>T2</code>是<code>string</code></p><p>下面这并<strong>不叫做一个模板模板参数</strong>，因为<code>XCLs&lt;string,set&lt;string&gt;&gt;mylist1;</code>中的<code>set&lt;string&gt;</code>就已经绑定好容器的元素类型了，使得<code>class CONT</code>变成<code>set&lt;string&gt;</code>根本没有模板进行推导。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>=<span class="hljs-title">list</span>&lt;T,allocator&lt;T&gt;&gt;&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT c;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-11-variadic-templates数量不定的模板参数"><a href="#C-11-variadic-templates数量不定的模板参数" class="headerlink" title="C++11: variadic templates数量不定的模板参数"></a>C++11: variadic templates数量不定的模板参数</h2><p>下面是一个数量不定的模板参数的例子，<code>print()</code>函数做得是一个将一堆参数输出的动作。</p><p>每次取出第一个参数输出，剩下的参数包递归下去每次输出参数的第一个。但请不要忘记写<code>void print(){ }</code>，因为当参数空的时候，你需要一个无参的<code>print</code>来结束print的递归。</p><p>如果你想知道 后面那一部分参数包有几个，你可以使用<code>sizeof...(args)</code>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013257682.png" srcset="/img/loading.gif" alt="image-20211216013257682"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; &#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;firstArg&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"123"</span>,<span class="hljs-string">"456"</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013211012.png" srcset="/img/loading.gif" alt="image-20211216013211012"></p><h2 id="C-11-auto关键字"><a href="#C-11-auto关键字" class="headerlink" title="C++11: auto关键字"></a>C++11: auto关键字</h2><p>这是一个<strong>语法糖</strong>。</p><p>算法竞赛里天天用，就不细说了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013608646.png" srcset="/img/loading.gif" alt="image-20211216013608646"></p><h2 id="C-11-ranged-base-for"><a href="#C-11-ranged-base-for" class="headerlink" title="C++11: ranged-base for"></a>C++11: ranged-base for</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013932605.png" srcset="/img/loading.gif" alt="image-20211216013932605"></p><h2 id="再谈reference引用"><a href="#再谈reference引用" class="headerlink" title="再谈reference引用"></a>再谈reference引用</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216014803125.png" srcset="/img/loading.gif" alt="image-20211216014803125"></p><ul><li><p>引用必须设初值，即必须定义时标明你引用的是谁。并且以后不可以修改这种绑定关系(但指针可以)。</p></li><li><p>对引用的修改就是对和他初始绑定的变量的修改</p></li><li><p>指针的大小是固定的8字节(64位系统，32位系统为4字节)，引用的大小取决于和他绑定的变量，变量多大引用多大，即<code>sizeof(reference) = sizeof(绑定的变量)</code>绑定的变量。<strong>但这是假象，引用就是指针实现的(而且还是一个指针常量)，所以其实实际只占用了指针的大小。同时，<code>&amp;reference = &amp;绑定的变量</code>也是假象，其实他们并不相同</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216152210353.png" srcset="/img/loading.gif" alt="image-20211216152210353"></p></li><li><p>拓扑结构的递归引用相当于最开始的绑定的变量: 即<code>int&amp; r = x;int&amp; r2=r;</code> <code>r2</code>修改其实就是对<code>x</code>修改</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216015810061.png" srcset="/img/loading.gif" alt="image-20211216015810061"></p><ul><li>reference具有天生自然的优势在参数中使用，因为保证了调用和被调用端口的一致(上图)。</li><li>函数重载中，参数仅有是否引用的区别会被认为是同一函数，因此不能同时出现</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216020211334.png" srcset="/img/loading.gif" alt="image-20211216020211334"></p><h2 id="再谈重载-overloading-函数"><a href="#再谈重载-overloading-函数" class="headerlink" title="再谈重载(overloading)函数"></a>再谈重载(overloading)函数</h2><p>上面一节最后谈到了，const是不是函数签名的一部分，这次我们来测试下：</p><p><strong>函数重载中，参数仅有是否加const的区别会被认为是不同同一函数，因此可以同时出现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; im)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span>&amp; im)</span></span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure><p><strong>函数重载中，函数仅有是否加const的区别会被认为是不同函数，因此可以同时出现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span> im)</span><span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span> im)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    <span class="hljs-keyword">const</span> test a;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> t = <span class="hljs-number">1.5</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;a.imag(t)&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//1</span><br><br>    test b;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;b.imag(t)&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此我们可以 认为const是判别是否为相同函数的<strong>函数签名</strong> 的一部分</p><h2 id="虚指针-vptr-和虚表-vtbl"><a href="#虚指针-vptr-和虚表-vtbl" class="headerlink" title="虚指针(vptr)和虚表(vtbl)"></a>虚指针(vptr)和虚表(vtbl)</h2><p>带<code>x</code>个虚函数的class的大小也只会多 <strong>8 字节(64位下)</strong>，这是因为含有虚函数的对象/类有一个虚表指针，他的大小是8字节，这个虚表指针会指向虚表。</p><p><strong>那么编译器是如何处理虚函数的呢？</strong></p><p>1.如果<strong>类中有虚函数，就将虚函数的地址记录在类的虚函数表中</strong>。</p><p>2.<strong>派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址</strong>，否则指向基类的函数地址。<br>3.<strong>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表</strong>。</p><p>4.实例在调用虚函数的时候，<strong>通过这个虚函数表指针找到类中的虚函数表，再找到相应的函数进行调用</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216200306046.png" srcset="/img/loading.gif" alt="image-20211216200306046"></p><p>1.首先<code>class A</code>有两个虚函数，因此虚表应该有两个指针指向两个虚函数。如下图标出的红色框。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216201251442.png" srcset="/img/loading.gif" alt="image-20211216201251442"></p><p>2.<code>class B</code>继承了<code>Class A</code>，但是<code>class B</code>的虚函数也是<code>vfun1()</code>，由于和从<code>A</code>继承的虚函数<code>vfun1()</code>同名，这就会推翻<code>class B</code>从<code>class A</code>所继承来的<code>vfun1()</code>, 因此可以看作是一个全新的函数<code>B::vfun1()</code>。除此之外，还会从<code>class A</code>继承一个<code>vfun2()</code>虚函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216201727405.png" srcset="/img/loading.gif" alt="image-20211216201727405"></p><p><strong>虚函数实现了多态：</strong></p><p>A可以看作是shape，里面有纯虚函数draw()，继承他的各个形状自己改写draw()函数，我们的容器可以存不同的形状(通过父类指针作为容器元素)，调用draw就会触发不同的效果，实现了多态。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216211058781.png" srcset="/img/loading.gif" alt="image-20211216211058781"></p><h2 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h2><p>转自: <a href="https://www.cnblogs.com/leoncumt/p/10491842.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoncumt/p/10491842.html</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br><br>&#125;;<br><br>D* pD=<span class="hljs-keyword">new</span> D();<br><span class="hljs-comment">// pD的静态类型是它声明的类型D*，动态类型也是D*</span><br>B* pB=pD;<br><span class="hljs-comment">// pB的静态类型是它声明的类型B*，动态类型是pB所指的对象pD的类型D*</span><br>c* pC=<span class="hljs-keyword">new</span> C();<br><span class="hljs-comment">// pC的静态类型是它声明的类型C*，动态类型也是C*</span><br>pB=pC;<br><span class="hljs-comment">// pB的动态类型可以改变，现在它的动态类型为C*</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>静态绑定：</strong></li></ul><p>绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</p><ul><li><strong>动态绑定：</strong></li></ul><p>绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br>    <span class="hljs-comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致同名隐藏；这里只是为了说明动态绑定和静态绑定才这样使用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>D* pD=<span class="hljs-keyword">new</span> D();<br><span class="hljs-comment">// pD的静态类型是它声明的类型D*，动态类型也是D*</span><br>B* pB=pD;<br><span class="hljs-comment">// pB的静态类型是它声明的类型B*，动态类型是pB所指的对象pD的类型D*</span><br></code></pre></div></td></tr></table></figure><p><strong>pD-&gt;DoSomething()和pB-&gt;DoSomething()调用的是同一个函数吗？</strong></p><p><strong>答案：</strong>不是的，虽然<code>pD</code>和<code>pB</code>指向同一对象，但函数<code>DoSomething()</code>是一个<strong>non-virtual函数，它是静态绑定的</strong>，也就是编译器会在编译器根据对象的静态类型来选择函数，<code>pD</code>的静态类型是<code>D*</code>，那么编译器在处理<code>pD-&gt;DoSomething()</code>的时候会将它指向<code>D::DoSomething()</code>。同理，<code>pB</code>的静态类型是<code>B*</code>，那么<code>pB-&gt;DoSomething()</code>调用的就是B::DosSomething()。</p><p><strong>pD-&gt;vfun()和pB-&gt;vfun()调用的是同一函数吗？</strong></p><p><strong>答案：</strong>是的，这是因为<code>vfun</code>是一个虚函数，他是<strong>动态绑定的，即绑定的是对象的动态类型</strong>，<code>pB</code>和<code>pD</code>虽然静态类型不同，但他们同时指向一个对象，他们的动态对象是相同的，都是<code>D*</code>，所以，他们调用的是同一个函数：<code>D::vfun()</code>。</p><p><strong>指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的。</strong><br><strong>例如：</strong>D.DoSomething()和D.vfun()永远调用的都是D::DoSomething()和D::vfun()。</p><p><strong>综上总结：</strong></p><p>只有虚函数才绑定的是对象的动态类型(动态绑定)，其他的全部是静态绑定。</p><h2 id="再谈this和动态绑定"><a href="#再谈this和动态绑定" class="headerlink" title="再谈this和动态绑定"></a>再谈this和动态绑定</h2><p>从汇编来看静态绑定：</p><p>下面的a是一个对象，他是静态绑定。因此汇编程序直接用指令call 了一个地址即<code>A::vfun1()</code>的地址。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220014231828.png" srcset="/img/loading.gif" alt="image-20211220014231828"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216213346290.png" srcset="/img/loading.gif" alt="image-20211216213346290"></p><p>pa的动态类型是<code>B*</code>在运行<code>pa-&gt;vfun1</code>时动态绑定为<code>B::vfun1()</code>，因此才能使得pa-&gt;vfun1()运行出来是<code>B::vfun1()</code>函数。</p><p>在汇编中来看他是怎么实现动态绑定的呢？</p><p>1.他是通过p指针指向虚表完成的，<strong>p指针也就是this指针</strong>。</p><p>2.而<code>this</code>指针是干什么用的？<strong>在不同的对象调用的时候，编译器会自动将该对象的地址赋予“this”</strong>。</p><p>3.因此正是<code>this</code>中有对象的动态类型，因此this得以通过虚函数表和虚指针正确的调用出<code>B::vfun1()</code>函数，就像下图一样找到最后需要的函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216200306046.png" srcset="/img/loading.gif" alt="image-20211216200306046"></p><h2 id="重载operator-new-delete-new-delete"><a href="#重载operator-new-delete-new-delete" class="headerlink" title="重载operator new/delete/new[]/delete[]"></a>重载operator new/delete/new[]/delete[]</h2><p>首先我们有必要区分一下 <code>operator new</code>和<code>new operator</code>(delete也是同理)</p><p><strong>new operator是c++内建的，无法改变其行为；(delete也是同理)</strong></p><p><strong>而operator new 是可以根据自己的内存分配策略去重载的。(delete也是同理)</strong></p><p>因此我们重载只可以对operator new进行重载，下面会介绍全局函数重载和成员函数重载</p><p><strong>对于全局函数重载，直接如下写即可：</strong></p><p>但是这种影响是很宽泛的，我们几乎不会这么用</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220145856829.png" srcset="/img/loading.gif" alt="image-20211220145856829"></p><p><strong>当然我们更常用的是如何重载一个成员函数中的new/delete：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220150135319.png" srcset="/img/loading.gif" alt="image-20211220150135319"></p><p>new operator第一步分配空间会使用operator new来做，此时如果你重载了对象的operator new，那么就会调用重载后的。</p><p><strong><code>operator new []/operator delete[]</code>的内存大小为什么多4？</strong></p><p>对于<code>operator new []/operator delete[]</code>和上面没什么区别，多了一个<code>[]</code>而已。</p><p>这里我们发现下图中new operator操作第一步调用operator new的时候分配的是对象的内存$(FOO)*(N个)$后还多了一个4字节，这个表示连续有少个对象，起一个计数器counter作用。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220151015091.png" srcset="/img/loading.gif" alt="image-20211220151015091"></p><p><strong>强制调用全局默认的new/delete/new []/delete[]:</strong></p><p>即使你定义了成员函数里写了operator new/delete的重载函数，你依然可以强制调用global的new/delete，操作方法为: 在new/delete前加<code>::</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<br>::<span class="hljs-keyword">delete</span> pf;<br></code></pre></div></td></tr></table></figure><p><strong>最后一个具体使用示例：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220152209269.png" srcset="/img/loading.gif" alt="image-20211220152209269"></p><h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new()/delete()"></a>重载new()/delete()</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220175638793.png" srcset="/img/loading.gif" alt="image-20211220175638793"></p><p>new() 称之为placement new()，我们需要重载operator new实现，那么和上面的普通的重载operator new有什么区别呢？他的区别就是在operator new()重载函数中的参数多了一些东西。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220175824558.png" srcset="/img/loading.gif" alt="image-20211220175824558"></p><ul><li>placement new()的第一参数必须是 <code>size_t</code>,其余的参数就是所谓的placement arguments。</li><li><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220180144514.png" srcset="/img/loading.gif" alt="image-20211220180144514"></li></ul><p><strong>一个标准库中placement new()的例子：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220181140327.png" srcset="/img/loading.gif" alt="image-20211220181140327"></p><p>sgi在basic_string内部定义了一个Rep的结构体，负责COPY-ON-WRITE的实现。要实现COPY-ON-WRITE，就必须对分配的内存块进行计数，Rep就用来进行计数，并把它放在每个内存块的起始位置。同时Rep里还存有一些状态信息。<br>所以内存布局是这样的，Rep|char_type, char_type, char_type……</p><blockquote><p><strong>写入时复制（英语：Copy-on-write，简称COW）</strong>是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象高级编程-上</title>
    <link href="/2021/12/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8A/"/>
    <url>/2021/12/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象高级编程"><a href="#C-面向对象高级编程" class="headerlink" title="C++面向对象高级编程"></a>C++面向对象高级编程</h1><h2 id="header头文件防卫式声明"><a href="#header头文件防卫式声明" class="headerlink" title="header头文件防卫式声明"></a>header头文件防卫式声明</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209230451166.png" srcset="/img/loading.gif" alt="image-20211209230451166"></p><p>这是一种防卫式声明，防卫式声明的作用是：防止由于同一个头文件被包含多次，而导致了重复定义。防卫式声明表示，如果<code>__COMPLEX__</code>没有被定义过，那么就展开定义，否则跳过。</p><p><code>__COMPLEX__</code>被称为<strong>预处理器变量</strong>一般有两种状态：已定义或未定义。</p><ul><li><code>#ifndef</code> 指示检测指定的预处理器变量是否未定义，如果未定义，那么跟在后面的所有指示被处理，直到出现#endif；如果已定义，那么#ifndef测试为假，该指示和#endif指示间的代码都被忽略。</li><li><code>#define</code>指示接受一个名字并定义该名字为预处理器变量。</li></ul><p>一个例子：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">-- <span class="hljs-string">"Car.h"</span>，代码如下（并没有添加防卫式声明）：<br><span class="hljs-comment">// Car.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// ...</span><br>&#125;;<br>-- <span class="hljs-string">"Person.h"</span>，代码如下（包含了Car.h文件）：<br><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Car.h"</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Car car;<br>&#125;;<br>-- 在<span class="hljs-string">"main.cpp"</span>中，我们同时include两个头文件：<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Car.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Person.h"</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> &lt;br&gt;</span>&#123;<br>    Person p;<br>&#125;<br>此时，我们会发现编译出错：Redefinition of 'Car'.<br></code></pre></div></td></tr></table></figure><p>我们需要知道，在预编译阶段，编译器会把.h文件展开，即main.cpp中的代码可以看做是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Car car;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    Person p;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h2><p>我们如果希望double类型的实部和虚部变成int，那么我们需要重写一个几乎一样的complex类，这是我们所不希望的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209231326729.png" srcset="/img/loading.gif" alt="image-20211209231326729"></p><p>因此出现了模板：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209231508596.png" srcset="/img/loading.gif" alt="image-20211209231508596"></p><p>我们先把类型设为T，使用时根据所写的类型再将T绑定为各种类型。</p><h2 id="inline内敛函数"><a href="#inline内敛函数" class="headerlink" title="inline内敛函数"></a>inline内敛函数</h2><p>首先了解一下什么是内敛函数？</p><p><strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>），用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。</p><ul><li>如果你的函数写在class定义里，那么这个函数会成为<strong>inline函数</strong>的候选人，具体内敛与否还要看编译器自己。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209232037127.png" srcset="/img/loading.gif" alt="image-20211209232037127"></p><ul><li>你也可以给函数前加上inline，但是这只是你对编译器的<strong>建议</strong>，具体内敛与否还要看编译器自己。</li></ul><h2 id="access-level访问级别"><a href="#access-level访问级别" class="headerlink" title="access level访问级别"></a>access level访问级别</h2><p><strong>private,public,protected的访问范围:</strong></p><p><strong>private:</strong> 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br><strong>protected:</strong> 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br><strong>public:</strong> 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p><p><strong>类的继承后方法属性变化:</strong><br><strong>使用private继承</strong>,父类的所有方法在子类中变为private;<br><strong>使用protected继承</strong>,父类的protected和public方法在子类中变为protected,private方法不变;<br><strong>使用public继承</strong>,父类中的方法属性不发生改变;</p><h2 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h2><p>C++ 类构造函数可以用<strong>初始化列表</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r=<span class="hljs-number">0</span>,<span class="hljs-keyword">double</span> i=<span class="hljs-number">0</span>):re(r),im(i)&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r=<span class="hljs-number">0</span>,<span class="hljs-keyword">double</span> i=<span class="hljs-number">0</span>)&#123;re=r;im=i;&#125;<br></code></pre></div></td></tr></table></figure><p>但我们尽量用第一种，第一种写法更正规，这是构造函数特有的写法(指<code>:re(r),im(i){}</code>)。</p><h2 id="构造函数的重载overloading"><a href="#构造函数的重载overloading" class="headerlink" title="构造函数的重载overloading"></a>构造函数的重载overloading</h2><p>函数是可以重载overloading的，即参数不同，但是函数名相同，调用函数时编译器会自动选择参数对应的函数，<strong>重载的几个同名函数本质上都是各不相同的函数</strong>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209234150840.png" srcset="/img/loading.gif" alt="image-20211209234150840"></p><p>这种是正确的吗？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209234407554.png" srcset="/img/loading.gif" alt="image-20211209234407554"></p><p>比如定义一个<code>complex c</code>此时编译器发现这两者都可以使用一个是全是默认参数，另一个是无参，编译器认为都可以，所以此时这两者是不能一起存在的。</p><h2 id="构造函数放在private的意义—单例模式"><a href="#构造函数放在private的意义—单例模式" class="headerlink" title="构造函数放在private的意义—单例模式"></a>构造函数放在private的意义—单例模式</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209234847158.png" srcset="/img/loading.gif" alt="image-20211209234847158"></p><p>此时是不能调用构造函数的，所以这种做法一定不可能出现吗？并不是，当你不希望被外界创建对象时可以使用，那么这样的一个类还有什么用呢？<strong>单例模式</strong>。（下面内容建议先浏览<code>static静态：静态变量，静态函数</code>这一节）</p><p>没有任何人可以创建A类，A类只有一个对象a一开始就被创造好等待被初始化。 </p><ul><li><p>外界想获得这唯一的a：通过<code>getInstance()</code>函数</p></li><li><p>外界想修改这个唯一的a：通过<code>A::getInstance().setup(...);</code></p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209235038633.png" srcset="/img/loading.gif" alt="image-20211209235038633"></p><h2 id="常量成员函数const"><a href="#常量成员函数const" class="headerlink" title="常量成员函数const"></a>常量成员函数const</h2><p>成员函数可以分为两种：会改变数据的和不会改变数据的，不会改变数据的十分建议加上const，表示这个成员函数不能改变成员变量。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209235254760.png" srcset="/img/loading.gif" alt="image-20211209235254760"></p><p>不管你的函数加没加<code>const</code>，这么用是没问题的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209235536414.png" srcset="/img/loading.gif" alt="image-20211209235536414"></p><p>但是如果一个<code>const</code>类型的对象 <code>real()</code>和<code>imag()</code>函数没加<code>const</code>，下面这种用法就是错误的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209235629111.png" srcset="/img/loading.gif" alt="image-20211209235629111"></p><p>因为希望complex的成员变量是不可以被改变的，而你的real，imag函数却不是const类型的，表示你有可能会改变他们，因此编译器不会让这种危险的事情发生，编译错误。</p><p><strong>最后总结：</strong></p><p>除了下面的表格总结外，我们还有一条c++中的重要法则： </p><p><strong>当成员函数const和non-const版本同时存在，const对象只会调用const版本，non-const对象只会调用non-const版本。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220021543751.png" srcset="/img/loading.gif" alt="image-20211220021543751"></p><h2 id="传参：by-value-by-reference"><a href="#传参：by-value-by-reference" class="headerlink" title="传参：by value/by reference"></a>传参：by value/by reference</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210000143936.png" srcset="/img/loading.gif" alt="image-20211210000143936"></p><p>引用<strong>占四个字节</strong>的内存(本质是一个指针)。</p><p>我们尽量都传引用，因为他普遍来说更快，但是引用有可能会改变原来的值，如果我们不希望这种情况发生，那么可以利用(const complex&amp;)的方法，使得参数无法修改。</p><p>pass by reference(to const)的一个小例子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*pass by reference*/</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> &amp;a = c;<br>a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出5，这个引用时可以修改引用值的</span><br><br><span class="hljs-comment">/*pass by reference(to const)*/</span><br></code></pre></div></td></tr></table></figure><h2 id="友元friend"><a href="#友元friend" class="headerlink" title="友元friend"></a>友元friend</h2><p>一份更仔细的介绍: <a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210001054480.png" srcset="/img/loading.gif" alt="image-20211210001054480"></p><p>友元不是成员函数，但是它<strong>可以访问类中的私有成员</strong>，但他会破坏c++类的封装性，尽量少用，规范的用。</p><h2 id="相同class的各个对象互为友元"><a href="#相同class的各个对象互为友元" class="headerlink" title="相同class的各个对象互为友元"></a>相同class的各个对象互为友元</h2><p>看一下下面的问题：没有friend的字眼，为什么func可以直接访问private里的实部和虚部呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210001343468.png" srcset="/img/loading.gif" alt="image-20211210001343468"></p><p>可以这么解释：相同class的各个对象互为友元</p><h2 id="this和重载运算符函数的设计"><a href="#this和重载运算符函数的设计" class="headerlink" title="this和重载运算符函数的设计"></a>this和重载运算符函数的设计</h2><p>这两者等价，this是一个隐藏的指针(但你不能在参数列写出来，this是已经默认存在的)，谁调用这个函数谁就是this</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210003518533.png" srcset="/img/loading.gif" alt="image-20211210003518533"></p><p>对于重载运算符，如果我们只用c2+=c1这种，那么你写：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">complex</span>&amp; <span class="hljs-built_in">complex</span>::<span class="hljs-keyword">operator</span>+=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; r）<br>&#123;<br><span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">complex</span>::<span class="hljs-keyword">operator</span>+=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; r）<br>&#123;<br>__doapl(<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>都是ok的，但是我们要思考到：</p><p>很多人会有这种用法： <code>c3+=c2+=c1</code> 这种运算方式是指c2 +=c1,c3+=c2 ,此时对于第二种返回void的写法就出了问题，因为c2+=c1执行完成后这个东西本身要当成右值，然而却返回了void，因此会出错。</p><p>所以我们总是建议写第一种。</p><h2 id="重载运算符函数的常见用法-规则"><a href="#重载运算符函数的常见用法-规则" class="headerlink" title="重载运算符函数的常见用法/规则"></a>重载运算符函数的常见用法/规则</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210201248027.png" srcset="/img/loading.gif" alt="image-20211210201248027"></p><p>这里为什么选用return by value呢？</p><p>因为 a = b+c+d  在c++中b,c,d做完值是不可以变得，return by reference会导致b,c变化。</p><p><strong>如何区分加减和正负？</strong></p><p>根据参数的数量即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210202140742.png" srcset="/img/loading.gif" alt="image-20211210202140742"></p><p><strong><code>==</code> <code>!=</code>的设计标准</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210202419885.png" srcset="/img/loading.gif" alt="image-20211210202419885"></p><h2 id="typename-临时对象"><a href="#typename-临时对象" class="headerlink" title="typename()临时对象"></a><code>typename()</code>临时对象</h2><p><code>typename(...)</code>就是建立一个临时对象，这个对象不需要名字，用完即毁。标准库经常会有这种用法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210201853227.png" srcset="/img/loading.gif" alt="image-20211210201853227"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210202006287.png" srcset="/img/loading.gif" alt="image-20211210202006287"></p><p>运行完当前行后 <code>complex()</code>和<code>complex(4,5)</code>即消失</p><h2 id="lt-lt-的重载"><a href="#lt-lt-的重载" class="headerlink" title="&lt;&lt;的重载"></a><code>&lt;&lt;</code>的重载</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210202911883.png" srcset="/img/loading.gif" alt="image-20211210202911883"></p><p><strong>上述的<code>ostream&amp; os</code>为什么不加上<code>const</code>呢？</strong></p><p>这是因为在</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ++">return os&lt;&lt;&quot;(&quot;&lt;&lt;real(x)&lt;&lt;&quot;,&quot;&lt;&lt;imag(x)&lt;&lt;&quot;)&quot;;<br></code></pre></div></td></tr></table></figure><p>中<code>os</code>的状态是不断在变化的。</p><p><strong>重载&lt;&lt;的函数返回值可以加<code>const</code>吗？</strong></p><p>不可以，因为这里在不断改变<code>cout</code>的状态：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210203457500.png" srcset="/img/loading.gif" alt="image-20211210203457500"></p><h2 id="拷贝构造函数-析构函数"><a href="#拷贝构造函数-析构函数" class="headerlink" title="拷贝构造函数/析构函数"></a>拷贝构造函数/析构函数</h2><p><strong>拷贝构造函数</strong>如果你不写编译器会默认帮你写一个，即单纯的一个个把成员变量复制过去，但是对于字符串，里面的变量是指针，就会拷贝完后两者都指向同一个字符串。默认的构造函数是有风险的：如果你修改原对象中的字符串，会导致拷贝得到的那个对象字符串也发生变化。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210204953451.png" srcset="/img/loading.gif" alt="image-20211210204953451"></p><p><strong>析构函数：</strong></p><p>class里有指针我们大多数会做动态分配内存，动态分配的话在变量生命结束之前要释放空间。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210205056346.png" srcset="/img/loading.gif" alt="image-20211210205056346"></p><p>delete对象的指针就是：将指针所指向的内存空间回收</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210205355524.png" srcset="/img/loading.gif" alt="image-20211210205355524"></p><h2 id="含有指针的类必须要拷贝构造函数和重载赋值-函数"><a href="#含有指针的类必须要拷贝构造函数和重载赋值-函数" class="headerlink" title="含有指针的类必须要拷贝构造函数和重载赋值=函数"></a>含有指针的类必须要拷贝构造函数和重载赋值=函数</h2><p>如果你不写编译器会默认帮你写一个，即单纯的一个个把成员变量复制过去，但是对于字符串等里面的变量含有指针的类，拷贝/赋值完后两者都指向同一个字符串。</p><p>例如下面 world就造成了<strong>内存泄漏</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210205903468.png" srcset="/img/loading.gif" alt="image-20211210205903468"></p><p>因此对于重载=函数，需要</p><p><strong>1.先清空自己，防止内存泄露(这点一定要注意，因为可能存在<code>s1 = s2, s1 = s3, s1 = s4</code>这种多次赋值操作，如果不清空每次提前自己就会导致自己之前new出的内存找不到了，导致内存泄漏)</strong></p><p><strong>2.重新分配空间</strong></p><p><strong>3.给新空间赋值</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210210133496.png" srcset="/img/loading.gif" alt="image-20211210210133496"></p><p>同时要注意到<strong>自我赋值问题</strong>，即a = a这种傻瓜的用法，但可能确实存在这种用法，因此此时return 自己即可。如果你不写自我赋值检测，那么做以上那么三步，会导致结果出错。</p><h2 id="堆，栈与内存管理"><a href="#堆，栈与内存管理" class="headerlink" title="堆，栈与内存管理"></a>堆，栈与内存管理</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210211452869.png" srcset="/img/loading.gif" alt="image-20211210211452869"></p><p>c1存在<strong>栈</strong>里，程序离开变量作用域后会自动释放内存。</p><p>而p指针所指向的内存时new开辟的空间，是存放在<strong>堆</strong>里的，需要手动释放空间。</p><p><strong>什么是内存泄露呢？</strong></p><p>指针生命结束了，但指针所指的堆中的空间仍然存在。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210225514119.png" srcset="/img/loading.gif" alt="image-20211210225514119"></p><h2 id="new一个对象的原理"><a href="#new一个对象的原理" class="headerlink" title="new一个对象的原理"></a>new一个对象的原理</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210225938299.png" srcset="/img/loading.gif" alt="image-20211210225938299"></p><p>所以<strong>new一个类的对象内部其实做了三件事情：</strong></p><p><strong>1.<code>operator new()</code> 分配空间并返回一个<code>void*</code>类型指针p</strong></p><p><strong>2.void*类型 强转(通过<code>static_cast</code>) 成为目标class类型指针p</strong></p><p><strong>3.指针p调用构造函数。</strong></p><p>TIPS of <code>operator new()</code></p><blockquote><p>operator new()：指对new的重载形式，它是一个函数，并不是运算符。</p><p>对于operator new来说，分为全局重载和类重载，</p><p>1.全局重载是void* ::operator new(size_t size)</p><p>2.在类中重载形式 void* A::operator new(size_t size)。</p><p>还要注意的是这里的operator new()完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个<strong>void*指针</strong>。而<strong>构造函数的调用(如果需要)是在new运算符中完成的</strong></p></blockquote><h2 id="delete一个对象的原理"><a href="#delete一个对象的原理" class="headerlink" title="delete一个对象的原理"></a>delete一个对象的原理</h2><p>先调用析构函数(<code>~fun()</code>)，再释放内存(调用<code>free()</code>)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210230710412.png" srcset="/img/loading.gif" alt="image-20211210230710412"></p><h2 id="new-要搭配delete"><a href="#new-要搭配delete" class="headerlink" title="new [ ]要搭配delete [ ]"></a>new [ ]要搭配delete [ ]</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210231520440.png" srcset="/img/loading.gif" alt="image-20211210231520440"></p><p><strong>如果new array不搭配delete array很可能会造成内存泄漏：</strong></p><p>下图例子，我们调用delete 其实都会删除掉那一块部分，因为开头的cookie(即下图的21h)记录了这一块的大小，这一块是没有问题的。</p><p>问题就出在对于array中的每一个对象，<code>delete[]</code>会对每一个对象都调用析构函数，而<code>delete</code>只会对array的第一个对象调用析构函数，如果对象中是一个指针指向外部空间，那么析构函数就没有回收那部分的内存空间，导致内存泄漏</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210232317492.png" srcset="/img/loading.gif" alt="image-20211210232317492"></p><h2 id="static静态：静态变量，静态函数"><a href="#static静态：静态变量，静态函数" class="headerlink" title="static静态：静态变量，静态函数"></a>static静态：静态变量，静态函数</h2><p>首先要了解对于一个非静态(non-static)的成员函数，他要怎么面对各种各样的对象调用他呢？通过this指针获得对象的数据，然后在自己的函数逻辑中进行计算。如下图：c1，c2，c3分别各自拥有this指针，可以通过this指针调用函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210233750163.png" srcset="/img/loading.gif" alt="image-20211210233750163"></p><p>那么下面先讨论<strong>static变量：</strong></p><p>比如银行的利率每年调整，每个人的账户都加入一个利率显然是没必要的重复数据，修改也不方便，那利率就可以设置为static 数据，自己独自一份。</p><p><strong>static静态函数：</strong></p><p>他只能处理静态数据</p><p><strong>static 称为类变量，它属于这个类，而不属于这个类的实例对象</strong>（但是可以通过实例对象去访问），当类链接的时候就为其分配空间并初始化默认值，空间分配在堆中。 </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210234931612.png" srcset="/img/loading.gif" alt="image-20211210234931612"></p><p><strong>调用static函数方式</strong>有两种：可以通过对象调用或者类名直接调用。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210234550827.png" srcset="/img/loading.gif" alt="image-20211210234550827"></p><p><strong>单例模式可以有这种写法</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211209235038633.png" srcset="/img/loading.gif" alt="image-20211209235038633"></p><p><strong>尝试更好的写法：</strong>static变量写在函数里，即即使你一开始创建了A a，但没有人用这个单例，依然不会占用空间。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211210235828020.png" srcset="/img/loading.gif" alt="image-20211210235828020"></p><p>自己写的一个小例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">static</span> A a;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br><br>    A(<span class="hljs-keyword">int</span> xx = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> yy = <span class="hljs-number">0</span>): x(xx), y(yy) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;A::getInstance().x&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="函数模板中的参数推导-argument-deduction"><a href="#函数模板中的参数推导-argument-deduction" class="headerlink" title="函数模板中的参数推导(argument deduction)"></a>函数模板中的参数推导(argument deduction)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001053901.png" srcset="/img/loading.gif" alt="image-20211211001053901"></p><h2 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h2><p>对标准库里的东西全部打开，以后不用写<code>std::cin</code>等 直接写<code>cin</code>即可</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001343326.png" srcset="/img/loading.gif" alt="image-20211211001343326"></p><p>也可以<strong>部分展开namespace：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001503678.png" srcset="/img/loading.gif" alt="image-20211211001503678"></p><h2 id="复合-composition"><a href="#复合-composition" class="headerlink" title="复合(composition)"></a>复合(composition)</h2><p>复合就是has-a的关系，比如class A中有Class B的对象。其实C语言结构体是我们见过最早的复合了。</p><p>下面就是通过复合实现了一个adapter模式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211002417294.png" srcset="/img/loading.gif" alt="image-20211211002417294"></p><p><strong>复合的内存问题：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211002806030.png" srcset="/img/loading.gif" alt="image-20211211002806030"></p><p><strong>复合的构造函数和析构函数的调用顺序：</strong></p><p>构造函数调用顺序是先内部再外部，而析构函数相反。</p><p>除此之外，调用外部构造函数的时候先调用的是内部default构造函数，如果你内部有许多构造函数，你可以选择自己重写外部的构造函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211003711654.png" srcset="/img/loading.gif" alt="image-20211211003711654"></p><h2 id="委托-Delegation"><a href="#委托-Delegation" class="headerlink" title="委托(Delegation)"></a>委托(Delegation)</h2><p>可以简单理解为composition by reference，即通过指针/引用复合</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211004452966.png" srcset="/img/loading.gif" alt="image-20211211004452966"></p><h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211005736189.png" srcset="/img/loading.gif" alt="image-20211211005736189"></p><p>继承就是：子类有父类的成分</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211005216822.png" srcset="/img/loading.gif" alt="image-20211211005216822"></p><p>同时要注意：父类的析构函数必须是virtual的，否则会出现undefined behavior</p><h2 id="继承中的虚函数"><a href="#继承中的虚函数" class="headerlink" title="继承中的虚函数"></a>继承中的虚函数</h2><p><strong>non-virtual函数：</strong>你不希望子类重新定义(override)它</p><p><strong>virtual函数：</strong>你希望子类重新定义它</p><p><strong>pure virtual函数：</strong>你希望子类一定要重新定义它，你对他没有默认定义</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211010211587.png" srcset="/img/loading.gif" alt="image-20211211010211587"></p><p><strong>举一个例子：</strong></p><p>利用虚函数延缓了主要功能的其中一个动作。可以让我们在后期通过虚函数修改自己的功能/添加新功能。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211010747368.png" srcset="/img/loading.gif" alt="image-20211211010747368"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211012342931.png" srcset="/img/loading.gif" alt="image-20211211012342931"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(A-G)NEC Programming Contest 2021(AtCoder Beginner Contest 229)</title>
    <link href="/2021/12/07/A-G-NEC-Programming-Contest-2021-AtCoder-Beginner-Contest-229/"/>
    <url>/2021/12/07/A-G-NEC-Programming-Contest-2021-AtCoder-Beginner-Contest-229/</url>
    
    <content type="html"><![CDATA[<h1 id="A-G-NEC-Programming-Contest-2021-AtCoder-Beginner"><a href="#A-G-NEC-Programming-Contest-2021-AtCoder-Beginner" class="headerlink" title="(A-G)NEC Programming Contest 2021(AtCoder Beginner"></a>(A-G)NEC Programming Contest 2021(AtCoder Beginner</h1><h2 id="A-First-Grid"><a href="#A-First-Grid" class="headerlink" title="A - First Grid"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_a" target="_blank" rel="noopener">A - First Grid</a></h2><p>当且仅当有两个#需要判断，其他直接输出YES。当有两个#时，判断这两个#是否在对角线即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-built_in">string</span> s[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s[<span class="hljs-number">0</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'#'</span>) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s[<span class="hljs-number">1</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'#'</span>) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Hard-Calculation"><a href="#B-Hard-Calculation" class="headerlink" title="B - Hard Calculation"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_b" target="_blank" rel="noopener">B - Hard Calculation</a></h2><p>模拟题，模拟意义下大数加法，判断是否进位即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-built_in">string</span> s1,s2;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;<br>    reverse(s1.<span class="hljs-built_in">begin</span>(),s1.<span class="hljs-built_in">end</span>());<br>    reverse(s2.<span class="hljs-built_in">begin</span>(),s2.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">bool</span> hard = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">min</span>(s1.<span class="hljs-built_in">size</span>(),s2.<span class="hljs-built_in">size</span>());i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x = s1[i] - <span class="hljs-string">'0'</span>;<br>        <span class="hljs-keyword">int</span> y = s2[i] - <span class="hljs-string">'0'</span>;<br>        <span class="hljs-keyword">if</span>(x+y&gt;=<span class="hljs-number">10</span>) hard = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(hard) &#123;<span class="hljs-keyword">break</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(hard) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hard"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Easy"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Cheese"><a href="#C-Cheese" class="headerlink" title="C - Cheese"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_c" target="_blank" rel="noopener">C - Cheese</a></h2><p>贪心题，按照a排序，贪心的从前往后拿即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">3e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br>pii a[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <span class="hljs-keyword">int</span> n,w;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i].first&gt;&gt;a[i].second;<br>    &#125;<br>    sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,greater&lt;pii&gt;());<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [d,cnt]:a)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cnt&lt;=w)<br>        &#123;<br>            w -= cnt;<br>            ans += <span class="hljs-number">1l</span>l*cnt*d;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//w = 0;</span><br>            ans += <span class="hljs-number">1l</span>l*w*d;<br>            w = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(w==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-Longest-X"><a href="#D-Longest-X" class="headerlink" title="D - Longest X"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_d" target="_blank" rel="noopener">D - Longest X</a></h2><p>二分，考虑预处理前缀$pre[]$表示前i个字符有多少个$.$  ，然后对于每个前缀$pre[i]$，在数组$pre[]$中二分第一个大于$pre[i-1]+k$的位置$idx$,然后让$idx—$,也就是最后一个小于等于$pre[i-1]+k$的位置，那么$idx-pre[i]+1$就是从第$i$个字符开始可以做到的最长连续序列的长度。其他位置同理照做，复杂度$O(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">3e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><span class="hljs-keyword">int</span> pre[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    s = <span class="hljs-string">"v"</span> + s;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br><br>        pre[i] = pre[i<span class="hljs-number">-1</span>] + (s[i]==<span class="hljs-string">'.'</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> idx = upper_bound(pre+i,pre+<span class="hljs-number">1</span>+n,k+pre[i<span class="hljs-number">-1</span>]) - pre;<br>        <span class="hljs-keyword">if</span>(idx!=n+<span class="hljs-number">1</span>)<br>        &#123;<br>            idx--;<br>            ans = <span class="hljs-built_in">max</span>(ans,idx - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(n - i + <span class="hljs-number">1</span>,ans);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E-Graph-Destruction"><a href="#E-Graph-Destruction" class="headerlink" title="E - Graph Destruction"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_e" target="_blank" rel="noopener">E - Graph Destruction</a></h2><p>并查集，倒着建立并查集即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">3e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[MAXN];<br><span class="hljs-keyword">int</span> p[MAXN]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">un</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        g[x].push_back(y);<br>        g[y].push_back(x);<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(v&gt;i&amp;&amp;<span class="hljs-built_in">find</span>(i)!=<span class="hljs-built_in">find</span>(v)) &#123;un(i,v);cnt--;&#125;<br>        &#125;<br>       <span class="hljs-comment">// cout&lt;&lt;cnt&lt;&lt;endl;</span><br>        ans.push_back(cnt);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">" "</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"0"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="F-Make-Bipartite"><a href="#F-Make-Bipartite" class="headerlink" title="F - Make Bipartite"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_f" target="_blank" rel="noopener">F - Make Bipartite</a></h2><p>DP题，希望我们去掉边后是一个二分图，我们可以采用染色的方法来表示二分图，即相邻的两个点颜色总是不同。</p><p>可以把中心点$0$设为黑色(用1表示)，设为白色(用$0$表示)同理等价。</p><p>设状态$dp[i][j][sorce]$表示染色到第$i$个点，将第$i$个点染色为$j$颜色，且顶点$1$的颜色为$sorce$已经删去的边权</p><p>然后从点$1$开始染色，顶点1可以是白色/黑色，因此初始状态有两种:$dp[1][0][0]=0,dp[1][1][1] = a[i]$ ,$dp[1][1][1]$由于顶点0也是黑色，如果顶点1也想染成黑色，那么就必须切断$a[1]$这条边。</p><p>转移就是四种：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+b[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+a[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+a[i]+b[i<span class="hljs-number">-1</span>]);<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+a[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+a[i]+b[i<span class="hljs-number">-1</span>]);<br>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+b[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure><p>最后计算答案时我们要比较四个：</p><p>即$dp[n][1][1]+b[n]$,$dp[n][0][0]+b[n]$(因为顶点1和顶点n颜色一样，那么要断掉外边$b[n]$)  和  $dp[n][1][0],dp[n][0][1]$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">min</span>(&#123;dp[n][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+b[n],dp[n][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+b[n],dp[n][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-comment">//unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();</span><br><span class="hljs-comment">//mt19937 rand_num(seed);</span><br><br>ll dp[MAXN][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>ll a[MAXN],b[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <span class="hljs-built_in">memset</span>(dp,INF,<span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-comment">//v0 is black(1)</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;b[i];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+b[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+a[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+a[i]+b[i<span class="hljs-number">-1</span>]);<br>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+a[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+a[i]+b[i<span class="hljs-number">-1</span>]);<br>        dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+b[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">min</span>(&#123;dp[n][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+b[n],dp[n][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+b[n],dp[n][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&#125;)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="G-Longest-Y"><a href="#G-Longest-Y" class="headerlink" title="G - Longest Y"></a><a href="https://atcoder.jp/contests/abc229/tasks/abc229_g" target="_blank" rel="noopener">G - Longest Y</a></h2><p>这题要有一些前置的知识：</p><p>首先考虑在一条数轴上，有n个工厂，现在希望在数轴上的找某一点，使得其他工厂到这个点的距离最小，这是最经典的贪心题，也就是绝对值不等式的应用，直接选择n个工厂位置的中位数即可。</p><p>现在回到我们这个题上，我们不放考虑二分答案$len$, 对于$check(len)$, 我们可以$O(n)$的枚举每个点最为$len$的中点(运用了上面的贪心性质)，然后利用一些维护技巧来$O(1)$的看看左边凑连续$len/2$个$Y$，右边凑连续$len - len/2$个$Y$的花费是否小于$K$。那么这个题就可做到$O(nlogn)$了。</p><p>那么剩下的问题就是如何$O(1)$维护左右连续某个数量的$Y$的花费是多少：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211207154620742.png" srcset="/img/loading.gif" alt="image-20211207154620742"></p><p>对上面图，我们可以维护每个红色点的前缀和，我们可以O(1)查出三根红线长度和$red$，那么利用$3*a[i]-red$就是绿色线段的和，但是我们知道我们不是都移动到a[i],因为如果a[i]前面已经有Y了，那就只能移到这个Y的前面。因此我们其实是多计算了，$1+2+3$的距离。此时我们再减去这段多算的距离，就是左半部全部靠向$a[i]$的花费，此时我们就可以$O(1)$的维护了查询花费了。</p><p>右半部同理，但是细节很多，有点麻烦难写。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-comment">//unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();</span><br><span class="hljs-comment">//mt19937 rand_num(seed);</span><br><br><span class="hljs-keyword">char</span> s[MAXN];<br>ll k;<br>ll n,m;<br>ll a[MAXN];<br>ll pre[MAXN];<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// cout&lt;&lt;"ch"&lt;&lt;len&lt;&lt;endl;</span><br>    ll lcnt = len/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    ll rcnt = len- lcnt;<br>    <span class="hljs-keyword">if</span>(len&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    ll minn = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lcnt;i+rcnt&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-comment">//cout&lt;&lt;"beg:"&lt;&lt;i&lt;&lt;endl;</span><br>        ll tep = <span class="hljs-number">1l</span>l*lcnt*a[i] - <span class="hljs-number">1l</span>l*(pre[i] - pre[i-lcnt]) - <span class="hljs-number">1l</span>l*(<span class="hljs-number">1</span>+lcnt<span class="hljs-number">-1</span>)*(lcnt<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//cout&lt;&lt;lcnt*a[i]&lt;&lt;" "&lt;&lt;pre[i] - pre[i-lcnt]&lt;&lt;" "&lt;&lt;(1+lcnt-1)*(lcnt-1)/2&lt;&lt;endl;</span><br>        ll tep2= <span class="hljs-number">1l</span>l*(pre[i+rcnt] - pre[i]) - <span class="hljs-number">1l</span>l*rcnt*a[i] - <span class="hljs-number">1l</span>l*(<span class="hljs-number">1</span>+rcnt)*rcnt/<span class="hljs-number">2</span>;<br>       <span class="hljs-comment">// cout&lt;&lt;(pre[i+rcnt] - pre[i])&lt;&lt;" "&lt;&lt;rcnt*a[i]&lt;&lt;" "&lt;&lt;(1+rcnt-1)*rcnt/2&lt;&lt;endl;</span><br>       <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;tep&lt;&lt;" "&lt;&lt;tep2&lt;&lt;endl;</span><br>        tep = tep + tep2;<br>        minn=<span class="hljs-built_in">min</span>(minn,tep);<br>    &#125;<br>    <span class="hljs-comment">//cout&lt;&lt;"ch: "&lt;&lt;len&lt;&lt;" "&lt;&lt;minn&lt;&lt;endl;</span><br>    <span class="hljs-keyword">if</span>(minn&lt;=k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <span class="hljs-built_in">string</span> ss;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;ss;<br><br>    n = ss.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ss.<span class="hljs-built_in">size</span>();i++) s[i+<span class="hljs-number">1</span>] = ss[i];<br>    <span class="hljs-built_in">cin</span>&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'Y'</span>) a[++m] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) pre[i] = pre[i<span class="hljs-number">-1</span>] + a[i];<br><br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><br>    ll l = <span class="hljs-number">2</span>,r = n;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        ll mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(check(<span class="hljs-number">1l</span>l*<span class="hljs-number">2</span>)==<span class="hljs-literal">false</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>END</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比赛板子</title>
    <link href="/2021/11/23/%E6%AF%94%E8%B5%9B%E6%9D%BF%E5%AD%90/"/>
    <url>/2021/11/23/%E6%AF%94%E8%B5%9B%E6%9D%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> endl <span class="hljs-meta-string">"\n"</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;di = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dj = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fastIO<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> C[MAXN], L[MAXN];<br><span class="hljs-comment">// 在main函数中...</span><br><span class="hljs-built_in">memcpy</span>(C, A, <span class="hljs-keyword">sizeof</span>(A)); <span class="hljs-comment">// 复制</span><br>sort(C, C + n); <span class="hljs-comment">// 排序</span><br><span class="hljs-keyword">int</span> l = unique(C, C + n) - C; <span class="hljs-comment">// 去重</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    L[i] = lower_bound(C, C + l, A[i]) - C + <span class="hljs-number">1</span>; <span class="hljs-comment">// 查找</span><br></code></pre></div></td></tr></table></figure><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (r - l &gt; eps)<br>&#123;<br>    mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">double</span> fl = f(mid - eps), fr = f(mid + eps);<br>    <span class="hljs-keyword">if</span> (fl &lt; fr)<br>        l = mid; <span class="hljs-comment">// 这里不写成mid - eps，防止死循环；可能会错过极值，但在误差范围以内所以没关系</span><br>    <span class="hljs-keyword">else</span><br>        r = mid;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><strong>整数集合上的二分：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117220854401.png" srcset="/img/loading.gif" alt="image-20210117220854401"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 判断条件很复杂时用check函数，否则if后直接写条件即可</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mid)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br><br><span class="hljs-comment">// 能二分的题一定是满足某种性质，分成左右两部分</span><br><span class="hljs-comment">// if的判断条件是让mid落在满足你想要结果的区间内</span><br><br><span class="hljs-comment">// 找满足某个条件的第一个数  即右半段</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;  <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 找满足某个条件的最后一个数  即左半段</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>实数域上的二分：</strong></p><p>$eps=10^{-(k+2)}$     $k=保留小数k位$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>实数域上的三分：</strong></p><p><img src="https://cdn.acwing.com/media/article/image/2019/11/13/13726_8bf63ee605-360%E6%88%AA%E5%9B%BE20191113165558620.jpg" srcset="/img/loading.gif" alt="360截图20191113165558620.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span></span>&#123;<span class="hljs-comment">/*根据题目意思计算*/</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">three</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l,<span class="hljs-keyword">double</span> r)</span> <span class="hljs-comment">//找凸点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(l&lt;r<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> mmid=(mid+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(f(mid)&gt;f(mmid)) r=mmid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(f(l)&gt;f(r)) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><script type="math/tex; mode=display">\sum_1^{10}\lfloor 10/i \rfloor</script><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r;l&lt;=k;l=r+<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(k / l != <span class="hljs-number">0</span>)<br>        r=k / (k / l);<br>    <span class="hljs-keyword">else</span> r = k;<br>    ans += (k / l) * (r - l + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><script type="math/tex; mode=display">\sum_1^{10}\lfloor 10/i \rfloor * i</script><p>这里和上一个模板的改变是：将连续的$\lfloor 10/i\rfloor$数值相等区间前的系数$i$ 用等差数列求和快速求出。相当于每一段多了一个系数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r;l&lt;=k;l=r+<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(k / l != <span class="hljs-number">0</span>)<br>        r=k / (k / l);<br>    <span class="hljs-keyword">else</span> r = k;<br>    ans += (k / l) * (r - l + <span class="hljs-number">1</span>)*(l + r) / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="上下取整的转换技巧"><a href="#上下取整的转换技巧" class="headerlink" title="上下取整的转换技巧"></a>上下取整的转换技巧</h2><p>上取整函数建议自己写 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//方法1：</span><br><span class="hljs-keyword">if</span> (temp%k == <span class="hljs-number">0</span>)<br>    result = temp / k ;<br><span class="hljs-keyword">else</span><br>    result = (temp / k)+<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//方法2：但要注意temp+k是否有可能溢出</span><br>result = (temp +k<span class="hljs-number">-1</span>)/ k;<br></code></pre></div></td></tr></table></figure><p>转换技巧:  有时候需要我们做整除分块，将上整除转换为下整除</p><script type="math/tex; mode=display">\lceil \frac {m}{n} \rceil = \lfloor \frac{m-1}{n} \rfloor + 1</script><h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll  n, m, p;<br><span class="hljs-function">ll <span class="hljs-title">Ext_gcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123; x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>ll ret = Ext_gcd(b, a%b, y, x);<br>y -= a / b * x;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">Inv</span><span class="hljs-params">(ll a, <span class="hljs-keyword">int</span> m)</span> </span><br><span class="hljs-function"></span>&#123;   <br>ll d, x, y, t = (ll)m;<br>d = Ext_gcd(a, t, x, y);<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (x%t + t) % t;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-function">ll <span class="hljs-title">Cm</span><span class="hljs-params">(ll n, ll m, ll p)</span>  </span><br><span class="hljs-function"></span>&#123;<br>ll a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (m)<br>&#123;<br>a = (a*n) % p;<br>b = (b*m) % p;<br>m--;<br>n--;<br>&#125;<br><span class="hljs-keyword">return</span> (ll)a*Inv(b, p) % p;  <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(ll n, ll m, ll p)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (ll)Cm(n%p, m%p, p)*(ll)Lucas(n / p, m / p, p) % p;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>  T;<br><span class="hljs-built_in">cin</span> &gt;&gt; T;<br><span class="hljs-keyword">while</span> (T--)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, Lucas(n, m, p));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="lcm-gcd"><a href="#lcm-gcd" class="headerlink" title="lcm/gcd"></a>lcm/gcd</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br>&#125;<br> <br><span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*(b/gcd(a,b));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="预处理阶乘-排列组合-逆元-预处理逆元"><a href="#预处理阶乘-排列组合-逆元-预处理逆元" class="headerlink" title="预处理阶乘+排列组合+逆元(预处理逆元)"></a>预处理阶乘+排列组合+逆元(预处理逆元)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll fac[MAXN];<br>ll facinv[MAXN];<br><br><br><span class="hljs-comment">//复杂度log2(x)</span><br><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll n,ll x,ll p=MOD)</span><span class="hljs-comment">//n^x%p</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">1</span>;<br>    ans=ans%p;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>) ans=ans*<span class="hljs-number">1l</span>l*n%p;<span class="hljs-comment">//1ll防止溢出</span><br>        n=n*<span class="hljs-number">1l</span>l*n%p;<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(ll range)</span></span><br><span class="hljs-function"></span>&#123;<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=range;i++) &#123;ans = (ans*<span class="hljs-number">1l</span>l*i)%MOD;fac[i] = ans;&#125;<br>    facinv[range] = ksm(fac[range],MOD<span class="hljs-number">-2</span>,MOD);<br>    <span class="hljs-keyword">for</span>(ll i=range<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;facinv[i] = facinv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%MOD;&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">ccc</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans = fac[x];<br>    ans = (ans*facinv[y]%MOD)*facinv[x-y]%MOD;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">aaa</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=y;i++)<br>    &#123;<br>        ans=ans*(<span class="hljs-number">1l</span>l*y+<span class="hljs-number">1l</span>l*i<span class="hljs-number">-1</span>)%MOD;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="线性筛-欧拉筛"><a href="#线性筛-欧拉筛" class="headerlink" title="线性筛/欧拉筛"></a>线性筛/欧拉筛</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> primes[maxn / <span class="hljs-number">10</span>];<span class="hljs-comment">// 质数 2，3，5，7...排列好的数组</span><br><span class="hljs-keyword">bool</span> isPrime[maxn + <span class="hljs-number">5</span>];<span class="hljs-comment">//isPrime[i] :i是质数吗？</span><br><span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-comment">//质数的个数</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span> (!isPrime[i]) primes[tot++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; i * primes[j] &lt;= maxn; j++)&#123;<br>            isPrime[i * primes[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">vector, 变长数组，倍增的思想<br>    size<span class="hljs-literal">()</span>  返回元素个数<br>    empty<span class="hljs-literal">()</span>  返回是否为空<br>    clear<span class="hljs-literal">()</span>  清空<br>    front<span class="hljs-literal">()</span>/back<span class="hljs-literal">()</span><br>    push<span class="hljs-constructor">_back()</span>/pop<span class="hljs-constructor">_back()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    <span class="hljs-literal">[]</span><br>    支持比较运算，按字典序<br><br>pair&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br><span class="hljs-built_in">string</span>，字符串<br>    size<span class="hljs-literal">()</span>/length<span class="hljs-literal">()</span>  返回字符串长度<br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    substr(起始下标，(子串长度))  返回子串<br>    c<span class="hljs-constructor">_str()</span>  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  向队尾插入一个元素<br>    front<span class="hljs-literal">()</span>  返回队头元素<br>    back<span class="hljs-literal">()</span>  返回队尾元素<br>    pop<span class="hljs-literal">()</span>  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  插入一个元素<br>    top<span class="hljs-literal">()</span>  返回堆顶元素<br>    pop<span class="hljs-literal">()</span>  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-built_in">int</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;, greater&lt;<span class="hljs-built_in">int</span>&gt;&gt; q;<br><br>stack, 栈<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    push<span class="hljs-literal">()</span>  向栈顶插入一个元素<br>    top<span class="hljs-literal">()</span>  返回栈顶元素<br>    pop<span class="hljs-literal">()</span>  弹出栈顶元素<br><br>deque, 双端队列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    front<span class="hljs-literal">()</span>/back<span class="hljs-literal">()</span><br>    push<span class="hljs-constructor">_back()</span>/pop<span class="hljs-constructor">_back()</span><br>    push<span class="hljs-constructor">_front()</span>/pop<span class="hljs-constructor">_front()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    <span class="hljs-literal">[]</span><br><br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size<span class="hljs-literal">()</span><br>    empty<span class="hljs-literal">()</span><br>    clear<span class="hljs-literal">()</span><br>    <span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>/<span class="hljs-keyword">end</span><span class="hljs-literal">()</span><br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span><br><br>    set/multiset<br>        insert<span class="hljs-literal">()</span>  插入一个数<br>        find<span class="hljs-literal">()</span>  查找一个数<br>        count<span class="hljs-literal">()</span>  返回某一个数的个数<br>        erase<span class="hljs-literal">()</span><br>            (<span class="hljs-number">1</span>) 输入是一个数x，删除所有x   <span class="hljs-constructor">O(<span class="hljs-params">k</span> + <span class="hljs-params">logn</span>)</span><br>            (<span class="hljs-number">2</span>) 输入一个迭代器，删除这个迭代器<br>        lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span><br>            lower<span class="hljs-constructor">_bound(<span class="hljs-params">x</span>)</span>  返回大于等于x的最小的数的迭代器<br>            upper<span class="hljs-constructor">_bound(<span class="hljs-params">x</span>)</span>  返回大于x的最小的数的迭代器<br>    map/multimap<br>        insert<span class="hljs-literal">()</span>  插入的数是一个pair<br>        erase<span class="hljs-literal">()</span>  输入的参数是pair或者迭代器<br>        find<span class="hljs-literal">()</span><br>        <span class="hljs-literal">[]</span>  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-constructor">O(<span class="hljs-params">logn</span>)</span><br>        lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span><br><br>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 <span class="hljs-constructor">O(1)</span><br>    不支持 lower<span class="hljs-constructor">_bound()</span>/upper<span class="hljs-constructor">_bound()</span>， 迭代器的++，--<br><br>bitset, 圧位<br>    bitset&lt;<span class="hljs-number">10000</span>&gt; s;<br>    ~, &amp;, <span class="hljs-pattern-match">|, ^</span><br><span class="hljs-pattern-match">    &gt;&gt;, &lt;&lt;</span><br><span class="hljs-pattern-match">    <span class="hljs-operator">==</span>, !=</span><br><span class="hljs-pattern-match">    []</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    count()  返回有多少个1</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    any()  判断是否至少有一个1</span><br><span class="hljs-pattern-match">    none()  判断是否全为0</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    set()  把所有位置成1</span><br><span class="hljs-pattern-match">    set(k, v)  将第k位变成v</span><br><span class="hljs-pattern-match">    reset()  把所有位变成0</span><br><span class="hljs-pattern-match">    flip()  等价于~</span><br><span class="hljs-pattern-match">    flip(k) 把第k位取反</span><br></code></pre></div></td></tr></table></figure><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h2><p>设我们有一个数x，并保证a数组从<strong>小到大</strong>排好</p><p>upper_bound( a,a+n,x)：从数组的begin位置到end-1位置二分查找第一个大于x的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>lower_bound( a,a+n,x)：从数组的begin位置到end-1位置二分查找第一个大于或等于x的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>在数组a[5]={0,2,3,4,5}中，对于需要查找的x=2</p><p>lower_bound(a,a+n,x)-a 返回值为1，表示数组中第一个大于等于x的下标值</p><p>upper_bound(a,a+n,x)-a 返回值为2，表示数组中第一个大于x的下标值</p><p>上面是对于非递减数列的用法，那对于非递增数列的用法呢？<br>这时候我们就需要传入第四个参数 $greater<int>()$ 其中TYPE是指数组类型<br>这时候我们lower_bound就是返回数组中第一个小于或等于x的数的位置，upper_bound就返回数组中第一个小于x的数的位置了。<br><strong>找不到会返回a.end()/a[n+1]</strong> </p><h2 id="unorder-map防止被卡O-n-写法"><a href="#unorder-map防止被卡O-n-写法" class="headerlink" title="unorder_map防止被卡O(n)写法"></a>unorder_map防止被卡O(n)写法</h2><p>不同于<code>map</code>的红黑树实现，<code>unorder_map</code>的有hash实现，一般来说查找是O(1)的，而不是O(log)的，但是CF上有时会被hack成O(n)的，因此提出这种写法。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_hash</span> &#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">splitmix64</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x)</span> </span>&#123;<br>    x += <span class="hljs-number">0x9e3779b97f4a7c15</span>;<br>    x = (x ^ (x &gt;&gt; <span class="hljs-number">30</span>)) * <span class="hljs-number">0xbf58476d1ce4e5b9</span>;<br>    x = (x ^ (x &gt;&gt; <span class="hljs-number">27</span>)) * <span class="hljs-number">0x94d049bb133111eb</span>;<br>    <span class="hljs-keyword">return</span> x ^ (x &gt;&gt; <span class="hljs-number">31</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> FIXED_RANDOM =<br>        chrono::steady_clock::now().time_since_epoch().count();<br>    <span class="hljs-keyword">return</span> splitmix64(x + FIXED_RANDOM);<br>  &#125;<br><br>  <span class="hljs-comment">// 针对 std::pair&lt;int, int&gt; 作为主键类型的哈希函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">uint64_t</span>, <span class="hljs-keyword">uint64_t</span>&gt; x)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> FIXED_RANDOM =<br>        chrono::steady_clock::now().time_since_epoch().count();<br>    <span class="hljs-keyword">return</span> splitmix64(x.first + FIXED_RANDOM) ^<br>           (splitmix64(x.second + FIXED_RANDOM) &gt;&gt; <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>写完自定义的哈希函数后，就可以通过 <code>unordered_map&lt;int, int, my_hash&gt; my_map;</code> 或者 <code>unordered_map&lt;pair&lt;int, int&gt;, int, my_hash&gt; my_pair_map;</code> 的定义方式将自定义的哈希函数传入容器了。</p><h2 id="map自定义排列顺序："><a href="#map自定义排列顺序：" class="headerlink" title="map自定义排列顺序："></a>map自定义排列顺序：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//记录大数据点</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y;<br>    Node() &#123;&#125;<br>    Node(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y):x(x),y(y) &#123;&#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Node &amp;rhs) <span class="hljs-keyword">const</span> &#123;<br><span class="hljs-keyword">return</span> x &lt; rhs.x;<br>&#125; <br>&#125;;<br><span class="hljs-built_in">map</span>&lt;Node,<span class="hljs-keyword">int</span>&gt;mp;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> x1,y1;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;x1&gt;&gt;y1) &#123;<br>        <span class="hljs-keyword">if</span>(x1 == <span class="hljs-number">0</span>&amp;&amp; y1 == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        Node temp = Node(x1,y1);<br>        <span class="hljs-keyword">if</span>(!mp.count(temp)) &#123;<br>            mp[temp] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> mp[temp]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;u:mp) &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;u.first.x&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;u.first.y&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;u.second&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="set自定义顺序"><a href="#set自定义顺序" class="headerlink" title="set自定义顺序"></a>set自定义顺序</h2><p>set是一种关联式容器，所以有顺序，下面给出自定义顺序写法。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span> &#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;<br>&#125;;<br><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, cmp&gt; s;<br></code></pre></div></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RMQ</span>&#123;</span><br>    ll f1[<span class="hljs-number">22</span>][MAXN],f2[<span class="hljs-number">22</span>][MAXN];<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">highbit</span><span class="hljs-params">(ll x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">31</span> - __builtin_clz(x);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll *v,<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) f1[<span class="hljs-number">0</span>][i] = f2[<span class="hljs-number">0</span>][i]= v[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;x &lt;= highbit(n);x++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n - (<span class="hljs-number">1</span> &lt;&lt; x);i++) &#123;<br>                f1[x][i] = <span class="hljs-built_in">min</span>(f1[x - <span class="hljs-number">1</span>][i],f1[x - <span class="hljs-number">1</span>][i + (<span class="hljs-number">1</span> &lt;&lt; (x - <span class="hljs-number">1</span>))]);<br>                f2[x][i] = <span class="hljs-built_in">max</span>(f2[x - <span class="hljs-number">1</span>][i],f2[x - <span class="hljs-number">1</span>][i + (<span class="hljs-number">1</span> &lt;&lt; (x - <span class="hljs-number">1</span>))]);<br>            &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">get_min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        assert(l &lt;= r);<br>        <span class="hljs-keyword">int</span> t = highbit(r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f1[t][l],f1[t][r - (<span class="hljs-number">1</span> &lt;&lt; t) + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">get_max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        assert(l &lt;= r);<br>        <span class="hljs-keyword">int</span> t = highbit(r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f2[t][l],f2[t][r - (<span class="hljs-number">1</span> &lt;&lt; t) + <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//use</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[]....<br>RMQ st;<br>st.init(<span class="hljs-built_in">array</span>,n); <span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>复杂度O(n)</p><p>在长度为n的序列中求每个长度为m的区间最值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//求区间最大值</span><br><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; Q; <span class="hljs-comment">// 存储的是编号</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!Q.empty() &amp;&amp; i - Q.front() &gt;= m) <span class="hljs-comment">// 毕业</span><br>        Q.pop_front();<br>    <span class="hljs-keyword">while</span> (!Q.empty() &amp;&amp; V[Q.back()] &lt; V[i]) <span class="hljs-comment">// 比新生弱的当场退役（求区间最小值把这里改成&gt;即可）</span><br>        Q.pop_back();<br>    Q.push_back(i); <span class="hljs-comment">// 新生入队</span><br>    <span class="hljs-keyword">if</span> (i &gt;= m - <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; V[Q.front()] &lt;&lt; <span class="hljs-string">" "</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>求NGE(Next greater element)问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br>vector&lt;int&gt; V(n + 1), ans(n + 1);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    <span class="hljs-built_in">cin</span> &gt;&gt; V[i];<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; S;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br>    <span class="hljs-keyword">while</span> (!S.empty() &amp;&amp; V[S.top()] &lt; V[i])<br>    &#123;<br>        ans[S.top()] = i;<br>        S.pop();<br>    &#125;<br>    S.push(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">" "</span>;<br></code></pre></div></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>单点修改+区间查询                              </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> l,r;<br>    <span class="hljs-keyword">int</span> v;<br>&#125;tr[<span class="hljs-number">4</span>*MAXN];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].v = <span class="hljs-built_in">max</span>(tr[u&lt;&lt;<span class="hljs-number">1</span>].v,tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u] = &#123;l,r&#125;;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    build(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>    build(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-comment">//查询区间最大</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].v;<span class="hljs-comment">//树中节点已经被完全包含在[l,r]中</span><br>    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) v = query(u&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(l&gt;mid) v = <span class="hljs-built_in">max</span>(v,query(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x) tr[u].v = v;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x&lt;=mid) modify(u&lt;&lt;<span class="hljs-number">1</span>,x,v);<br>        <span class="hljs-keyword">else</span> modify(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x,v);<br>        pushup(u);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>区间修改+区间查询：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><span class="hljs-keyword">int</span> w[MAXN];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> l,r;<br>    ll sum,add;<br>&#125;tr[<span class="hljs-number">4</span>*MAXN];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum = tr[u&lt;&lt;<span class="hljs-number">1</span>].sum + tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u&lt;&lt;<span class="hljs-number">1</span>], &amp;right = tr[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(root.add)<br>    &#123;<br>        left.add += root.add,left.sum += (ll)(left.r - left.l  + <span class="hljs-number">1</span>)*root.add;<br>        right.add += root.add,right.sum += (ll)(right.r-right.l + <span class="hljs-number">1</span>)*root.add;<br>        root.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) tr[u] = &#123;l,r,w[r],<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        tr[u] = &#123;l,r&#125;;<br>        <span class="hljs-keyword">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        build(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>        build(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        pushup(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//区间修改(区间加d)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<br>    &#123;<br>        tr[u].sum += (ll)(tr[u].r - tr[u].l + <span class="hljs-number">1</span>)*d;<br>        tr[u].add += d;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        pushdown(u);<br>        <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(l&lt;=mid) modify(u&lt;&lt;<span class="hljs-number">1</span>,l,r,d);<br>        <span class="hljs-keyword">if</span>(r&gt;mid) modify(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,d);<br>        pushup(u);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//区间查询sum</span><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum;<br>    pushdown(u);<br>    <span class="hljs-keyword">int</span> mid = tr[u].l + tr[u].r&gt;&gt;<span class="hljs-number">1</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum += query(u&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum += query(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;w[i];<br>    build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> l,r,d;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;op&gt;&gt;l&gt;&gt;r;<br>        <span class="hljs-keyword">if</span>(*op==<span class="hljs-string">'C'</span>)<br>        &#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;d;<br>            modify(<span class="hljs-number">1</span>,l,r,d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;query(<span class="hljs-number">1</span>,l,r)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">'a'</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><strong>朴素并查集：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br><span class="hljs-comment">//按秩合并</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span>(rank[x]&lt;rank[y])<br>        parent[x]=y;  <span class="hljs-comment">// 合并是从rank小的向rank大的连边</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        parent[y]=x;<br>        <span class="hljs-keyword">if</span>(rank[x]==rank[y]) rank[x]++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//防止爆栈，非递归版本</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p=x;<br>    <span class="hljs-keyword">while</span>(p!=fa[p])<br>        p=fa[p];<br>    <span class="hljs-keyword">while</span>(x!=p)&#123;<br>        <span class="hljs-keyword">int</span> tmp=fa[x];<br>        fa[x]=p;<br>        x=tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>维护size的并查集：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N], <span class="hljs-built_in">size</span>[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    <span class="hljs-built_in">size</span>[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br><span class="hljs-built_in">size</span>[<span class="hljs-built_in">find</span>(b)] += <span class="hljs-built_in">size</span>[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></div></td></tr></table></figure><p><strong>维护到祖宗节点距离的并查集：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N], d[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></div></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><strong>单点修改+区间查询：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> tree[MAXN];<br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x&amp;(-x);&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans_tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i)) ans_tep+=tree[i];<br>    <span class="hljs-keyword">return</span> ans_tep;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">single_update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//第x个加y</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=n;i+=lowbit(i)) tree[i]+=y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> getsum(y)-getsum(x<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>        single_add(i,a[i]);<span class="hljs-comment">//单点更新来建立树</span><br>    &#125;<br>    查询区间 range_query(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)<br>    查询前缀 getsum(<span class="hljs-keyword">int</span> x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>区间修改+单点查询：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-keyword">int</span> tree_help[MAXN];<span class="hljs-comment">//差分辅助树状数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x&amp;(-x);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">part_update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=n;i+=lowbit(i)) tree_help[i]+=val;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    part_update(l,val);<br>    part_update(r+<span class="hljs-number">1</span>,-val);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">single_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans_tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i)) ans_tep+=tree_help[i];<br>    <span class="hljs-keyword">return</span> ans_tep;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>        part_update(i,a[i]-a[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//单点更新建立tree_help[]</span><br>    &#125;<br>    区间更新： update_query(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val);<br>    单点查询： single_query(<span class="hljs-keyword">int</span> x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>区间修改+区间查询：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5000</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-keyword">int</span> c1[MAXN],c2[MAXN];<span class="hljs-comment">//差分辅助树状数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x&amp;(-x);&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *o,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=n;i++)<br>    &#123;<br>        o[x]+=val;<br>        x+=lowbit(x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *o,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans_tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(x))<br>    &#123;<br>        ans_tep+=o[x];<br>        x-=lowbit(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans_tep;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans1_tep,ans2_tep;<br>    ans1_tep=x*getsum(c1,x);<br>    ans2_tep=getsum(c2,x);<br>    <span class="hljs-keyword">return</span> ans1-ans2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_quiry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans1_tep,ans2_tep;<br>    ans1=sum(r);<br>    ans2=sum(l<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> ans1_tep-ans2_tep;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    update(c1,l,val);<br>    update(c1,r+<span class="hljs-number">1</span>,-val);<br>    update(c2,l,(l<span class="hljs-number">-1</span>)*val);<br>    update(c2,r+<span class="hljs-number">1</span>,-r*val);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>        update(c1,i,a[i]-a[i<span class="hljs-number">-1</span>]);<br>        update(c2,i,(i<span class="hljs-number">-1</span>)*(a[i]-a[i<span class="hljs-number">-1</span>]));<br>    &#125;<br>    区间更新： update_range(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val)<br>    区间查询： range_quiry(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="平衡树AVL"><a href="#平衡树AVL" class="headerlink" title="平衡树AVL"></a>平衡树AVL</h2><p><img src="https://img-blog.csdn.net/20180722220546910" srcset="/img/loading.gif" alt="平衡树左旋"></p><p><img src="https://img-blog.csdn.net/20180722222413303" srcset="/img/loading.gif" alt="平衡树右旋"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    node *lchild,*rchild;<br>&#125;;<br><span class="hljs-function">node *<span class="hljs-title">Newnode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    node* newnode = <span class="hljs-keyword">new</span> node;<br>    newnode-&gt;data = x;<br>    newnode-&gt;lchild = newnode-&gt;rchild = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newnode;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;lchild),<span class="hljs-built_in">height</span>(root-&gt;rchild)) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getbalance</span><span class="hljs-params">(node* root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root-&gt;lchild) - <span class="hljs-built_in">height</span>(root-&gt;rchild);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(node*&amp;root)</span> <span class="hljs-comment">//右旋</span></span><br><span class="hljs-function"></span>&#123;<br>    node* temp = root-&gt;lchild;<br>    root-&gt;lchild = temp-&gt;rchild;<span class="hljs-comment">//根的左节点-&gt;跟的右节点</span><br>    temp-&gt;rchild = root;<br>    root = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(node*&amp;root)</span><span class="hljs-comment">//左旋</span></span><br><span class="hljs-function"></span>&#123;<br>    node* temp = root-&gt;rchild;<br>    root-&gt;rchild = temp-&gt;lchild;<br>    temp-&gt;lchild = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inst</span><span class="hljs-params">(node* &amp;root,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        root = Newnode(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(x&lt;root-&gt;data)<br>    &#123;<br>        inst(root-&gt;lchild,x);<br>        <span class="hljs-keyword">if</span>(getbalance(root)==<span class="hljs-number">2</span>)<span class="hljs-comment">//左边比右边高</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(getbalance(root-&gt;lchild)==<span class="hljs-number">1</span>) R(root);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getbalance(root-&gt;lchild)==<span class="hljs-number">-1</span>) &#123;L(root-&gt;lchild);R(root);&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        inst(root-&gt;rchild,x);<br>        <span class="hljs-keyword">if</span>(getbalance(root)==<span class="hljs-number">-2</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(getbalance(root-&gt;rchild)==<span class="hljs-number">1</span>) &#123;R(root-&gt;rchild);L(root);&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getbalance(root-&gt;rchild)==<span class="hljs-number">-1</span>) L(root);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    node *root = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>        inst(root,x);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><strong>Dijkstra（单源最短路，正边权）：</strong></p><p>无优化：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-keyword">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ACM-Template</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> dist[MAXN];<br><span class="hljs-keyword">bool</span> st[MAXN];<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[MAXN];<br><span class="hljs-built_in">map</span>&lt;pii,<span class="hljs-keyword">int</span>&gt;w;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-keyword">int</span> src)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[src]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;pii,<span class="hljs-built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt;&gt;heap;<br>    heap.push(&#123;<span class="hljs-number">0</span>,src&#125;);<br><br>    <span class="hljs-keyword">while</span>(!heap.empty())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.top();<br>        heap.pop();<br><br>        <span class="hljs-keyword">int</span> u = t.second,distance = t.first;<br>        <span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> st[u] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> v = g[u][i];<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;distance+w[&#123;u,v&#125;])<br>            &#123;<br>                dist[v] = distance + w[&#123;u,v&#125;];<br>                heap.push(&#123;dist[v],v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        g[x].push_back(y);<br>        w[&#123;x,y&#125;]=z;<br>    &#125;<br>    dij(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;dist[n]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><strong>SPFA（单源最短路，正负边权皆可）:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> v,w,nxt;<br>&#125; e[N*<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    tot++;<br>    e[tot].v=v;<br>    e[tot].w=w;<br>    e[tot].nxt=head[u];<br>    head[u]=tot;<br>&#125;<br>ll dis[M];<br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; Q;<br><span class="hljs-keyword">bool</span> vis[M];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3F</span>,<span class="hljs-keyword">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    Q.push(s);<br>    vis[s]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!Q.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> u=Q.front();<br>        Q.pop();<br>        vis[u]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u]; i; i=e[i].nxt)<br>            <span class="hljs-keyword">if</span>(dis[u]+e[i].w&lt;dis[e[i].v])<br>            &#123;<br>                dis[e[i].v]=dis[u]+e[i].w;<br>                <span class="hljs-keyword">if</span>(!vis[e[i].v])<br>                &#123;<br>                    vis[e[i].v]=<span class="hljs-number">1</span>;<br>                    Q.push(e[i].v);<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Floyd $O(n^3)$</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="手写堆"><a href="#手写堆" class="headerlink" title="手写堆"></a>手写堆</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ACM-Template</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastIO ios::sync_with_stdio(false);cin.tie(0);</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-4</span>;<br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">11</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">44</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> largest = i;<br>    <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>&lt;=n&amp;&amp;a[largest]&lt;a[i*<span class="hljs-number">2</span>]) largest = i*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=n&amp;&amp;a[largest]&lt;a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) largest = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(largest!=i)<br>    &#123;<br>        swap(a[largest],a[i]);<br>        adjust(n,largest);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//create max heap</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        adjust(n,i);<br>    &#125;<br>    <span class="hljs-comment">//sort</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        swap(a[<span class="hljs-number">1</span>],a[i]);<br>        adjust(i<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="奇怪的知识"><a href="#奇怪的知识" class="headerlink" title="奇怪的知识"></a>奇怪的知识</h1><ul><li>对于小于n的所有素数$p$，$\sum 1/p=loglogn$</li><li>对于小于n的所有正整数$x$，$\sum 1/x = logn$，也就是调和级数</li><li></li></ul><h1 id="无极鲅鱼"><a href="#无极鲅鱼" class="headerlink" title="无极鲅鱼"></a>无极鲅鱼</h1><ul><li>请检查是否应该开<code>long long</code></li><li>每个test case清空数组的时候应当大一些，比如清空1到n的时候，请尝试清楚1到n+1，因为上一个test case的n+1可能会影响到这一次的结果。</li><li><code>#pragma comment(linker, &quot;/STACK:10240000000000,10240000000000&quot;)</code> 手动开栈</li><li>再读一边题目，是否读错了题目。</li><li>自定义比较函数别用<code>&lt;=</code>  最好定义<code>&lt;</code></li><li><code>endl</code>太慢，用<code>&quot;\n&quot;</code> 或者 <code>#define endl &quot;\n&quot;</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #754 (Div. 2) A-E</title>
    <link href="/2021/11/15/Codeforces-Round-754-Div-2-A-E/"/>
    <url>/2021/11/15/Codeforces-Round-754-Div-2-A-E/</url>
    
    <content type="html"><![CDATA[<p>题目地址：<a href="https://codeforces.com/contest/1605" target="_blank" rel="noopener">链接</a></p><h2 id="A-A-M-Deviation-贪心"><a href="#A-A-M-Deviation-贪心" class="headerlink" title="A. A.M. Deviation(贪心)"></a>A. A.M. Deviation(贪心)</h2><p>每次操作可以使得a+c-2*b   +3或者-3 。那么答案只需要%3即可，如果%后结果为2，就让他再减去3等到|-1| = 1;</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#pragma comment(linker, "/STACK:10240000000000,10240000000000")</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*(b/gcd(a,b));<br>&#125;<br><br><span class="hljs-comment">//int a[MAXN];</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-keyword">int</span> d = a+c<span class="hljs-number">-2</span>*b;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(d)%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">    cin.tie(0);</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="B-Reverse-Sort-双指针，贪心"><a href="#B-Reverse-Sort-双指针，贪心" class="headerlink" title="B. Reverse Sort(双指针，贪心)"></a>B. Reverse Sort(双指针，贪心)</h2><p>最多一次操作，两个指针i,j, i从左到右选择1，j从右到左选择0，使得两者选择的长度相同，并且i&lt;j。 然后一把交换完成。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#pragma comment(linker, "/STACK:10240000000000,10240000000000")</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><br><br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;s;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans,ans0;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'1'</span>) ans.push_back(i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'0'</span>) ans0.push_back(i+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> sz = ans.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(sz==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sz==(ans[sz<span class="hljs-number">-1</span>]-ans[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)&amp;&amp;ans[sz<span class="hljs-number">-1</span>]==n) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r=ans0.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;sz&amp;&amp;r&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(ans[l]&gt;ans0[r]) <span class="hljs-keyword">break</span>;<br>                l++;<br>                r--;<br>            &#125;<br>            l--;<br>            r++;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;l+<span class="hljs-number">1</span>+ans0.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-r+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">" "</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=l;i++) <span class="hljs-built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">" "</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&lt;=ans0.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++) <span class="hljs-built_in">cout</span>&lt;&lt;ans0[i]&lt;&lt;<span class="hljs-string">" "</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">    cin.tie(0);</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="C-Dominant-Character（贪心，暴力）"><a href="#C-Dominant-Character（贪心，暴力）" class="headerlink" title="C. Dominant Character（贪心，暴力）"></a>C. Dominant Character（贪心，暴力）</h2><p>有连续两个a,那么答案直接输出2即可。</p><p>如果没有的话考虑 长度小于7的暴力即可，因为accabba/abbacca是你能够造出最长的符合要求的序列了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#pragma comment(linker, "/STACK:10240000000000,10240000000000")</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><br><br><span class="hljs-keyword">int</span> prea[MAXN],preb[MAXN],prec[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            prea[i+<span class="hljs-number">1</span>] = prea[i];<br>            preb[i+<span class="hljs-number">1</span>] = preb[i];<br>            prec[i+<span class="hljs-number">1</span>] = prec[i];<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'a'</span>) prea[i+<span class="hljs-number">1</span>]++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'c'</span>) prec[i+<span class="hljs-number">1</span>]++;<br>            <span class="hljs-keyword">else</span> preb[i+<span class="hljs-number">1</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> minn = INF;<br>        <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">2</span>;len&lt;<span class="hljs-number">10</span>;len++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;n;i++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> cnta = prea[i+len<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>] - prea[i];<br>                <span class="hljs-keyword">int</span> cntb = preb[i+len<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>] - preb[i];<br>                <span class="hljs-keyword">int</span> cntc = prec[i+len<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>] - prec[i];<br>                <span class="hljs-keyword">if</span>(cnta&gt;cntb&amp;&amp;cnta&gt;cntc)<br>                &#123;<br>                    ok = <span class="hljs-literal">true</span>;<br>                    minn = <span class="hljs-built_in">min</span>(minn,len);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ok) <span class="hljs-built_in">cout</span>&lt;&lt;minn&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">    cin.tie(0);</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="D-Treelabeling（构造，二进制，博弈）"><a href="#D-Treelabeling（构造，二进制，博弈）" class="headerlink" title="D. Treelabeling（构造，二进制，博弈）"></a>D. Treelabeling（构造，二进制，博弈）</h2><p>表面看起来是个树博弈，但是这个题的本质是希望你赋值出一棵树，使得在任何点都无法走向其他点。因此这个题变成了一个构造题。</p><p>如何构造上述的树呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/3KEMB33@(HA%5D_E66UT)BQ%7DK.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /></p><p>首先我们发现1  , 23 ,  4567  , 789….15 , 16….31 ,  ..每组都是可以相互联通的值，因此我们要让他们在树同一层，使得他们无法相连。</p><p>首先对树分层涂色，然后计算两种颜色的数量，如上图数量少的是蓝色，为3。 转换成2进制：11 也就是1 + 2，正好可以用 1 和 23这两组赋值。可是任何的数量都可以用几个组进行赋值吗？答案是肯定的，我们只需要对数量少的进行二进制表示，然后从1  , 23 ,  4567  , 789….15 , 16….31 ,  ..这些组种选几组来赋值即可，剩下得随便放。</p><p>二进制拆分的好处就是选择完这组后就要把这组的数全拿走，可为什么非要选择这组就要把这组的数全拿走赋值呢？不可以只用一部分呢？</p><p>比如 对于组4567你只用了456，剩下了7，而我们这种做法种红色节点是可以随便放的，这会导致你可能在红色节点上放了7，而456可能是相邻的蓝色节点，这就无法保证每个点孤立了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">2e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> ll mod =  <span class="hljs-number">998244353</span>;<br><br><span class="hljs-keyword">int</span> color[MAXN];<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> last=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = color[last] ^ <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(v!=last) dfs(v,u);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> vis[MAXN];<br><span class="hljs-keyword">int</span> c0[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>       cnt[<span class="hljs-number">0</span>] = cnt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> n;<br>       <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;vis[i] = <span class="hljs-number">0</span>;g[i].<span class="hljs-built_in">clear</span>();&#125;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>       &#123;<br>           <span class="hljs-keyword">int</span> x,y;<br>           <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>           g[x].push_back(y);<br>           g[y].push_back(x);<br>       &#125;<br>       dfs(<span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cnt[color[i]]++;<br>       <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">0</span>]&gt;cnt[<span class="hljs-number">1</span>])<br>       &#123;<br>           swap(cnt[<span class="hljs-number">0</span>],cnt[<span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) color[i] ^=<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> pp = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">22</span>;i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>((cnt[<span class="hljs-number">0</span>]&gt;&gt;i)&amp;<span class="hljs-number">1</span>)<br>           &#123;<br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=(<span class="hljs-number">1</span>&lt;&lt;i);j&lt;=(<span class="hljs-number">1</span>&lt;&lt;(i+<span class="hljs-number">1</span>))<span class="hljs-number">-1</span>;j++)<br>               &#123;<br>                   c0[++pp]=j;<br>                   vis[j]=<span class="hljs-number">1</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">int</span> p1=<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(color[i]==<span class="hljs-number">0</span>)<br>           &#123;<br>               <span class="hljs-built_in">cout</span>&lt;&lt;c0[pp--]&lt;&lt;<span class="hljs-string">" "</span>;<br>           &#125;<br>           <span class="hljs-keyword">else</span><br>           &#123;<br>               <span class="hljs-keyword">while</span>(vis[p1]) ++p1;<br>               <span class="hljs-built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="hljs-string">" "</span>;<br>               p1++;<br>           &#125;<br>       &#125;<br>       <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E-Array-Equalizer-前缀和，绝对值维护，二分"><a href="#E-Array-Equalizer-前缀和，绝对值维护，二分" class="headerlink" title="E. Array Equalizer(前缀和，绝对值维护，二分)"></a>E. Array Equalizer(前缀和，绝对值维护，二分)</h2><p>这是一个挺有意思的题目</p><p>首先考虑如何让数组a变为数组b：</p><p>首先$a_1$需要减去 $a_1-b_1$</p><p>随后$a_2$需要减去 $a_2’-b_2 = a_2-(a_1-b_1) - b_2$</p><p>$a_3$需要减去$a_3’ - b_3 = a_3 - (a_1-b_1)-b_3$</p><p>$a_4$需要减去$a_4’-b_4 = a_4-(a_1-b_1)-(a_2-(a_1-b_1)-b_2)-b_4$</p><p>通过以上不难发现,我们从$a_1$开始操作到$a_n$，只需要考虑$a_i$的$i$的因子有哪儿些即可，只有$i$的因子会对$a_i$做贡献。</p><p>接下来考虑如何应对b1的变化，我们要求的式子是：</p><p>$f(b_1) = |a_1-b_1|+|a_2-(a_1-b_1) - b_2|+|a_3 - (a_1-b_1)-b_3|+|a_4-(a_1-b_1)-(a_2-(a_1-b_1)-b_2)-b_4|$</p><p>这是一个关于$b_1$的函数，其他都是定值，这里难处理的问题在于如何解决绝对值的问题，考虑将所有绝对值表示为$|kb_1+c|$的形式，保证k&gt;0。</p><p>式子转化为:</p><script type="math/tex; mode=display">f(b_1)=|k_1b_1+c_1|+|k_2b_1+c_2|+...|k_nb_1+c_n|</script><p>考虑如何去掉绝对值呢？ $k_ib_1+c_i&gt;=0$也就是$b_1&gt;-c_i/k_i$时即可直接去掉，否则需要加一个负号再去掉。</p><p>由于有q(q&lt;=1e5)个询问，我们可以按照$-c_i/k_i$进行排序，然后对于每个查询q，我们只需要二分排序后$-c_i/k_i$,找到分割位置即可，前面半部分都是直接去绝对值即可，后面半部分需要去绝对值后再加个符号，最后再利用前缀和快速维护答案。</p><p><strong>细节有点麻烦，但是好题！</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#pragma comment(linker, "/STACK:10240000000000,10240000000000")</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;long long,long long&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br>ll a[MAXN],b[MAXN];<br>pii kc[MAXN];<br>pii prez[MAXN],suff[MAXN];<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;c;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pii x,pii y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>*x.second/(<span class="hljs-number">1.0</span>*x.first)&lt;<span class="hljs-number">-1.0</span>*y.second/(<span class="hljs-number">1.0</span>*y.first);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;b[i];<br>    b[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        kc[i].second += a[i] - b[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+i;j&lt;=n;j+=i)<br>        &#123;<br>            kc[j].second -= kc[i].second;<br>        &#125;<br>    &#125;<br>    kc[<span class="hljs-number">1</span>].first = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+i;j&lt;=n;j+=i)<br>        &#123;<br>            kc[j].first -= kc[i].first;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for(int i=1;i&lt;=6;i++) cout&lt;&lt;kc[i].first&lt;&lt;" ";</span><br><span class="hljs-comment">//    cout&lt;&lt;endl;</span><br><span class="hljs-comment">//    for(int i=1;i&lt;=6;i++) cout&lt;&lt;kc[i].second&lt;&lt;" ";</span><br><span class="hljs-comment">//    cout&lt;&lt;endl;</span><br>    <span class="hljs-built_in">vector</span>&lt;pii&gt;coef;<br>    ll lef = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(kc[i].first==<span class="hljs-number">0</span>) lef+=<span class="hljs-built_in">abs</span>(kc[i].second);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(kc[i].first&lt;<span class="hljs-number">0</span>) coef.push_back(&#123;-kc[i].first,-kc[i].second&#125;);<br>            <span class="hljs-keyword">else</span> coef.push_back(kc[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//cout&lt;&lt;lef&lt;&lt;endl;</span><br>    sort(coef.<span class="hljs-built_in">begin</span>(),coef.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">//for(int i=0;i&lt;coef.size();i++) cout&lt;&lt;coef[i].first&lt;&lt;" "&lt;&lt;coef[i].second&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;coef.<span class="hljs-built_in">size</span>();i++) c.push_back(<span class="hljs-number">-1.0</span>*coef[i].second/(<span class="hljs-number">1.0</span>*coef[i].first));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;coef.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) &#123;prez[i].first = coef[i].first;prez[i].second = coef[i].second;&#125;<br>        <span class="hljs-keyword">else</span> &#123;prez[i].first = prez[i<span class="hljs-number">-1</span>].first + coef[i].first;prez[i].second = prez[i<span class="hljs-number">-1</span>].second + coef[i].second;&#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=coef.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        suff[i] = &#123;suff[i+<span class="hljs-number">1</span>].first+coef[i].first, suff[i+<span class="hljs-number">1</span>].second+coef[i].second&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> q;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;q;<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        ll x;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>        <span class="hljs-keyword">int</span> idx = upper_bound(c.<span class="hljs-built_in">begin</span>(),c.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1.0</span>*x) - c.<span class="hljs-built_in">begin</span>();<br>        ll ans = prez[idx<span class="hljs-number">-1</span>].first*x+prez[idx<span class="hljs-number">-1</span>].second;<br>        ans+=-suff[idx].first*x-suff[idx].second;<br>        ans+=lef;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">    cin.tie(0);</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC224-G - Roll or Increment(人类智慧，数学)</title>
    <link href="/2021/11/11/ABC224-G-Roll-or-Increment-%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7%EF%BC%8C%E6%95%B0%E5%AD%A6/"/>
    <url>/2021/11/11/ABC224-G-Roll-or-Increment-%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7%EF%BC%8C%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个$N$个面的骰子，开始的值是$S$，现在希望到$T$，你可以做两种操作，操作可以任意顺序，任意次：</p><p>1.花费$A$：将$S$加$1$，但要注意$S$等于$N$时不可以进行该操作。</p><p>2.花费$B$：随机投掷骰子一次，等概率出现$1-N$之间的数。</p><p>寻求一种$S$到$T$期望花费最小的策略，输出最小期望。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211111152750571.png" srcset="/img/loading.gif" alt="image-20211111152750571"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    首先思考，如果一个骰子做了操作1在做操作2，这是十分奇怪的，因为既然要做操作2，何必做操作1呢，先做的操作1不会对操作2有任何影响。<strong>因此得出第一个结论：先做操作2，再做操作1</strong>(也可以不做操作2直接做操作1,总之不能做完操作1再做操作2)。</p><p>​    那么掷到多大才可以做操作1呢？不妨设为$X$, 那么投掷到目标区间$[T-X+1,T]$的时候就可以直接进行操作1，直到T，要么就一直进行操作2。因此期望就是: 投掷到目标区间花费的期望$E_1$+从目标区间到T的期望$E_2$。</p><p>​    首先考虑$E_2=(X-1)*A/2$，这个计算就是一个线性期望计算。</p><p>​    然后重点考虑$E_2$的计算，设第$i$次才投到目标区间的概率为$p_i$, 则:</p><script type="math/tex; mode=display">E_2=\Sigma_{i=1}^{\inf}p_i*i*B</script><p>然后就是高中数列知识错位相减得到结果即可，答案是$BN/2$。    </p><p>所以期望就是: $BN/2 + (X-1)A/2$，利用均值不等式:$BN/2 + (X-1)A/2&gt;=\sqrt{ABN/2}-N/2$即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 建信 04.电学实验课(矩阵快速幂，计数)</title>
    <link href="/2021/11/10/LeetCode-%E5%BB%BA%E4%BF%A1-04-%E7%94%B5%E5%AD%A6%E5%AE%9E%E9%AA%8C%E8%AF%BE-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E8%AE%A1%E6%95%B0/"/>
    <url>/2021/11/10/LeetCode-%E5%BB%BA%E4%BF%A1-04-%E7%94%B5%E5%AD%A6%E5%AE%9E%E9%AA%8C%E8%AF%BE-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-建信-04-电学实验课-矩阵快速幂，计数"><a href="#LeetCode-建信-04-电学实验课-矩阵快速幂，计数" class="headerlink" title="LeetCode 建信 04.电学实验课(矩阵快速幂，计数)"></a>LeetCode 建信 04.电学实验课(矩阵快速幂，计数)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h2><p>某电学实验使用了 row * col 个插孔的面包板，可视作二维矩阵，左上角记作 (0,0)。老师设置了若干「目标插孔」，它们位置对应的矩阵下标记于二维数组 position。实验目标要求同学们用导线连接所有「目标插孔」，即从任意一个「目标插孔」沿导线可以到达其他任意「目标插孔」。受实验导线长度所限，导线的连接规则如下：</p><p>一条导线可连接 相邻两列 的且 行间距 不超过 1 的两个插孔<br>每一列插孔中最多使用其中一个插孔（包括「目标插孔」）<br>若实验目标可达成，请返回使用导线数量最少的连接所有目标插孔的方案数；否则请返回 0。</p><p><strong>注意:</strong><br>输入数据保证每列最多仅有一个「目标插孔」；<br>答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>输入：row = 5, col = 6, position = [[1,3],[3,2],[4,1]]<br>输出：0<br>解释：根据连接规则无法达成实验目标。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211110160849593.png" srcset="/img/loading.gif" alt="image-20211110160849593"></p><hr><p>输入：row = 3，col = 4, position = [[0,3],[2,0]]<br>输出：3<br>解释：根据连接规则共有三种方案达成目标。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211110160915463.png" srcset="/img/loading.gif" alt="image-20211110160915463"></p><hr><p>输入：row = 5, col = 6, position = [[1,3],[3,5],[2,0]]<br>输出：6<br>解释：根据连接规则共有六种方案达成目标。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211110160939693.png" srcset="/img/loading.gif" alt="image-20211110160939693"></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>$1 &lt;= row &lt;= 20\<br>3 &lt;= col &lt;= 10^9\<br>1 &lt; position.length &lt;= 1000\<br>0 &lt;= position[i][0] &lt; row\<br>0 &lt;= position[i][1] &lt; col$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    由于每列只有一个插孔，所以连接顺序一定是从左到右一次连接，不会出现折返(这违反了”每一列插孔中最多使用其中一个插孔（包括「目标插孔」）”这个条件)。且每次前进一列一定只有三种连接方式：右上，右，右下。</p><p>​    将目标插孔按照列的大小排序，然后计算$position[i][1]$ 到$posistion[i-1][1]$两个相邻目标插孔间的方案数即可，最终答案就是 将这些相邻目标插孔方案数连乘起来。</p><p>​    考虑如何计算相邻目标插孔的方案数？我们先考虑相邻两列之间有哪儿些行可以转移，不妨设一个转移矩阵$T$，$T[i][j]$就代表当前一列的第$i$行可以转移到当前列的第$j$行。这个计算很简单：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">t[<span class="hljs-number">0</span>].len = row;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-built_in">max</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);j&lt;=<span class="hljs-built_in">min</span>(i+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>);j++)<br>    &#123;<br>        t[<span class="hljs-number">0</span>].a[i][j] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​    但是目标插孔相邻两列之间的距离不一定是1，加入是2，那么令$T=T^2$,此时$T[i][j]$就代表了前两列的第$i$行到当前第$j$行的方案数。可以列的范围高达1e9，如果目标插孔相邻两列之间的距离为1e9那怎么办呢？直接$T^{1e9}$这是不合理的复杂度高达$O(n^3m)$, 考虑矩阵快速幂，对1e9进行二进制拆分即可。我们只需要预处理出$T,T^2,T^4,T^8….T^{2^{30}}$即可，每次只需要前一个平方即可递推出下一个，预处理复杂度是$O(30*n^3)$。</p><p>​    接下来逐一处理相邻两个目标插孔即可，d二进制拆分$logd$，每次$n^3$的复杂度的矩阵乘法。最后复杂度是$O(n<em>logm</em>n^3)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> r,c;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">M</span>&#123;</span><br>        ll a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        M()&#123;<br>            <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> a);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;x,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]&lt;y[<span class="hljs-number">1</span>];<br>    &#125;<br>    M <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> M &amp;x,<span class="hljs-keyword">const</span> M &amp;y)<br>    &#123;<br>        M ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;x.len;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;x.len;j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;x.len;k++)<br>                &#123;<br>                    ans.a[i][j] = (ans.a[i][j] + (x.a[i][k]*y.a[k][j])%MOD)%MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans.len = x.len;<br>        <span class="hljs-keyword">return</span> z;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">electricityExperiment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;<br>        r = row, c = col;<br>        M t[<span class="hljs-number">33</span>];<br>        t[<span class="hljs-number">0</span>].len = row;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-built_in">max</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);j&lt;=<span class="hljs-built_in">min</span>(i+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>);j++)<br>            &#123;<br>                t[<span class="hljs-number">0</span>].a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>        &#123;<br>            t[i] = t[i<span class="hljs-number">-1</span>] * t[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        ll ans = <span class="hljs-number">0</span>;<br>        sort(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;p.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            M tep;<br>            tep.len = row;<br>            <span class="hljs-keyword">int</span> d = p[i][<span class="hljs-number">1</span>] - p[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;row;j++)<br>            &#123;<br>                tep.a[j][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">30</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (y &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) tep = tep * t[j];<br>            &#125;<br>            ans = ans*tep.a[p[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]][p[i][<span class="hljs-number">0</span>]]%MOD;<br>            <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #753 (Div. 3) F-H</title>
    <link href="/2021/11/06/Codeforces-Round-753-Div-3-F-H/"/>
    <url>/2021/11/06/Codeforces-Round-753-Div-3-F-H/</url>
    
    <content type="html"><![CDATA[<h2 id="F-Robot-on-the-Board-2（搜索）"><a href="#F-Robot-on-the-Board-2（搜索）" class="headerlink" title="F. Robot on the Board 2（搜索）"></a>F. Robot on the Board 2（搜索）</h2><p><strong>题意：</strong></p><p>题意：有一个n*m的棋盘，每个格子上有一个字符，U, D, L, R四个之一。机器人从任意一个格子为起始位置，按着字符方向（U,D,L,R分别是上下左右）走一格，直到碰到走过的格子或者出边界，最长的运动路径长度是多少。输出使运动路径最长的起始位置和路径长度</p><p><strong>题解：</strong></p><p>遍历每个点并对每个点按照规则搜索，同时记录走过的路径，走过的路径无需重复搜索。同时要注意如果搜索的路径有环，那么要把有环的地方的$len[x][y]$标记为同样的大小。每个点都只会最多被访问两次，复杂度O(n*m)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#pragma comment(linker, "/STACK:10240000000000,10240000000000")//手动开栈</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>;<br><br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">char</span> a[<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>][<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> len[<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>][<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> vis[<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>][<span class="hljs-number">2000</span>+<span class="hljs-number">2</span>];<br><span class="hljs-built_in">vector</span>&lt;pii&gt;t;<br><br><span class="hljs-keyword">bool</span> is_cir = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(vis[x][y]==<span class="hljs-number">1</span>) &#123;is_cir=<span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>    <span class="hljs-keyword">if</span>(vis[x][y]==<span class="hljs-number">1</span>||x&lt;=<span class="hljs-number">0</span>||y&lt;=<span class="hljs-number">0</span>||x&gt;n||y&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    is_cir = <span class="hljs-literal">false</span>;<br>    t.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">while</span>(check(x,y))<br>    &#123;<br>       <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span><br>        t.push_back(&#123;x,y&#125;);<br>        vis[x][y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-string">'U'</span>) x--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-string">'D'</span>) x++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-string">'L'</span>) y--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[x][y]==<span class="hljs-string">'R'</span>) y++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> xx=x, yy=y;<br>    <span class="hljs-keyword">int</span> cnt = len[x][y];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=t.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        cnt++;<br>        len[t[i].first][t[i].second] = cnt;<br>        <span class="hljs-keyword">if</span>(is_cir&amp;&amp;t[i].first==xx&amp;&amp;t[i].second==yy)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;t.<span class="hljs-built_in">size</span>();j++) len[t[j].first][t[j].second] = cnt;<br>            is_cir = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">2</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=m+<span class="hljs-number">2</span>;j++)<br>            &#123;<br>                len[i][j] = <span class="hljs-number">0</span>;<br>                vis[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> s;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;s;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>            &#123;<br>                a[i][j] = s[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>            &#123;<br>                dfs(i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxx = <span class="hljs-number">-1</span>;<br>        pii ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(len[i][j]&gt;maxx)<br>                &#123;<br>                    maxx = len[i][j];<br>                    ans.first = i;<br>                    ans.second = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans.first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;ans.second&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;maxx&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">    cin.tie(0);</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="G-Banquet-Preparations-1-构造，贪心"><a href="#G-Banquet-Preparations-1-构造，贪心" class="headerlink" title="G. Banquet Preparations 1(构造，贪心)"></a>G. Banquet Preparations 1(构造，贪心)</h2><p><strong>题意：</strong></p><p>​    给n组数，每组包含$a<em>i,b_i$两个数，现在可以对每组数做减去操作，操作是：使a减去一个非负数x，使b减去一个非负数y，同时保证x+y=m。希望每个数操作后使得$|\Sigma</em>{i=1}^na<em>i-\Sigma</em>{i=1}^nb_i|$最小，输出每组数的a和b分别多少。</p><p><strong>题解：</strong></p><p>​    一开始的这些数总共大小是$\Sigma<em>{i=1}^na_i+\Sigma</em>{i=1}^nb<em>i$，需要减去的大小是$n*m$,那么操作完后这些数的总共大小是$left = \Sigma</em>{i=1}^na<em>i+\Sigma</em>{i=1}^nb_i-n*m$, 我们希望剩下得$a，b$绝对值差最小，即进行完减去操作后，a和b两边的和各是$left/2$。</p><p>​    我们可以求出$a_i$进行完减去操作后的范围$[l,r]$, 只需要构造出$a_i$的和尽量接近$left/2$即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>;<br><br>pii a[MAXN];<br>pii rg[MAXN];<br><span class="hljs-keyword">int</span> ler[MAXN];<br>pii ori[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n,m;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>        ll sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;a[i].first&gt;&gt;a[i].second;<br>            ori[i].first = a[i].first;<br>            ori[i].second = a[i].second;<br>            sum += <span class="hljs-number">1l</span>l*a[i].first + <span class="hljs-number">1l</span>l*a[i].second;<br>            ll l = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,m-a[i].second);<br>            ll r = <span class="hljs-built_in">min</span>(m,a[i].first);<br>            rg[i].first = a[i].first - r;<br>            rg[i].second = a[i].first - l;<br>        &#125;<br>        sum = sum - <span class="hljs-number">1l</span>l*n*m;<br>        sum/=<span class="hljs-number">2</span>;<br>        ll lef = sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            lef-=rg[i].first;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(lef&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                a[i].first -= rg[i].first;<br>                ler[i] = rg[i].second - rg[i].first;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(lef&gt;=ler[i])<br>                &#123;<br>                    a[i].first -= ler[i];<br>                    lef -= ler[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    a[i].first -= lef;<br>                    lef-=lef;<br>                &#125;<br>            &#125;<br>            ll ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                ans+=<span class="hljs-number">1l</span>l*(ori[i].first-a[i].first)<span class="hljs-number">-1l</span>l*(ori[i].second-(m-a[i].first));<br>            &#125;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">abs</span>(ans)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;a[i].first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;m-a[i].first&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ll ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                a[i].first -= rg[i].first;<br>                a[i].second =m - a[i].first;<br>                ans+=<span class="hljs-number">1l</span>l*(ori[i].first-a[i].first)<span class="hljs-number">-1l</span>l*(ori[i].second-a[i].second);<br>            &#125;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">abs</span>(ans)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;a[i].first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;a[i].second&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="H-Banquet-Preparations-2-双指针，区间合并"><a href="#H-Banquet-Preparations-2-双指针，区间合并" class="headerlink" title="H. Banquet Preparations 2(双指针，区间合并)"></a>H. Banquet Preparations 2(双指针，区间合并)</h2><p><strong>题意：</strong></p><p>$n$个非负三元组$a_i, b_i, m_i$，保证$a_i + b_i ≥ m_i$ 。让每个三元组$a_i$ , $b_i$总共减少$m_i$。问最后使得减少后的$(a_i,b_i)$对 不同的对数最少的方案，和对数。</p><p><strong>题解：</strong></p><p>当一组数做完减去操作后，他们剩下的和是$sum=a_i+b_i-m_i$，只要当剩下的和$sum$相同才有可能$a，b$分别相同，所以我们先按照$sum$作为第一关键字进行排序。</p><p>接下来我们求出每个$a$的范围，如果剩下的$sum$相同且$a$的范围有交集，那么两组数就可以使得$(a,b)$相同。然后我们把a的范围$[range_l,range_r]$的$range_l$作为第二关键字，$range_r$作为第三关键字，最后对他们用双指针做区间合并，如果无交集区间则ans++统计答案。排序复杂度$O(nlogn)$，双指针区间合并$O(n)$，总复杂度$O(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">////</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a,b,m;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> rgl,rgr;<br>    <span class="hljs-keyword">int</span> newa,newb;<br>    <span class="hljs-keyword">int</span> id;<br>&#125;p[MAXN];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.sum==b.sum)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a.rgl==b.rgl) <span class="hljs-keyword">return</span> a.rgr&lt;b.rgr;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.rgl&lt;b.rgl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.sum&lt;b.sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.id&lt;b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;p[i].a&gt;&gt;p[i].b&gt;&gt;p[i].m;<br>            p[i].id = i;<br>            p[i].rgl = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,p[i].a-p[i].m);<br>            p[i].rgr = <span class="hljs-built_in">min</span>(p[i].a,p[i].a-(p[i].m-p[i].b));<br>            p[i].sum = p[i].a + p[i].b - p[i].m;<br>        &#125;<br>        sort(p+<span class="hljs-number">1</span>,p+<span class="hljs-number">1</span>+n,cmp);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = p[<span class="hljs-number">1</span>].rgl,r = p[<span class="hljs-number">1</span>].rgr;<br>        <span class="hljs-keyword">int</span> last_i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[i].sum==p[i<span class="hljs-number">-1</span>].sum)<br>            &#123;<br>                <span class="hljs-keyword">int</span> nowl = p[i].rgl, nowr = p[i].rgr;<br>                <span class="hljs-keyword">if</span>(nowl&lt;=r)<br>                &#123;<br>                    l = nowl;<br>                    r = <span class="hljs-built_in">min</span>(r,nowr);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=last_i;j&lt;=i<span class="hljs-number">-1</span>;j++)<br>                    &#123;<br>                        p[j].newa = l;<br>                        p[j].newb = p[j].b - (p[j].m-(p[j].a-l));<br>                    &#125;<br>                    ans++;<br>                    l = p[i].rgl;<br>                    r = p[i].rgr;<br>                    last_i = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=last_i;j&lt;=i<span class="hljs-number">-1</span>;j++)<br>                &#123;<br>                    p[j].newa = l;<br>                    p[j].newb = p[j].b - (p[j].m-(p[j].a-l));<br>                &#125;<br>                ans++;<br>                l = p[i].rgl;<br>                r = p[i].rgr;<br>                last_i = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=last_i;j&lt;=n;j++)<br>        &#123;<br>            p[j].newa = l;<br>            p[j].newb = p[j].b - (p[j].m-(p[j].a-l));<br>        &#125;<br>        ans++;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sort(p+<span class="hljs-number">1</span>,p+<span class="hljs-number">1</span>+n,cmp2);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;p[i].a-p[i].newa&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;p[i].b-p[i].newb&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSD: Principled Synthetic-to-Real Dehazing Guided by Physical Priors介绍</title>
    <link href="/2021/07/22/PSD-Principled-Synthetic-to-Real-Dehazing-Guided-by-Physical-Priors%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/07/22/PSD-Principled-Synthetic-to-Real-Dehazing-Guided-by-Physical-Priors%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="PSD-Principled-Synthetic-to-Real-Dehazing-Guided-by-Physical-Priors"><a href="#PSD-Principled-Synthetic-to-Real-Dehazing-Guided-by-Physical-Priors" class="headerlink" title="PSD: Principled Synthetic-to-Real Dehazing Guided by  Physical Priors"></a>PSD: Principled Synthetic-to-Real Dehazing Guided by  Physical Priors</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>首先介绍一下雾霾模型：</p><script type="math/tex; mode=display">I(x) = J(x)t(x) + A(1-t(x))</script><p>其中$J(x)$是原图，$I(x)$是观测的雾霾图像，$t(x)$是透射率，$A$是全局大气光。</p><p>​    早期模型是基于物理先验的方法，然而这些方法鲁棒性很差，需要单独调参。随着深度学习的进入，许多方法开始依赖于CNN，效率和效果变得更快更好，但也有存在着一定的问题，比如真实数据集不够，只能利用合成数据集训练，而合成数据集训练出的模型在真实雾霾场景下的效果很一般。所以当下去雾模型的问题是如果将任务从生成雾霾图像数据集迁移到真实雾霾场景。在论文中，作者提出了一种PSD的方法帮助模型从合成数据集泛化到真实场景。</p><p>​    PSD包含两部分：监督式的预训练和无监督式微调，后面会具体描述这两个的操作。</p><p>​    作者认为这篇文章的创新点/贡献如下：</p><ul><li>作者使用当下表现很好的去雾模型作为backbone并利用和合成数据来预训练backbone，真正的雾霾图像用于微调模型。</li><li>结合了多种表现很好的物理先验指导微调，这也是PSD的核心。</li><li>去雾效果SOTA</li></ul><h2 id="Proposed-Method"><a href="#Proposed-Method" class="headerlink" title="Proposed Method"></a>Proposed Method</h2><h3 id="Framework-Overview"><a href="#Framework-Overview" class="headerlink" title="Framework Overview"></a>Framework Overview</h3><p>主要分为预训练和微调两部分：</p><ul><li><p>预训练</p><p>利用当下的SOTA去雾模型来做backbone，因为这些SOTA模型可以在生成数据上获得极好的效果，并且可以提供雾霾图像的domain knowledge。</p><p>通过把backbone修改成基于物理模型的网络，这样可以同时产生无雾霾图像$J$，投射图$t$，全局大气光$A$。修改如下图：</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210721221750651.png" srcset="/img/loading.gif" alt="image-20210721221750651"></p><p>​    为了可以联合最优化这三者$J,t,A$，作者给出了一个reconstruction loss，这个loss指导着网络的输出符合雾天退化模型。</p><p>​    注意：在这一部分我们只利用有标签的生成数据做训练，因此这部分预训练得到的模型是在生成数据域上的模型。</p><ul><li><p>微调</p><p>​    用无标签的真实数据训练，这一部分是希望做到域自适应，从生成数据域转换道真实数据域上。作者认为无雾的图像总是遵守一些特定规律，也就是符合一些物理先验知识，同时它认为单独的先验物理知识并不总是准确的，作者提出了一种包含多个不同先验知识的prior loss committee来指导训练无标签的真实数据。</p><p>​    除此之外，作者利用了<strong>LwF(Learning without forget)</strong>方法，来避免灾难性遗忘。</p></li></ul><p>​    </p><h3 id="网络介绍：Physics-Based-Network"><a href="#网络介绍：Physics-Based-Network" class="headerlink" title="网络介绍：Physics-Based Network"></a>网络介绍：Physics-Based Network</h3><p>​    大部分去雾的深度学习模型都是直接估计恢复后的图片，但作者提出的是在他们的基础上添加了两个模块：<strong>Physics-compatible head</strong>和<strong>Atmospheric light estimation network(A-Net)</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210721223832033.png" srcset="/img/loading.gif" alt="image-20210721223832033"></p><ul><li>Physics-compatible head</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210721224249230.png" srcset="/img/loading.gif" alt="image-20210721224249230"></p><p>这部分两个分支，每个分支都有两层卷积层，这里假设backbone是一种可以有效提取投射图和去雾后图像的特征提取器，backbone得到feature map后直接连入Physics-compatible head的卷积层。</p><ul><li>Atmospheric light estimation network(A-Net)</li></ul><p>这一部分就是用的DCPDN种的U-Net来估计全局大气光，作者还为backbone和这个子网络提出了reconstruction loss。</p><h3 id="预训练部分：-Model-Pretraining"><a href="#预训练部分：-Model-Pretraining" class="headerlink" title="预训练部分： Model Pretraining"></a>预训练部分： Model Pretraining</h3><p>我们使用的backbone是有loss function的，但是我们用的模型还多出了两个模块的参数也需要训练，所以用backbone 的loss function显然是不合理的，作者提出了reconstruction loss $L_{Rec}$联合优化整个模型。</p><p>通过$\tilde{J},\tilde{t},\tilde{A}$可以还原出输入的有雾图像：</p><script type="math/tex; mode=display">\tilde{I}=\tilde{J} \odot \tilde{t}+\tilde{A} \odot(1-\tilde{t})</script><p>我们因此定义Loss为：</p><script type="math/tex; mode=display">\mathcal{L}_{R e c}=\|I-\tilde{I}\|_{1}</script><p>​    那么我们的loss其实就整合了$\tilde{J},\tilde{t},\tilde{A}$三种参数，使得三者可以共同训练，其中$I$是ground-truth的输入有雾图像。</p><h3 id="Prior-Loss-Committee："><a href="#Prior-Loss-Committee：" class="headerlink" title="Prior Loss Committee："></a>Prior Loss Committee：</h3><ul><li><strong>Dark Channel Prior(DCP) Loss</strong></li></ul><script type="math/tex; mode=display">\mathcal{L}_{D C P}=E(t, \tilde{t})=t^{T} L t+\lambda(t-\tilde{t})^{T}(t-\tilde{t})</script><p>$t$代表DCP估计的通透率，$\tilde{t}$代表作者提出的网络估计的通透率，$L$是$Laplacian-like$矩阵。这个公式第一项$t^{T}Lt$帮助图像成功抠图，第二项符合暗通道解决方法，$\lambda$是超参数。</p><ul><li><strong>Bright Channel Prior(BCP) Loss</strong></li></ul><p>DCP Loss极大地改善了在真实雾霾图像上的表现，但也带来了一个问题：DCP会使得图像比期望图像更暗一些。因此我们提出了BCP Loss来使生成的图像更明亮，增强对比度：</p><script type="math/tex; mode=display">\mathcal{L}_{B C P}=\|t-\tilde{t}\|_{1}</script><ul><li><strong>CLAHE Reconstruction Loss</strong></li></ul><p>我们已经提出了两个Loss,但是上面两个Loss一个会使得图像变暗，一个让图像变亮，如何才能平衡好两者使得对比度正常？作者提出了CLAHE Reconstruction Loss，首先从真实雾霾图像放入网络中得到$\tilde{t},\tilde{A}$.然后带入利用CLAHE去雾的结果$J_{CLAHE}$和$\tilde{t},\tilde{A}$还原有雾图像，然后对比还原出有雾图像和真实有雾图像的loss，loss越小说明CLAHE还原出的原图和真实无雾结果越接近，此时的对比度，亮度也最真实。</p><script type="math/tex; mode=display">\mathcal{L}_{C L A H E}=\left\|I-I_{C L A H E}\right\|_{1}</script><p><strong>最后我们组合成Prior Loss Committee：</strong></p><script type="math/tex; mode=display">\mathcal{L}_{C L A H E}=\lambda_{d} \mathcal{L}_{D C P}+\lambda_{b} \mathcal{L}_{B C P}+\lambda_{c} \mathcal{L}_{C L A H E}</script><p>三个$\lambda$为trade-off权重。</p><h3 id="Synthetic-to-Real-Generalization"><a href="#Synthetic-to-Real-Generalization" class="headerlink" title="Synthetic-to-Real Generalization"></a>Synthetic-to-Real Generalization</h3><ul><li>LwF(Learning without forgetting) loss</li></ul><p>下面就是如何泛化模型，首先了为避免灾难性遗忘，利用LwF(Learning without forgetting) loss $\mathcal{L}_{l w f}$，帮助我们记住在生成数据集上去雾任务。在利用真实数据更新模型$M$的过程中，同时也要用冻结的原模型$M_0$同时处理真实数据：</p><script type="math/tex; mode=display">\mathcal{L}_{l w f}=\left\|F_{s}-F_{o s}\right\|_{1}+\left\|F_{r}-F_{o r}\right\|_{1}</script><p>其中$F<em>s，F</em>{os}$是在生成数据上，$M,M<em>0$的feature map，$F_r,F</em>{or}$是在真实数据集上$M,M_0$的feature map。</p><ul><li>sky loss</li></ul><p>此外，物理先验通常不能正确处理图像中的天空，从而导致伪影和颜色偏移。为了解决这个问题，我们通过暗通道先验粗略估计输入图像的天空区域，并在微调时尽可能保留天空区域的原始像素值，损失函数如下:</p><script type="math/tex; mode=display">\mathcal{L}_{s k y}=\left\|M_{s k y} \odot\left(J-J_{o}\right)\right\|_{1}</script><p>$J,J<em>0$分别是在$M,M_0$模型下恢复得到的去雾图片，$M</em>{sky}$是天空部分的二分掩膜，这样每处天空在两个模型下的区别就体现出来了，我们希望这种区别小一些，这样就可以让天空处保持原模型的样子。</p><blockquote><p>这里放在一起优化可以更好地改进，我的想法是：既然已经拿到了二分掩膜找到了天空的位置，可以对他们进行分开处理，先让非天空的景物进行恢复，然后再用原模型还原出天空，根据二分掩膜的边界进行拼接。</p></blockquote><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>值得一提，这篇文章算是我读过的paper中十分solid的，主观，客观，间接利用下游方法反过来反应PSD的效果，还有Ablation study证明idea的有效性。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210722182315341.png" srcset="/img/loading.gif" alt="image-20210722182315341"></p><h3 id="主观评价："><a href="#主观评价：" class="headerlink" title="主观评价："></a>主观评价：</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210722182706128.png" srcset="/img/loading.gif" alt="image-20210722182706128"></p><h3 id="无参考图像质量评估-客观量化-："><a href="#无参考图像质量评估-客观量化-：" class="headerlink" title="无参考图像质量评估(客观量化)："></a>无参考图像质量评估(客观量化)：</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210722182637266.png" srcset="/img/loading.gif" alt="image-20210722182637266"></p><h3 id="Ablation-Study"><a href="#Ablation-Study" class="headerlink" title="Ablation Study"></a>Ablation Study</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210722182419097.png" srcset="/img/loading.gif" alt="image-20210722182419097"></p><p>文章做了ablation study说明文章的idea确实是solid的。</p><h3 id="任务驱动评价"><a href="#任务驱动评价" class="headerlink" title="任务驱动评价"></a>任务驱动评价</h3><p>去雾最终是为了下游任务更好的使用，作者提出可以对图片先进行去雾处理，然后放在yolo3中比较mAP的涨点，结果显示PSD效果最好，可以真正利用在下游任务中，提高下游任务精度。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210722183241158.png" srcset="/img/loading.gif" alt="image-20210722183241158"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MTCNN(Multi-task Cascaded Convolutional Networks)介绍</title>
    <link href="/2021/07/19/MTCNN-Multi-task-Cascaded-Convolutional-Networks-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/07/19/MTCNN-Multi-task-Cascaded-Convolutional-Networks-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="MTCNN-Joint-Face-Detection-and-Alignment-using-Multi-task-Cascaded-Convolutional-Networks"><a href="#MTCNN-Joint-Face-Detection-and-Alignment-using-Multi-task-Cascaded-Convolutional-Networks" class="headerlink" title="MTCNN-Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks"></a>MTCNN-Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</h1><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ul><li>MTCNN框架利用级联架构，通过精心设计的深度卷积网络的三个阶段，以从粗略到细致的方式预测人脸和landmark位置。</li><li>提出 a new online hard sample mining strategy，即一种新的困难样本挖掘策略，这种策略帮助MTCNN在实际中获得更好的效果。</li></ul><blockquote><p><a href="https://blog.csdn.net/u010165147/article/details/97105166" target="_blank" rel="noopener">关于物体检测中的困难样本挖掘介绍</a></p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​    级联的人脸检测最早由Viola和Jones两人提出，他们利用Harr特征和AdaBoost训练出了级联分类器，然而，相当多的研究[1,3,4]表明，即使使用更高级的特征和分类器，这种检测器在真实世界的人脸变化更大的场景中应用，效果仍然可能会显著退化。</p><p>​    深度学习方法中利用CNN来检测人脸后来也源源不断的出现，其中Yang[4]的方法由于CNN过于复杂导致训练花费太大，同时它的模型没有考虑到人脸landmark位置和包围盒回归的内在关系。</p><p>​    人脸对齐也引起了广泛的研究兴趣。该领域的研究大致可分为两类，即基于<strong>回归的方法</strong>和模板拟合方法。也有人提出了利用深度卷积神经网络将人脸属性识别作为辅助任务来提高人脸对齐性能。</p><p>​    但是正如上面所说的，无论是人脸检测还是人脸对齐，都没有很好的注意到他们两者的内在关系。Zhang et al[20]利用多任务CNN来提高多视角人脸检测</p><p>的准确率，但检测召回率受到<strong>弱人脸检测器产生的初始检测窗口的限制</strong>。</p><p><strong>这里我们总结一下上述的缺点：</strong></p><ul><li>CNN过于复杂导致训练花费太大</li><li>没有考虑到人脸landmark位置和包围盒回归的内在关系(人脸检测和人脸对齐内在关系没有考虑)</li><li>Multi-task CNN来提高了多视角人脸检测的准确率，但检测召回率受到<strong>弱人脸检测器产生的初始检测窗口的限制</strong>。</li></ul><p><strong>本文提出的CNN分三个阶段：</strong></p><ul><li>P-Net：在第一阶段，它通过一个浅层CNN快速生成候选窗口</li><li>R-Net：它通过一个更复杂的CNN来拒绝大量的非人脸窗口来优化窗口</li><li>O-Net：使用更强大的CNN再次细化结果，并输出5个面部landmark位置(两个眼，一个鼻子，嘴巴的两角)。</li></ul><p>大概流程如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210717190416487.png" srcset="/img/loading.gif" alt="image-20210717190416487"></p><p><strong>文章的贡献：</strong></p><p>(1)提出了一种新的基于级联CNN的联合人脸检测和对齐框架，并精心设计了轻量级CNN架构以实现实时性能。</p><p>(2)提出了一种有效的硬样在线开采方法来提高性能。</p><p>(3)在具有挑战性的基准上进行了大量实验，结果表明，与目前最先进的技术相比，该方法在人脸检测和人脸对齐任务中的性能有显著提高。（当然这篇文章发表于16年,现在的效果排名可以看下图）</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210717191259974.png" srcset="/img/loading.gif" alt="image-20210717191259974"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210717191402835.png" srcset="/img/loading.gif" alt="image-20210717191402835"></p><p>​                                                                                                                (上面两图均来自paper with code)</p><h2 id="Approach-Details"><a href="#Approach-Details" class="headerlink" title="Approach  Details"></a>Approach  Details</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>在进入网络前，先对图片构造图像金字塔，获得不同尺度大小的图片。</p><ol><li><p>首先利用一个全卷积网络(Proposal Net,P-Net)获得待选人脸窗口和包围框的回归向量，使用包围盒回归进行校准，然后通过NMS获得预选框。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718190221536.png" srcset="/img/loading.gif" alt="image-20210718190221536"></p></li><li><p>所有的候选框被送入另一个CNN，称为Refine Network (R-Net)，该网络进一步拒绝大量的假候选框，使用包围盒回归进行校准，并进行NMS。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718190240812.png" srcset="/img/loading.gif" alt="image-20210718190240812"></p></li><li><p>这一阶段与第二阶段相似，但在这一阶段，我们的目标是在更多的监督下识别面部区域。特别是，该网络将输出五个面部landmark的位置。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718190252590.png" srcset="/img/loading.gif" alt="image-20210718190252590"></p></li></ol><h3 id="CNN架构"><a href="#CNN架构" class="headerlink" title="CNN架构"></a>CNN架构</h3><p>作者认为之前也出现过多个CNN框架用于人脸检测，但是都被以下几点所影响了性能和效果：</p><ul><li>卷积中的滤波器缺少多样性，这可能限制了分辨人脸的能力</li><li>与其他多分类目标检测和分类任务相比，人脸检测是一项具有挑战性的二分类任务，因此每层需要的过滤器数量较少，但需要加深网络的深度。</li></ul><p>更改后的效果如下:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210719161612406.png" srcset="/img/loading.gif" alt="image-20210719161612406"></p><p>将PReLU(Parametric Rectified Linear Unit),作为卷积和全连接层后的非线性激活函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210719161751773.png" srcset="/img/loading.gif" alt="image-20210719161751773"></p><p>如果ai=0，那么PReLU退化为ReLU；如果ai是一个很小的固定值(如ai=0.01)，则PReLU退化为Leaky ReLU(LReLU)。 有实验证明，与ReLU相比，LReLU对最终的结果几乎没什么影响。</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210719162726366.png" srcset="/img/loading.gif" alt="image-20210719162726366"></p><p>作者利用三个任务来训练我们的CNN检测器:人脸/非人脸分类、边界框回归和面部landmark定位。</p><ul><li>人脸/非人脸识别</li></ul><script type="math/tex; mode=display">L_{i}^{d e t}=-\left(y_{i}^{d e t} \log \left(p_{i}\right)+\left(1-y_{i}^{d e t}\right)\left(1-\log \left(p_{i}\right)\right)\right)</script><p>$p_i$是网络认为$x_i$为人脸的概率，$y_i^{det}$代表ground-trurh标签，表明$x_i$到底是不是人脸。</p><ul><li>包围盒回归</li></ul><p>对于每个候选窗口，我们预测它与最近的ground-truth(即边界框的左、顶、高度和宽度)之间的偏移量。学习目标被表述为一个回归问题，我们对每个样本使用欧几里德损失。</p><script type="math/tex; mode=display">L_{i}^{b o x}=\left\|\hat{y}_{i}^{b o x}-y_{i}^{b o x}\right\|_{2}^{2}</script><ul><li>面部landmark定位</li></ul><script type="math/tex; mode=display">L_{i}^{\text {landmark }}=\left\|\hat{y}_{i}^{\text {landmark }}-y_{i}^{\text {landmark }}\right\|_{2}^{2}</script><p>作者使用的训练方式是Multi-source training训练，同时不是对于所有样本都要用三种loss一起计算，几个例子，比如一个候选框里没有人脸，那么我们只用是否人脸的检测损失(即式子(1))即可。包围框损失和landmark损失根本不用算，因为此时的问题还是怎么找到人脸，而不是准确的找到人脸并找到landmark位。</p><p>总之来说，将上述三个loss合并在一起后，我们的损失函数就是：</p><script type="math/tex; mode=display">\min \sum_{i=1}^{N} \sum_{j \in\{\text { det }, \text { box,landmark }\}} \alpha_{j} \beta_{i}^{j} L_{i}^{j}</script><p>$N$是训练样本的数量</p><p>在P-Net，R-Net中，$\alpha<em>{det}=1,\alpha</em>{box}=0.5,\alpha_{landmark}=0.5$，也就是此时我们更注重detection，更在意检测到人脸。</p><p>在O-Net中，$\alpha<em>{det}=1,\alpha</em>{box}=0.5,\alpha_{landmark}=1$，也就是此时我们更注重detection，更在意检测到人脸的landmark。</p><p>$\beta$是采样类型指示，当判定为非人脸时，$\beta<em>{box}=0，\beta</em>{landmark}=0,\beta<em>{det}=1$,判定为人脸时全部取1，即$\beta</em>{box}=1，\beta<em>{landmark}=1,\beta</em>{det}=1$.</p><p>L就代表不同的loss值。</p><ul><li><p>online hard sample minning</p><p>不同于传统的困难样本挖掘是在原始分类器经过训练后进行的，本文是在face/non-face分类任务中进行在线硬样本挖掘，这是适应训练过程的。</p><p>具体是在一个batch里面的图片数据，只取分类损失（det loss）的前70%的训练数据backprop回去。</p><p>注意：其余两类损失不做这样的hard sample mining，原因在于回归问题再微小的nudge修正都是有用的，但是二分类就未必了。</p></li></ul><h2 id="Trainning-Data"><a href="#Trainning-Data" class="headerlink" title="Trainning Data"></a>Trainning Data</h2><p>MTCNN的训练集来源于 WILDER FACE 和 CelebA，用前者产生人脸分类任务的图像，后者产生人脸关键位置标注的图像。</p><p>生成的方式是随机取样，根据取样框框与 Ground Truth 人脸框的 IoU 值将其分为4类：</p><p>Negative：IoU&lt;0.3</p><p>Positive：IoU&gt;0.65</p><p>Part：0.4&lt;IoU&lt;0.65</p><p>Landmark：标注了左右眼、鼻、两嘴角共5个位置的横纵坐标的人脸图</p><p>训练集的数据比为 <strong>3:1:1:2 (negatives/ positives/ part face/ landmark face) data.</strong>  </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] B. Yang, J. Yan, Z. Lei, and S. Z. Li, “Aggregate channel features for multi-view face detection,” in IEEE International Joint Conference on Biometrics, 2014, pp. 1-8. </p><p>[2] P. Viola and M. J. Jones, “Robust real-time face detection. International journal of computer vision,” vol. 57, no. 2, pp. 137-154, 2004 </p><p>[3] M. T. Pham, Y. Gao, V. D. D. Hoang, and T. J. Cham, “Fast polygonal integration and its application in extending haar-like features to improve object detection,” in IEEE Conference on Computer Vision and Pattern Recognition, 2010, pp. 942-949. </p><p>[4]S. Yang, P. Luo, C. C. Loy, and X. Tang, “From facial parts responses to<br>face detection: A deep learning approach,” in IEEE International Conference on Computer Vision, 2015, pp. 3676-3684.  </p><p>[5]人脸检测—MTCNN从头到尾的详解 - 丘学文的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/58825924" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58825924</a></p><p>[6]MTCNN人脸检测：三个臭皮匠，顶个诸葛亮 || 5分钟看懂CV顶刊论文 - Uno Whoiam的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/59262113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59262113</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPN(Region Proposal Network)介绍</title>
    <link href="/2021/07/18/RPN-Region-Proposal-Network-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/07/18/RPN-Region-Proposal-Network-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="RPN-Region-Proposal-Network"><a href="#RPN-Region-Proposal-Network" class="headerlink" title="RPN(Region Proposal Network)"></a>RPN(Region Proposal Network)</h1><p>RPN简单来说就是<strong>输入一张图片可以得到很多待选框</strong>的一个网络，再详细一点就是：</p><p>RPN的本质是对所有候选框进行判定，前景概率为多少，如果是前景那么其候选框所需要的修正因子应该是多少。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718150049697.png" srcset="/img/loading.gif" alt="image-20210718150049697"></p><p>​    </p><h2 id="首先经过backbone提取特征："><a href="#首先经过backbone提取特征：" class="headerlink" title="首先经过backbone提取特征："></a>首先经过backbone提取特征：</h2><p>​    首先拿到一张原图时，我们要先利用backbone获得feature map，可以看到上图中右部从feature map中获得了一个256维的向量，这个256来自于哪儿里呢？其实就是feature map的深度，而我们的backbone是ZF时，提取出的feature map深度就是256的。官方也提到可以用VGG16来当作backbone，这样得到的feature map深度就是512的了。当然上图举的例子是ZF做backbone时的情况。</p><p>​    同时也要注意获得256维向量是通过滑动窗口获得的，即3*3的滑动窗口扫面feature map的每一处，padding 1个，步长也是1, 就正好覆盖了feature map。</p><h2 id="找出anchor-box："><a href="#找出anchor-box：" class="headerlink" title="找出anchor box："></a>找出anchor box：</h2><p>​    feature map上的每一个点都可以映射回原图，映射方法如下图，首先计算$x$方向上的$stride_x$，$y$方向上的$stride_y$，这两个是怎么计算的呢？ 举个例子，比如输入的图像是500*600的，经过backbone得到的feature map大小是100*150,那么$stride_x = 500/100 = 5,stride_y =600/150=4$。 此时我们查看feature map上每个点$(a,b)$映射回原图的坐标就是$(a<em>stride_x,b</em>stride_y)$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718151219049.png" srcset="/img/loading.gif" alt="image-20210718151219049"></p><p>找到原图坐标后，在原图出画出k个anchor box: </p><p>作者给出了九种的anchor box：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">[[ <span class="hljs-number">-84.</span>  <span class="hljs-number">-40.</span>   <span class="hljs-number">99.</span>   <span class="hljs-number">55.</span>]<br> [<span class="hljs-number">-176.</span>  <span class="hljs-number">-88.</span>  <span class="hljs-number">191.</span>  <span class="hljs-number">103.</span>]<br> [<span class="hljs-number">-360.</span> <span class="hljs-number">-184.</span>  <span class="hljs-number">375.</span>  <span class="hljs-number">199.</span>]<br> [ <span class="hljs-number">-56.</span>  <span class="hljs-number">-56.</span>   <span class="hljs-number">71.</span>   <span class="hljs-number">71.</span>]<br> [<span class="hljs-number">-120.</span> <span class="hljs-number">-120.</span>  <span class="hljs-number">135.</span>  <span class="hljs-number">135.</span>]<br> [<span class="hljs-number">-248.</span> <span class="hljs-number">-248.</span>  <span class="hljs-number">263.</span>  <span class="hljs-number">263.</span>]<br> [ <span class="hljs-number">-36.</span>  <span class="hljs-number">-80.</span>   <span class="hljs-number">51.</span>   <span class="hljs-number">95.</span>]<br> [ <span class="hljs-number">-80.</span> <span class="hljs-number">-168.</span>   <span class="hljs-number">95.</span>  <span class="hljs-number">183.</span>]<br> [<span class="hljs-number">-168.</span> <span class="hljs-number">-344.</span>  <span class="hljs-number">183.</span>  <span class="hljs-number">359.</span>]]<br></code></pre></div></td></tr></table></figure><p>其中每行的4个值 $(x_1,y_1,x_2,y_2) $表矩形左上和右下角点坐标。9个矩形共有3种形状，长宽比为大约为$1:2, 1:1, 2:1$三种，实际上通过anchors就引入了检测中常用到的多尺度方法。在代码中，作者把任意大小的输入图像reshape成800x600。然后再用九个anchor box来包围，其实就几乎覆盖到了各种各样尺度的目标。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718155228975.png" srcset="/img/loading.gif" alt="image-20210718155228975"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718152947759.png" srcset="/img/loading.gif" alt="image-20210718152947759" style="zoom:67%;" /></p><p>到此Anchor box就找到了</p><h2 id="调整anchor-box："><a href="#调整anchor-box：" class="headerlink" title="调整anchor box："></a>调整anchor box：</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718153802828.png" srcset="/img/loading.gif" alt="image-20210718153802828"></p><p>除了刚才介绍的结构，这里还一个$2k\  score$和$4k\ coordinates$。 这两个就是对anchor box进行调整的。对于feature map的每一个点都会在原图生成$k$个anchor box。</p><ul><li>每个anchor box都有2个概率，即是背景(无目标物)的概率和是前景(有目标物)的概率, 所以每个点有$2k$个score</li><li>每个anchor box都有4个回归参数，即是包围框的左上角点和包围框的长宽，所以每个点有$4k$个coordinates，帮助我们调整anchor box的位置与大小。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718154621051.png" srcset="/img/loading.gif" alt="image-20210718154621051"></p><p>请注意RPN网络找的目标可以有多个，因此我们只区分是前景概率和是背景概率，我们在RPN中并不关心这个到底是前景中的哪儿一个目标。举个例子，想获得人和车的预选包围框，车和人都算是前景。</p><h2 id="感受野问题："><a href="#感受野问题：" class="headerlink" title="感受野问题："></a>感受野问题：</h2><ul><li>对于ZF网络作为Backbone，他的感受野是171。</li><li>对于VGG网络作为Backbone，他的感受野是228。</li></ul><p>那么这就有一个问题，我们在feature map中的每一个点要映射回原图，而你的感受野只有171*171这么大, 为什么anchor box要有256*256,甚至是512*512这么大的？</p><p>作者给出的看法是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718155328374.png" srcset="/img/loading.gif" alt="image-20210718155328374"></p><p>即感受野小于实际物体的包围框是有可能的，因为我们人也可以看到物体的一部分就大概猜出物体的整体大小。实际中，这个方法也确实是work的。</p><h2 id="减少候选框"><a href="#减少候选框" class="headerlink" title="减少候选框:"></a>减少候选框:</h2><ol><li>对于1张1000*600*3的图像，大约有60*40*9个<strong>anchor</strong></li><li>忽略跨越边界的anchor，大约剩下6k个<strong>anchor</strong></li><li>RPN生成的<strong>候选框</strong>存在大量的重叠，基于<strong>候选框</strong>的得分，采用非极大值抑制，IoU设置尾0.7，最后只剩2k个<strong>候选框</strong>。</li></ol><p>请注意上面的anchor和候选框不是同一个东西，anchor经过4k个回归参数的调整后才叫候选框。</p><h2 id="RPN训练方式："><a href="#RPN训练方式：" class="headerlink" title="RPN训练方式："></a>RPN训练方式：</h2><p>RPN每次从待选anchor中抽取256个anchors，每次让正负样本比为1：1。如果正样本少于128，假设为x，那么我们就让负样本为256-x。</p><p>这里是怎么定义正负样本的呢？</p><p>正样本： 我们的anchor与ground-truth box最大的IoU&gt;0.7,那么就可以认为是正样本，如果最大的都不大于0.7，那么我们就把IoU最大的Anchor作为正样本即可。</p><p>负样本： 我们的anchor与所有的ground-truth box的IoU&lt;0.3,那么就可以认为是负样本。</p><p>正负样本之外的我们就会丢弃掉。</p><h3 id="loss函数："><a href="#loss函数：" class="headerlink" title="loss函数："></a>loss函数：</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718165644649.png" srcset="/img/loading.gif" alt="image-20210718165644649"></p><h3 id="分类损失函数："><a href="#分类损失函数：" class="headerlink" title="分类损失函数："></a>分类损失函数：</h3><p>首先说分类损失，原文给的是<code>Softmax Cross Entorpy Loss</code>来计算的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718173721552.png" srcset="/img/loading.gif" alt="image-20210718173721552"></p><p>1代表是前景，0代表是背景，那么:</p><script type="math/tex; mode=display">L_{cls}=-log(p_i)</script><p>比如第一个anchor实际是前景，而预测前景概率是0.9，那么$L = -log(0.9)$，第二个是背景，而背景概率是0.2，那么$L = -log(0.2)$。</p><p>在pytorch官方实现的方式是用二分类的交叉熵损失<code>Binart Cross Entropy</code>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718180649938.png" srcset="/img/loading.gif" alt="image-20210718180649938"></p><p>也就是说这里只需要预测K个值即可。</p><h3 id="边界框损失函数："><a href="#边界框损失函数：" class="headerlink" title="边界框损失函数："></a>边界框损失函数：</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718181104344.png" srcset="/img/loading.gif" alt="image-20210718181104344"></p><h2 id="Faster-RCNN整体是怎么训练的？"><a href="#Faster-RCNN整体是怎么训练的？" class="headerlink" title="Faster-RCNN整体是怎么训练的？"></a>Faster-RCNN整体是怎么训练的？</h2><p>我们知道RPN的提出让Faster R-CNN真正做到了end-to-end，使得网络之间关系更加密切，效果更好。</p><p>现在的Faster R-CNN直接采用RPN Loss+Fast R-CNN Loss来做。</p><p>但是原文中采用分别训练RPN和Fast R-CNN Loss：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210718182153148.png" srcset="/img/loading.gif" alt="image-20210718182153148"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch10-策略优化进阶</title>
    <link href="/2021/06/07/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch10-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/06/07/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch10-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="策略优化进阶——上"><a href="#策略优化进阶——上" class="headerlink" title="策略优化进阶——上"></a>策略优化进阶——上</h2><p>本次的内容：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602155707220.png" srcset="/img/loading.gif" alt=""></p><p>首先还是先回顾一下Value-based RL和Policy-based RL区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602160051163.png" srcset="/img/loading.gif" alt="image-20210602160051163"></p><p>策略目标和策略梯度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602204803475.png" srcset="/img/loading.gif" alt="image-20210602204803475"></p><p>策略梯度(Policy gradient)有下面几种常见的算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602210030754.png" srcset="/img/loading.gif" alt="image-20210602210030754"></p><p>这里要说一下这四个优化方法的关系：</p><p>首先是REINFORCE使用的是$G_t$,是由MC方法获得的，他其实就是Q Actor-Critic方法中$Q^w$的采样。Advantage Actor-Critic中为$A^w$,即把$Q^w$减去了一个baseline，这么做是为了减少方差。TD Acrot-critic中直接使用TD target作为reward function。</p><p>critic会用policy evaluation来估计$Q^\pi(s,a)$,$A^\pi(s,a)$,$V^\pi(s)$</p><p>下面介绍当下最历害/前沿的六种强化学习算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602211059323.png" srcset="/img/loading.gif" alt="image-20210602211059323"></p><h3 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h3><p>在介绍这些算法前，首先我们要了解基于Policy Gradient的缺点：</p><ul><li>首先是sample effiency问题：当前优化的policy不仅要被优化，也要用这个policy来采取数据，所以采样效率其实很低。</li><li>训练过程不稳定：强化学习采集到的数据一般都不是iid的，有很强的关联。比如我们的step size不是那么正确，导致的结果是：step too far-&gt;bad policy-&gt;bad data,也就是坏的策略会导致坏的数据，坏的数据会使得策略变得更差，导致我们很难从一个错误的policy中恢复回来。</li></ul><p>对应于这两点，解决方法是：</p><ul><li><p>怎么让训练更稳定：利用Trust region和natual policy gradient</p></li><li><p>怎么让sample高效一些：用另一个policy去产生策略，即off-policy方法，比如在TPRO中就用到了Importance sampling</p></li></ul><p><strong>Natural Policy gradient的概念：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602212829498.png" srcset="/img/loading.gif" alt="image-20210602212829498"></p><p>原来我们考虑的policy gradient就是在一个欧几里得空间找一个d，这个d方向可以使得$J(\theta)$变化最快。</p><p>但是这里有个问题就是，这个d对采取怎样参数化的形式很敏感。</p><p>所以这里提出了一种新的方法：通过分布空间(policy output)来进行梯度更新</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602213334424.png" srcset="/img/loading.gif" alt="image-20210602213334424"></p><p>利用KL散度控制梯度变化前后的输出的分布的差异为一个定值c，然后在此基础上在参数空间中找一个d使得J函数变换最大。</p><p>这里补充一下KL散度的概念：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602213729987.png" srcset="/img/loading.gif" alt="image-20210602213729987"></p><p>上面说到，我们现在考虑得更新方式为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602213820832.png" srcset="/img/loading.gif" alt="image-20210602213820832"></p><p>这种constraint的最优化可以用拉格朗日乘子来解决，如上图。然后把KL[]这个函数用泰勒展开，得到上图中的式子。</p><p>然后我们对上面那个优化函数求导即可，就可以得到natual policy gradient：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602214158029.png" srcset="/img/loading.gif" alt="image-20210602214158029"></p><p>因此我们现在策略的更新方式为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602214353311.png" srcset="/img/loading.gif" alt="image-20210602214353311"></p><p>和原来相比就是多了一个$F^{-1}$,即Fisher information matrix。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602214446265.png" srcset="/img/loading.gif" alt="image-20210602214446265"></p><p>这里的F就是KL散度的二阶导数，我们可以用下式进行计算。</p><p>$F=E<em>{ \left.\pi</em>{\theta}(s, a}\right]}\left[\nabla \log \pi<em>{\theta}(s, a) \nabla \log \pi</em>{\theta}(s, a)^{T}\right]$</p><p>F意味着策略的曲率与模型参数$\theta$的相关性。</p><p>所以Natural policy gradient的出现使得我们让策略优化可以与模型参数空间的选择无关。</p><p> <strong>Importance Sampling方法：</strong></p><p>另外一个方面是我们想把policy gradient方法改成off-policy的方法，我们知道off-policy learning自身有很多好处，我们可以用另一种算法在环境里面去探索(explore)，采集到很多激进的数据，这样来喂给优化的策略。</p><p>这里采取方法是Importance sampling(重要性采样)：Importance sampling在采样过程里面也是用的比较广泛的。</p><p>它的简单概念是：我们现在假设要去估计一个函数的期望，比如说要估算f(x)这个值，x是从p分布里面采样出来的；有时候我们不知道怎么去p分布里面采样，比如说p分布的形式非常奇怪，没法去直接采样，我们只能从如uniform distribution或者Gaussian distribution里面采样，那么我们怎么去根据一个不知道怎么采样的p估计这个f(x)参数呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602220143126.png" srcset="/img/loading.gif" alt="image-20210602220143126"></p><p>通过简单的变换，f(x)针对p的期望，变换成另一种期望的形式，这样x就可以从另外一个分布里面采样了。采样很多的x后再取平均。</p><p>同样的原理，我们可以把策略优化的目标函数也改写一下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602222400585.png" srcset="/img/loading.gif" alt="image-20210602222400585"></p><p>α是优化的策略里面产生的，假设我们现在优化函数没法对它采样，就可以从另外一个策略函数里面对它采样，比如从 $\hat{\pi}$里面去采样action，通过importance sampling去乘以ratio来近似。这里变化就是我们可以用behavior policy $ \hat{\pi}$ 去产生实际的轨迹。</p><p><strong>Increasing the Robustness(鲁棒性) with Trust Regions(信赖域)：</strong></p><p>​    所以这样就可以把策略函数改写成基于之前另外一个策略的一个优化函数，另外一个策略最简单的办法是可以用之前的这个策略，在Deep Q learning中有两个策略函数，behavior policy是用的之前的策略函数，因为之前的策略函数产生的数据我们也可以放到这个replay buffer里面，所以就可以重用之前采到的数据。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602225000736.png" srcset="/img/loading.gif" alt="image-20210602225000736"></p><p>这里有个问题需要注意一下，$\frac{\pi_\theta}{\hat{\pi}}$可能非常大，也就是说上下两个策略差距比较大，同样我们可以借用上面的方法，用KL散度来限制分布的差异，限制两个策略的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602225604165.png" srcset="/img/loading.gif" alt="image-20210602225604165"></p><p>一个形象的例子是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602225626137.png" srcset="/img/loading.gif" alt="image-20210602225626137"></p><p>​    每次优化过程只能在这个圆圈里面（安全的区域）选择一个方向，这样就可以使得这个训练尽可能的稳定，这样也使得它的概率输出和上一步的概率输出的步数尽可能的小，随着训练过程也可以使得trust region缩的越来越小，更新也会变得越来越小，整个过程也会变得越来越稳定。</p><p><strong>Trust Region Optimization:</strong></p><p>对Trust Region Optimization进行进一步的推导，对价值函数做泰勒展开，展开如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602231324132.png" srcset="/img/loading.gif" alt="image-20210602231324132"></p><p>此时的目标变为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602231824462.png" srcset="/img/loading.gif" alt="image-20210602231824462"></p><p>这个式子是有显示解的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602232211516.png" srcset="/img/loading.gif" alt="image-20210602232211516">    </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602232311127.png" srcset="/img/loading.gif" alt="image-20210602232311127"></p><p>我们会发现他和Natural gradient(自然梯度）的形式很一致。</p><p>我们发现这个natural gradient没有学习率，而是用KL散度之间的差别$\delta$来代替学习率。δ是直接在限制更新之后的policy和之前的policy的近似程度 ，也就是说做了这个推导过后δ和learning rate直接联系起来了。这也是TRPO推导非常好的地方，不需要设定step-size，只需要指定trust region的大小，即更新后的策略和之前的策略输出距离多少，然后用距离去推出step-size。这样我们可以把trust region设的很小，这样就使得更新非常稳定。</p><p>到现在为止，我们推导的就是在TRPO中的Natural policy gradient：</p><ul><li>TRPO是在natural policy gradient的基础上加了importance sampling。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602232716810.png" srcset="/img/loading.gif" alt="image-20210602232716810"></p><p>由于我们提到了H的逆这个问题，求逆复杂度是$O(n^3)$的，十分慢，因此我们常用<strong>共轭梯度法</strong>来解绝这个问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602233256646.png" srcset="/img/loading.gif" alt="image-20210602233256646"></p><p>所以完整的方法就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602233343692.png" srcset="/img/loading.gif" alt="image-20210602233343692"></p><p>TPRO中通过一些推导(具体可看论文的附录)，证明了一个guaranteed monotonic improvement，即：</p><p>随着迭代增加，我们的J函数是单调的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602233726968.png" srcset="/img/loading.gif" alt="image-20210602233726968"></p><p><strong>TPRO的一些问题：</strong></p><ul><li>计算量非常大。虽然用了conjugate gradient method(共轭梯度法），但是对于每一次迭代，policy都要算H逆。</li><li>在近似H的时候，H本身是个期望，但是我们在近似这个期望的时候是用样本近似，需要很多样本。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602234233708.png" srcset="/img/loading.gif" alt="image-20210602234233708"></p><ul><li>TRPO在某些游戏上并不会比DQN更好。</li></ul><h3 id="ACKTR"><a href="#ACKTR" class="headerlink" title="ACKTR"></a>ACKTR</h3><p><strong>paper:</strong> Y.Wu, et al. “Scalable trust-region method for deep reinforcement learning using Kronecker-factored approximation”. NIPS 2017.</p><p>​    ACKTR的核心思想是想提升TRPO的计算效率。在TRPO里面有一步是算Fisher information matrix(FIM),即$H^{-1}$，在矩阵维度很大的时候求逆计算量非常大。因此，ACKTR提出用Kronecker-factored approximation curvature(K-FAC) 方法来加速求逆。</p><h3 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h3><p>PPO可以看作是TRPO的简单版本：</p><p>首先回顾TRPO的loss function：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602235520908.png" srcset="/img/loading.gif" alt="image-20210602235520908"></p><p>我们采用这种方法区合并约束：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602235546420.png" srcset="/img/loading.gif" alt="image-20210602235546420"></p><p>这样在优化时，一方面就考虑到了让前面一部分变大，另一方面让后面一部分变小。</p><p>我们会发现有个参数$\beta$在衡量他们二者，这个$\beta$可以做到自适应，如下的算法流程图：</p><p>当我们的KL散度过大，说明策略更新过快，变化过大，那么我们就变大$\beta$,让优化时更注重KL散度。反之亦然。</p><p>这个方法叫做PPO with Adaptive KL Penalty</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210602235859119.png" srcset="/img/loading.gif" alt="image-20210602235859119"></p><p>​    因为PPO本身优化的过程是利用first-order optimization(SGD，一阶优化) 优化的，所以优化效率比二阶的TRPO快很多，因为PPO的算法过程中并没有去计算KL散度或者Fisher information matrix。</p><p>​    除了上面adaptive beta的方法，PPO提供了第二种方式是把objective function自身带了clipping，所以它提出了更复杂一些的形式来处理本身loss的优化情况。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210603002012967.png" srcset="/img/loading.gif" alt="image-20210603002012967"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210603002250843.png" srcset="/img/loading.gif" alt="image-20210603002250843"></p><p><strong>这就是PPO with Clipped Objective</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210603002450181.png" srcset="/img/loading.gif" alt="image-20210603002450181"></p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch9-策略优化基础-下</title>
    <link href="/2021/06/07/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch9-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-%E4%B8%8B/"/>
    <url>/2021/06/07/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch9-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="策略优化基础——下"><a href="#策略优化基础——下" class="headerlink" title="策略优化基础——下"></a>策略优化基础——下</h2><h3 id="Score-Function-Gradient-Estimator"><a href="#Score-Function-Gradient-Estimator" class="headerlink" title="Score Function Gradient Estimator"></a>Score Function Gradient Estimator</h3><p>我们考虑写一个更广义的策略函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526171539941.png" srcset="/img/loading.gif" alt="image-20210526171539941"></p><p>上面那个推导过程不太详细，下面给出具体的推导步骤：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526182549786.png" srcset="/img/loading.gif" alt="image-20210526182549786"></p><p>这个梯度可以理解为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526204806093.png" srcset="/img/loading.gif" alt="image-20210526204806093"></p><p>p(x)为采样得到的值，他们梯度就是上图蓝色箭头，而f(x)代表给这些梯度一个权重。</p><p>比如当权重分布如下时：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526204957634.png" srcset="/img/loading.gif" alt="image-20210526204957634"></p><p>此时这个p(x)分布会向权值大的哪个方向平移，最后移动至下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526205123627.png" srcset="/img/loading.gif" alt="image-20210526205123627"></p><p>可以看到概率函数p(x)的形状变了，整个形状变得往能得到更高分数的区域走；所以score function gradient estimator就可以通过这样一个几何解释来理解。</p><p><strong>Score Function Gradient Estimator与Maximum Likelihood estimator(极大似然估计)的对比：</strong></p><p>score Function Gradient Estimator多了reward function，可以看成加权后的极大似然估计，也就是说这种policy gradient estimator鼓励函数向获得奖励更多的地方移动。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526212119365.png" srcset="/img/loading.gif" alt="image-20210526212119365"></p><p>而极大似然估计就是单纯的优化一个参数，这个参数是从训练数据中学到的，他学到的是训练数据的分布。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526213505031.png" srcset="/img/loading.gif" alt="image-20210526213505031"></p><p>​    在优化的过程中，score Function Gradient Estimator这种policy gradient estimator方法是：鼓励策略进入到得到奖励尽可能多的区域里面。supervised learning是直接有个标签去优化函数；策略函数是优化策略概率函数使得能够尽可能进入到能够采样产生更高奖励的区域里面。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526214253947.png" srcset="/img/loading.gif" alt="image-20210526214253947"></p><p>更形象的理解就是：</p><p>policy gradient方法希望优化概率分布函数$P$的参数$\theta$，从而使得函数更靠近获得奖励高的区域，如下图，我们其实就是希望P函数移动到靠近红色的区域上，这样我们采样时得到的奖励的期望也会更多。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526214434895.png" srcset="/img/loading.gif" alt="image-20210526214434895"></p><h3 id="Large-Variance-of-Policy-Gradient"><a href="#Large-Variance-of-Policy-Gradient" class="headerlink" title="Large Variance of Policy Gradient"></a>Large Variance of Policy Gradient</h3><p>现在policy gradient是采样产生的:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526214922685.png" srcset="/img/loading.gif" alt="image-20210526214922685"></p><p>由于我们用的MC方法，即基于抽样得到的gradient。但是方差（variance)是非常大的，导致训练不稳定，因此我们现在的新的目标就是减少方差。</p><p>有两种办法减少Policy Gradient的方差：</p><ul><li><strong>方法一：Use temporal causality利用时序上的因果关系减少variance</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526221946506.png" srcset="/img/loading.gif" alt="image-20210526221946506"></p><p>原来这个式子有一个问题就是，这个式子没有因果关系，他先计算了路径上的log likelihood，然后再把路径上每个点的奖励进行加和。</p><p>不如写成如下形式：我们每走一步，只计算当前一步所获得奖励。</p><p>即写为下式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526222704781.png" srcset="/img/loading.gif" alt="image-20210526222704781"></p><p>那我们的原来的梯度就可以改写成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526222359202.png" srcset="/img/loading.gif" alt="image-20210526222359202"></p><p>进行一点推到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526223018729.png" srcset="/img/loading.gif" alt="image-20210526223018729"></p><p>最后的$G<em>t=\sum</em>{t^{\prime}=t}^{T-1} r_{t^{\prime}}$</p><p>说一些推到中的细节：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526225121955.png" srcset="/img/loading.gif" alt="image-20210526225121955" style="zoom:67%;" /></p><p>这一步的转化就是和算贡献一样：前面时刻t的每一个score function会对后面时刻的$r_{t’}$做贡献,其中$t’&gt;=t$</p><p>这个其实就是REINFORCE算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526225807209.png" srcset="/img/loading.gif" alt="image-20210526225807209"></p><ul><li><strong>方法二：引入baseline</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210526230654519.png" srcset="/img/loading.gif" alt="image-20210526230654519"></p><p>这个方法可以不改变期望(保证了仍然是无偏估计)的同时还降低方差：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527151936972.png" srcset="/img/loading.gif" alt="image-20210527151936972"></p><p>期望为0的证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527160506754.png" srcset="/img/loading.gif" alt="image-20210527160506754"></p><p><strong>Vanilla Policy Gradient Algorithm with Baseline：</strong></p><p>有时候我们会把baseline用一种参数去拟合，写为$b_w(s)$<br>使得baseline本身带有参数w，在优化过程中同时优化 $\theta$和$w$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527162300142.png" srcset="/img/loading.gif" alt="image-20210527162300142"></p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">对于每次迭代:iter = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,....：<br>用策略\pi_theta收集m条轨迹<br>对于每个轨迹\tau的每一步t：<br>计算G_t^(i)=r_&#123;t&#125;+r_&#123;t+<span class="hljs-number">1</span>&#125;+...r_&#123;T<span class="hljs-number">-1</span>&#125;<br>计算advantage estimate：A_t^(i) = G_t^(i)-b(s_t)<br>通过更新w来更新b(s_t)，即最小化(b(s_t)-G_t^(i))^<span class="hljs-number">2</span>：<br>计算策略梯度g<br>利用SGD/Adam更新参数\theta<br><span class="hljs-keyword">return</span> /theta，baseline(即b(s))<br></code></pre></div></td></tr></table></figure><h3 id="Actor-critic"><a href="#Actor-critic" class="headerlink" title="Actor-critic"></a>Actor-critic</h3><p>我们在上一小节已经提出了Policy gradient：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527165838088.png" srcset="/img/loading.gif" alt="image-20210527165838088"></p><p>我们会用一种新的方法来减少梯度，这种方法就是利用cirtic（评价者）</p><p>首先$G_t$在前面提到过是在MC 梯度下降中抽样而来，它本质上是对Q函数无偏的估计：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527170057607.png" srcset="/img/loading.gif" alt="image-20210527170057607"></p><p>我们这里利用critic去估计Q函数从而替换掉$G_t$:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527170511331.png" srcset="/img/loading.gif" alt="image-20210527170511331"></p><p>那么这就是Actor-Critic Policy Gradient方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527170640401.png" srcset="/img/loading.gif" alt="image-20210527170640401"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527172030517.png" srcset="/img/loading.gif" alt="image-20210527172030517"></p><p>Actor表演者：它就是利用策略函数生成动作，因此成为actor.</p><p>Critic评价者：评价这个动作的价值，类似于Q函数。</p><p>这个critic和policy evaluation的作用很类似：评价当前策略$\pi_\theta$的参数$\theta$到底好不好。</p><p>计算方法有以下三种：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527172611868.png" srcset="/img/loading.gif" alt="image-20210527172611868"></p><p>这样我们就得到了QAC算法：</p><p>假设critic是一个线性的价值函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527174245070.png" srcset="/img/loading.gif" alt="image-20210527174245070"></p><p>QAC算法流程图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527174404599.png" srcset="/img/loading.gif" alt="image-20210527174404599"></p><p>这里利用TD error来更新w，由于我们假设了critic的$Q_w$由$\psi$的线性组合得到，那么$Q_w$的梯度就是$\psi$ ，因此更新w的式子为：$\mathbf{w} \leftarrow \mathbf{w}+\beta \delta \psi(s, a)$</p><p>而$\theta$得更新就是policy gradient更新即可。</p><p>理论上我们需要用两个不同的函数来拟合：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527175135623.png" srcset="/img/loading.gif" alt="image-20210527175135623"></p><p>实际中我们可以让这两个函数共享网络结构，节省计算：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527175209102.png" srcset="/img/loading.gif" alt="image-20210527175209102"></p><p><strong>Actor-critic这种方法同样可以用baseline来减少方差：</strong></p><p>首先回顾一下Q函数和V函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527175630079.png" srcset="/img/loading.gif" alt="image-20210527175630079"></p><p>我们之前定义的baseline是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527175839421.png" srcset="/img/loading.gif" alt="image-20210527175839421"></p><p>因为$G<em>t=r_t+r</em>{t+1}+…r_{T-1}$</p><p>因此:$b(s_t)= E(G_t)$</p><p>而我们之前提到过用Q函数代替$G_t$,那么$b(s_t)=E(Q(.))=V^{\pi,\gamma}(s)$</p><p><strong>policy gradient的一个非常好的应用：解决 不可微分的计算成分</strong></p><p>比如一个网络的得传播是由多段组成的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527182857599.png" srcset="/img/loading.gif" alt="image-20210527182857599"></p><p>中间可能有一段是不可维分的，那么对于这样一部分会使得我们在bp时无法传播到前半段。</p><p>解决方法有两个：</p><ul><li><p>方法一：用Reparameterization trick(VAE变分编码器中使用的trick)的方法。（不懂，以后再说QAQ）</p></li><li><p>方法二：用采样的方法，中间不可微的阶段可以用样本来替代。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527183030226.png" srcset="/img/loading.gif" alt="image-20210527183030226"></p><p>基于policy gradient的算法有很多：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210527230126690.png" srcset="/img/loading.gif" alt="image-20210527230126690"></p><p>RL的两个学派：</p><p><strong>1.Value-based RL:利用dynamic programming和bootstrapping的方法去优化它的价值函数，得到价值函数后，从Q函数里面采取行为。</strong><br>代表算法：Deep Q-learning and its variant<br>代表人物：Richard Sutton (no more than 20 pages on PG out of the 500-page textbook), David Silver, from DeepMind<br>从控制论背景出发<br><strong>2.Policy-based RL:只需要少量样本，就可以拟合出策略函数。</strong><br>代表算法： PG, and its variants TRPO, PPO, and others<br>代表人物：Pieter Abbeel, Sergey Levine, John<br>Schulman, from OpenAI, Berkelely<br>从机器人，机器学习背景出发</p><p>DeepMind和OpenAI两大RL流派区别：<br><a href="https://www.zhihu.com/question/316626294/answer/627373838" target="_blank" rel="noopener">https://www.zhihu.com/question/316626294/answer/627373838</a><br>殊途同归，都往Actor-critic发展。<br>DeepMind主要研究游戏领域，主要跑仿真对样本本身不挑剔；OpenAI研究机器人，更注重sample effectioncy（有效性），减少采样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习中的KernelModel/LinearModel总结</title>
    <link href="/2021/05/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84KernelModel-LinearModel%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84KernelModel-LinearModel%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习中的KernelModel-LinearModel总结"><a href="#机器学习中的KernelModel-LinearModel总结" class="headerlink" title="机器学习中的KernelModel/LinearModel总结"></a>机器学习中的KernelModel/LinearModel总结</h1><p>​    对学到的一些KernelModel/LinearModel做了一下梳理，便于以后忘记时能知道他们提出的动机和与其他模型的联系.</p><p><img src="https://i.loli.net/2021/05/25/ptN3TUMuwyDEeqa.png" srcset="/img/loading.gif" alt="Kernel Models .png"></p><p>PDF文件链接：<a href="https://drive.google.com/file/d/1yMQHTWnqxit2OTr_O1DzvRMnBCzp1s3t/view?usp=sharing" target="_blank" rel="noopener">谷歌云盘</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch8-策略优化基础-上</title>
    <link href="/2021/05/22/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch8-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-%E4%B8%8A/"/>
    <url>/2021/05/22/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch8-%E7%AD%96%E7%95%A5%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="策略优化基础——上"><a href="#策略优化基础——上" class="headerlink" title="策略优化基础——上"></a>策略优化基础——上</h1><h3 id="Value-based-RL-vs-Policy-based-RL"><a href="#Value-based-RL-vs-Policy-based-RL" class="headerlink" title="Value-based RL vs. Policy-based RL"></a>Value-based RL vs. Policy-based RL</h3><p>Value-based RL vs. Policy-based RL:</p><ul><li>Value-based RL</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522163333480.png" srcset="/img/loading.gif" alt="image-20210522163333480"></p><p>Value-based Policy是默认策略是determinsitic的，也就是说我们的策略选择并且只选择能使得$Q(a,s_t)$价值函数最大的那个action.</p><ul><li>Policy-based RL</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522163701352.png" srcset="/img/loading.gif" alt="image-20210522163701352"></p><p>基于策略的强化学习不同于基于价值的强化学习，他的策略选择是通过$\pi_\theta(a|s)$这个动作概率分布来采样决定当前的动作是什么，其中$\theta$是一个要通过数据学习的参数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522164441367.png" srcset="/img/loading.gif" alt="image-20210522164441367"></p><p>Policy-based RL 的好处：</p><ul><li><p>不管数据有多么的少，我们还是可以训练出一个策略函数，虽然可能并不是很好，当数据变多，效果就会变好。而在Value-Based RL中价值函数的估计是需要整个的table，这个对数据的要求远大于Policy-based RL 。</p></li><li><p>Policy gradient在高维空间中更有效。</p></li><li>Policy gradient学到的是一个概率分布。</li></ul><p>缺点：</p><ul><li>可能会收敛到局部最优解</li><li>计算一个策略时，他的方差很大，每次训练得出的效果差别较大。</li></ul><p>下面先来介绍一下策略：</p><p>策略有两种类型，一种是Deterministic的，另一种为stochastic的。</p><ul><li>deterministic：给定一个状态，策略返回一个确定的action。</li><li>stochastic： 给定一个状态，策略返回一个动作的概率分布（比如40%往左走，60%向右走）。</li></ul><p>比如在石头剪刀布中: 一个确定性的策略很多容易被打败，而用概率分布比如每个动作各33%的概率出手，就会好很多。</p><p>再举一个例子说明stochastic policy的好处，如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522170743542.png" srcset="/img/loading.gif" alt="image-20210522170743542"></p><p>比如这样的一个游戏，深色方块是一个魔幻的地方，进去的玩家不知道这是左边的深色格子还是右边的深色格子，换句话说在这两个格子时环境的状态一摸一样，因此在deterministic policy下我们会得到一摸一样且唯一的action。 那么我们经过学习后就会发现，在白色区域时，下面的格子是骷髅头，那么就会往边上走，而在金币处会向下走，在深色格子处无论向哪儿边走都会导致一边被困住，如下图。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522175431495.png" srcset="/img/loading.gif" alt="image-20210522175431495"></p><p>而如果利用stochastic policy：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522175420245.png" srcset="/img/loading.gif" alt="image-20210522175420245"></p><h3 id="策略函数的优化"><a href="#策略函数的优化" class="headerlink" title="策略函数的优化"></a>策略函数的优化</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522180855605.png" srcset="/img/loading.gif" alt="image-20210522180855605"></p><p>我们优化的目标是优化策略参数$\theta$</p><p>首先的问题是怎么衡量$\pi_\theta$的好坏呢？</p><ul><li>如果在一个<strong>有终止的环境(episodic environment)</strong>中，我们可以用开始状态$s_1$的价值的期望来表示：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522181302812.png" srcset="/img/loading.gif" alt="image-20210522181302812"></p><ul><li>如果是在一个<strong>连续无终止的环境下(continuing environment)</strong>，我们可以用状态的平均价值：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522181450742.png" srcset="/img/loading.gif" alt="image-20210522181450742"></p><div class="hljs code-wrapper"><pre><code> 也可以用每一步的平均回报：</code></pre></div><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522181539766.png" srcset="/img/loading.gif" alt="image-20210522181539766"></p><p>策略的价值也可以从轨迹中来看:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522184802516.png" srcset="/img/loading.gif" alt="image-20210522184802516"></p><p>我们这里假设$\gamma$ 是一个轨迹，这个轨迹从策略$\pi_\theta$中来进行采样，然后去计算采样的轨迹所得到奖励的期望。数学表达就是采样$m$条轨迹，计算这些轨迹的平均奖励。</p><p>而我们的优化目标就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522185317228.png" srcset="/img/loading.gif" alt="image-20210522185317228"></p><p>Policy-based RL的优化目标是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522190047107.png" srcset="/img/loading.gif" alt="image-20210522190047107"></p><p>优化方法为：</p><ul><li>如果$J(\theta)$是可导的：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522190212720.png" srcset="/img/loading.gif" alt="image-20210522190212720"></p><p>可以用梯度上升(梯度下降反着走)，共轭梯度法，或者拟牛顿法。</p><ul><li><p>如果$J(\theta)$不可导：可以用黑盒优化相关的算法</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522190650197.png" srcset="/img/loading.gif" alt="image-20210522190650197"></p></li></ul><p>比如 交叉熵方法，爬山算法 (Hill climbing)，进化算法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522191051096.png" srcset="/img/loading.gif" alt="image-20210522191051096"></p><p>迭代N次，对于每次迭代：</p><p>首先假设我们参数的分布函数$P_{\mu^{(i)}}(\theta)$，这个分布函数初始化可以是一个高斯分布，然后从这个参数的分布函数进行抽样，抽取出m组参数。</p><p>然后对这m组参数，分别计算在每组参数$\theta$下的$J(\theta)$ 并存于$C$这个集合中。</p><p>接着，我们在$C$中挑选出集合$J(\theta)$前10%大的的$\theta$, 然后再用这些$\theta$来优化分布函数中的参数，从而使得参数分布进行了更新。</p><p>还有一种方法是用差值来代替梯度：</p><p>他算出每个维度的梯度</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522211055225.png" srcset="/img/loading.gif" alt="image-20210522211055225"></p><p>计算策略梯度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522212120497.png" srcset="/img/loading.gif" alt="image-20210522212120497"></p><p>第三部中用了一个小技巧：把 $\nabla\pi<em>\theta/\pi</em>\theta$换为了score function$\nabla ln\pi$。</p><h3 id="策略函数的形式"><a href="#策略函数的形式" class="headerlink" title="策略函数的形式"></a>策略函数的形式</h3><ul><li><p>第一种是Softmax Policy：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522214244793.png" srcset="/img/loading.gif" alt="image-20210522214244793"></p><p>在某个状态$s$下，首先把$\phi(s,a)^T$这个对原特征做完feature transform后再做一个线性组合得到：$\phi(s,a)^T\theta$。</p><p>最后转换成概率，得到$\pi_\theta$：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522214439812.png" srcset="/img/loading.gif" alt="image-20210522214439812"></p></li><li><p>另一种策略函数的形式是Gaussian Policy：</p><p>有些时候策略是连续的，比如机器人控制问题，<strong>动作空间是个连续的过程，需要连续控制变量</strong>。对于连续策略变量，高斯是一个比较好的定义方式。</p><p>首先把状态特征量的线性组合作为高斯函数的均值，方差Variance既可以把它参数化也可以把它设为固定的$\sigma^2$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522215430409.png" srcset="/img/loading.gif" alt="image-20210522215430409"></p><p>所以当我们要得到一个动作时，就直接对高斯函数进行采样，这样我们就可以得到连续的值：：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522215437969.png" srcset="/img/loading.gif" alt="image-20210522215437969"></p><p>这里的score function是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522215553267.png" srcset="/img/loading.gif" alt="image-20210522215553267"></p></li></ul><h3 id="Monte-Carlo-policy-gradient"><a href="#Monte-Carlo-policy-gradient" class="headerlink" title="Monte-Carlo policy gradient"></a>Monte-Carlo policy gradient</h3><p>Policy Gradient是策略优化的一个经典算法，先说MDP最简单的形式——只走一步</p><p><strong>Policy Gradient for one-step MDPs：</strong></p><p>这个方法只走一步，用一步的reward来进行计算：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522221406855.png" srcset="/img/loading.gif" alt="image-20210522221406855"></p><p>然后写出$J(\theta)$的表示函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522221836779.png" srcset="/img/loading.gif" alt="image-20210522221836779"></p><p>计算梯度，这里计算梯度用到了上面提到的score function的技巧：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522221919474.png" srcset="/img/loading.gif" alt="image-20210522221919474"></p><ul><li><p>Policy Gradient for Multi-step MDPs</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522224214917.png" srcset="/img/loading.gif" alt="image-20210522224214917"></p></li></ul><p>首先从策略中抽样出很多轨迹</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522224352536.png" srcset="/img/loading.gif" alt="image-20210522224352536"></p><p>然后计算轨迹的期望作为$J(\theta)$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522224455240.png" srcset="/img/loading.gif" alt="image-20210522224455240"></p><p>此时我们的需要优化的参数$\theta$已经被包含到了关于轨迹的概率函数，现在我们的目标就是优化这个$\theta$使得$J(\theta)$最大。</p><p>Multi-step MDPs的策略梯度是什么？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522224850718.png" srcset="/img/loading.gif" alt="image-20210522224850718"></p><p>那么现在就得到了策略梯度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522225044983.png" srcset="/img/loading.gif" alt="image-20210522225044983"></p><p>因为我们实际上并不知道这个轨迹$\tau$的分布，所以我们一般会用蒙特卡罗的方法来代替：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522225307159.png" srcset="/img/loading.gif" alt="image-20210522225307159"></p><p>下面要对$logP(\tau_i;\theta)$分解：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522225809736.png" srcset="/img/loading.gif" alt="image-20210522225809736"></p><p>这里也体现了我们写成log这种技巧的好处到底是什么，他将一些没用的量扔了出去，并变成了score funciton的加和。</p><p>那么现在我们可以把</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210522230244717.png" srcset="/img/loading.gif" alt="image-20210522230244717"></p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch7-价值函数近似-下</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch7-%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC-%E4%B8%8B/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch7-%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="价值函数近似—下"><a href="#价值函数近似—下" class="headerlink" title="价值函数近似—下"></a>价值函数近似—下</h1><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519233158541.png" srcset="/img/loading.gif" alt="image-20210519233158541"></p><ul><li>线性组合的前提是需要我们设计出很好的feature</li><li>我们可以用非线性的函数拟合，常用的方法就是：DNN（Deep Neural Network）</li></ul><p>现在DRL的一个大致情况：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520000418525.png" srcset="/img/loading.gif" alt="image-20210520000418525"></p><ul><li><p>DNN用来拟合价值函数，策略函数和环境模型</p></li><li><p>Loss function可以通过SGD来做梯度下降</p></li><li>目前的挑战：1.效率问题，参数太多  2.deadly triad</li></ul><p>Deep Q-Networks(DQN):</p><p>DQN通过神经网络拟合了action-value function(q函数)，同时在Atari游戏上表现出色。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520002033890.png" srcset="/img/loading.gif" alt="image-20210520002033890"></p><ul><li>端到端学习</li><li>输入是四帧图像</li><li>输出是18个操作</li><li>对游戏直接增减的分数作为奖励</li></ul><p>之前Q-Learning学习中很难克服两个问题：</p><ul><li><p>我们用的是监督学习 ，需要i.i.d的数据，而因为输入是相邻帧，关联性很高</p></li><li><p>网络学习q或者v需要bootstraping迭代，每次都把td target作为标签通过监督学习拟合，td target是变的，导致了</p></li></ul><p>那么DQN是如何解决上面这两个问题的呢？</p><ul><li>Experience replay</li></ul><p>Experience replay这种方法用了一个容器replay memory $D$来存储$(s<em>t,a_t,r_t.s</em>{t+1})$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520204931422.png" srcset="/img/loading.gif" alt="image-20210520204931422"></p><p>然后在对$D$进行采样，利用采样得到的来构建TD target，进一步就可以得到所拟合的Q函数的梯度。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520204959678.png" srcset="/img/loading.gif" alt="image-20210520204959678"></p><p>因此这种方法把不同轨迹的数据集合在一起，抽样训练，降低了相关性。</p><ul><li>Fixed Q targets</li></ul><p>解决的方法是通过一个$w^-$ 来替代TD target中的$w^-$。这个$w^-$是几轮迭代前的$w$,这样我们就可以求梯度时忽略原来TD Target第二项w不求导造成的问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520205453588.png" srcset="/img/loading.gif" alt="image-20210520205453588"></p><p>更新方法如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520212701456.png" srcset="/img/loading.gif" alt="image-20210520212701456"></p><p>这里周博磊老师给出了一个直观的解释：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520212508908.png" srcset="/img/loading.gif" alt="image-20210520212508908"></p><p>老鼠相当于我们的target function，老鼠每动几步，猫才会行动一步，这样就可以更好的看准target来优化。原来TD Target每次都会变化，这会导致目标一致变化导致拟合困难。</p><p><strong>DQN近些年的一些进步工作:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210520213637260.png" srcset="/img/loading.gif" alt="image-20210520213637260"></p><ul><li><p>Double DQN  <a href="https://arxiv.org/pdf/1509.06461.pdf" target="_blank" rel="noopener">Paper Link</a></p></li><li><p>Dueling DQN <a href="https://arxiv.org/pdf/1511.06581.pdf" target="_blank" rel="noopener">Paper Link</a></p></li><li><p>Prioritized Replay <a href="https://arxiv.org/pdf/1511.05952.pdf" target="_blank" rel="noopener">Paper Link</a></p></li><li><p>还有一个非常有趣的是Agent57，是去年五月刚发的一篇文章，可以理解为把许多改进融合了起来 。 <a href="https://deepmind.com/blog/article/Agent57-Outperforming-the-human-Atari-benchmark" target="_blank" rel="noopener">Blog Link</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch6-价值函数近似-上</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch6-%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC-%E4%B8%8A/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch6-%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="价值函数近似—上"><a href="#价值函数近似—上" class="headerlink" title="价值函数近似—上"></a>价值函数近似—上</h1><p>Plan：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513211004841.png" srcset="/img/loading.gif" alt="image-20210513211004841"></p><p>前面提到的状态量都很小，而许多实际环境得状态量是很多的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513211057098.png" srcset="/img/loading.gif" alt="image-20210513211057098"></p><p>比如围棋局面高达：$10^{170}$, 那么这么多的状态必然是不能有概率转移矩阵的，因此状态很多的强化学习任务一般也都是model-free的。</p><p>回想之前在model-free中我们是怎么进行policy evaluation的？ 是通过填写Q-Table。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513211504330.png" srcset="/img/loading.gif" alt="image-20210513211504330"></p><p>而在状态数过多时，填写Q-table根本不可能。</p><p>这里一个trival的想法就是函数近似：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513211819468.png" srcset="/img/loading.gif" alt="image-20210513211819468"></p><p>我们想通过见过的状态来近似估计出价值函数，状态动作函数，策略函数等，希望可以泛化到未见过的状态上。</p><p>比如对于价值函数$v$, 可以这样设计：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513212243059.png" srcset="/img/loading.gif" alt="image-20210513212243059"></p><p>输入状态，通过学习$w$,最后得到价值函数$v(s,w)$</p><p>对于状态动作函数$q$, 有两种可行的设计方式:</p><p>一种是输入状态s和动作a，学习参数w，得到q(s,a,w):</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513212426677.png" srcset="/img/loading.gif" alt="image-20210513212426677"></p><p>另一种方法是，通过输入状态，学习参数w，得到各种动作的q值，然后我们使用时直接加一个argmax即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513212516094.png" srcset="/img/loading.gif" alt="image-20210513212516094"></p><p>对于函数估计：</p><ul><li>可以采用线性的把feature combine起来</li><li>神经网络</li><li>决策树</li><li>近邻(Nearest Neighbour)算法</li></ul><p>我们这里假设我们已经指导真正的价值函数$v^{\pi}$，我们的近似函数为$\hat{v}$ ：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513230532246.png" srcset="/img/loading.gif" alt="image-20210513230532246"></p><p>通过上图计算它们的差距$J(w)$,最小化$J(w)$ 就是我们现在的任务，可以使用梯度下降来做。</p><p><strong>状态的表示方法：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513231229597.png" srcset="/img/loading.gif" alt="image-20210513231229597"></p><p>状态可以用一个向量$x(s) = (x_1(s),…,x_n(s))^T$来表示，向量中可以有很多东西：比如在上图左下角的mountain car中，我们可以选择车的位置，车的速度。在 cart pole游戏中可以选择木块的位置，木块的速度，杆的角度，杆上端的速度等…</p><p><strong>线性模型来拟合函数：</strong></p><p>可以写为：</p><script type="math/tex; mode=display">\hat{v}(s, \mathbf{w})=\mathbf{x}(s)^{T} \mathbf{w}=\sum_{j=1}^{n} x_{j}(s) w_{j}</script><p>所以现在目标函数可以写为：</p><script type="math/tex; mode=display">J(\mathbf{w})=\mathbb{E}_{\pi}\left[\left(v^{\pi}(s)-\mathbf{x}(s)^{T} \mathbf{w}\right)^{2}\right]</script><p>那么他的梯度+stepsize设置为$\alpha$时可以表示为：</p><script type="math/tex; mode=display">\Delta \mathbf{w}=\alpha\left(v^{\pi}(s)-\hat{v}(s, \mathbf{w})\right) \mathbf{x}(s)</script><p>然后梯度下降。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210513234922149.png" srcset="/img/loading.gif" alt="image-20210513234922149"></p><p>这里运用了一个Table lookup feature的写法：</p><p>他把多个$x(s)$组合在一起变成一个表$x^{table}(s)=(1(s=s_1),…,1(s=s_n))$ ,这样的方法类似于one-hot编码，是哪儿个状态就对应位置是1向量 ，其他是0向量。</p><p>因此:$\hat{v}(s, \mathbf{w})=\left(\mathbf{1}\left(s=s<em>{1}\right), \ldots, \mathbf{1}\left(s=s</em>{n}\right)\right)\left(w<em>{1}, \ldots, w</em>{n}\right)^{T}$，其中$w_i$在此时代表权重向量$w$和$x(s_i)$的向量乘积。</p><p><strong>预测(Prediction)问题, 怎么求价值函数：</strong></p><p>之前都是再假设我们有$v^\pi$,但实际上我们并没有，因此可以借用model-free中的想法，用MC或者TD的方法来估计并代替$v^\pi$：</p><p>原式为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514001210536.png" srcset="/img/loading.gif" alt="image-20210514001210536"></p><p>现在我们要用MC的方法或者TD的方法来搞：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514001252130.png" srcset="/img/loading.gif" alt="image-20210514001252130"></p><p>下面我们详细的说一下MC和TD的方法</p><ul><li>MC方法：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514001848813.png" srcset="/img/loading.gif" alt="image-20210514001848813"></p><p>MC的方法是无偏的估计，但是由于抽取单个一般都是噪音很大的，因此我们需要选取多个求平均。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514002021821.png" srcset="/img/loading.gif" alt="image-20210514002021821"></p><p>这样我们就可以产生一些trainning 数据，它是一个个Pair。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514002113828.png" srcset="/img/loading.gif" alt="image-20210514002113828"></p><p>在线性模型中$\Delta_W\hat{v}(s_t,w)$是一个线性的，即xw，因此可以直接求偏导得出$x(s_t)$</p><ul><li>TD方法：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514002332914.png" srcset="/img/loading.gif" alt="image-20210514002332914"></p><p>TD方法用TD target代替了真实价值。这是一个有偏的，因为TD target的抽样期望并不等于$v^\pi(s_t)$, 因为TD target中包含了我们上次的估计，这种在估计上估计肯定是有偏的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514002608725.png" srcset="/img/loading.gif" alt="image-20210514002608725"></p><p>因此我们也可以把这种方法发到control问题的第一步policy evalution</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210514002644170.png" srcset="/img/loading.gif" alt="image-20210514002644170"></p><p>拟合行为价值函数，和状态价值函数相同的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519193439670.png" srcset="/img/loading.gif" alt="image-20210519193439670"></p><p>这里我们还是假设行为价值函数Action-Value Function是一个通过不同feature线性的组合得到的函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519193730827.png" srcset="/img/loading.gif" alt="image-20210519193730827"></p><p>由于我们还是和之前一样假设了我们已知q函数，但实际上我们是不知道的，因此还是需要TD Target或者MC的抽样来做替换。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519194037804.png" srcset="/img/loading.gif" alt="image-20210519194037804"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519194441936.png" srcset="/img/loading.gif" alt="image-20210519194441936"></p><p>总结：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519195405751.png" srcset="/img/loading.gif" alt="image-20210519195405751"></p><p>上面算法进行更新时有关收敛的问题：</p><ul><li>TD Target对w的梯度包含了w，这其实是不太准确的。</li><li>首先TD Target和就是一个估计的过程，我们用这个估计出来的值去做梯度下降，去估计价值函数，这有太大的不确定性。</li><li>上面我们都是在用linear的function，事实上，当我们使用non-linear function进行拟合时或者是off-policy的方法进行拟合时结果非常不稳定。</li></ul><p>强化学习训练不稳定的原因：</p><ul><li>函数估计所造成的误差</li><li>Bootstrapping会使得估计是在之前估计的基础上估计的，比如TD Target的第二项本来就是估计的，现在却要用这个估计的来更新训练估计价值函数。</li><li>off-policy训练中，采集到的数据是behavior policy所得到的，而我们优化的函数确实在另一个数据分布上的函数。</li></ul><p>有关能否找到最优解的问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519223152223.png" srcset="/img/loading.gif" alt="image-20210519223152223"></p><ul><li><p>用Table Lookup方法一般都是可以找到最优解的。</p></li><li><p>在Linear的算法中，MC，Sarsa可以找到一个近似最优解的算法。而Q-Learning还是比较难找一个最优解。</p></li><li><p>Non-Linear算法下，三种方法都无法保证最优解。</p></li></ul><p>现在我们优化的方法都是单步的优化，我们可以每次优化一个batch：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519232147324.png" srcset="/img/loading.gif" alt="image-20210519232147324"></p><p>假设我们有一堆数据$D$, 数据类型为&lt;状态，实际价值&gt;，这里的实际价值可以用TD Target或者MC中的$G_t$来替换。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519232322553.png" srcset="/img/loading.gif" alt="image-20210519232322553"></p><p>我们的目标是最优化w，使得w可以最好的fit model，也就是最小化$E_D$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210519232627291.png" srcset="/img/loading.gif" alt="image-20210519232627291"></p><p>因此我们可以用mini-batch 的SGD来做梯度下降。</p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch5-无模型价值函数估计和控制-下</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch5-%E6%97%A0%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%8E%A7%E5%88%B6-%E4%B8%8B/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch5-%E6%97%A0%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%8E%A7%E5%88%B6-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="无模型的价值函数估计和控制—下"><a href="#无模型的价值函数估计和控制—下" class="headerlink" title="无模型的价值函数估计和控制—下"></a>无模型的价值函数估计和控制—下</h1><p>上一节讲了预测(prediction)问题，这一节我们来解决控制(control)问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506222813211.png" srcset="/img/loading.gif" alt="image-20210506222813211"></p><p>我们之前再policy evaluation中用的方法是动态规划迭代，而上一节提到了一种新的做法也就是通过MC方法来做在特定策略$\pi$下计算状态的价值函数。</p><p><strong>model-free时control问题的解决方法：</strong></p><ul><li>在model-free中，我们首先要用MC方法来填一个表格Q-table，即policy evaluation：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506224528600.png" srcset="/img/loading.gif" alt="image-20210506224528600"></p><ul><li>然后去更新策略，即control的第二步策略提升policy improvement</li></ul><p>在MC算Q-table时有一个trade-off，也就是exploration和exploitation之间的trade-off。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506225241469.png" srcset="/img/loading.gif" alt="image-20210506225241469"></p><p><strong>$\epsilon$-Greedy Exploration​ ：</strong></p><p>提出了在策略$\pi$下，一个状态在策略$\pi$下不仅可以对应着一个当前收益最大的act，还会有一个随机的act，这个随机的act就是为了exploration。</p><p>这个$\epsilon$是可以变化的，在前期可以大一些，后面可以逐渐变小。</p><p>MC with $\epsilon$-Greedy Exploration算法有一个特点：在新策略下的价值函数总比以前就策略下的价值函数大。下面给出一个简单的证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506230233190.png" srcset="/img/loading.gif" alt="image-20210506230233190"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506234705288.png" srcset="/img/loading.gif" alt="image-20210506234705288"></p><p><strong>Sarsa算法（On-Policy TD Control）：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511212737480.png" srcset="/img/loading.gif" alt="image-20210511212737480"></p><p>Sarsa这名字的来历就是：SARSA分开来看，根据当前状态，做出ACT，得到Reward，然后转移到一个状态，做出新的ACT。</p><p>伪代码：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511214856933.png" srcset="/img/loading.gif" alt="image-20210511214856933"></p><p>即然存在n-step TD，那么也会存在n-step sarsa。</p><p><strong>On-policy  vs.  Off-policy Learning：</strong></p><p>On-policy是 学习策略$\pi$通过策略$\pi$所产生的轨迹数据。</p><p>Off-policy是指在学习策略$\pi$时，用了两种策略产生轨迹数据给他学习：一种策略是现在学到的策略，也是我们希望最优化的策略，我们一般称之为目标策略target policy $\pi$。另一个 策略是我们拿来探索的策略，那么这个探索的策略可以激进一些，我们称之为行为策略behavior policy $\mu$ ，这个行为策略通过探索找到一些新的轨迹数据，然后再喂给target policy来学习。</p><p>on-policy 与 off-policy的本质区别在于：更新Q值时所使用的方法是沿用既定的策略（on-policy）还是使用 新策略（off-policy）。</p><p><strong>Off-Policy Control with Q-Learning：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511220835055.png" srcset="/img/loading.gif" alt="image-20210511220835055"></p><p>Q-Learning 就是一种Off-Policy的算法，一种target policy是按照贪心的方法选择当前已知最好的方法去更新，另一种就是behavior policy，但是这里她并没有采用完全的随机，因为完全的随机其实一般效果不会那么好，我们可以用$\epsilon-greedy$的方法，前期$\epsilon$可以大一些随机性强一些，以后$\epsilon$调到低一些即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511222437412.png" srcset="/img/loading.gif" alt="image-20210511222437412"></p><p><strong>Q-Learning vs. Sarsa:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511223537205.png" srcset="/img/loading.gif" alt="image-20210511223537205"></p><p>从backup这个图上来看：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511223856072.png" srcset="/img/loading.gif" alt="image-20210511223856072"></p><p>Sarsa中的A’ 是通过和A一样，从策略当前的策略抽取到的。而Q-Learning中，他是通过观察Q-Table，找到一个可以使得$Q(S_{t+1},a)$最大的$a$。</p><p><strong>cliff walk问题中，看一下Sarsa和Q-learning的区别：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511224316635.png" srcset="/img/loading.gif" alt="image-20210511224316635"></p><p>Q-learning的策略更激进，Sarsa的策略更稳健。</p><p><strong>总计：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210511224418317.png" srcset="/img/loading.gif" alt="image-20210511224418317"></p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch4-无模型价值函数估计和控制-上</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch4-%E6%97%A0%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%8E%A7%E5%88%B6-%E4%B8%8A/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch4-%E6%97%A0%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1%E5%92%8C%E6%8E%A7%E5%88%B6-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="无模型的价值函数估计和控制—上"><a href="#无模型的价值函数估计和控制—上" class="headerlink" title="无模型的价值函数估计和控制—上"></a>无模型的价值函数估计和控制—上</h1><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505200826789.png" srcset="/img/loading.gif" alt="image-20210505200826789"></p><p>这一次讲的是model-free的value function的预策(prediction)和控制(control)。</p><p>model-free就是指无模型，MDP不是已知的。也就是说我们不知道$R(Reward)$和状态转移矩阵$P$</p><p>下面是上一次课的concise review：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505201103886.png" srcset="/img/loading.gif" alt="image-20210505201103886"></p><p>对于Model-free的RL，我们没有了R和P, 因此我们需要从交互过程中来学习：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505203412074.png" srcset="/img/loading.gif" alt="image-20210505203412074"></p><p>而交互过程就是这样的一个序列：${S_1,A_1,R_1,S_2,A_2,R_2,..S_T,A_T,R_T}$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505204213590.png" srcset="/img/loading.gif" alt="image-20210505204213590"></p><p><strong>在model-free时，如何在特定的策略下，估计状态的价值函数呢？</strong></p><ul><li><p><strong>蒙特卡洛策略估计</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505210813648.png" srcset="/img/loading.gif" alt="image-20210505210813648"></p><p>为了写成迭代的形式，我们可以建立一个上一时刻的平均值和下一时刻平均值的关系：</p><p>$\begin{aligned} \mu<em>{t} &amp;=\frac{1}{t} \sum</em>{j=1}^{t} x<em>{j} \ &amp;=\frac{1}{t}\left(x</em>{t}+\sum<em>{j=1}^{t-1} x</em>{j}\right) \ &amp;=\frac{1}{t}\left(x<em>{t}+(t-1) \mu</em>{t-1}\right) \ &amp;=\mu<em>{t-1}+\frac{1}{t}\left(x</em>{t}-\mu_{t-1}\right) \end{aligned}$</p><p>利用这个方法，我们可以改写一下蒙特卡洛的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505211616960.png" srcset="/img/loading.gif" alt="image-20210505211616960"></p><p>这里比较一下蒙特卡洛MC方法和动态规划DP方法的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505212157744.png" srcset="/img/loading.gif" alt="image-20210505212157744"></p><p>在DP中，我们获得一个状态的价值是根据下层所有情况来得到的。</p><p>而在MC中：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505212302882.png" srcset="/img/loading.gif" alt="image-20210505212302882"></p><p>我们只是根据几条路径来大致估计的，可能有些路径会被忽略掉，因此并不是根据下层所有可能出现的情况来得到状态的价值的。</p><p><strong>造成这样区别的主要原因就是：我们不知道状态转移概率矩阵P。</strong></p></li></ul><ul><li><p><strong>Temporal Difference(TD) learning ，时间差分学习</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505213619048.png" srcset="/img/loading.gif" alt="image-20210505213619048"></p></li></ul><p>TD方法也是用了上面的一个online mean的技巧，这里它通过TD target（即$R<em>{t+1}+\gamma v(S</em>{t+1})$）来更新，这一步由两部分分别是$R<em>{t+1}$和$\gamma v(S</em>{t+1})$：</p><p>$R<em>{t+1}$是在新的一步中直接获得的奖励，第二部分$\gamma v(S</em>{t+1})$利用了动态规划的思想，利用之前的估计来估计现在的，也就是当前$S<em>t$可以转移到$S</em>{t+1}$,那么就用$S_{t+1}$的value function的值来更新即可。</p><p>我们对比一下TD和 MC方法的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505215024640.png" srcset="/img/loading.gif" alt="image-20210505215024640"></p><p><strong>更多的区别：</strong></p><ol><li>TD算法在每一步状态的转移下都可以实时在线学习，而MC必须做完一个episode才能知道return的大小。</li><li>TD可以从不完整的交互序列来学习，而MC不可以，他必须需要一个完整的交互序列才可以得到return</li><li>TD可以在一个无终止的环境下学习，而MC由于需要完整的序列，而无终止环境下序列是无限长的，因此MC无法在无终止的环境下学习。</li><li>当然，TD也有缺点，就是TD假设了强化学习任务有马尔科夫特征，即当前状态只和上一时刻有关系，而与更早的时刻无关。而MC没有对马尔科夫环境做出要求。</li></ol><p>TD有一些灵活的用法，比如n-step TD：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210505215917166.png" srcset="/img/loading.gif" alt="image-20210505215917166"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506085517428.png" srcset="/img/loading.gif" alt="image-20210506085517428"></p><p>TD的step如果远一些，那么就会加大搜索深度，到达极限即使MC方法，也就是找到一条完整的路径来算return。而TD加宽搜索广度即是DP方法。如果又宽又广即是穷举了决策树，也就是穷举算法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210506085849669.png" srcset="/img/loading.gif" alt="image-20210506085849669"></p><p>统计学中，bootstrapping可以指依赖于重置随机抽样的一切试验。bootstrapping可以用于计算样本估计的准确性。对于一个采样，我们只能计算出某个统计量统计量)(例如均值))的一个取值，无法知道均值统计量的分布情况。但是通过自助法(bootstrapping)我们可以模拟出均值统计量的近似分布。有了分布很多事情就可以做了（比如说有你推出的结果来进而推测实际总体的情况）。</p><p>在这里我们可以简单理解为在估计上估计(estimate by estimating)，比如DP就用到了这种思想，利用了其他状态的value function的值来估计一个状态value function的值。</p><p>而MC没有，他是抽取了决策树的一部分的支路，然后取了个平均，每一步都是实实在在的return，没有任何估计，因此是estimate by sampling。</p><p>而在TD中由于TD target包含两部分：$R<em>{t+1}$和$\gamma v(S</em>{t+1})$</p><p>$R<em>{t+1}$是通过真实的走一步，看看得到了环境的return是什么，因此这是sample，而后面的$\gamma v(S</em>{t+1})$就是利用了bootstrap。</p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch3-马尔可夫决策过程(MDP)—下</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch3-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-MDP-%E2%80%94%E4%B8%8B/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch3-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-MDP-%E2%80%94%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="马尔可夫决策过程-MDP-—下"><a href="#马尔可夫决策过程-MDP-—下" class="headerlink" title="马尔可夫决策过程(MDP)—下"></a>马尔可夫决策过程(MDP)—下</h1><p><strong>马尔可夫决策过程有两个核心问题：分别是预策(prediction)和控制(control)</strong></p><ul><li>预测：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503214530939.png" srcset="/img/loading.gif" alt="image-20210503214530939"></p><p>预策问题就是给定马尔可夫决策过程和策略$\pi$， 或者给出马尔科夫奖励过程。然后去做预策每个状态的价值函数$v^{\pi}$</p><ul><li>控制：</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503214841239.png" srcset="/img/loading.gif" alt="image-20210503214841239"></p><p>控制是指给出一个马尔可夫过程，需要最优化得到价值函数和策略。</p><p>这两个问题都可以通过动态规划来解决。</p><p>首先是预测问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503215450158.png" srcset="/img/loading.gif" alt="image-20210503215450158"></p><p>通过这样的状态转移方程去做动态规划即可。</p><p>这里给出一个代码框架：</p><script type="math/tex; mode=display">v_{t+1}(s)=\sum_{a \in \mathcal{A}} \pi(a \mid s)\left(R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} P\left(s^{\prime} \mid s, a\right) v_{t}\left(s^{\prime}\right)\right)</script><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#在已知策略\pi 下迭代</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    old_table = self.table.copy()<br><br>    <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> range(self.obs_dim):<br>        <span class="hljs-comment">#由于已知策略，可以直接根据policy，输入当前state找出act</span><br>        act = self.policy(state)<br>        transition_list = self._get_transitions(state, act)<br><br>        state_value = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> transition <span class="hljs-keyword">in</span> transition_list:<br>            prob = transition[<span class="hljs-string">'prob'</span>]<br>            reward = transition[<span class="hljs-string">'reward'</span>]<br>            next_state = transition[<span class="hljs-string">'next_state'</span>]<br>            done = transition[<span class="hljs-string">'done'</span>]<br><br>            <span class="hljs-comment"># [TODO] what is the right state value?</span><br>            <span class="hljs-comment"># hint: you should use reward, self.gamma, old_table, prob,</span><br>            <span class="hljs-comment"># and next_state to compute the state value</span><br>            state_value += prob*(reward+self.gamma*<span class="hljs-number">1</span>*old_table[next_state])<br><br>            <span class="hljs-comment"># update the state value</span><br>            self.table[state] = state_value<br><br>        <span class="hljs-comment"># [TODO] Compare the old_table and current table to</span><br>        <span class="hljs-comment">#  decide whether to break the value update process.</span><br>        <span class="hljs-comment"># hint: you should use self.eps, old_table and self.table</span><br>        should_break = <span class="hljs-literal">None</span><br>        <span class="hljs-comment">#如果迭代两次差距太小就说明收敛</span><br>        <span class="hljs-keyword">if</span> (np.fabs(self.table - old_table) &lt; np.array([self.eps]*self.obs_dim)).all():<br>            should_break = <span class="hljs-literal">True</span><br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503222023509.png" srcset="/img/loading.gif" alt="image-20210503222023509"></p><p>我们举一个例子来迭代一下$v$:</p><p>开始时:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503222552287.png" srcset="/img/loading.gif" alt="image-20210503222552287"></p><p>一定次数的传播后$v$就会逐渐稳定：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503222638284.png" srcset="/img/loading.gif" alt="image-20210503222638284"></p><p>上述都是再讲怎么迭代计算出$v^{\pi}(s)$。</p><p>我们还有一个问题是control，也就是如何算出最优化的策略/状态价值函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503224251512.png" srcset="/img/loading.gif" alt="image-20210503224251512"></p><p>最优的状态价值函数中的有关变量是策略$\pi$, 也就是 在各种各样的策略下，可以使得每个状态价值最大的策略就是我们需要选择的策略，在这样的策略下，我们就可以获得最优的状态价值函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503225215570.png" srcset="/img/loading.gif" alt="image-20210503225215570"></p><p>同理，如果找最优策略，就如上述所说的，找可以使得状态价值函数最大的策略就被成为最优的策略。</p><p>当我们知道最优化的值时，就可以说MDP问题被解决了。</p><p><strong>怎么寻找最佳的策略：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504091803979.png" srcset="/img/loading.gif" alt="image-20210504091803979"></p><p>最简单的一种方式就是选择可以使得$a =  argmax _{a \in A}q<em>(s,a)$的action，这样的action，并让这种动作的在状态出现的概率$\pi^</em>(a \mid s) = 1$即可，此时由公式：</p><script type="math/tex; mode=display">v^{\pi}(s)=\sum_{a \in A} \pi(a \mid s) q^{\pi}(s, a)</script><p>不难得知$v^{\pi}$在此时取得了最大值，那么根据上最优化策略的定义，此时的$\pi$即为最优策略。</p><p>一个简单的想法，就是枚举所有的状态的action，算一算他们的state-value function，然而这种方法仅仅枚举复杂度就达到了$O(s^a)$，其中s为状态数，a为在该状态下可做的行为数量。</p><p>还有一种想法是<strong>策略迭代(Policy Iteration)：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504094510039.png" srcset="/img/loading.gif" alt="image-20210504094510039"></p><p>这种策略分为两部分，一个是计算在策略$\pi$下的value function，另一个是提升策略(即贪心的选择可以使得v函数更大的$\pi$)。</p><p>提升策略中有两步：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504094854696.png" srcset="/img/loading.gif" alt="image-20210504094854696"></p><p>首先是计算状态行为价值函数(q函数)，也就是在状态s做出动作a所获得的reward。</p><p>然后计算新策略下计算使得q在状态s下可以被最大化的动作。这种迭代方式叫做策略迭代：它包括策略估计和策略提升</p><p>上面已经给出在策略$\pi$下如何迭代计算出价值函数，这里再给出<strong>策略提升的框架代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_policy</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-string">"""You need to define a new policy function, given current</span><br><span class="hljs-string">    value function. The best action for a given state is the one that</span><br><span class="hljs-string">    has greatest expected return.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    To optimize computing efficiency, we introduce a policy table,</span><br><span class="hljs-string">    which take state as index and return the action given a state.</span><br><span class="hljs-string">    """</span><br>    policy_table = np.zeros([self.obs_dim, ], dtype=np.int)<br><br>    <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> range(self.obs_dim):<br>        state_action_values = [<span class="hljs-number">0</span>] * self.action_dim<br>        <br>        <span class="hljs-comment"># [TODO] assign the action with greatest "value"</span><br>        <span class="hljs-comment"># to policy_table[state]</span><br>        <span class="hljs-comment"># hint: what is the proper "value" here?</span><br>        <span class="hljs-comment">#  you should use table, gamma, reward, prob,</span><br>        <span class="hljs-comment">#  next_state and self._get_transitions() function</span><br>        <span class="hljs-comment">#  as what we done at self.update_value_function()</span><br>        <span class="hljs-comment">#  Bellman equation may help.</span><br>        best_action = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> act <span class="hljs-keyword">in</span> range(self.action_dim):<br>            transition_list = self._get_transitions(state, act)<br>            action_value = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> transition <span class="hljs-keyword">in</span> transition_list:<br>                prob = transition[<span class="hljs-string">'prob'</span>]<br>                reward = transition[<span class="hljs-string">'reward'</span>]<br>                next_state = transition[<span class="hljs-string">'next_state'</span>]<br>                done = transition[<span class="hljs-string">'done'</span>]<br>                action_value += prob*(reward+self.gamma*self.table[next_state])<br>            state_action_values[act] = action_value<br>        best_action = np.argmax(state_action_values)<br>        policy_table[state] = best_action<br><br>    self.policy = <span class="hljs-keyword">lambda</span> obs: policy_table[obs]<br></code></pre></div></td></tr></table></figure><p>那么就可以推出：Bellman Optimality Equation</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504101827815.png" srcset="/img/loading.gif" alt="image-20210504101827815"></p><p>因此就可以通过<strong>Bellman Optimality Equation得出迭代算法：</strong></p><p>这种迭代叫做：<strong>价值迭代Value iteration</strong><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504102033826.png" srcset="/img/loading.gif" alt="image-20210504102033826"></p><p>代码框架：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">old_policy_result = &#123;<br>    obs: <span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> obs <span class="hljs-keyword">in</span> range(trainer.obs_dim)<br>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(config[<span class="hljs-string">'max_iteration'</span>]):<br>    <span class="hljs-comment"># train the agent</span><br>    trainer.train()  <span class="hljs-comment"># [TODO] please uncomment this line</span><br><br>    <span class="hljs-comment"># evaluate the result</span><br>    <span class="hljs-keyword">if</span> i % config[<span class="hljs-string">'evaluate_interval'</span>] == <span class="hljs-number">0</span>:<br>        print(<span class="hljs-string">"[INFO]\tIn &#123;&#125; iteration, current "</span><br>              <span class="hljs-string">"mean episode reward is &#123;&#125;."</span>.format(<br>            i, trainer.evaluate()<br>        ))<br><br>        <span class="hljs-comment"># [TODO] compare the new policy with old policy to check should</span><br>        <span class="hljs-comment">#  we stop.</span><br>        <span class="hljs-comment"># [HINT] If new and old policy have same output given any</span><br>        <span class="hljs-comment">#  observation, them we consider the algorithm is converged and</span><br>        <span class="hljs-comment">#  should be stopped.</span><br>        should_stop = <span class="hljs-literal">None</span><br>        should_stop = <span class="hljs-literal">True</span><br>        new_policy_result = &#123;<br>        obs: trainer.policy(obs) <span class="hljs-keyword">for</span> obs <span class="hljs-keyword">in</span> range(trainer.obs_dim)<br>        &#125;<br>        <span class="hljs-keyword">for</span> obs <span class="hljs-keyword">in</span> range(trainer.obs_dim):<br>            <span class="hljs-keyword">if</span> new_policy_result[obs] != old_policy_result[obs]:<br>                should_stop = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>        old_policy_result = new_policy_result<br>        <span class="hljs-keyword">if</span> should_stop:<br>            print(<span class="hljs-string">"We found policy is not changed anymore at "</span><br>                  <span class="hljs-string">"iteration &#123;&#125;. Current mean episode reward "</span><br>                  <span class="hljs-string">"is &#123;&#125;. Stop training."</span>.format(i, trainer.evaluate()))<br>            <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><p>举一个最短路的例子，在不断的更新迭代，我们发现距离左上角深色方块越远，v函数在该点的状态越小。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504102959224.png" srcset="/img/loading.gif" alt="image-20210504102959224"></p><p><strong>最后总结一下策略迭代和价值迭代的区别：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504104405231.png" srcset="/img/loading.gif" alt="image-20210504104405231"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504104546069.png" srcset="/img/loading.gif" alt="image-20210504104546069"></p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch2-马尔可夫决策过程(MDP)—上</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch2-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-MDP%E2%80%94%E4%B8%8A/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch2-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-MDP%E2%80%94%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="马尔可夫决策过程-MDP-—下"><a href="#马尔可夫决策过程-MDP-—下" class="headerlink" title="马尔可夫决策过程(MDP)—下"></a>马尔可夫决策过程(MDP)—下</h1><p>本次课的plan list：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503145229795.png" srcset="/img/loading.gif" alt="image-20210503145229795"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503145747456.png" srcset="/img/loading.gif" alt="image-20210503145747456"></p><p>环境和agent交互的过程可以通过马尔科夫决策过程来表示。</p><p>马尔可夫决策过程可以解决许多实际问题，因此这是RL种的一个基本框架。</p><p>一般来说MDP的环境是fully observable的，但其实partically observable也是可以通过MDP来解决的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503150321929.png" srcset="/img/loading.gif" alt="image-20210503150321929"></p><p>如果一个状态转移是符合马尔可夫的，那么说明当前的状态只与上一时刻有关。</p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503150917853.png" srcset="/img/loading.gif" alt="image-20210503150917853"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503151136695.png" srcset="/img/loading.gif" alt="image-20210503151136695"></p><p>上图可以看作：在当前状态转移到其他的概率，我们可以用一个状态转移矩阵来表示，可以看作是一个条件概率，即在当前状态下到达其他状态的概率。</p><p>这个图可以看作马尔可夫链，一个例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503151409853.png" srcset="/img/loading.gif" alt="image-20210503151409853"></p><p><strong>马尔可夫奖励过程（Markov Reward Process）：</strong></p><p>马尔可夫奖励过程 = 马尔可夫链 + 奖励函数</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503151842212.png" srcset="/img/loading.gif" alt="image-20210503151842212"></p><p>现在我们给上述例子中的马尔可夫链加上奖励：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503152322631.png" srcset="/img/loading.gif" alt="image-20210503152322631"></p><p>奖励可以用一个向量$R$来表示。</p><p><strong>马尔可夫奖励过程 中Return的定义：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503152847130.png" srcset="/img/loading.gif" alt="image-20210503152847130"></p><p>这里面包含一个折扣因子，距离我们越远的汇报折扣的越多。</p><p><strong>马尔可夫奖励过程 中value function的定义：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503153230074.png" srcset="/img/loading.gif" alt="image-20210503153230074"></p><p>可以简单理解为从未来获得奖励和的期望</p><p><strong>为什么我们加上了discount factor $\gamma$  这个东西呢？</strong></p><ul><li><p>首先他很好的避免了环状的马尔可夫过程，避免了无穷的奖励</p></li><li><p>我们希望尽可能快的得到奖励</p></li><li><p>人和动物对立刻奖励有更大的倾向</p></li></ul><p>当马尔科夫过程中的$\gamma$设置成1时，我们就把未来的奖励和当前立刻可以获得的奖励看成等价的，而把$\gamma$设置成0，说明我们只关心立刻获得的奖励。一般我们把这个$\gamma$当成超参数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503154451137.png" srcset="/img/loading.gif" alt="image-20210503154451137"></p><p>对于$s_4$我们如何计算在此处的价值呢？</p><p>我们可以从$s_4$开始移动，获得各种路径，再把路径所获得的reward传回来。我们可以蒙特卡洛计算，也可以通过下述的Bellman equation来算：</p><p><strong>计算马尔可夫过程的价值：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503161530210.png" srcset="/img/loading.gif" alt="image-20210503161530210"></p><p>首先value function的公式如上</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503161611972.png" srcset="/img/loading.gif" alt="image-20210503161611972"></p><p>我们可以给他换个写法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210504165537849.png" srcset="/img/loading.gif" alt="image-20210504165537849"></p><p>也就是<strong>bellman equation</strong>。</p><p><strong>Bellman Equation：</strong></p><p>Bellman Equation 定义了当前状态与下一个状态的关系</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503162002943.png" srcset="/img/loading.gif" alt="image-20210503162002943"></p><p>我们可以把bellman equation改写成矩阵形式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503162039114.png" srcset="/img/loading.gif" alt="image-20210503162039114"></p><p>那么我们在此时就可以推导出矩阵V的形式：</p><script type="math/tex; mode=display">V = R + \gamma P V\\V = (I-\gamma P)^{-1} R</script><p>但矩阵求逆的复杂度是$O(n^3)$,因此这种直接求逆的解法只适用于少量状态的马尔可夫过程。</p><p>我们可以通过迭代的方法解决大型的马尔可夫过程：</p><ul><li><p>动态规划 Dynamic Programming</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503163042254.png" srcset="/img/loading.gif" alt="image-20210503163042254"></p><p>一直去迭代这个bellman equation，直到他们函数$v(s)$收敛</p></li><li><p>蒙特卡罗方法 Monte-Carlo</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503162820520.png" srcset="/img/loading.gif" alt="image-20210503162820520"></p><p>其实就是大量的模拟取平均，举个例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503162857818.png" srcset="/img/loading.gif" alt="image-20210503162857818"></p><p>对于$s_4$的价值，我们首先随机的生成一些路径，看看这些路径带来的价值，然后用获得的价值和除以路径数，就可以估算这个状态点可以获得的价值期望。</p></li></ul><p><strong>马尔科夫决策过程(Markov Decision Process,MDP)：</strong></p><p>马尔科夫决策过程 = 马尔可夫奖励过程 + 决策(action)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503163328306.png" srcset="/img/loading.gif" alt="image-20210503163328306"></p><p>此时，状态转移的概率分布也会收到action影响，那么reward function也会受到action影响。</p><p>而action是什么是取决于策略(policy)的，而policy有两种，分别是：deterministic和stochastic的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503164327800.png" srcset="/img/loading.gif" alt="image-20210503164327800"></p><p>在这里我们有一个假设就是，各个时间点上都是在对policy function采样。</p><p>如果我们知道马尔可夫决策过程并已知采取的策略，那么我们就可以把马尔可夫决策过程转化为马尔科夫奖励过程。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503170336528.png" srcset="/img/loading.gif" alt="image-20210503170336528"></p><p><strong>马尔可夫奖励过程和马尔可夫决策过程的区别：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503174020319.png" srcset="/img/loading.gif" alt="image-20210503174020319"></p><p>上图可以看出马尔可夫决策过程多了一个在某个状态下action的分布，这个action的不同会导致不同的状态转移矩阵。</p><p>在马尔可夫决策过程中：</p><p>对于一个状态价值函数$v^{\pi}(s)$，就是衡量在策略$\pi$下这个状态的价值。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503175247085.png" srcset="/img/loading.gif" alt="image-20210503175247085"></p><p>在马尔可夫决策过程过出现了一个新的动作价值函数(action-value function)，他表示在决策$\pi$下，状态$s$时，采取动作$a$，所获得的价值。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503175529314.png" srcset="/img/loading.gif" alt="image-20210503175529314"></p><p>不难发现，$v^{\pi}(s)$和$q^{\pi}(s,a)$很相似，我们只需要让$q^{\pi}(s,a)$取到各种action，算一算期望，就可以得到$v^{\pi}(s)$。</p><p>因此：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503180537658.png" srcset="/img/loading.gif" alt="image-20210503180537658"></p><p>$\pi(a|s)$代表在状态$s$下做出动作$a$的概率。</p><p><strong>Bellman Expectation Equation：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503181805866.png" srcset="/img/loading.gif" alt="image-20210503181805866"></p><p>用当前状态和下一状态的方式 重写了 state-value function 和 action-value function。</p><p>上面我们提到了$v^{\pi}(s)$和$q^{\pi}(s,a)$的关系(即下式(8)),我们还有Bellman Expectation Equation(下式(9))，那么我们就可以推出(10),(11):</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503182256328.png" srcset="/img/loading.gif" alt="image-20210503182256328"></p><p>$v^{\pi}(s) =\sum<em>{a \in A} \pi(a \mid s)\left(R(s, a)+\gamma \sum</em>{s^{\prime} \in S} P\left(s^{\prime} \mid s, a\right) v^{\pi}\left(s^{\prime}\right)\right)$这个式子并不难理解，如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503182720199.png" srcset="/img/loading.gif" alt="image-20210503182720199"></p><p>首先$R(s,a)+\gamma \Sigma_{s’ \in S}P(s’|s,a)v^{\pi}(s’)$代表在状态$s$，做出动作$a$，到达状态$s’$时的价值所得到的reward。也就是叶子节点backup到了黑色节点action，代表在这个动作下所获的reward，也就是$q^{\pi}(s,a)$。第二次backup就是action节点到根节点状态s，即：</p><p>$v^{\pi}(s)=\sum<em>{a \in A} \pi(a \mid s)\left(R(s, a)+\gamma \sum</em>{s^{\prime} \in S} P\left(s^{\prime} \mid s, a\right) v^{\pi}\left(s^{\prime}\right)\right)$</p><p>相当于对不同action的reward 乘上这个action在状态s下出现的几率，计算了在状态s获得价值的期望。</p><p>最后举一个例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503213253034.png" srcset="/img/loading.gif" alt="image-20210503213253034"></p><p>马尔可夫链/马尔科夫奖励过程相当于小船随波逐流，到哪儿完全凭随机，没有任何主观的干扰(比如action)。而马尔可夫决策过程则完全不同，除了河流的流向影响着状态，船夫所做的行动也会影响船的走向。</p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习纲要Ch1-Overview</title>
    <link href="/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch1-Overview/"/>
    <url>/2021/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BA%B2%E8%A6%81Ch1-Overview/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-Reinforcement-learning-Overview"><a href="#Intro-to-Reinforcement-learning-Overview" class="headerlink" title="Intro to Reinforcement learning-Overview"></a>Intro to Reinforcement learning-Overview</h1><p><strong>强化学习可以做什么？</strong></p><p>强化学习成为近几年来的热点，强化学习这种方法再许多领域上都取得了成功，比如，强化学习可以教计算机在虚拟环境中控制机器人，控制机器手等…</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210429140100015.png" srcset="/img/loading.gif" alt="image-20210429140100015"></p><p>(图：机器手按照规则旋转立方体)</p><p>​    对于一些策略游戏来说，强化学习在近几年同样有很大的突破：比如王者荣耀的觉悟AI(AAAI2020，Mastering Complex Control in MOBA Games with Deep Reinforcement Learning)，围棋中的AlphaGo和MOBA游戏DOTA(Dota 2 with Large Scale Deep Reinforcement Learning)。这些策略游戏需要角计算机在无数的像素构成画面中学会策略游戏，并学习人类的操作。</p><p><strong>强化学习的主要思想:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210429141019501.png" srcset="/img/loading.gif" alt="image-20210429141019501"></p><p>​    强化学习中的两个重要角色是：Agent(智能体)和Environment(环境)，Environment是Agent不仅所处的地方，也是Agent进行交互的对象。在每次交互时，Agent首先观察Environment的状态，并作出一种决策后开始行动后。此时环境也由于Agent的行动开始发生变化。需要注意的是，环境的变化也可能是自己变化导致的，不一定是Agent导致的。</p><p>​    环境的变化/状态会使得智能体获得激励信号(reward signal)，激励信号可以简单理解为一个数值，或者向量，它会告诉智能体此时环境的状态是好还是坏，当然这里的好坏是由你自己的目标来定义的，智能体的目标就是最大化他的累计奖励(cumulative reward)，可以简单理解为智能体所获得的回报(Return)。</p><p>强化学习和监督学习的区别：</p><ul><li>强化学习中的数据是一个序列，但是却不是独立同分布的，比如打砖块这个游戏，他的输入序列就是一帧帧的图像，图像间很显然不是独立的。</li><li>学习者无法告诉你哪儿个动作好，而是自己去尝试，同时也导致了强化学习的reward是delay的，不会实时反应。</li><li>Trial and error exploration，我们要平衡exploration和exploitation，exploration指我们会尝试一些新的方法，有可能效果会很好，也有可能会导致效果变差，浪费了时间，exploitation指就按照现在已经尝试过的方法中效果最好的一种接着训练。</li><li>我们只有reward signal来判断我们的效果如何，而这个激励信号也是是delay的。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210502104013675.png" srcset="/img/loading.gif" alt="image-20210502104013675"></p><p>历史就是输入的一个序列：观测，动作，回馈这样的序列</p><p>我们可以把state看成有关历史的一个函数：</p><script type="math/tex; mode=display">H_t = O_1,R_1,A_1,...,A_{T-1},O_t,R_t\\S_t = f(H_t)</script><p>我们一般有两个state，分别是：环境状态和智能体状态</p><script type="math/tex; mode=display">S_t^e = f^e(H_t)\\S_t^a = f^a(H_t)</script><p>全观测：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503135826682.png" srcset="/img/loading.gif" alt="image-20210503135826682"></p><p>部分观测：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503135937272.png" srcset="/img/loading.gif" alt="image-20210503135937272"></p><p>对于扑克牌这种游戏，我们是无法看到对方的牌的，所以无法做到全观测。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503140159958.png" srcset="/img/loading.gif" alt="image-20210503140159958"></p><p>对于一个agent需要有下面几个内容：</p><ul><li>policy：策略，agent的有关动作的函数</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503140629195.png" srcset="/img/loading.gif" alt="image-20210503140629195"></p><p>策略有随机策略和确定策略，随即策略是对于策略分布进行抽样，抽出一种策略。</p><ul><li><p>value  function：价值函数，评价每个状态/动作的好坏</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503140901818.png" srcset="/img/loading.gif" alt="image-20210503140901818"></p><p>价值函数就是在某一种策略下，未来的奖励在折价后的和的期望。</p><p>这个折价是折价因子(Discount factor)造成的，折价因子的出现是因为我们想在较短的时间里获得较多的收益，所以时间越后面所获得的回报应该做一个折扣。</p><p>value function可以用在两个方面</p><p>一个是评价状态和动作的好坏：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503141826039.png" srcset="/img/loading.gif" alt="image-20210503141826039"></p><p>也可以通过这个函数来选择动作：<br><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503141636082.png" srcset="/img/loading.gif" alt="image-20210503141636082"></p></li><li><p>model：模型，agent对环境的理解，预策环境的状态</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503142054822.png" srcset="/img/loading.gif" alt="image-20210503142054822"></p><hr><p>基于策略的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503142513005.png" srcset="/img/loading.gif" alt="image-20210503142513005"></p><p>基于价值函数的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503142542637.png" srcset="/img/loading.gif" alt="image-20210503142542637"></p><p>agent有三种（基于学习方法）:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503142732201.png" srcset="/img/loading.gif" alt="image-20210503142732201"></p><p>一种是value-based agent：它通过价值函数来做决策，就像上面的走迷宫，距离终点的距离大小就是他的决策方法。同时他<strong>隐式的学习到策略</strong>，也就是走最近的路。</p><p>还有policy-based agent：直接学习策略</p><p>还有Actor-Critic agent：两者都学习</p><p>基于是否有模型，agent分为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210503145140412.png" srcset="/img/loading.gif" alt="image-20210503145140412"></p>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH8-循环神经网络</title>
    <link href="/2021/04/19/CS231n-CH8-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/04/19/CS231n-CH8-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>后面补一个专题梳理一下这一节：to do..</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418220507728.png" srcset="/img/loading.gif" alt="image-20210418220507728"></p><p>原来的CNN是1对1的模型，即输入是固定的大小，输出也是固定的大小。</p><p>而RNN可以是：</p><p>1对多：输入一张图片，输出对图片的理解。</p><p>多对1：输入一段文字，输出情感。或者输入一段视频，输出视频中所作的决策。</p><p>多对多：翻译中输入可变，输出可变。</p><p><strong>RNN主要用于处理大小可变的有序数据。</strong></p><p>但实际上RNN也可以处理一些输入大小固定，输出大小固定的问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418221500352.png" srcset="/img/loading.gif" alt="image-20210418221500352"></p><p>比如手写数字识别，他不是单纯的做一个前向传递然后把识别结果返回出来。而是观察一组图片，看看这些图片的各种不同部分，在完成这样的一组观察后再得出识别结果。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418222055571.png" srcset="/img/loading.gif" alt="image-20210418222055571"></p><p>这个$f<em>W$相当于途中的绿色模块，他对old state$h</em>{t-1}$和当前输入的状态$x_t$做运算得到下一个隐藏态$h_t$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418222647581.png" srcset="/img/loading.gif" alt="image-20210418222647581"></p><p>比如：上例就是$h_t$首先不断更新，最后得到$h_t$,然后做一个全连接层得到的$y_t$</p><p>我们把这个计算过程展开会更好的理解RNN是如何处理序列的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418223037106.png" srcset="/img/loading.gif" alt="image-20210418223037106"></p><p>这样我们就可以预策每个时刻的$y$了。</p><p>同时我们可以把每个时刻的loss和总共的loss加上去：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418223223212.png" srcset="/img/loading.gif" alt="image-20210418223223212"></p><p>当然如果哦我们在做多对一的任务，比如给出一段文字/视频，输出表达的情感，那么只需要最后的输出即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418223316380.png" srcset="/img/loading.gif" alt="image-20210418223316380"></p><p>当然还有1对多问题的结构：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418223343273.png" srcset="/img/loading.gif" alt="image-20210418223343273"></p><p>Sequence to Sequence结构是一个<strong>多对一</strong> 和 <strong>一对多</strong>组合的情况：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418223453678.png" srcset="/img/loading.gif" alt="image-20210418223453678"></p><p>可以理解为输入一段文字得到一个表达，然后表达在转化为一段文字，多用于翻译中。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418224225774.png" srcset="/img/loading.gif" alt="image-20210418224225774"></p><p>一个预策hello的例子，上图是训练阶段：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418224853371.png" srcset="/img/loading.gif" alt="image-20210418224853371"></p><p>测试阶段，我们需要把softmax的得分变成一个概率分布，然后再抽取字母。</p><p>​    这样做的好处是，想象prepare,prescent这两个单词的前缀 都是pre，如果我们只选择得分最多的作为结果，那么结果就会过于单一，如果采用概率来抽样，那么prepare和prescent都有机会被学习到。这使得我们的输出结果更加多样化。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418225848525.png" srcset="/img/loading.gif" alt="image-20210418225848525"></p><p>上图这种训练方法是很难训练的，因为我们需要把所有的loss算一遍返回总的loss，然后算梯度再更新，这样迭代一次却需要把整个全部计算一次，同时这也会导致内存不够。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210418230004344.png" srcset="/img/loading.gif" alt="image-20210418230004344"></p><p>一种Truncated Backpropagation through time(TBPTT)的方法把很长的序列分解为每几十个一组。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419131435574.png" srcset="/img/loading.gif" alt="image-20210419131435574"></p><p>对于RNN这样的网络，是很容易出现梯度爆炸/梯度弥散的：</p><p>对于梯度爆炸可以用梯度阶段(Gradient clipping)来解绝：</p><p>如果梯度的L2范数大于某一个阈值，就把他截断并做一个缩小的除法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419131624732.png" srcset="/img/loading.gif" alt="image-20210419131624732"></p><p>而对于梯度消失，一般我们会选择一个换一个更好的RNN结构来做，这也是LSTM出现的原因。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419132234399.png" srcset="/img/loading.gif" alt="image-20210419132234399"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419132608763.png" srcset="/img/loading.gif" alt="image-20210419132608763"></p><p>LSTM中有两个hidden state(隐藏状态)，一个是和vanilla RNN一样的$h_{t-1}$，另一个是$c_t$称为cell state。这个cell state类似于保留在LSTM内部的隐藏状态。</p><p>计算时首先我们可以计算出$i,f,o,g$ 的值，然后用这些值去更新$c_t$, 然后再用$c_t$计算处next step的$h_t$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419133541096.png" srcset="/img/loading.gif" alt="image-20210419133541096"></p><p>$i$：input gate，输入门，表示神经元要接受多少新的输入信息</p><p>$f$：forget gate，遗忘门，我们要以往多少之前的神经元记忆</p><p>$o$：output gate，输出门，表示我们要输出多少信息给外部</p><p>$g$: Gate gate，表示我们想让input神经元有多少信息</p><p>$i,f,o$的范围由于sigmoid导致范围是0-1，而$g$的范围由于tanh的作用是-1到1.</p><p>其中$f$ 为0说明我们想要忘记上一个cell state的值，是1说明要记住。</p><p>一个具体的结构图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419135020028.png" srcset="/img/loading.gif" alt="image-20210419135020028"></p><p>LSTM有两个好处：</p><ul><li><p>LSTM做bp时通过forget gate时是逐元素相乘，这比矩阵乘法快很多</p></li><li><p>LSTM会在不同的时间乘以不同的forget gate，而在vanilla RNN我们只会不断乘一个不变的$W$，这就很容易导致梯度爆炸/弥散。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210419151524591.png" srcset="/img/loading.gif" alt="image-20210419151524591"></p><p>和ResNet类似，LSTM也为网络提供了一个快速进行反向传播的通道。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH7-CNN框架</title>
    <link href="/2021/04/17/CS231n-CH7-CNN%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/04/17/CS231n-CH7-CNN%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="CNN框架"><a href="#CNN框架" class="headerlink" title="CNN框架"></a>CNN框架</h1><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415173026774.png" srcset="/img/loading.gif" alt="image-20210415173026774"></p><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>AlexNet结构如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415173124918.png" srcset="/img/loading.gif" alt="image-20210415173124918"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415173358095.png" srcset="/img/loading.gif" alt="image-20210415173358095"></p><p>网络结构：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415174601793.png" srcset="/img/loading.gif" alt="image-20210415174601793"></p><p>第一层有96个卷积核，每个卷积核的大小是11*11*3,所以第一层输出的大小是: 55*55*96。</p><p>那么第一层的参数有：(11*11*3)*96 = 35K.</p><p>第二层，即POOL1，这层在做Max pooling输出的结果大小是27*27*96。</p><p>这一层没有参数，因为是在做Max Pooling，取最大值即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415175146259.png" srcset="/img/loading.gif" alt="image-20210415175146259"></p><p>AlexNet的一些细节：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210415175307835.png" srcset="/img/loading.gif" alt="image-20210415175307835"></p><p>第一次使用ReLu损失函数，做了Normalizaiton，有很多数据增强的数据，dropout的概率是0.5，batchsize为128，梯度下降使用的是SGD Momentum,学习率1e-2开始训练，weight decay设置为5e-4，还用了模型集成，训练多个模型对他们取平均…</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416163734112.png" srcset="/img/loading.gif" alt="image-20210416163734112"></p><p>我们之前算第二层的大小是55*55*96 ，而上图红色框种的深度是48，这是由于当时最好的GPU也只是GTX580，显存只有3G，所以不得不采用分开的训练方式。</p><h2 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h2><p><strong>这篇文章写的很好：</strong></p><p>一文读懂VGG网络 - Amusi的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/41423739" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41423739</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416165807394.png" srcset="/img/loading.gif" alt="image-20210416165807394"></p><p>VGGNet一般16-19层，它只包含3*3的卷积(pad 1),Max Pooling是2*2的。</p><ul><li><p><strong>为什么用小的卷积核？</strong></p><p><strong>reference：</strong><a href="https://zhuanlan.zhihu.com/p/41423739" target="_blank" rel="noopener">知乎：一文读懂VGG网络</a></p><p>​    VGG16相比AlexNet的一个改进是<strong>采用连续的几个3x3的卷积核代替AlexNet中的较大卷积核（11x11，7x7，5x5）</strong>。对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核是优于采用大的卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。</p><p>​    简单来说，在VGG中，使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5*5卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。</p><p>​    比如，3个步长为1的3x3卷积核的一层层叠加作用可看成一个大小为7的感受野（其实就表示3个3x3连续卷积相当于一个7x7卷积），其参数总量为 $3\times(9\times C^2)$ ，如果直接使用7x7卷积核，其参数总量为 $49\times C^2$ ，这里 C 指的是输入和输出的通道数。很明显，$27\times C^2\le 49\times C^2$，即<strong>减少了参数</strong>；而且3x3卷积核有利于更好地保持图像性质。</p></li><li><p><strong>怎么使用2个3x3卷积核可以来代替5*5卷积核</strong></p></li></ul><p>想做到2个3*3卷积核可以来代替5*5卷积核,也就是对于同样一个单位的感受野，2个3*3的卷积核也可以看到5*5的感受野：</p><p>可以这样来做，通过两层的3*3卷积使得第三层的一个单位可以看到第一层5*5的视野：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416180456519.png" srcset="/img/loading.gif" alt="image-20210416180456519"></p><h2 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416184736509.png" srcset="/img/loading.gif" alt="image-20210416184736509"></p><p>视频讲的有带点乱,找了些资料梳理了下。</p><p>reference：</p><p><a href="https://zhuanlan.zhihu.com/p/73857137" target="_blank" rel="noopener">深度学习|经典网络 GoogLeNet（一）</a></p><p><a href="https://zhuanlan.zhihu.com/p/32702031" target="_blank" rel="noopener">深入理解GoogLeNet结构（原创）</a></p><ul><li><strong>网络结构：</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/v2-766c3f59d3791da39ad805606d6445f6_r.jpg" srcset="/img/loading.gif" alt="v2-766c3f59d3791da39ad805606d6445f6_r"></p><ul><li><p>GoogleNet新提出了Inception，这是什么？</p><p>Inception就是把多个卷积或池化操作，放在一起组装成一个网络模块，设计神经网络时以模块为单位去组装整个网络结构。模块如下图所示</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416193845211.png" srcset="/img/loading.gif" alt="image-20210416193845211"></p><p>​        在未使用这种方式的网络里，我们一层往往只使用一种操作，比如卷积或者池化，而且卷积操作的卷积核尺寸也是固定大小的。但是，<strong>在实际情况下，在不同尺度的图片里，需要不同大小的卷积核，这样才能使性能最好，或者或，对于同一张图片，不同尺寸的卷积核的表现效果是不一样的，因为他们的感受野不同</strong>。所以，<strong>我们希望让网络自己去选择，Inception便能够满足这样的需求</strong>，一个Inception模块中并列提供多种卷积核的操作，网络在训练的过程中通过调节参数自己去选择使用，同时，<strong>由于网络中都需要池化操作，所以此处也把池化层并列加入网络中</strong>。</p><ul><li><p><strong>为什么要提出Inception？</strong></p><p>一般来说，提升网络性能最直接的办法就是增加网络深度和宽度，但一味地增加，会带来诸多问题：<br>1）参数太多，如果训练数据集有限，很容易产生过拟合；<br>2）网络越大、参数越多，计算复杂度越大，难以应用；<br>3）网络越深，容易出现梯度弥散问题（梯度越往后穿越容易消失），难以优化模型。<br>我们希望在增加网络深度和宽度的同时减少参数，为了减少参数，自然就想到将全连接变成稀疏连接。但是在实现上，全连接变成稀疏连接后实际计算量并不会有质的提升，因为大部分硬件是针对密集矩阵计算优化的，稀疏矩阵虽然数据量少，但是计算所消耗的时间却很难减少。在这种需求和形势下，Google研究人员提出了Inception的方法：<strong>能更高效的利用计算资源，在相同的计算量下能提取到更多的特征，从而提升训练结果</strong>。</p></li><li><p><strong>实际中需要什么样的Inception？</strong></p><p>我们在上面提供了一种Inception的结构，但是这个结构存在很多问题，是不能够直接使用的。首要问题就是参数太多，导致特征图厚度太大。为了解决这个问题，作者在其中加入了1X1的卷积核，改进后的Inception结构如下图</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416194145863.png" srcset="/img/loading.gif" alt="image-20210416194145863"></p><p>​    这样做有两个好处，首先是大大<strong>减少了参数量</strong>，其次，<strong>增加的1X1卷积后面也会跟着有非线性激励，这样同时也能够提升网络的表达能力</strong>。</p><ul><li><p><strong>1*1卷积有什么用？</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417121105534.png" srcset="/img/loading.gif" alt="image-20210417121105534"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417123543710.png" srcset="/img/loading.gif" alt="image-20210417123543710"></p><p>如果不加1*1的卷积，那么对于上图的计算量高达8.54亿次计算。因此加上一个1*1的卷积的原因就是降低feature map的深度，如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417121347102.png" srcset="/img/loading.gif" alt="image-20210417121347102"></p><p>因此做完1*1卷积后，结果为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417121552106.png" srcset="/img/loading.gif" alt="image-20210417121552106"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417121724855.png" srcset="/img/loading.gif" alt="image-20210417121724855"></p><p>现在的操作降低到了3.58亿次操作。</p></li></ul><p>  <strong>知乎上的解释：</strong></p><p>  <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416195129813.png" srcset="/img/loading.gif" alt="image-20210416195129813"></p><p>  <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416194913131.png" srcset="/img/loading.gif" alt="image-20210416194913131"></p><p>  这里要注意：题目中所说的1*1是对深度做操作的，1*1卷积就是把feature map上的每个位置的c个channel做了一次重新组合,一般用来提高或者降低channel数。</p><p>  <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210416194932237.png" srcset="/img/loading.gif" alt="image-20210416194932237"></p><ul><li><p><strong>多个尺寸上进行卷积再聚合的原因？</strong></p><p>可以看到对输入做了4个分支，分别用不同尺寸的filter进行卷积或池化，最后再在特征维度上拼接到一起。这种全新的结构有什么好处呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417151459105.png" srcset="/img/loading.gif" alt="image-20210417151459105"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417155307211.png" srcset="/img/loading.gif" alt="image-20210417155307211"></p></li></ul><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p><strong>Reference：</strong></p><p>Resnet到底在解决一个什么问题呢？ - 薰风初入弦的回答 - 知乎 <a href="https://www.zhihu.com/question/64494691/answer/786270699" target="_blank" rel="noopener">https://www.zhihu.com/question/64494691/answer/786270699</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417124340194.png" srcset="/img/loading.gif" alt="image-20210417124340194"></p><p>152层…</p><p>起因是有人做了实验，发现56层不仅在训练集上效果好(当然这是应该的，人们认为这是过拟合的原因)，可是在测试集上依然比20层的网络错误率低，这就说明56层的网络并没有过拟合。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417124603813.png" srcset="/img/loading.gif" alt="image-20210417124603813"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417125452353.png" srcset="/img/loading.gif" alt="image-20210417125452353"></p><p>​    当我们堆叠一个模型时，理所当然的会认为效果会越堆越好。因为，假设一个比较浅的网络已经可以达到不错的效果，<strong>那么即使之后堆上去的网络什么也不做，模型的效果也不会变差</strong>。然而深度学习很难做到这一点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417160620669.png" srcset="/img/loading.gif" alt="image-20210417160620669"></p><p>​    这样层层的向前传播使得开始的信息还能被完整的保留的可能性太小。</p><p>​    ResNet的出现就是为了<strong>让模型的内部结构至少有恒等映射的能力</strong>。以保证在堆叠网络的过程中，网络至少不会因为继续堆叠而产生退化。所以这也是ResNet敢用152层的原因。</p><ul><li><strong>ResNet做是如何做到恒等映射的呢？</strong></li></ul><p>前面提到了学习一个恒等映射很难，但是学习一个全为0的函数很简单，因此ResNet把网络设计为$H(x) = F(x) + x$,即把恒等映射作为网络的一部分。由于我们的学习目标是$F(x)$，就可以把问题转化为学习残差函数$F(x) = H(x) -x$.  </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210417162541557.png" srcset="/img/loading.gif" alt="image-20210417162541557"></p><p>这样当$F(x)=0$（这个是易学的）时即说明这是一个恒等映射($H(x) = x$)</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH6-训练神经网络-下</title>
    <link href="/2021/04/13/CS231n-CH6-%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E4%B8%8B/"/>
    <url>/2021/04/13/CS231n-CH6-%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="训练神经网络-下"><a href="#训练神经网络-下" class="headerlink" title="训练神经网络(下)"></a>训练神经网络(下)</h1><h2 id="更好的优化"><a href="#更好的优化" class="headerlink" title="更好的优化"></a>更好的优化</h2><h3 id="SGD的缺点："><a href="#SGD的缺点：" class="headerlink" title="SGD的缺点："></a>SGD的缺点：</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412155433357.png" srcset="/img/loading.gif" alt="image-20210412155433357"></p><p>SGD在某些情况下效果并不会很好，比如loss在竖直方向上下降的很快，在另两个维度上loss下降的很慢，这就会导致得到上下剧烈波动的线。在三维空间如此，在高维空间上更容易出现这个问题。最优化过程会变得很慢。</p><p>SGD还有一个缺点就是无法处理鞍点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412160642413.png" srcset="/img/loading.gif" alt="image-20210412160642413"></p><p>即梯度=0，但是却不是极大值/极小值。</p><p>梯度到这个地方时由于梯度变为了0，会导致停止迭代。</p><p>在这个一维的情况下，由于一边会导致loss上升，一边会导致loss下降，也就是鞍点时或导致梯度为0无法迭代更新，但这个一般不会遇到，因为几率很小。但如果是在一个大型的网络上，当你的参数有成百上千个，在某个方向上会使loss上升，在另一个方向上会使loss下降，这个其实很常见的情况。此时梯度为0的几率就大了很多。</p><p>还有一个问题就是由于SGD是选一个mini-batch来作为下降的梯度，但是数据中有噪声的时候，就会导致梯度下降的每一步都不是特别准确，从而导致下降十分缓慢。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412161721767.png" srcset="/img/loading.gif" alt="image-20210412161721767"></p><h3 id="SGD-Momentum-动量梯度下降"><a href="#SGD-Momentum-动量梯度下降" class="headerlink" title="SGD+Momentum(动量梯度下降)"></a>SGD+Momentum(动量梯度下降)</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412162046820.png" srcset="/img/loading.gif" alt="image-20210412162046820"></p><p>思想就是用速度作为新的梯度。这样在一个很大的下坡(梯度变大)时，速度会累计变大，这样就不会陷入到局部最小值和鞍点，同时如果到了一个比较平的面，即梯度变化不明显时，$\rho$ 作为摩擦系数会使得速度不断减小。最后速度不在变换。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412163147835.png" srcset="/img/loading.gif" alt="image-20210412163147835"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412163416416.png" srcset="/img/loading.gif" alt="image-20210412163416416"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412165012648.png" srcset="/img/loading.gif" alt="image-20210412165012648"></p><p>还有一种叫做<code>Nesterov Momentum</code>的SGD，在之前的动量梯度下降中我们是通过速度和梯度的求和得到新的速度，这个速度和真正最好的方向大致相同。而Nesterov Momentum也是求一个速度，然后先用这个速度去更新，然后更新完成后再算他的梯度，然后再返回更新前的状态，用更新前的速度+梯度去真正的做更新。</p><p>可以作换元得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412165237203.png" srcset="/img/loading.gif" alt="image-20210412165237203"></p><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412172907218.png" srcset="/img/loading.gif" alt="image-20210412172907218"></p><p>加了一个放缩项，也就是如果你在某一个维度上的梯度特别大，那么就grad_square会帮你更新时减少他的影响。</p><p><code>AdaGrad</code>的问题在于他的step-size会越来越小，在学习目标是一个凸函数的时候，有理论证明这会表现得不错。但是在非凸函数上就会导致在局部极值点上被困住。</p><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p>RMSProp是在AdaGrad基础上产生的变体，他除了每次对梯度进行叠加外，还增加了一个类似于摩擦系数/衰减系数的东西，来对梯度进行减少。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412173409413.png" srcset="/img/loading.gif" alt="image-20210412173409413"></p><p>因此在局部极值点的时候，grad_square由于衰减系数会下降，梯度此时更新的步长反而会变大。</p><p>RMSProp会曲折得找最小值，而SGD Momentum会先绕过最小值点然后最后再回到loss最小的地方。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412174238020.png" srcset="/img/loading.gif" alt="image-20210412174238020"></p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412174828940.png" srcset="/img/loading.gif" alt="image-20210412174828940"></p><p>这种方法搞了两个动量，把动量和RMSProp融合在了一起。</p><p>但是在第一步我们会发现 第二动量(Second Momentum)是一个非常小的值，那么x第一步就会走很大的一步。因此可以加入无偏估计：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413205544597.png" srcset="/img/loading.gif" alt="image-20210413205544597"></p><p>至于无偏估计的设置成这个样子的推到在：</p><p>Adam算法中的一阶矩和二阶矩的无偏估计如何证明是无偏的？ - 湖海的回答 - 知乎 <a href="https://www.zhihu.com/question/325651810/answer/1120697058" target="_blank" rel="noopener">https://www.zhihu.com/question/325651810/answer/1120697058</a></p><p><strong>一般Adam是我们的首选。</strong></p><h3 id="衰减的学习率"><a href="#衰减的学习率" class="headerlink" title="衰减的学习率"></a>衰减的学习率</h3><p>无论是什么什么样的梯度下降，学习率这个超参数都是避不开的，有时候学习率可以逐渐衰减也是一种方法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413210346068.png" srcset="/img/loading.gif" alt="image-20210413210346068"></p><p>但是实际情况下不要直接让他衰减，应该先用没有衰减的看一看效果，观察loss的变化情况，然后再加上衰减试一试。</p><h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化(Regularization)"></a>正则化(Regularization)</h2><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>一些常见的regularization</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413211802885.png" srcset="/img/loading.gif" alt="image-20210413211802885"></p><p>神经网络种我们常用$Dropout$这种方法：每层随机的把一些神经元的值置为0</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413211838808.png" srcset="/img/loading.gif" alt="image-20210413211838808"></p><p>代码实现只需要加上这几行：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413212154813.png" srcset="/img/loading.gif" alt="image-20210413212154813"></p><p><strong>为什么这个$Dropout$想法是可取的呢？</strong></p><p>一种解释是：比如用网络去判断是否是一个猫，你列出了一堆的特征，是否有毛，有爪子….，而dropout删掉了一些特征，这样网络就不能完全依赖这些特征组合，而是真正的学到了一些东西，这就好比我每次都告诉你一步一步怎么做你是学不会东西的，但是我把其中一些部分去掉你来学习就会学到属于网络自己的东西，这样网络就需要零散不同的特征来判断。这一定程度上就防止了过拟合。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413212733741.png" srcset="/img/loading.gif" alt="image-20210413212733741"></p><p>还有一种解释的理解方法是：由于dropout的存在，我们在dropout后用的是一个子网络来计算下面的，每一个dropout都会产生一个子网络，这就像一堆子网络用一个共享参数的集成学习。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413213122752.png" srcset="/img/loading.gif" alt="image-20210413213122752"></p><p>当我们测试时，Dropout的随机性会带来结果不确定，比如我们训练好一个网络，昨天测试还是人，今天就变成了猫，即使你的网络已经训练完成，参数也设定完成，但是随机使一些神经元失效依然会导致测试结果的不稳定。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413213637147.png" srcset="/img/loading.gif" alt="image-20210413213637147"></p><p>因此此时的网络类似于上述的式子，一种直观的想法是我们可以用平均来确定结果：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413213740645.png" srcset="/img/loading.gif" alt="image-20210413213740645"></p><p>然而这个式子几乎是不可能处理的。</p><p>我们也许可以这样处理，考虑一个简单的神经元：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413213939070.png" srcset="/img/loading.gif" alt="image-20210413213939070"></p><p>我们去求他的score的期望：得分的期望是不做dropout的一半。</p><p>因此我们可以在训练时用dropout，而在测试时把dropout去掉，但做传递得分时我们只传递一半。</p><p>这样用一种近似的方法求了原本随机结果的平均。</p><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p>当然还记得Batch Normalization吗？我们一般认为加了BN就不用Dropout了，具体原因可以看上一节的BN。</p><h3 id="数据增强-Data-Augumentation"><a href="#数据增强-Data-Augumentation" class="headerlink" title="数据增强(Data Augumentation)"></a>数据增强(Data Augumentation)</h3><p>还有一种正则化的思想是：<strong>数据增强(Data Augumentation)</strong></p><p>数据增强从现有数据中生成更多有用数据的重要技术，用于训练实用的、通用的卷积神经网络，在不改变神经网络结构的前提下能有效降低过拟合，是一种有效的正则方法。目前深度学习中的数据增强方法大致有三类：</p><ul><li>空间变换</li><li>颜色失真</li><li>信息丢弃</li></ul><p>Realted:【技术综述】深度学习中的数据增强方法都有哪些？ - 言有三的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/61759947" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61759947</a></p><h3 id="Dropconnect"><a href="#Dropconnect" class="headerlink" title="Dropconnect"></a>Dropconnect</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413215443841.png" srcset="/img/loading.gif" alt="image-20210413215443841"></p><p>这种方法把层间的权重w矩阵的一部分置为了0。</p><h3 id="Stochastic-Depth"><a href="#Stochastic-Depth" class="headerlink" title="Stochastic Depth"></a>Stochastic Depth</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413220338594.png" srcset="/img/loading.gif" alt="image-20210413220338594"></p><p>训练的时候只用部分层，测试的时候用所有层。</p><p>太过于学术界的trick，实际上没多少人用。</p><h2 id="迁移学习-Transfer-learning"><a href="#迁移学习-Transfer-learning" class="headerlink" title="迁移学习(Transfer learning)"></a>迁移学习(Transfer learning)</h2><p>Transfer Learning帮助你没有很大的数据集也可以很好的训练网络。</p><p><strong>下面引用自：</strong></p><p>请问具体什么是迁移学习？ - Chuang的回答 - 知乎 <a href="https://www.zhihu.com/question/345745588/answer/826649936" target="_blank" rel="noopener">https://www.zhihu.com/question/345745588/answer/826649936</a></p><p>迁移学习(Transfer learning) 顾名思义就是把已训练好的模型（预训练模型）参数迁移到新的模型来帮助新模型训练。考虑到大部分数据或任务都是存在相关性的，所以通过迁移学习我们可以将已经学到的模型参数（也可理解为模型学到的知识）通过某种方式来分享给新模型从而加快并优化模型的学习效率不用像大多数网络那样从零学习。</p><p>其中，实现迁移学习有以下三种手段：</p><ol><li><strong>Transfer Learning</strong>：冻结预训练模型的全部卷积层，只训练自己定制的全连接层。</li><li><strong>Extract Feature Vector</strong>：先计算出预训练模型的卷积层对所有训练和测试数据的特征向量，然后抛开预训练模型，只训练自己定制的简配版全连接网络。</li><li><strong>Fine-tuning</strong>：冻结预训练模型的部分卷积层（通常是靠近输入的多数卷积层，因为这些层保留了大量底层信息）甚至不冻结任何网络层，训练剩下的卷积层（通常是靠近输出的部分卷积层）和全连接层。</li></ol><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210413221816198.png" srcset="/img/loading.gif" alt="image-20210413221816198"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH5-训练神经网络(上)</title>
    <link href="/2021/04/12/CS231n-CH5-%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E4%B8%8A/"/>
    <url>/2021/04/12/CS231n-CH5-%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="训练神经网络-上"><a href="#训练神经网络-上" class="headerlink" title="训练神经网络(上)"></a>训练神经网络(上)</h1><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p> <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210410232705398.png" srcset="/img/loading.gif" alt="image-20210410232705398"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210410233025296.png" srcset="/img/loading.gif" alt="image-20210410233025296"></p><p>问题：</p><ul><li><p>当x是一个很大/很小的区域时，梯度是一个十分接近0的数值，这会导致upstream如果是0，那么返回值就会十分小。这会使得梯度逐渐消失。</p></li><li><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411002045387.png" srcset="/img/loading.gif" alt="image-20210411002045387"></p><p>比如这个方程的对$x$的梯度是一堆$w$,我们假设数据的x要么都是大于0/要么都是小于0的，那么$\Sigma w_ix_i+b$这个式子对$w$求梯度是一堆$x$,我们上面假设了这里都是大于0，那么这个梯度也都大于0，同时$f$对$\Sigma w_ix_i+b$求导，由于f在各个点导数倒是正的，所以梯度恒大于0，这就导致了$f$对$w$求导是恒正的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411003604753.png" srcset="/img/loading.gif" alt="image-20210411003604753"></p><p>而这样会导致无法想着正确的梯度去走，w增加的永远是正值/负值，这样会导致收敛缓慢。无法向着正确的方向去走，我们仔细想想就会发现数据x中全正/全负是我们无法改变的，真正原因是因为sigmoid函数梯度恒大于0，这样就导致了梯度方向的局限。因此这也是sigmoid的缺点。当然，如果我们的数据是zero-mean的，也就是说有正有负的那种数据，sigmoid是不会影响什么的。总之，两个限制(数据全正全负，sigmoid梯度恒大于0)，有一个被解决就可以快速地梯度下降。</p></li><li><p>exp()计算比较费时。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411215745708.png" srcset="/img/loading.gif" alt="image-20210411215745708"></p><ul><li>$tanh$和$sigmiod$一样在x很大/很小的时候梯度几乎为0，这会导致upstream是0，那么返回值就会十分小。这会使得梯度逐渐消失。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411215952528.png" srcset="/img/loading.gif" alt="image-20210411215952528"></p><ul><li>ReLU梯度不会消失</li><li>计算高效(不包含exp())</li><li>收敛快</li><li>更符合生物上的特点</li></ul><p>缺点</p><ul><li><p>缺点是0点处不可导</p></li><li><p><strong>Dead ReLU Problem(神经元坏死现象)</strong>：ReLU在负数区域被kill的现象叫做dead relu。ReLU在训练的时很“脆弱”。在x&lt;0时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新。</p><p><strong>产生</strong>这种现象的两个<strong>原因</strong>：参数初始化问题；learning rate太高导致在训练过程中参数更新太大。</p><p><strong>解决方法</strong>：采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411221752359.png" srcset="/img/loading.gif" alt="image-20210411221752359"></p><p>和ReLU比，在负坐标上梯度不是0了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411222029682.png" srcset="/img/loading.gif" alt="image-20210411222029682"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411222541954.png" srcset="/img/loading.gif" alt="image-20210411222541954"></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>我们一般会对<strong>数据做中心化（零均值化zero-mean）</strong>，原因就是上面提到的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210411222827272.png" srcset="/img/loading.gif" alt="image-20210411222827272"></p><p>对训练的图像求个平均，然后让每张图像都减去这个平均图像。</p><p><strong>权重的初始化问题：</strong></p><p>深度前馈网络与Xavier初始化原理 - 知乎 <a href="https://zhuanlan.zhihu.com/p/27919794" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27919794</a></p><h2 id="批量归一化-Batch-Normalization"><a href="#批量归一化-Batch-Normalization" class="headerlink" title="批量归一化(Batch Normalization)"></a>批量归一化(Batch Normalization)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412114711250.png" srcset="/img/loading.gif" alt="image-20210412114711250"></p><p>这个式子可以推一推，就是把x的分布变成了均值为0，方差为1的一个分布。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412115256170.png" srcset="/img/loading.gif" alt="image-20210412115256170"></p><p>我们通常会那一个batch的数据，然后对每一维度求期望，方差，然后归一化这些数据。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412115507181.png" srcset="/img/loading.gif" alt="image-20210412115507181"></p><p>Batch Normalization通常放在全连接层后，卷积层后，非线性层前。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412115942446.png" srcset="/img/loading.gif" alt="image-20210412115942446"></p><p>我们可以对Batch Nomalization后的$x$进行缩放，$y = \gamma x+\beta$,其中如果我们的$\gamma=\sqrt{Var[x]},\beta=E[x]$时，就相当于我们没做Batch normaliazation，因此我们的$\gamma,\beta$在学习中也可以恢复到不做normalization的情况，这样加入batch normalization的效果不好时也可以保证恢复回来。</p><p>总体来说，<code>Batch Normalization</code>的过程是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412121031927.png" srcset="/img/loading.gif" alt="image-20210412121031927"></p><p>BN的优点：</p><ul><li><p>可以使用更高的学习率</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412130421433.png" srcset="/img/loading.gif" alt="image-20210412130421433"></p><p>原因大概解释一下就是：首先我们要知道高学习率通常会导致梯度爆炸/梯度消失，这是因为底层的网络对高层的网络会有叠加的影响。而BN由于对层进行归一化，因此这组织了某层输出的值会变得过大或者过小，因此这直接的解绝了梯度爆炸/梯度消失的问题。 因此我们此时就可以用更高的学习率。</p><p>同时下面这个数学上的解释也是work的：</p><p>深度学习中 Batch Normalization为什么效果好？ - Juliuszh的回答 - 知乎 <a href="https://www.zhihu.com/question/38102762/answer/302841181" target="_blank" rel="noopener">https://www.zhihu.com/question/38102762/answer/302841181</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412131651757.png" srcset="/img/loading.gif" alt="image-20210412131651757"></p></li><li><p>可以防止过拟合，当然作者在原文章中并没拿出什么有力的论证，所以只是含糊的说有了BN就可以不要dropout层了。</p></li></ul><p>对于训练，学习率的一般通过在[1e-5,1e-3]做validation来选择。</p><p>超参数的除了grid search(即一组一组的参数一个一个去做validation，哪儿个好用哪儿个)。也可以random  search(给每个超参数设定一个分布，然后去对每个参数从他所属的分布中抽样，用这样的方法获得一组超参数，然后再去validation)。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412142559169.png" srcset="/img/loading.gif" alt="image-20210412142559169"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412142757950.png" srcset="/img/loading.gif" alt="image-20210412142757950"></p><p>黄色：过高的学习率会导致梯度爆炸</p><p>蓝色：低的学习率导致loss下降缓慢</p><p>绿色：高的学习率也会导致无法陷入局部最优解</p><p>红色：好的学习率，loss下降快。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412142959585.png" srcset="/img/loading.gif" alt="image-20210412142959585"></p><p>一般这样开始loss不下降，在某一个节点突然下降，说明<strong>初始化做的不好</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210412143103173.png" srcset="/img/loading.gif" alt="image-20210412143103173"></p><p>如果validation和train的差别太大，说明是overfitting了，可以试着做一些正则化。如果差别不大且两者准确率都不高，那就应该去找模型的问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH4-卷积神经网络</title>
    <link href="/2021/04/09/CS231n-CH4-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/04/09/CS231n-CH4-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>全连接层：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409162420380.png" srcset="/img/loading.gif" alt="image-20210409162420380"></p><p>卷积层(convolution Layer):</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409162546045.png" srcset="/img/loading.gif" alt="image-20210409162546045"></p><p>卷积网络就是一系列的卷积层的叠加，并加上各种各样的激活函数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409163643703.png" srcset="/img/loading.gif" alt="image-20210409163643703"></p><p>随着层数的增加，所包含的信息越来越多。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409163844238.png" srcset="/img/loading.gif" alt="image-20210409163844238"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409164331727.png" srcset="/img/loading.gif" alt="image-20210409164331727"></p><p>卷积计算过程：</p><p>我们可以一步一步的来走，那么得到的就是 5*5的结果</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409164505656.png" srcset="/img/loading.gif" alt="image-20210409164505656"></p><p>但是步长调整到2时：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409164739985.png" srcset="/img/loading.gif" alt="image-20210409164739985"></p><p>那么得到的就是一个3*3的结果。</p><p>步长为3时：(7-3)/3+1 = 2.33 所以这样会导致不平衡的结果，所以步长为3不可取。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409164831571.png" srcset="/img/loading.gif" alt="image-20210409164831571"></p><p>我们也可以在周围添上0，这样就可以在边缘上做卷积：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409165253842.png" srcset="/img/loading.gif" alt="image-20210409165253842"></p><p>例如：一个32*32*3的输入，用10个5*5*3的卷积核去做卷积，边缘填充为2,步长为1。那么最后得到的就是32*32*10的输出，首先是32怎么得出来的呢：</p><p>(32+2*2-5)/1 + 1 = 32。</p><p>由于有10个卷积核，那么就是10层。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409170501645.png" srcset="/img/loading.gif" alt="image-20210409170501645"></p><p>那么这个例子中包含多少参数呢：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409171108179.png" srcset="/img/loading.gif" alt="image-20210409171108179"></p><p>首先是每kernel的大小是5*5*3 = 75,还有一个bias项，所以一共是76，由于有10层，那么就是760个参数。</p><p>1*1的卷积也有意义：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409171525184.png" srcset="/img/loading.gif" alt="image-20210409171525184"></p><p>可以对深度进行操作。</p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409172416207.png" srcset="/img/loading.gif" alt="image-20210409172416207"></p><p>感受野(neuron view)：一个神经元所看到的视野，如上图蓝色面上的一个神经元是由卷积核和input做卷积得到的，他们操作的范围是5*5的范围。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409173042186.png" srcset="/img/loading.gif" alt="image-20210409173042186"></p><p>池化层(pooling layer)做的是降采样(downsampling)：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409173144211.png" srcset="/img/loading.gif" alt="image-20210409173144211"></p><p>我们一般不会做深度方向的池化，只对平面做。所以我们池化后的深度是不会变的。</p><p>一种常用的池化方法是Max Pooling。</p><p>Max Pooling：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210409173511648.png" srcset="/img/loading.gif" alt="image-20210409173511648"></p><p>除了pooling可以降采样，我们调整卷积时的步长也可以做到降采样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH3-介绍神经网络</title>
    <link href="/2021/04/08/CS231n-CH3-%E4%BB%8B%E7%BB%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/04/08/CS231n-CH3-%E4%BB%8B%E7%BB%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍神经网络"><a href="#介绍神经网络" class="headerlink" title="介绍神经网络"></a>介绍神经网络</h1><h2 id="反向传播-backpropagation"><a href="#反向传播-backpropagation" class="headerlink" title="反向传播(backpropagation)"></a>反向传播(backpropagation)</h2><p>梯度的计算是通过计算图 ：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408173032210.png" srcset="/img/loading.gif" alt="image-20210408173032210"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408173201444.png" srcset="/img/loading.gif" alt="image-20210408173201444"></p><p>链式法则告诉我们，我们只需要把计算图上的每一段相邻的梯度算出来，我们连乘上他们就是最后一个变量对最前面一个变量的梯度。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408174230201.png" srcset="/img/loading.gif" alt="image-20210408174230201"></p><p><strong>backpropagation的运行方式：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408174650557.png" srcset="/img/loading.gif" alt="image-20210408174650557"></p><p><strong>一个比较复杂的例子：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408175229409.png" srcset="/img/loading.gif" alt="image-20210408175229409"></p><p>对于<strong>add门</strong>，求对两边梯度都是1，因此直接传过去梯度upstream gradient即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408180823411.png" srcset="/img/loading.gif" alt="image-20210408180823411"></p><p>对于<strong>max门</strong>，local gradient只会对其中较大的一个变量的梯度1，另一个为0.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408180512330.png" srcset="/img/loading.gif" alt="image-20210408180512330"></p><p>对于<strong>mul门</strong>，对其中一个求梯度就是另一个变量的值，如下图，x<em>y对x求梯度就是y，也就是-4，然后upstream gradient是2，2\</em>(-4)=-8</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408180924815.png" srcset="/img/loading.gif" alt="image-20210408180924815"></p><p>假如变量是高维的，做法和刚才一样，只不过我们的梯度变成了雅可比矩阵。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408181616473.png" srcset="/img/loading.gif" alt="image-20210408181616473"></p><p>如果我们对向量求导，即x对每个4096维的向量的每个元素求偏导，那么结果这个雅可比矩阵就是4096*4096的矩阵，这个矩阵太过于大了。</p><p>其实这个矩阵存在大量0，我们只需要记录非零项即可，这样就大大减少了空间的开销。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408202521881.png" srcset="/img/loading.gif" alt="image-20210408202521881"></p><p>所以梯度就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408202738112.png" srcset="/img/loading.gif" alt="image-20210408202738112"></p><h2 id="神经网络-Neural-Network"><a href="#神经网络-Neural-Network" class="headerlink" title="神经网络(Neural Network)"></a>神经网络(Neural Network)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408205641681.png" srcset="/img/loading.gif" alt="image-20210408205641681"></p><p>$f=Wx$是一种最简单的线性的网络。</p><p>我们可以组成一个两层的网络，其中一层是$W_2$，另一层是$max(0,W_1x)$，这一层将网络变成了非线性的，这是因为$max(0,W_1x)$本身不是一个线性的函数。</p><p>扩展到多层网络：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408210850595.png" srcset="/img/loading.gif" alt="image-20210408210850595"></p><p>一些激活函数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408211605721.png" srcset="/img/loading.gif" alt="image-20210408211605721"></p><p>神经网络的叫法： 一般我们更喜欢叫 k层神经网络，k=1(a input layer)+hidden layer层数.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210408211700789.png" srcset="/img/loading.gif" alt="image-20210408211700789"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH2-损失函数/最优化/特征提取</title>
    <link href="/2021/04/07/CS231n-CH2-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-%E6%9C%80%E4%BC%98%E5%8C%96-%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <url>/2021/04/07/CS231n-CH2-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-%E6%9C%80%E4%BC%98%E5%8C%96-%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="CS231n：Computer-Science"><a href="#CS231n：Computer-Science" class="headerlink" title="CS231n：Computer Science"></a>CS231n：Computer Science</h1><h1 id="损失函数和优化"><a href="#损失函数和优化" class="headerlink" title="损失函数和优化"></a>损失函数和优化</h1><h2 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407202528540.png" srcset="/img/loading.gif" alt="image-20210407202528540"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407202647510.png" srcset="/img/loading.gif" alt="image-20210407202647510"></p><p>​    我们这里使用了multiclass SVM loss(hinge loss function)，如果属于$y_i$类别的图像在$y_i$类得到的分数比在$j$类中得到的分数多1(这个1可以看作两类差距的一个阈值margin，毕竟如果两类如果差距不大，说明分类还是有些问题的，此时loss也不该为0)，那么说明没有损失，也就是$L_i = 0$此时。</p><p>​    反之，属于$y_i$类别的图像在$y_i$类得到的分数比在$j$类中得到的分数低了一些的时候，说明了预测不准确，loss我们直接设置两个类别得到的分数的差值。</p><p>如果想知道更多有关hinge loss和SVM的关系,可以查看 ：</p><p><a href="https://www.zhihu.com/question/62881491/answer/500947075" target="_blank" rel="noopener">如何把SVM的推导和损失函数联系起来？</a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407204303622.png" srcset="/img/loading.gif" alt="image-20210407204303622"></p><p>一个具体计算SVM loss的例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407204525977.png" srcset="/img/loading.gif" alt="image-20210407204525977"></p><p>这里的car所得到的4.9分上下稍微浮动并不会影响到loss function的大小，因为在hinge loss中它一直是等于0的。</p><p>在我们最小化L(W)时要小心overfitting</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407212700503.png" srcset="/img/loading.gif" alt="image-20210407212700503"></p><p>所以加上正则项：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407212800144.png" srcset="/img/loading.gif" alt="image-20210407212800144"></p><p>正则化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407213123657.png" srcset="/img/loading.gif" alt="image-20210407213123657"></p><p>​    L1正则化更喜欢稀疏的解，比如(1,0,0,0)这样的$w$在L1正则化上比比(0.5,0.5,0.5,0.5)小，但是在$L2$正则化上他们是相同的，因此我们可以认为L1更喜欢稀疏的解，他会让一些项趋于0来降低模型复杂度。  反观L2正则化，在(1,0,0,0)这样的w上L2正则化是大于(0.25,0.25,0.25,0.25)的，虽然他们的L1是相同的，这是因为L2正则化更喜欢用一个均匀且整体较小的w来降低模型的复杂度，使得当数据的某一维度发生变化时，这样均匀且较小的权重不会使得结果发生很大的差异，这样降低了模型的复杂度。</p><p>还有一种在深度学习中用的classifier，叫做Softmax Classifier(Mutinomial Logistic Regression)。这种方法和上面的SVM不同，SVM只是关心正确分类的分数比其他分类的分数高出一个阈值即可，然而他并不关心这些分数有什么具体的意义，在Softmax 中这些都代表着一种几率。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407215324298.png" srcset="/img/loading.gif" alt="image-20210407215324298"></p><p>一个例子：<strong>score-&gt;exp(score)-&gt;normalize(可以看成几率占比)-&gt;L=-log(.)</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407215922414.png" srcset="/img/loading.gif" alt="image-20210407215922414"></p><p>你可能会有疑问，如果-log(.)中是0怎么办？这样损失就是无限小了，而其他即使有损失也会这一项掩盖。还记得我们做了exp()吗，如果而exp()无论里面的值是多少，也不会得到0。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407220708409.png" srcset="/img/loading.gif" alt="image-20210407220708409"></p><p>这两者的区别在于：在hinge loss中如果你已经分类正确并且比其他分类的分数高出一个阈值，此时分类正确的分数即使再高一些也不会影响hinge loss的大小，因为他就是0。但是在cross-entropy loss中，他总会使得正确的更加正确，使得正确的几率趋于1。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407221454282.png" srcset="/img/loading.gif" alt="image-20210407221454282"></p><h2 id="最优化-Optimization"><a href="#最优化-Optimization" class="headerlink" title="最优化(Optimization)"></a>最优化(Optimization)</h2><p>普通梯度下降(GD)：就是梯度相反方向乘上一个学习率，用这个去更新w，从而做到最优化。</p><p>随机梯度下降(SGD): </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407223451922.png" srcset="/img/loading.gif" alt="image-20210407223451922"></p><p>SGD一大好处就是每次迭代复杂度很低，比如再logistic regression中，梯度的表达式是$1/N *\Sigma_{n=1}^{N} \theta(-y_nw_t^Tx_n)(-y_nx_n)$。需要计算复杂度是$O(N)$,而SGD随机选择一个小的批量，用这个小的批量去更新，那么迭代一次复杂度就是$O(size\  of \ minibatch)$</p><h2 id="特征提取-Feature-extraction"><a href="#特征提取-Feature-extraction" class="headerlink" title="特征提取(Feature extraction)"></a>特征提取(Feature extraction)</h2><p>我们直接把图像的rgb三个维度扔到向量里去预测一般不会得到很好的效果，我们一般习惯于先寻找与图像的特征或者形象有关的向量，然后用这些代表着图像特征的向量来做预策</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407224131842.png" srcset="/img/loading.gif" alt="image-20210407224131842"></p><p>一种很好的表现图像颜色特征的方法是：颜色直方图</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407224536750.png" srcset="/img/loading.gif" alt="image-20210407224536750"></p><p>比如这个青蛙，绿色部分就比较高。</p><p>还有一种梯度直方图，也可以表现出图片的特征：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407224820114.png" srcset="/img/loading.gif" alt="image-20210407224820114"></p><p>还有一种提取图像特征的方法是：Bag iof words</p><p>事实上，这是从NLP中得到的灵感，如果你想对一句话用向量表示，我们可以对这句话中不同的次做一个统计。放在图像中，我们首先需要构建自己的图像字典，做法是首先对图像集随机的抽取小片图像块，然后做聚类得到几种不同类别的图像块，把他们放入图像字典，我们就可以得到图像字典。然后图像就可以用这些图像字典来表示，向量就代表着每种图像块的数量。这是李飞飞在CVPR2005上提到的一种提取图像特征的方法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407225330162.png" srcset="/img/loading.gif" alt="image-20210407225330162"></p><p>现在我们更多采用卷积神经网络来做这件事情。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407225705602.png" srcset="/img/loading.gif" alt="image-20210407225705602"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210407224419570.png" srcset="/img/loading.gif" alt="image-20210407224419570"></p><p>即feature transform</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n-CH1-图像分类</title>
    <link href="/2021/04/06/CS231n-CH1-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <url>/2021/04/06/CS231n-CH1-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CS231n：Computer-Science"><a href="#CS231n：Computer-Science" class="headerlink" title="CS231n：Computer Science"></a>CS231n：Computer Science</h1><h1 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h1><h2 id="数据驱动方法"><a href="#数据驱动方法" class="headerlink" title="数据驱动方法"></a>数据驱动方法</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210405221211444.png" srcset="/img/loading.gif" alt="image-20210405221211444"></p><p>800*600*3, 其中3代表三个channels（R,G,B）。</p><p>我们可以把图像分类想成这两个大的部分：</p><ul><li>第一个是训练部分：放进去(图像,label)，训练得到模型</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(imgs, labels)</span>:</span><br>    <span class="hljs-comment">#Machine Learning</span><br>    <span class="hljs-keyword">return</span> model<br></code></pre></div></td></tr></table></figure><ul><li>第二个是预策部分：有了模型后，放进去测试图像，预测得到测试label</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span><span class="hljs-params">(model, test_images)</span>:</span><br>    <span class="hljs-comment">#use model to predict label</span><br>    <span class="hljs-keyword">return</span> test_labels<br></code></pre></div></td></tr></table></figure><p>这一节我们主要讲的是数据驱动的方法。</p><p>第一种分类器叫做<code>Nearest Neighbor</code>，用的是K-邻近算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210405222738843.png" srcset="/img/loading.gif" alt="image-20210405222738843"></p><p>思路很简单，首先给出img和label，他会记住所有的img和label，然后test_img输入后就寻找test_img周围的图片，那么周围图片的类别可以大致的估计出这个测试图片的类别。</p><p>但是我们是怎么比较两个图片的距离呢：</p><p>这里采用了L1 distance：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210405223824562.png" srcset="/img/loading.gif" alt="image-20210405223824562"></p><p>对于一张图片，<code>Nearest Neighbour</code>这个classifier训练是$O(1)$的，即把图片记住即可，但是预策一张图片却是$O(N)$的，因为我们需要算每个图片和这个图片的L1 Distance。</p><p>直观上来看：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210405224407555.png" srcset="/img/loading.gif" alt="image-20210405224407555"></p><p>我们寻找最近的1个点（K=1）就会被上图中的中心点的黄色影响。</p><p>改变K的大小可以得到不同的效果</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210405224529421.png" srcset="/img/loading.gif" alt="image-20210405224529421"></p><h2 id="K-最近邻算法（KNN）"><a href="#K-最近邻算法（KNN）" class="headerlink" title="K-最近邻算法（KNN）"></a>K-最近邻算法（KNN）</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406194153593.png" srcset="/img/loading.gif" alt="image-20210406194153593"></p><p>如果旋转坐标系，那么L1这种测距方式就会改变距离大小，但是L2不会。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406194456417.png" srcset="/img/loading.gif" alt="image-20210406194456417"></p><p>L1的决策边界趋于跟随坐标轴，这是因为L1取决于坐标轴的选取，而L2和坐标轴无关。</p><p>超参数(Hyperparameters):</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406194902514.png" srcset="/img/loading.gif" alt="image-20210406194902514"></p><p>超参数是我们需要自己选择的，而不是算法学到的，比如K值的选择。</p><p>超参数的设置：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406195134681.png" srcset="/img/loading.gif" alt="image-20210406195134681"></p><p>总是选择对训练集最好这是一种很不好的想法，比如KNN中你就总会选择K=1，而这样会造成过拟合。因为这在测试集上会表现得很差。因此我们更应该关心在测试集上的表现。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406195422645.png" srcset="/img/loading.gif" alt="image-20210406195422645"></p><p>那么我们既然不可以再训练集上测试，那我们就在测试集上测试。这其实也是欠妥的，那我们就不知道在新的数据上的表现如何了（因为没数据了）。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406200230890.png" srcset="/img/loading.gif" alt="image-20210406200230890"></p><p>最好的方法应该是做validation，把不同的超参数用train set训练，在validation set上测试哪儿个超参数表现得最好，然后把最好的超参数+model 去测试test set。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406200904090.png" srcset="/img/loading.gif" alt="image-20210406200904090"></p><p>还有一种cross-validation的方法叫做V-Fold Cross Validation，把训练数据集拆成V份，如上图，拆成了5份，绿色部分代表训练的数据，黄色的用不同的超参数来测试的数据。下面同理，找出平均表现最好的超参数。最后用这个最好的超参数+model 去测试test得到真正的表现。值得注意的是，这种方法同样有缺点，那就是在深度学习中数据往往非常大，因此这种多次检验的方法十分耗时。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406201808725.png" srcset="/img/loading.gif" alt="image-20210406201808725"></p><p>如上图，cross-validation告诉我们K=7时表现较好，此时validation很好的帮我们选择了超参数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406202056313.png" srcset="/img/loading.gif" alt="image-20210406202056313"></p><p>KNN在图像上是几乎不会用的，原因有：</p><ul><li>非常慢，需要和每一个训练样本比较</li><li>我们对同一张图片做遮挡/平移/染色 仍然会被认为一类，L2不太适合作为视觉差异。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406202513303.png" srcset="/img/loading.gif" alt="image-20210406202513303"></p><h2 id="线性分类（Linear-Classification）"><a href="#线性分类（Linear-Classification）" class="headerlink" title="线性分类（Linear Classification）"></a>线性分类（Linear Classification）</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406203221932.png" srcset="/img/loading.gif" alt="image-20210406203221932"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406203307639.png" srcset="/img/loading.gif" alt="image-20210406203307639"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406203559473.png" srcset="/img/loading.gif" alt="image-20210406203559473"></p><p>最简单的一个线性分类器就是$f(x,W)=Wx+b$,我们可以得到十个维度的分数（即十个物种的分数），分数最高的就可以把他归属到那一类。</p><p>举个例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406203745108.png" srcset="/img/loading.gif" alt="image-20210406203745108"></p><p>但这样的方法局限性也很明显，下图给出了线性分类学到的W在图像上到底长什么样：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406204014663.png" srcset="/img/loading.gif" alt="image-20210406204014663"></p><p>比如第一个plane是蓝色的，这会让图像识别认为蓝色多的就是飞机，第二个car红色车身上方有蓝色挡风玻璃，然而这种判断太过于没有说服力。</p><p>所以linear classification只是对每一个类别学了一个模板，如果一个类别的东西有多种类型，那么一个模板似乎并不能很好的预测。</p><p>现实中的许多数据可能不能做到线性可分，即使他是从同一个分布取出来的数据。</p><p>下一次我们会讨论：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210406204752212.png" srcset="/img/loading.gif" alt="image-20210406204752212"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH15：Matrix Factorization</title>
    <link href="/2021/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH15%EF%BC%9AMatrix-Factorization/"/>
    <url>/2021/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH15%EF%BC%9AMatrix-Factorization/</url>
    
    <content type="html"><![CDATA[<h1 id="CH15：Matrix-Factorization"><a href="#CH15：Matrix-Factorization" class="headerlink" title="CH15：Matrix Factorization"></a>CH15：Matrix Factorization</h1><h2 id="Linear-Network-Hypothesis"><a href="#Linear-Network-Hypothesis" class="headerlink" title="Linear Network Hypothesis"></a>Linear Network Hypothesis</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320134129803.png" srcset="/img/loading.gif" alt="image-20210320134129803"></p><p>还记得Netflix推荐系统那个问题吗，他给出的数据$D$ 有两个东西，一个是$\tilde x$，代表着用户的ID,例如：1126，5566，6211</p><p>另一个是ID为$n$的人，对电影$m$的评分，我们记为$r_{nm}$。</p><p> 类似于ID,血型，编程语言 这种feature都是categorical features，也就是<strong>类别特征</strong>。没有什么具体大小的意义，只是代表某一类。</p><p>许多的机器学习模型只能处理数值特征：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320134931324.png" srcset="/img/loading.gif" alt="image-20210320134931324"></p><p>但是decision tree可以很好的处理类别特征。</p><p>如果我们想要用在数值特征的机器学习模型上，就要对类别特征通过encoding进行feature transform，转换到数值特征。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320135152589.png" srcset="/img/loading.gif" alt="image-20210320135152589"></p><p>这里提供一种编码的方式，我们有四个类型，那么就用一个四维的向量来表示每个血型。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320135821019.png" srcset="/img/loading.gif" alt="image-20210320135821019"></p><p>再来看看训练资料：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320140059982.png" srcset="/img/loading.gif" alt="image-20210320140059982"></p><p>对于每个user他有一串的评分，’?’表示没看过/没评分，我们想从这样的资料里来学到user的喜好。那么下面要做的就是对每个user进行特征精炼，很自然想到的方法就是NNet。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320140340640.png" srcset="/img/loading.gif" alt="image-20210320140340640"></p><p>这样的网络的训练输入是：user编码后的id的每一位，输入就是这个user的喜好，这个网络训练完成后，每个$x_i$被赋值为1时，网络就会 输出ID为00…0100…0的喜好(其中的1在第$i$个)。</p><p>这样就把复杂的资料存入了这个NNet中。</p><p>中间的这个tanh转换是必要的吗？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320140900315.png" srcset="/img/loading.gif" alt="image-20210320140900315"></p><p>因为我们每次只有一个$x$会等于1，如上图，假设是第二个，经过转换得到就是 $tanh(w<em>{21}^{(1)})$和$tanh(w</em>{22}^{(1)})$，这两个值去组合得到不同的y和$w<em>{21}^{(1)}$,$w</em>{22}^{(1)}$去组合没什么区别，</p><p>所以我们可以改成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320141556147.png" srcset="/img/loading.gif" alt="image-20210320141556147"></p><p>我们对上面的转换矩阵重新命名一下:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320141710045.png" srcset="/img/loading.gif" alt="image-20210320141710045"></p><p>那么我们的网络的函数就可以写成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320141748050.png" srcset="/img/loading.gif" alt="image-20210320141748050"></p><p>最后得到的结果就是一个$N*1$的矩阵，也就代表了$x$的打分情况。</p><p>对一个具体的用户$x_n$来看，式子可以写为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320141944533.png" srcset="/img/loading.gif" alt="image-20210320141944533"></p><h2 id="Basic-Matrix-Factorization"><a href="#Basic-Matrix-Factorization" class="headerlink" title="Basic Matrix Factorization"></a>Basic Matrix Factorization</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320142805776.png" srcset="/img/loading.gif" alt="image-20210320142805776"></p><p>做到这一步，可以把$Vx$看作是对$x$的一种转换，转换为$\phi(x)$,然后再和一个$W^T$相乘。这样就相当于我们把一个user很抽象的特征(ID)转换为了一种对user的具体描述，这个具体描述和$W^T$做一个相乘后就反映了user的电影喜好。</p><p>那么我们就可以写出error measure：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320143541248.png" srcset="/img/loading.gif" alt="image-20210320143541248"></p><p>我们的评分总表如下，我们可以拆成两个部分，一个是user自带的特征($v$) 和 电影的特征($w$) 进行计算后就会得到这个人对这个电影的得分。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320143827014.png" srcset="/img/loading.gif" alt="image-20210320143827014"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320143835358.png" srcset="/img/loading.gif" alt="image-20210320143835358"></p><p>当然这一步是在神经网络上做到的，他提取精炼到的特征信息可能如下，比如$v$ 代表着 [喜不喜欢戏剧，喜不喜欢武打片，……],而movie中提取到的信息就是[包含戏剧内容吗，包含武打内容吗 …….],那么此时我们就学到了这种特征。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320143949777.png" srcset="/img/loading.gif" alt="image-20210320143949777"></p><p>下面我们最小化$E_{in}$:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320144446101.png" srcset="/img/loading.gif" alt="image-20210320144446101"></p><p>有位有两个变数$V$和$W$,因此我们考虑分别做最优化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320145004222.png" srcset="/img/loading.gif" alt="image-20210320145004222"></p><ul><li><p>当$v<em>n$确定，也就是确定了哪儿个人的时候，我们就最优化每部电影的$w_m$即可，因为我们已知$r</em>{nm}$,$v_n$，而且还是square error，那么我们就可以对每部电影做一个linear regression，这个在insight上的理解就是，确定了某个人，又给了你这个人对每个电影的评分，那么我们就要通过这些数据调整电影的特点，类似于下图，调整一下每个圈的权重，这样就知道电影的风格了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320145756509.png" srcset="/img/loading.gif" alt="image-20210320145756509"></p></li><li><p>当$w_m$确定时，同理，确定了哪儿个电影，有不同的人对他的评分，那么我们就可以对这些人的口味进行训练，得到下图的效果：</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320145928467.png" srcset="/img/loading.gif" alt="image-20210320145928467"></p><p>这个也可以用linear regression来做。</p><p>这种方法叫做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320150050247.png" srcset="/img/loading.gif" alt="image-20210320150050247"></p><p>那么我们提出这种算法<code>Alternating Least Squares(交替最小二乘法)</code>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320150136161.png" srcset="/img/loading.gif" alt="image-20210320150136161"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320150436898.png" srcset="/img/loading.gif" alt="image-20210320150436898"></p><h2 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h2><p><strong>SGD介绍</strong>：机器学习基石/CH11：Linear-Models-for-Classification/Stochastic-Grad-Descent（随机梯度下降）</p><p>比如现在我们对具体的一个观众来求偏微分，那么$err()$求出来的结果 除了当n=1126都是0。</p><p>同理我们就可以写出对第n个观众的偏微分和对第m个电影的偏微分。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320152817247.png" srcset="/img/loading.gif" alt="image-20210320152817247"></p><p>那么我也可以用SGD的方式来做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320153538452.png" srcset="/img/loading.gif" alt="image-20210320153538452"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320153754857.png" srcset="/img/loading.gif" alt="image-20210320153754857"></p><p>在基石中最后一节课讲到的的Sampling Bias(抽样偏差)，即我们今年喜欢看的电影和去年喜欢看的电影可能并不是从同一个分布出来的，这有着时间的变化，同时我们今年看的电影更有可能影响我们今年的观影喜好，因此在SGD训练的时候，我们可以选择在SGD最后几百次梯度下降的时候多选择更晚一些的观影评价进行更新。</p><h2 id="Summary-of-Extraction-Models（提取模型总结）"><a href="#Summary-of-Extraction-Models（提取模型总结）" class="headerlink" title="Summary of Extraction Models（提取模型总结）"></a>Summary of Extraction Models（提取模型总结）</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320161229648.png" srcset="/img/loading.gif" alt="image-20210320161229648"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320155215684.png" srcset="/img/loading.gif" alt="image-20210320155215684"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320161630327.png" srcset="/img/loading.gif" alt="image-20210320161630327"></p><p>Extraction Models的好处/劣处：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210320161747616.png" srcset="/img/loading.gif" alt="image-20210320161747616"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH14：Radial Basis Function Network</title>
    <link href="/2021/03/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH14%EF%BC%9ARadial-Basis-Function-Network/"/>
    <url>/2021/03/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH14%EF%BC%9ARadial-Basis-Function-Network/</url>
    
    <content type="html"><![CDATA[<h2 id="CH14：Radial-Basis-Function-Network"><a href="#CH14：Radial-Basis-Function-Network" class="headerlink" title="CH14：Radial Basis Function Network"></a>CH14：Radial Basis Function Network</h2><h2 id="RBF-Network-Hypothesis"><a href="#RBF-Network-Hypothesis" class="headerlink" title="RBF Network Hypothesis"></a>RBF Network Hypothesis</h2><p>首先回忆一下Gaussian Kernel在SVM中的应用</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318202139040.png" srcset="/img/loading.gif" alt="image-20210318202139040"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318202221263.png" srcset="/img/loading.gif" alt="image-20210318202221263"></p><p>我们在$x_n$处找$\alpha_n$ 来组合Gaussian Kernel，使得实现最大边界。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318202440114.png" srcset="/img/loading.gif" alt="image-20210318202440114"></p><p>高斯核也叫径向基(<em>Radial</em> <em>Basis</em> Function，RBF)核。其中radial代表我们今天算的和距离有关，也就是$x$和中心$x_n$。</p><p>我们今天就是要做radial hypothesis的linear aggregation。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318203052060.png" srcset="/img/loading.gif" alt="image-20210318203052060"></p><p>RBF Network和Neural Network的区别是：Neural Network是先和$w$做内积然后tanh转化，而RBF Network是通过把输入看成centre，然后去做距离的RBF Function。</p><p>这两者的输出反而没什么区别，都是linear aggregation</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318203454217.png" srcset="/img/loading.gif" alt="image-20210318203454217"></p><p>那么我们应该关注的两个变量就是系数$\beta_m$和中心$\mu_m$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318203844216.png" srcset="/img/loading.gif" alt="image-20210318203844216"></p><p>output采用的是sign(),也就是二分类，M就是support vector的数量。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318204013005.png" srcset="/img/loading.gif" alt="image-20210318204013005"></p><p>我们在kernel中提到kernel通过把两个向量转换道z空间，找到他们的相似性。</p><p>相似性是一个很好的定义特征转换的方法，RBF中通过距离的相似性做feature transform。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318204709887.png" srcset="/img/loading.gif" alt="image-20210318204709887"></p><h2 id="RBF-Network-Learning"><a href="#RBF-Network-Learning" class="headerlink" title="RBF Network Learning"></a>RBF Network Learning</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318205105341.png" srcset="/img/loading.gif" alt="image-20210318205105341"></p><p>我们定义一个Full RBF Network，他有N笔资料，那么就有N个中心，他的物理意义就是：我的每笔资料对会对周围资料有影响，影响力大小为$\beta_m$。</p><p>比如Uniform的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318205804822.png" srcset="/img/loading.gif" alt="image-20210318205804822"></p><p>我们通过大家意见的相似度来整合每个人的意见，把所有点都当做中心点。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318210030932.png" srcset="/img/loading.gif" alt="image-20210318210030932"></p><p>高斯函数是一个幂指数函数，他的下降非常快，因此那个最接近$x_m$的$x$掌握了主导权，那么我们是不是就不用考虑每个人了，找出主导权的来做决定就好了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318210227601.png" srcset="/img/loading.gif" alt="image-20210318210227601"></p><p>我们考虑有主导权的那个$x$(最接近$x_m$的$x$), 用他的投票$y_m$代替所有的人。</p><p>这应该叫做selection而不是aggregation了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318210400488.png" srcset="/img/loading.gif" alt="image-20210318210400488"></p><p>这叫好比找中心$x_m$的最近的邻居，我们称之为最邻近模型。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318210648326.png" srcset="/img/loading.gif" alt="image-20210318210648326"></p><p>我们可能一个来代表所有人还是有点太不合理了，那么我们考虑最有主导权的k个$x$, 也就是距离中心最近的k个邻居。</p><p>那么我们考虑最佳化这个$\beta$就好了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318210842609.png" srcset="/img/loading.gif" alt="image-20210318210842609"></p><p>我们先把他看作一个linear regression的问题，然后用square error去衡量错误。</p><p>那么我们的资料就是这些 RBF Function组成的资料：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318211026966.png" srcset="/img/loading.gif" alt="image-20210318211026966"></p><p>最优化$\beta$  ? linear regression很容易做到这个问题，这是有闭式解的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318211114417.png" srcset="/img/loading.gif" alt="image-20210318211114417"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318211439805.png" srcset="/img/loading.gif" alt="image-20210318211439805"></p><p>$Z$矩阵的大小是一个N<em>N的，即每个点距离每个中心的RBF Function。那么这肯定是一个<em>*对称矩阵</em></em>，因为a到b和b到a的距离必然相同。</p><p>有一个theoretical fact：如果$x_n$各不相同，那么$Z$就是一个可逆的。证明这个很容易，如果存在$x_1=x_2$,那么Z的第一二行会相同，第一二列也会相同，那么这明显就不是满秩的了，也就是说不可逆了。</p><p>那么我们的$\beta$表达式可以写成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318211753349.png" srcset="/img/loading.gif" alt="image-20210318211753349"></p><p>full Gaussian RBF Network中的$\beta$做完回归后：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318212013590.png" srcset="/img/loading.gif" alt="image-20210318212013590"></p><p>这里推到发现：$g_{RBF}(x_1) = \beta ^TZ^{-1}(Z的第一行)$，这就得到了一个很有趣的结果：</p><p>$g<em>{RBF}(x_n) = y_n$,这就说明我们的$E</em>{in} =0$， 但这感觉有点怪怪的: 可能回有overfitting。</p><p>那我们加上正则化：那么我们用ridge regression来做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318213426783.png" srcset="/img/loading.gif" alt="image-20210318213426783"></p><p>其中$\lambda$是一个正则量，代表着正则化的程度。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318213614043.png" srcset="/img/loading.gif" alt="image-20210318213614043"></p><p>在kernel ridge regression中我们对无限多维的转换做regularization，在RBF Network中是对有限多维做regularization。</p><p>我们考虑考虑不让所有数据来做中心，考虑一部分有代表性的来做中心即可，那么就可以减少overfitting了。</p><h2 id="K-Means-Algorithm"><a href="#K-Means-Algorithm" class="headerlink" title="K-Means Algorithm"></a>K-Means Algorithm</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318214441732.png" srcset="/img/loading.gif" alt="image-20210318214441732"></p><p>如果$x_1$和$x_2$相近，那么就没必要搞两个中心，聚类时选一个看作中心即可。</p><p>现在先做一个聚类，分成M个集合，我们希望每个集合中的中心和这个集合中的数据是相似的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318214654383.png" srcset="/img/loading.gif" alt="image-20210318214654383"></p><p>我们还是先做一个error measure function：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318214819648.png" srcset="/img/loading.gif" alt="image-20210318214819648"></p><p>采用square error，对每个集合来说，找出这个集合中的每个点和中心点的距离差。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318215058615.png" srcset="/img/loading.gif" alt="image-20210318215058615"></p><p>但这个貌似并不好做最优化，因为有两个优化要做：一个是排列组合问题：怎么分开不同的集合，另一个是中心点怎么选择的数值优化问题。</p><p>如果中心点确定了，那么我们选择距离某个中心点最近的中心点即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318215636262.png" srcset="/img/loading.gif" alt="image-20210318215636262"></p><p>那么没了分组的问题 ，我们可以直接做数值优化的问题了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318215746338.png" srcset="/img/loading.gif" alt="image-20210318215746338"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318215803024.png" srcset="/img/loading.gif" alt="image-20210318215803024"></p><p>那么最佳的$\mu_m$就是每个集合内$x$的平均。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318215905314.png" srcset="/img/loading.gif" alt="image-20210318215905314"></p><p>那么<code>K-Means</code>算法就可以提出：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318220021734.png" srcset="/img/loading.gif" alt="image-20210318220021734"></p><ul><li><p>初始的$\mu$怎么选：一般来说从$x_n$中随便选取k个即可</p></li><li><p>怎么停止？会停止吗？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318220146215.png" srcset="/img/loading.gif" alt="image-20210318220146215"></p><p>当然会，集合不变化后，$E_{in}$是逐渐变小的。</p></li></ul><p>同时也可以提出<code>RBF Network Using K-Means</code>算法了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318220334263.png" srcset="/img/loading.gif" alt="image-20210318220334263"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318220435045.png" srcset="/img/loading.gif" alt="image-20210318220435045"></p><ul><li>用非监督的方法K-Means来帮助我们精炼到了feature transform，就像autoencoder一样。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318220603445.png" srcset="/img/loading.gif" alt="image-20210318220603445"></p><ul><li>参数选择：怎么选择M，$\gamma$ ?  还是Validation   : )  </li></ul><p>老实说，RBF Network是一种old-fashion的model，他和Gauss SVM，Neural Network可能表现没什么区别，但是它可以帮我们连接一些我们已知的算法，建立一个完整的算法体系。</p><h2 id="K-Means-and-RBFNet-in-ACTION"><a href="#K-Means-and-RBFNet-in-ACTION" class="headerlink" title="K-Means and RBFNet in ACTION"></a>K-Means and RBFNet in ACTION</h2><p>一个K-Means的Demo：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318221028859.png" srcset="/img/loading.gif" alt="image-20210318221028859"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318221124016.png" srcset="/img/loading.gif" alt="image-20210318221124016"></p><p>不同的k的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318221149315.png" srcset="/img/loading.gif" alt="image-20210318221149315"></p><p>我们可以用这些K-means做的结果，用RBF Network using k-means去做binary classification：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318221314786.png" srcset="/img/loading.gif" alt="image-20210318221314786"></p><p>如果我们第一层的K-Means做的比较合理，那么RBF Network来做也是很轻松的，随着K的变大,RBF Network的feature transform的维度也更大，边界会更精准一些，但是要小心overfitting哦。</p><p>我们最后来看Full RBF Network：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210318221759620.png" srcset="/img/loading.gif" alt="image-20210318221759620"></p><p>值得一提的是:Full RBF Network因为要考虑所有的点，因此计算量很大，比如nearest neighbour这种方法，他很依赖于一些几何上的算法，来计算的快一些</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH13：Deep Learning</title>
    <link href="/2021/03/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH13%EF%BC%9ADeep-Learning/"/>
    <url>/2021/03/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH13%EF%BC%9ADeep-Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="CH13：Deep-Learning"><a href="#CH13：Deep-Learning" class="headerlink" title="CH13：Deep Learning"></a>CH13：Deep Learning</h1><h2 id="Deep-Neural-Network"><a href="#Deep-Neural-Network" class="headerlink" title="Deep Neural Network"></a>Deep Neural Network</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317192103675.png" srcset="/img/loading.gif" alt="image-20210317192103675"></p><p>Deep NNet特点 ：</p><ul><li><p>训练很难</p></li><li><p>结构复杂，很多层很难决定结构</p></li><li><p>模型效果很好</p></li><li><p>层数变多可以获得更多的实际物理意义</p></li></ul><p>实际物理意义举个例子，如下 ：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317192318665.png" srcset="/img/loading.gif" alt="image-20210317192318665"></p><p>每一层的神经元都有他自己的物理意义，向着从简单到复杂feature的转换。</p><p>一些Deep Learning的chllenges和keys：</p><ul><li>结构复杂</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317193020437.png" srcset="/img/loading.gif" alt="image-20210317193020437"></p><p>比如决定网络结构的时候，我们可以人为的做一些选择，比如图像识别，我们网络连接时，对于某个像素，我们只连接他周围的像素。</p><ul><li>模型复杂</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317193314091.png" srcset="/img/loading.gif" alt="image-20210317193314091"></p><p>一般做视觉我们数据会很大很多，因此不用太担心。</p><p>同时也要做正则化，例如：dropout和denoising</p><ul><li><p>局部最佳很难：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317193437870.png" srcset="/img/loading.gif" alt="image-20210317193437870"></p></li></ul><p>可以通过pre-traning来选择合适的初始化值，避免局部最小。</p><ul><li>计算量大</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317193602822.png" srcset="/img/loading.gif" alt="image-20210317193602822"></p><p>现阶段的GPU 已经可以做很大的运算了。</p><h2 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317194213125.png" srcset="/img/loading.gif" alt="image-20210317194213125"></p><p>首先我们要对权重w的初值pre-training，它不用做到很好，能够帮助最后w迭代的快一些即可，同时帮助我们在一个还不错的地方做梯度下降，这样效果也会更好。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317194652702.png" srcset="/img/loading.gif" alt="image-20210317194652702"></p><p>​    什么是好的权重？ 可以保存原来的信息，只是比较简明精炼。如果你设计的把原来的资料搞得乱七八糟毫无规律，那么下一层也训练不出来什么好的效果。</p><p>​    一个比较具体的例子就是下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317194941797.png" srcset="/img/loading.gif" alt="image-20210317194941797"></p><p>我们分开的这些小部分可以重建回来，那么它必然带着原来的信息，且更精炼，那么这个转换就是一个information-preserving(信息保留)的。</p><p>怎么找这么一个information-preserving的转换呢？</p><p>还是通过一个简单的神经网络：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317195529292.png" srcset="/img/loading.gif" alt="image-20210317195529292"></p><p>这个网络很有意思，最开始输入$x$进去，他输出还是$x$，这说明了第一次所做的转换可以反转回来，也就说信息得到了保留。</p><p>我们称之为autoencoder自动编码：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317195656463.png" srcset="/img/loading.gif" alt="image-20210317195656463"></p><p>那么我们就是在让这个information-preserving Neural Network逼近一个不做任何转换的函数，这有什么意义呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317200241356.png" srcset="/img/loading.gif" alt="image-20210317200241356"></p><p>这个逼近过程利用了一些数据的隐藏结构：</p><ul><li>对于监督学习，这些隐藏的结构可以帮助我们做一个合理的transform，也就是学习数据所带的有效信息。</li><li>对于非监督学习，比如分布稠密的检测，这个transform可以告诉我们分布的稠密，我们就k可以知道数据起到主要作用的表达信息是什么。反着来看，我们还可以通过找到那些$g(x)! \approx x$，来看到是为什么差？为什么不合群。 所以可以告诉我们什么要的数据是一个典型的数据。</li></ul><p>那么我们可以提出这个基本的<code>Autoencoder</code>的算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317201350570.png" srcset="/img/loading.gif" alt="image-20210317201350570"></p><p>训练数据很简单就是 (x,y=x),因为我们想让它输入输出一样。</p><p>我们通常希望第二层的神经元数量要少于第一层，因为我们希望得到的是精炼的信息。</p><p>可以用backprop训练，层数不多很容易训练。</p><p>有时我们会加上这个限制：$w<em>{ij}^{(1)} =w</em>{ji}^{(2)}$，这个很容易理解，这个权重怎么送过来的就怎么传回去，这样做完后如果能够按照转化来的时候的方法转换回去，那么信息说明得到了保留。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317202420410.png" srcset="/img/loading.gif" alt="image-20210317202420410"></p><p>那么我们对每一层来做即可，得到每层的初始权重。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="Denoising-Autoencoder"><a href="#Denoising-Autoencoder" class="headerlink" title="Denoising Autoencoder"></a>Denoising Autoencoder</h2><p>由于深度神经网络模型复杂，我们要小心overfitting，可以添加一些regularization：</p><ul><li>比如网络结构限制的简单一些</li><li>比如上一章所提到的weight-elimination regularizer 或者是weight decay regularizer</li><li>early stopping</li></ul><p>除此之外，我们还有一种方法：</p><p>先回顾一下overfitting的原因：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317203546561.png" srcset="/img/loading.gif" alt="image-20210317203546561"></p><p>一个直观的想法是：我们直接去掉noise，这样noise少一些，overfit就会减轻一些，但是这样并不容易做到。</p><p>想让网络鲁棒性更强，我们甚至可以主动喂给autoencoder网络一些noise！</p><p>这个想法非常反直观，我们换个角度来想，如果我们在训练autoencoder的时候放一些noise，比如写的很丑的数字一，但是我们依然把他的输出期望设置为干净的1。那么我们的encoder就有了一种去除杂质的功能。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317204440749.png" srcset="/img/loading.gif" alt="image-20210317204440749"></p><p>我们称之为denoising autoencoder，具体就是训练数据上的输入加一些noise，输出不变，用这样的数据去训练一个denoising的encoder。</p><p>这样做出来的权重一定程度上表达了我们需要的性质，也获得了一定的去杂质功能，这也是一种regularization的方式。</p><h2 id="Principal-Component-Analysis-PCA"><a href="#Principal-Component-Analysis-PCA" class="headerlink" title="Principal Component Analysis(PCA)"></a>Principal Component Analysis(PCA)</h2><p>autoencoder不是一个线性模型，里面包含tanh()。</p><p>我们现在考虑线性的autoencoder：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317210130194.png" srcset="/img/loading.gif" alt="image-20210317210130194"></p><p>考虑一些特殊的条件：</p><ul><li>$x_0$我们会拿掉，这样就保持了输入输出维度一致</li><li>限制$w<em>{ij}^{(1)} = w</em>{ji}^{(2)}=w_{ij}$： 正则化</li><li>假设中间层的维度小于输入输出两侧的维度，为了压缩精炼信息。</li></ul><p>不妨另$W = [w_{ij}]$,这是一个$d* \tilde d$维的矩阵。</p><p>那么我们就可以推出新的用$W$表示的$h(x)$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317210846704.png" srcset="/img/loading.gif" alt="image-20210317210846704"></p><p>我们的error measure function $E_{in}$就是变化后和希望得到的结果的平方差，而我们希望得到的恰好是我们的输入，那么表达式就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317211026674.png" srcset="/img/loading.gif" alt="image-20210317211026674"></p><p>我们尝试去解他的闭式解：</p><p>$WW^T$首先可以做特征分解(也叫谱分解/酉相似对角化)：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317214343309.png" srcset="/img/loading.gif" alt="image-20210317214343309"></p><ul><li>$d*d$维的矩阵$V$的每一行向量是互相垂直/正交的(orthogonal):所以$VV^T=V^TV=I_d，I_d是一个单位矩阵$</li><li>$\Gamma$是一个对角矩阵，这个对角矩阵,对角上的值是$W$的特征值，非零项最多有$\tilde d$个，这个不难理解，因为我们的$W$是一个$d*\tilde d$的矩阵，那么他的秩最大是$\tilde d$。</li></ul><p>$WW^Tx_n = V\Gamma V^Tx_n$</p><ul><li>我们从几何意义理解这个式子，$V^Tx_n$可以看作对$x_n$做一个旋转或平移</li><li><p>那么$\Gamma V^Tx_n$就可以看作，我们把$V^Tx_n$    $d$到$\tilde d$维的数据变为了0，然后放缩了其他项</p></li><li><p>$ V\Gamma V^Tx_n$,表示我们最后在旋转回来</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317215007785.png" srcset="/img/loading.gif" alt="image-20210317215007785"></p><p>那么这个公式前面的$x_n$也可以看作：$x_n = VIV^Tx_n$,$I$是单位矩阵。</p><p>那么现在把问题转化为了$W$最佳化问题转换为了$\Gamma$和$V$最佳化的问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317215851919.png" srcset="/img/loading.gif" alt="image-20210317215851919"></p><ul><li><p>首先红色的$V$代表back-rotate，就是第一次旋转/反射 的逆变换，这不会影响长度，所以我们暂时可以把他们去掉</p></li><li><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317220218142.png" srcset="/img/loading.gif" alt="image-20210317220218142"></p><p>我们想要先考虑里面一层最小化$\Gamma$的问题： 也就是说我们想要尽可能多的0塞入$(I-\Gamma)$这个对角矩阵中，这样就可以减少这个表达式的值。由于$\Gamma$的$rank\le \tilde d$,因此我们不失一般性的设$\Gamma$长这个样子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317220717594.png" srcset="/img/loading.gif" alt="image-20210317220717594"> </p></li></ul><p>那么下一步我们就去做$V$的最佳化维题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317220832260.png" srcset="/img/loading.gif" alt="image-20210317220832260"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317221058596.png" srcset="/img/loading.gif" alt="image-20210317221058596"></p><p>首先把最小化问题转成最大换，原来代表的是留下哪儿些维度，希望他们最小，这就等价于拿掉哪儿些维度，希望他们最大。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317221310845.png" srcset="/img/loading.gif" alt="image-20210317221310845"></p><p>首先只考虑是对角上非零的个数只有一个的情况：</p><p>由lagrange multiplier可以得到：</p><p>我们对两边<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317222404376.png" srcset="/img/loading.gif" alt="image-20210317222404376">和他的限制条件<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317222417315.png" srcset="/img/loading.gif" alt="image-20210317222417315">分别求导后，最优解是可以使得两个导数平行，即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317222525088.png" srcset="/img/loading.gif" alt="image-20210317222525088"></p><p>这么看来$v$就是这个绿色部分就是的特征向量！</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317222830355.png" srcset="/img/loading.gif" alt="image-20210317222830355"></p><p>那么在$\tilde d = 1$的情况下，最优的$v$就是 $XX^T$的最大特征向量。</p><p>拓展到$\tilde d$不限制为1的情况下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317222814934.png" srcset="/img/loading.gif" alt="image-20210317222814934"></p><p>我们找最大的几个特征向量即可，这就是我们最好的$V$</p><p>因此linear autoencoder就是在告诉我们：我们拿到一个数据矩阵，我们对他做特征分解，找出最大的几个特征向量，这几个特征向量就是最符合$x_n$的向量，我们最应该做投影，做特征转化的向量。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317223422148.png" srcset="/img/loading.gif" alt="image-20210317223422148"></p><p><code>Linear Autoencoder</code>算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317223734229.png" srcset="/img/loading.gif" alt="image-20210317223734229"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317224133309.png" srcset="/img/loading.gif" alt="image-20210317224133309"></p><p>因此这个算法可以帮我们最大化投影后的效果。</p><p>他主要用在PCA(<em>Principal Component Analy</em>sis,主成分分析)上，主成分分析中希望我们最大化 一个差值：$x- \overline x$,即投影后的变化量最大。</p><p>其实PCA算法就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210317224922367.png" srcset="/img/loading.gif" alt="image-20210317224922367"></p><p>也就是说把一个高维的数据找到一个线性上表现最好的形式。</p><p>这也是PCA的主要作用：降维</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH12：Neural Network</title>
    <link href="/2021/03/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH12%EF%BC%9ANeural-Network/"/>
    <url>/2021/03/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH12%EF%BC%9ANeural-Network/</url>
    
    <content type="html"><![CDATA[<h1 id="CH12：Neural-Network"><a href="#CH12：Neural-Network" class="headerlink" title="CH12：Neural Network"></a>CH12：Neural Network</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228220541673.png" srcset="/img/loading.gif" alt="image-20210228220541673"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228215532630.png" srcset="/img/loading.gif" alt="image-20210228215532630"></p><p>我们可以自由决定$w$和$\alpha$ . </p><p>首先这种aggregation操作可以做到logic operation(逻辑运算)：</p><p><strong>AND运算：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228221105142.png" srcset="/img/loading.gif" alt="image-20210228221105142"></p><p>我们的这种aggregation of Perceptron是很复杂度 ：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228221401687.png" srcset="/img/loading.gif" alt="image-20210228221401687"></p><p>上图发现，我们用足够多的perceptron就可以得到一个近似于target boundary的结果，因此它是一种能力很强的组合方法。当然这也意味着很容易overfit。</p><p>当然这种方法也有一些局限(Limitation)：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228221654625.png" srcset="/img/loading.gif" alt="image-20210228221654625"></p><p>由于异或是非线性可分的，因此这种方法不能直接处理。</p><p>那可以先考虑做一次feature transform，那么也就是我要做两层转换。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228221849981.png" srcset="/img/loading.gif" alt="image-20210228221849981"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228221906244.png" srcset="/img/loading.gif" alt="image-20210228221906244"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210228222043662.png" srcset="/img/loading.gif" alt="image-20210228222043662"></p><p>多层的perceptron就是basic Neural Network。</p><h2 id="Neural-Network-Hypothesis"><a href="#Neural-Network-Hypothesis" class="headerlink" title="Neural Network Hypothesis"></a>Neural Network Hypothesis</h2><p>输出可以看作一个多层模型嵌套后的线性组合：$s=w^T\phi^{(1)}(\phi^{(2)}(\phi^{(3)}(…)))$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301192151147.png" srcset="/img/loading.gif" alt="image-20210301192151147"></p><p>s可以做下面这三种操作：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301193924231.png" srcset="/img/loading.gif" alt="image-20210301193924231"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301194407652.png" srcset="/img/loading.gif" alt="image-20210301194407652"></p><p>我们之前一直都讨论的神经元处理都是sign阶梯函数来处理的，但是这种很难最优化$w$,而若全部换成线性的，其实也没什么作用，因为线性的组合还是线性的，这样做是没有意义的。</p><p>因此考虑$tanh(s)$这个函数来处理，他在近似原点的地方符合linear，远离原点的地方符合sign.</p><p>同时注意到,$tanh(s)$可以化简为：$tanh(s) = 2\theta(2s)-1$</p><p>那么把这个hypothesis改进后:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301194958611.png" srcset="/img/loading.gif" alt="image-20210301194958611"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301195540978.png" srcset="/img/loading.gif" alt="image-20210301195540978"></p><p>其中输入得第0号是输入的常数项。</p><p>我们提出了两个概念：一个是分数score，另一个是transformed转换后的输入：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301200105397.png" srcset="/img/loading.gif" alt="image-20210301200105397"></p><h2 id="Neural-Work-Learning"><a href="#Neural-Work-Learning" class="headerlink" title="Neural Work Learning"></a>Neural Work Learning</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301201323593.png" srcset="/img/loading.gif" alt="image-20210301201323593"></p><p>我们可以写成square error的形式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301201347205.png" srcset="/img/loading.gif" alt="image-20210301201347205"></p><p>但是这样的效率很低，因此目标是:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210301201429553.png" srcset="/img/loading.gif" alt="image-20210301201429553"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316204745009.png" srcset="/img/loading.gif" alt="image-20210316204745009"></p><p>我们首先来算最后一层的，即第$L$层。</p><p>最后一层的输出是1的，那么$w^{(L)}$的应该是一个大小为$d^{(L-1)}*1$的矩阵：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316204911304.png" srcset="/img/loading.gif" alt="image-20210316204911304"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316205304606.png" srcset="/img/loading.gif" alt="image-20210316205304606"></p><p>那么最后一层可以很方便的算出来。</p><p>如果不是最后一层呢？</p><p>同样的方法我们应用到这里，但是对于$ \frac{\part e_n}{\part s_j^{(l)}}$，我们很难计算,因此我们选择用暂时不处理，并用$\delta_j^{(l)}$代替。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316205633344.png" srcset="/img/loading.gif" alt="image-20210316205633344"></p><p>下面我们来处理这个难搞的偏微分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316211030732.png" srcset="/img/loading.gif" alt="image-20210316211030732"></p><p>一个$e_n$是$s_j^{(l)}$经多次变化才会得到的，如图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316211133152.png" srcset="/img/loading.gif" alt="image-20210316211133152"></p><p>和之前一样，我们用连锁律来一步一步倒推回去：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316211338063.png" srcset="/img/loading.gif" alt="image-20210316211338063"></p><p>这里有个$\Sigma$的原因是因为$s$是一个高维的的数据,所以我们需要对 每一个都求偏微分加在一起。</p><p>最后写出下式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316211557772.png" srcset="/img/loading.gif" alt="image-20210316211557772"></p><p>继续推到，第一项绿色的就是我们定义的$\delta$  ，红色项推导：根据上面的转换图可以看出$s<em>k^{(l+1)}$是由$x_j^{(l)}*w</em>{jk}^{(l+1)}$得到，故对偏微分就是$w_{jk}^{(l+1)}$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316211756801.png" srcset="/img/loading.gif" alt="image-20210316211756801"></p><p>现在我们有了递推式$l$层可以通过$l+1$层推出。</p><p>那么我们就可以提出这个新的算法Backpropagation Algorithm反向传播算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316213534347.png" srcset="/img/loading.gif" alt="image-20210316213534347"></p><p>实际应用中 ，对于一次运算④，我们回把①到③做多次去求得一个平均值，即$average(x<em>i^{(l-1)}\delta</em>{j}^{(l)})$。同时注意到这种①到③运算是可以并行的运算的，这就是大大加快了效率。</p><p>我们称这种多次运算取平均的方法叫做<code>mini-batch</code></p><h2 id="Optimization-and-Regularization"><a href="#Optimization-and-Regularization" class="headerlink" title="Optimization and Regularization"></a>Optimization and Regularization</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316215916603.png" srcset="/img/loading.gif" alt="image-20210316215916603"></p><p>我们写出$E_{in}$函数，发现下面这几个问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316220105671.png" srcset="/img/loading.gif" alt="image-20210316220105671"></p><p>第一，这个是一个非凸的函数，因此会有很多个山谷，因此我们并不是很容易中找到一个全局最小化的地方，我们所用的GD/SGD 通过反向传播算法得到的也只是一个局部的最小值。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316220553254.png" srcset="/img/loading.gif" alt="image-20210316220553254"></p><p>第二，由于有多个山谷，权重$w$的不同初始化的值会导致不同的局部最小值，坦白来说，并没有什么最好的方法来最优的初始化这个$w$,但是我们可以通过一些技巧来做到一个还算不错的结果。</p><ul><li>首先如果权重$w$很大,那么做$tanh()$时会导致梯度非常小，为什么呢？$tanh()$在$w$非常大的时候函数曲线已经接近平的了，这样我们每次只会走非常小的一步，这样就在有限的次数里可能不会走到最小的谷底。</li><li>因此给出的建议是：权重选择要随机一些，同时权重尽量一些。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316221604534.png" srcset="/img/loading.gif" alt="image-20210316221604534"></p><p>那么这个算法在使用tanh做transfer function的情况下的复杂度，用VC dimension来衡量大概是$O(VD)$。 他可以来做许多事情如果你的神经元足够多。但是同样也要小心这样带来的overfitting。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316221854223.png" srcset="/img/loading.gif" alt="image-20210316221854223"></p><p><strong>对于overfitting，我们可以做Regularization:</strong></p><p>我们不难想到一种basic choice就是 做L2正则化，限制w的权重平方和。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316222110628.png" srcset="/img/loading.gif" alt="image-20210316222110628"></p><p>但是这么做没什么意义，好比一个近似等比例的缩小：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316222407874.png" srcset="/img/loading.gif" alt="image-20210316222407874"></p><p>比如原来的权重是8现在就是4，原来是10现在就是6，这种放缩并不会帮助你解绝overfit。</p><p>L2正则化本质上没有帮我们解决降低$d_{VC}$的问题，也就是说没有帮我们把一些w变成0.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316222925703.png" srcset="/img/loading.gif" alt="image-20210316222925703"></p><p>我们现在不妨考虑L1正则化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316222819603.png" srcset="/img/loading.gif" alt="image-20210316222819603"></p><p>但是这有一些问题，就是带着绝对值不好微分，backprop是要求微分的。</p><p>还有一种比较常用的方法就是使用weight-elimination regularizer。weight-elimination regularizer类似于L2 regularizer，只不过是在L2 regularizer上做了尺度的缩小，<strong>这样能使large weight和small weight都能得到同等程度的缩小</strong>，从而让更多权重最终为零。weight-elimination regularizer的表达式如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316223306669.png" srcset="/img/loading.gif" alt="image-20210316223306669"></p><p>还有一种有趣的正则化方法：early stopping</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316223712245.png" srcset="/img/loading.gif" alt="image-20210316223712245"></p><p>我们每次的GD只是观察一个小的范围内并作出选择，随着我们迭代次数变多，也就是时间变长，我们看到的会更多也就会导致overfit，因此我们运行的时间越短，那么$d_{VC}$也会越小。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316223954131.png" srcset="/img/loading.gif" alt="image-20210316223954131"></p><p>因此我们选一个适合的时间，得到一个适合的$d_{VC}$,那么我们就可以获得一个不错的结果。</p><p>下面是一个运行时间t和错误率 的关系的图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210316224039339.png" srcset="/img/loading.gif" alt="image-20210316224039339"></p><p>那么也就是说我们还要选择一个参数：时间$t$ </p><p>怎么做呢？ Validation！</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH11：Gradient-Boosted-Decision-Tree</title>
    <link href="/2021/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH11%EF%BC%9AGradient-Boosted-Decision-Tree/"/>
    <url>/2021/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH11%EF%BC%9AGradient-Boosted-Decision-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="CH11：Gradient-Boosted-Decision-Tree"><a href="#CH11：Gradient-Boosted-Decision-Tree" class="headerlink" title="CH11：Gradient Boosted Decision Tree"></a>CH11：Gradient Boosted Decision Tree</h1><h2 id="AdaBoost-Decision-Tree"><a href="#AdaBoost-Decision-Tree" class="headerlink" title="AdaBoost Decision Tree"></a>AdaBoost Decision Tree</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225222501198.png" srcset="/img/loading.gif" alt="image-20210225222501198"></p><p>我们在AdaBoost-DTree中的第二步的DTree算法中加入了权重$u^{(t)}$。</p><p>如何实现这个呢 ？</p><p>我们回想一下在bootstrap中，我们把$u_n$代表着每个数据被选到的数量。但是我们现在的DTree算法没有权重这一说，我们又想要加上权重这个概念，那怎么办呢？</p><p>我们可以提前先对数据处理一下，比如原来有三个数据(1,1)(2,2) (3,3),权重是2，1，0，也就是2个(1,1),1个(2,2),没有(3,3),那么我们把数据先改变为(1,1)(1,1)(2,2),然后再去随机抽取，这样就用 <strong>抽到的概率</strong> 代替了 <strong>权重的概念</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225225234849.png" srcset="/img/loading.gif" alt="image-20210225225234849"></p><p>我们现在用sampling 来代替权重概念，还没有魔改DTree。</p><p>在AdaBoost中 $\alpha_t = ln(♦_t) = ln \sqrt{(1-\epsilon_t)/\epsilon_t}$,我们如果同样用到这里：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225235227976.png" srcset="/img/loading.gif" alt="image-20210225235227976"></p><p>我们发现如果我们把树做成了fully-grown，那么$E_{in}=0$,那么会导致权重$\alpha = ∞$，这样就导致了只有这一个$g_t$来决定了，这不就变成decision tree了吗？</p><p>我们可以用一些手段来限制长成fully-grwon，并且尽量让他不全作对：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225235813712.png" srcset="/img/loading.gif" alt="image-20210225235813712"></p><ul><li>可以pruned来限制树高</li><li>我们抽一部分数据来训练decision tree。</li></ul><p>我们反正不需要做的太好，我们把树高限制在1层就好了</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226000850887.png" srcset="/img/loading.gif" alt="image-20210226000850887"></p><p>一层不就是decision stump了吗？</p><p>我们称之为AdaBoost-Stump ，他就是AdaBoost-DTree的一种特殊情况。</p><p>此时也不用做sampling了，因为此时$E_{in}=0$的可能性几乎不存在了，做这个多此一举。</p><h2 id="Optimization-of-AdaBoost"><a href="#Optimization-of-AdaBoost" class="headerlink" title="Optimization of AdaBoost"></a>Optimization of AdaBoost</h2><p>再来回顾一下AdaBoost中的权重迭代：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226161136211.png" srcset="/img/loading.gif" alt="image-20210226161136211"></p><p>我们是否可以写成一个整体呢？即等两种形式都写成乘菱形的形式。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226161932365.png" srcset="/img/loading.gif" alt="image-20210226161932365"></p><p>那么我们可以直接推出$u_n^{T+1}$的通项公式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226162411135.png" srcset="/img/loading.gif" alt="image-20210226162411135"></p><p>其中橘色的一项就是AdaBoost最终返回的结果$G(x)$：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226162603587.png" srcset="/img/loading.gif" alt="image-20210226162603587"></p><p>在linear blending那一节提到过：linear blending和 线性模型+feature transform很像。(如下图)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226165545108.png" srcset="/img/loading.gif" alt="image-20210226165545108"></p><p>而hard-margin SVM margin的表达式是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226165813321.png" srcset="/img/loading.gif" alt="image-20210226165813321"></p><p>这里的$w^T\phi(x_n)$的就是还没有正规化之前的距离，$y_n$无所谓，他只代表在哪儿一边。</p><p>这么来看，margin和voting score好像很相似，至少表达了同一种性质。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226170556108.png" srcset="/img/loading.gif" alt="image-20210226170556108"></p><p>所以当<strong>迭代的次数多一些，$u_n^{(T+1)}$小一些，AdaBoost可以达到large margin的效果</strong>。</p><p>$u_n^{(T+1)}$小一些，AdaBoost效果就好一点，那不如把$u_n^{(T+1)}$看作一种新的error  measure的指标。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226171521723.png" srcset="/img/loading.gif" alt="image-20210226171521723"></p><p>且这种新的错误指标还是0/1 error measure的上界，那我们能做到很好吗？</p><p>我们来证明一下：</p><p>首先回顾gradient descent：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226172611163.png" srcset="/img/loading.gif" alt="image-20210226172611163"></p><p>$\eta$是步长/学习率，$v^T$是梯度的反方向。</p><p>同理我们考虑$Min\   E_{ADA}$是否也可以转化成这种想法：</p><p>在第$t$次迭代，我们想找一个$h$使得error迭代后最小。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226235013482.png" srcset="/img/loading.gif" alt="image-20210226235013482"></p><p>化简：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226235409161.png" srcset="/img/loading.gif" alt="image-20210226235409161"></p><p>现在问题转化为了：如何最小化第二项。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226235459540.png" srcset="/img/loading.gif" alt="image-20210226235459540"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210226235714704.png" srcset="/img/loading.gif" alt="image-20210226235714704"></p><p>我们现在把这个式子做一个平移：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227005510055.png" srcset="/img/loading.gif" alt="image-20210227005510055"></p><p>那么我们最小化$E_{in}^{u(t)}(h)$即可</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227005904222.png" srcset="/img/loading.gif" alt="image-20210227005904222"></p><p>那么谁在最小化$E_{in}^{u(t)}(h)$？  这个问题等价于：谁找到了一个最好的$h$作为$g_t$?</p><p>我们看下AdaBoost的算法流程：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222011244963.png" srcset="/img/loading.gif" alt="image-20210222011244963"></p><p>很明显最小化$E_{in}^{u(t)}(h)$的任务就是AdaBoost算法中的$A$来做的，而且这个最好的$h$就像是梯度下降中的梯度方向。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227020800388.png" srcset="/img/loading.gif" alt="image-20210227020800388"></p><p>我们找到最好的h，也就是$g_t$后，我们想着走的大步一些：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227020920164.png" srcset="/img/loading.gif" alt="image-20210227020920164"></p><p>这样找的最优的$\eta$由于是贪心的来走，所以肯定比一个固定的$\eta$大：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227021646829.png" srcset="/img/loading.gif" alt="image-20210227021646829"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227022703631.png" srcset="/img/loading.gif" alt="image-20210227022703631"></p><p>我缓缓打出一个问号？ 这个最好的$\eta$居然就是$\alpha_t$。</p><p>之前我们认为$\alpha_t$是在帮我们做不同$g_t$权重的衡量,现在来看，背后还在帮助我们做最佳化，快速到达最好的局面。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227023937467.png" srcset="/img/loading.gif" alt="image-20210227023937467"></p><p>AdaBoost中的这种steepest decent用到了函数式梯度。</p><h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>那么AdaBoost的本质是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227024344037.png" srcset="/img/loading.gif" alt="image-20210227024344037"></p><p>我们可以把这种思想带入任何其他的error measure方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227024908244.png" srcset="/img/loading.gif" alt="image-20210227024908244"></p><p>这种算法就是GradientBoost。</p><p>由于任何error measure都可以使用，那么：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227025106668.png" srcset="/img/loading.gif" alt="image-20210227025106668"></p><p>我们现在对回归任务/软分类问题也做GradientBoost。</p><p>我们下面再回归任务上来看看GradientBoost怎么用的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227025454635.png" srcset="/img/loading.gif" alt="image-20210227025454635"></p><p>和上一节AdaBoost一样，做Taylor展开：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227030652494.png" srcset="/img/loading.gif" alt="image-20210227030652494"></p><p>$h(x)$是走的方向，那么他应该要和$2(s_n-y_n)$组合起来保持是负的，才能不断地是原算式边小。</p><p>那么$h(x)$符号方面至少要保证$h(x_n) = -k*(s_n-y_n),其中k&gt;0$,我们希望下降的越大越好，反正$h$没什么限制，不妨让$k$趋于无穷</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227031622661.png" srcset="/img/loading.gif" alt="image-20210227031622661"></p><p>这么做看起来明显不是很合理，之前再gradient descent中我们限制了梯度向量的长度为一个定值。</p><p>那么谁来解决$h(x_n)$的大小问题呢？用$\eta$，因为$\eta$是第二层，外面那一层的优化，他会帮我们来做这个事情。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227032434540.png" srcset="/img/loading.gif" alt="image-20210227032434540"></p><p>我们首先加上了一个平方项，这个和最小化式子是相违背的，这样就帮助我们尽可能地减小$h(x)_n$的大小。</p><p>我们并不关注那些常数项，和最优化没关系。</p><p>最后我们推出我们只关心$h(x_n)$和$(y_n-s_n)$的相似度，而$(y_n-s_n)$代表了实际与预期的差距。</p><p>那么现在的我们最小化的就是 这样一个square error：$(h(x_n)-(y_n-s_n))^2$,再做对数据${(x_n,y_n-s_n)}$一次regression找最好的$h$即可。</p><p>现在问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227173206285.png" srcset="/img/loading.gif" alt="image-20210227173206285"></p><p>发现又变成了squre error的形式，等于现在再做一次regression，不过我们的只求一个$\eta$。</p><p>最后把所有的东西合并在一起，提出Gradient Boosted Decision Tree(GBDT)算法</p><p><code>Gradient Boosted Decision Tree(GBDT)</code>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227224805845.png" srcset="/img/loading.gif" alt="image-20210227224805845"></p><h2 id="Summary-of-Aggregation"><a href="#Summary-of-Aggregation" class="headerlink" title="Summary of Aggregation"></a>Summary of Aggregation</h2><p>首先是blending(即已经获得$g_t$后的aggregate方法)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227230408968.png" srcset="/img/loading.gif" alt="image-20210227230408968"></p><ul><li><p>uniform：适用于$g_t$的地位相差不大</p></li><li><p>non-uniform：也就是linear blending，要小心overfit</p></li><li>conditional：也就是stacking，要小心overfit</li></ul><p>和第一种aggregation不同，这第二部分的aggregation是边学边获得$g_t$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227230836402.png" srcset="/img/loading.gif" alt="image-20210227230836402"></p><ul><li><p>bagging：bootstrap抽取数据训练 + uniform合在一起</p></li><li><p>AdaBoost：处理$g_t$的线性组合</p></li><li>Decision Tree：处理conditional vote</li></ul><p>还有一个GradientBoost，他的$g_t$的多样性通过对余数做regression来得到。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227232349094.png" srcset="/img/loading.gif" alt="image-20210227232349094"></p><p>我们还可以进行组合：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227232602033.png" srcset="/img/loading.gif" alt="image-20210227232602033"></p><p>aggregation带来的好处是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210227233043284.png" srcset="/img/loading.gif" alt="image-20210227233043284"></p><p>不拟合的时候aggregation相当于做feature transform帮你拟合，却也可以帮你regularization防止过拟合，因此选择合适的aggregation方法才可以获得更好的表现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH10：Random Forest</title>
    <link href="/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH10%EF%BC%9ARandom-Forest/"/>
    <url>/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH10%EF%BC%9ARandom-Forest/</url>
    
    <content type="html"><![CDATA[<h1 id="CH10：Random-Forest"><a href="#CH10：Random-Forest" class="headerlink" title="CH10：Random Forest"></a>CH10：Random Forest</h1><h2 id="Random-Forest-Algorithm"><a href="#Random-Forest-Algorithm" class="headerlink" title="Random Forest Algorithm"></a>Random Forest Algorithm</h2><p>首先回顾：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224181106431.png" srcset="/img/loading.gif" alt="image-20210224181106431"></p><p><code>random forest</code>是两部分组成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224181409080.png" srcset="/img/loading.gif" alt="image-20210224181409080"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224181520290.png" srcset="/img/loading.gif" alt="image-20210224181520290"></p><p>流程是：</p><ul><li>首先对数据做bootstrap，处理数据</li><li>然后用处理完的数据去跑decision tree，获得很多个$g_t$</li><li>最后uniform的合并这些树，也就是uniform的合并$g_t$</li></ul><p>这个算法的特点：</p><ul><li><p>我们可以看到用decision tree处理数据的时候，不同份数据没有关系，所以可以并行计算，很高效</p></li><li><p>还有就是random forest 继承了C&amp;RT的优势：可以处理multi-class的数据</p></li><li>C&amp;RT由于时fully-grown tree可能回overfit，但是bagging会大大的减轻这种情况。</li></ul><p>我们合起来这些树的时候，希望这些书很多样性，除了我们bootstrap做出来的数据可以帮助多样性外，我们还可以对数据的feature下手，比如feature 的维度是$d$，我们可以随机抽$d’(d’&lt;d)$个维度(即抽一个feature的子集)来做C&amp;RT decision tree。</p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224191235692.png" srcset="/img/loading.gif" alt="image-20210224191235692"></p><p>除了这个random特性，Random Forest还有一个random的特性：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224193659604.png" srcset="/img/loading.gif" alt="image-20210224193659604"></p><p>已经抽取后的$d’$维数据，我们在给他乘上一个投影矩阵，其中投影矩阵的每一行从基向量随机抽出来</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224194416101.png" srcset="/img/loading.gif" alt="image-20210224194416101"></p><p>这种方法使每次分支得到的不再是单一的子特征集合，而是子特征的线性组合（权重不为1）。<strong>好比在二维平面上不止得到水平线和垂直线，也能得到各种斜线。</strong>这种做法使子特征选择更加多样性。值得注意的是，不同分支$i$下的$p_i$是不同的，而且向量$p_i$中大部分元素为零，因为我们选择的只是一部分特征，这是一种低维映射。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224203439786.png" srcset="/img/loading.gif" alt="image-20210224203439786"></p><h2 id="Out-of-bag-Estimate"><a href="#Out-of-bag-Estimate" class="headerlink" title="Out-of-bag Estimate"></a>Out-of-bag Estimate</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224212331714.png" srcset="/img/loading.gif" alt="image-20210224212331714"></p><p>Bagging中bootstrap用图来表示就是下面这样：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224212416495.png" srcset="/img/loading.gif" alt="image-20210224212416495"></p><p>他代表了我们训练的$g$是由哪儿些数据训练出来的，红色的$*$代表这个数据在这个训练中没有被用到，用到的就会放入到$D$中。</p><p>我们称这些红色的$*$为：$g_t$的out-of-bag数据</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224213119586.png" srcset="/img/loading.gif" alt="image-20210224213119586"></p><p>对于一个数据$(x_n,y_n)$来说,他成为out of bag的几率是 $(1-1/N)^N$,其中N是抽出来的数据的数量。</p><p>如果$N$足够大，那么一个数据成为OOB的概率就是$1/e$。也就是说我们的数据有$1/3$是没有被用到的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224213936316.png" srcset="/img/loading.gif" alt="image-20210224213936316"></p><p>我们有$1/3$的资料没用，那么我们有这个做validation不就好了吗？</p><ul><li><p>我们用OOB来验证$g_t$？其实是不需要的，因为我们并不关心$g_t$做的怎么样，反正最后aggregate在一起效果好就行。</p></li><li><p>但是我们需要用OOB来验证$G$(最后把$g$ 合并在一起的函数)，在blending或者random forest中的decision tree中我们会遇到一些参数，这些参数选择的怎么样，我们可以用OOB来验证。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224214740556.png" srcset="/img/loading.gif" alt="image-20210224214740556"></p><p>比如资料$(x_N,y_N)$他在$g_1$中被用到了，但是在$g_2,g_3,g_T$中没有被用到，所以我们可以说用$g_2,g_3,g_T$组合成的$G_N^-(x)$来做validation，</p><p>对每一个数据都这么做，有点类似于one-versus-all validation</p><p>最后得到这个错误率：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224220629394.png" srcset="/img/loading.gif" alt="image-20210224220629394"></p><p>我们和之前的validation再观察一下区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224220907560.png" srcset="/img/loading.gif" alt="image-20210224220907560"></p><ul><li><p>传统的用$E_{val}$来选择的方法，我们需要做两次训练动作，第一次用一部分训练$g$，然后validation选出最好的$g$，最后再用所有的数据重新训练这个hypothesis。</p></li><li><p>而$E_{oob}$只需要训练一次</p></li></ul><h2 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224222909626.png" srcset="/img/loading.gif" alt="image-20210224222909626"></p><ul><li>冗余的特征：例如生日和年龄</li><li>无关的特征：比如在预测癌症时，是否有保险这个东西和癌症没什么关系。</li></ul><p>我们只需要一堆feature里的一个子集，这<strong>样高效且鲁棒性好</strong>。</p><p>虽然高效，但是你怎么选出这个子集呢？这是一个组合问题，这里确实很耗费时间的。</p><p>我们可以给每个feature打一个分，选择最高的几个即可，怎么定义这个分数呢？</p><p>这里介绍<strong>random test</strong>：</p><p>大致的思想就是：如果一个维度很重要，那我把这个维度污染后得到结果回合原来的结果差距就会很大。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210224224900040.png" srcset="/img/loading.gif" alt="image-20210224224900040"></p><p>怎么污染呢？可以用permutation test来污染，我们把这一个维度的数据洗牌(仅仅是这个维度)，然后和原来的表现做对比。</p><p>剩下最后一个问题，我们怎么衡量$performance$呢？</p><p>我们不想再用validation了，因为这样会重新训练一下才能得到结果，我们可以用$E_{oob}$代替。</p><h2 id="Random-Forest-in-Action"><a href="#Random-Forest-in-Action" class="headerlink" title="Random Forest in Action"></a>Random Forest in Action</h2><p>我们来做一个对比：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225215149410.png" srcset="/img/loading.gif" alt="image-20210225215149410"></p><p>上图从左到右分别为：用C&amp;RT with random combination做的结果，第 t 次bootstrap得到的$g_t$，$t$棵树合在一起的效果。</p><p>我们把迭代次数增加：</p><p>t=100</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225215409730.png" srcset="/img/loading.gif" alt="image-20210225215409730"></p><p>t=400</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225215425731.png" srcset="/img/loading.gif" alt="image-20210225215425731"></p><p>t=1000</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225215447716.png" srcset="/img/loading.gif" alt="image-20210225215447716"></p><p>观察上图的左下角在边上的红色叉叉，如果是通过random forest来做，可以发现得到结果没有在边上，也就是<strong>做到了large-margin</strong>。</p><p>并且<strong>边界更加光滑</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225215639800.png" srcset="/img/loading.gif" alt="image-20210225215639800"></p><p>我们对一份数据加上10%噪音</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210225220139369.png" srcset="/img/loading.gif" alt="image-20210225220139369"></p><p>random forest依然得到了很好的效果.</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH9：Decision Tree</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH9%EF%BC%9ADecision-Tree/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH9%EF%BC%9ADecision-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="CH9：Decision-Tree"><a href="#CH9：Decision-Tree" class="headerlink" title="CH9：Decision Tree"></a>CH9：Decision Tree</h1><h2 id="Decision-Tree-Hypothesis"><a href="#Decision-Tree-Hypothesis" class="headerlink" title="Decision Tree Hypothesis"></a>Decision Tree Hypothesis</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222201947821.png" srcset="/img/loading.gif" alt="image-20210222201947821"></p><p>一个decision tree的例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222202359077.png" srcset="/img/loading.gif" alt="image-20210222202359077"></p><ul><li>$g_t(x)$：称为base hypothesis，叶子节点，一个常数，代表路径$t$的终点的常量，也就是最后做的决定。</li><li>$q_t(x)$:  称为condition，  判断$x$是否在路径$t$上。</li></ul><p>我们可以把一棵树看成如下的样式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210529122441024.png" srcset="/img/loading.gif" alt="image-20210529122441024"></p><p>那么上图这种一个节点对应着三个子树，然后在子树中可以接着递归找子树。因此我们还可以用递归的来定义这个决策树：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222202917934.png" srcset="/img/loading.gif" alt="image-20210222202917934"></p><ul><li>$G(x)$ 一个树</li><li>$b(x)$分支条件</li><li>$G_c(c)$:第c个分支条件通向的子树</li></ul><p><strong>decision tree的优点：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222203127186.png" srcset="/img/loading.gif" alt="image-20210222203127186" style="zoom:50%;" /></p><ul><li>可解释性强，常用在医学等模型上。</li><li>简单，只是一个树递归</li><li>高效，判断的复杂度是log级别的</li></ul><p><strong>缺点：</strong></p><ul><li>没有很强的理论解释/理论支持</li><li>实际应用中依赖启发式的选择，需要灵感。</li></ul><h2 id="Decision-Tree-Algorithm"><a href="#Decision-Tree-Algorithm" class="headerlink" title="Decision Tree Algorithm"></a>Decision Tree Algorithm</h2><p>这个算法很容易写出一个basic的版本。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222203617410.png" srcset="/img/loading.gif" alt="image-20210222203617410"></p><p>但是我们要做四个选择</p><ul><li>分支有多少</li><li>依赖什么因素来分支</li><li>什么时候停止</li><li>回传的constant是什么</li></ul><p>下面介绍一种常用的decision tree：<code>Classification and Regression Tree(C&amp;RT)</code></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222203844228.png" srcset="/img/loading.gif" alt="image-20210222203844228"></p><ul><li><p>这个tree是一个binary tree，每个结点只有两个分支。</p></li><li><p>对于叶子节点的值怎么设定呢？</p><ul><li>对于classification任务(0/1 error)：我们用一组已经知道label的资料放进去跑decision tree，落在叶子节点后计数，看看每个叶子节点里1多还是0多，取多者为叶子节点的constant，即取最多的$y_n$。</li><li>对于regression任务(squared error)：取$y_n$的平均即可。</li></ul></li></ul><p>除了上面的 如何设置分支也是很重要的一部分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222205355159.png" srcset="/img/loading.gif" alt="image-20210222205355159"></p><p><code>C&amp;RT</code>的划分方法：</p><ul><li><strong>用<code>Decision Stump</code>来划分：</strong>对feature的每个维度划分，那么一共可以有$d$个binary decision。</li><li><strong>依靠purifying(纯度)来决定分支：</strong></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222210524103.png" srcset="/img/loading.gif" alt="image-20210222210524103"></p><p>对于每个binary decision，也就是一个$h$ ,我们考量他的得分$b(x)$，思路很简单，就是对于$h$分割开的两份我们分别去算各自那一份的不纯度，然后乘上那一份的大小，这个做法很符合直觉。</p><p>上述的$impurity$函数选择有下面几种：</p><p>首先可以通过$E_{in}$来选择。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222213449020.png" srcset="/img/loading.gif" alt="image-20210222213449020"></p><p>对于classification错误，我们也可以用这几种：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222213711232.png" srcset="/img/loading.gif" alt="image-20210222213711232"></p><p>实际应用这 在regression中常用<code>regression error</code>，在classification中常用<code>Gini index</code></p><p>最后一个问题就是：什么时候停止？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222214006301.png" srcset="/img/loading.gif" alt="image-20210222214006301"></p><h2 id="Decision-Tree-Heuristics-in-C-amp-RT"><a href="#Decision-Tree-Heuristics-in-C-amp-RT" class="headerlink" title="Decision Tree Heuristics in C&amp;RT"></a>Decision Tree Heuristics in C&amp;RT</h2><p><code>C&amp;RT</code>算法总结：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222214204395.png" srcset="/img/loading.gif" alt="image-20210222214204395"></p><p>二元分类任务可以很简单的完成，同时如果是一个multi-classification的任务，我们对上面的算法只需要constant改一下，impurity的计算公式改一下就可以做多分类问题了。</p><p>但是我们注意到了一个问题：</p><p>这个算法里要求最后是fully-grown tree，即$E_{in}(G)=0$, 但这样很有可能最后overfit。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222221003570.png" srcset="/img/loading.gif" alt="image-20210222221003570"></p><ul><li><p>我们需要一种regularizer,一种简单想法：控制叶子节点的数量。</p></li><li><p>然后我们去做正则化：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222221021100.png" srcset="/img/loading.gif" alt="image-20210222221021100"></p></li></ul><ul><li>$\lambda$怎么选择：validation</li></ul><p>通过$\lambda$来平衡这件事情，我们称这种decision tree为<code>pruned decision tree</code></p><p>但是这个方法操作起来没那么简单，我们考虑的是all possible G，那种类可就太多了，所以我们考虑这么做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222221349533.png" srcset="/img/loading.gif" alt="image-20210222221349533"></p><ul><li>先做一个fully-grown tree，作为$G^{(0)}$.</li><li>然后对这个G(0),每次去掉一个叶子节点，计算$E<em>{in}$,然后先放回去，接着再选一个叶子节点去掉，我们找这里面$E</em>{in}$最低的一种删除掉，作为$G^{(1)}$</li><li>以此循环</li></ul><p>如果我们有一些资料缺少了一些feature，我们可以用其他相似的feature 来替代：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222230831375.png" srcset="/img/loading.gif" alt="image-20210222230831375"></p><p>比如体重数据缺失了一部分，可以根据身高的threshold。</p><h2 id="Decision-Tree-in-Action"><a href="#Decision-Tree-in-Action" class="headerlink" title="Decision Tree in Action"></a>Decision Tree in Action</h2><p>举一个例子：</p><p>第一次：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222232922678.png" srcset="/img/loading.gif" alt="image-20210222232922678"></p><p>第二次：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222232939444.png" srcset="/img/loading.gif" alt="image-20210222232939444"></p><p>第三次：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222232951537.png" srcset="/img/loading.gif" alt="image-20210222232951537"></p><p>第四次：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222233009854.png" srcset="/img/loading.gif" alt="image-20210222233009854"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222233056743.png" srcset="/img/loading.gif" alt="image-20210222233056743"></p><p>我们可以看出区别：AdaBoost切的都是贯穿全局的，而C&amp;RT可以由于在子树里切，因此可以切一部分</p><p>当数据多的时候，我们会发现C&amp;RT效率会高一些，因为它可以切一小部分。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222233232138.png" srcset="/img/loading.gif" alt="image-20210222233232138"></p><p><strong>Decision tree 优势：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222233333535.png" srcset="/img/loading.gif" alt="image-20210222233333535"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH8：Adaptive Boosting</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH8%EF%BC%9AAdaptive-Boosting/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH8%EF%BC%9AAdaptive-Boosting/</url>
    
    <content type="html"><![CDATA[<h1 id="CH8：Adaptive-Boosting"><a href="#CH8：Adaptive-Boosting" class="headerlink" title="CH8：Adaptive Boosting"></a>CH8：Adaptive Boosting</h1><h2 id="Motivation-of-Boosting"><a href="#Motivation-of-Boosting" class="headerlink" title="Motivation of Boosting"></a>Motivation of Boosting</h2><p>我们假设一个老师教学生认苹果的场景：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221204246512.png" srcset="/img/loading.gif" alt="image-20210221204246512"></p><p>其中上半部分是苹果，下半部分是其他水果。</p><p>1.首先A提出<strong>按照形状判别</strong>苹果：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221204401308.png" srcset="/img/loading.gif" alt="image-20210221204401308"></p><p>那么A做对了一部分，但是蓝色方块的水果里判别犯了错误。</p><p>2.我们为了减少这些错误，我们可以把已经做对的变得小一些(表示我们减轻一些对这些图片的注意力，着重看我们犯错的地方)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221205111564.png" srcset="/img/loading.gif" alt="image-20210221205111564"></p><p>我们又提出一种判别的方法：红颜色的是苹果</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221205157904.png" srcset="/img/loading.gif" alt="image-20210221205157904"></p><p>但是这种方法在其他地方又会在蓝色部分判断错误。</p><p>3.我们重复第二步，放大错误，缩小正确的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221205317442.png" srcset="/img/loading.gif" alt="image-20210221205317442"></p><p>我们提出新的判别方法：苹果是绿色的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221205428810.png" srcset="/img/loading.gif" alt="image-20210221205428810"></p><p>我们此时犯了一堆错误，但是请注意，我们犯错的都是我们注意力已经下降的图片了，在主要的注意力上，比如右下角的番茄被判别正确了。</p><p>4.和上面一样，蓝色部分(错误的)放大，再找新的规则来判别：苹果有梗</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221205633153.png" srcset="/img/loading.gif" alt="image-20210221205633153"></p><p>以此不断重复。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221210142178.png" srcset="/img/loading.gif" alt="image-20210221210142178"></p><p>这就像一堆二元分类的classifier的aggregation。</p><p>老师给出的指导就是让我们focus on key example</p><h2 id="Diversity-by-Re-weighting"><a href="#Diversity-by-Re-weighting" class="headerlink" title="Diversity by Re-weighting"></a>Diversity by Re-weighting</h2><p>我们首先回想一下<code>Bagging算法</code>,首先做bootstrap：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221211046001.png" srcset="/img/loading.gif" alt="image-20210221211046001"></p><p>然后我们找出每个$g<em>t$通过使得该份数据都最小化$E</em>{in}$来得到。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221211057685.png" srcset="/img/loading.gif" alt="image-20210221211057685"></p><p>其实我们可以换一种写法，我们用$u_t$代表第$t$个数据的重复次数：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221211308193.png" srcset="/img/loading.gif" alt="image-20210221211308193"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221211400829.png" srcset="/img/loading.gif" alt="image-20210221211400829"></p><p>这里面的$u$的概念可以代表这个点的权重：</p><p>我们提出weighted base algorithm</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221212214679.png" srcset="/img/loading.gif" alt="image-20210221212214679"></p><p>我们可以把这个问题转化为一个SVM问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221213458324.png" srcset="/img/loading.gif" alt="image-20210221213458324"></p><p>也可以转化为一个logistic regression问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221215133126.png" srcset="/img/loading.gif" alt="image-20210221215133126"></p><p>在aggregate里我们提到过：我们希望$g$之间越不同越好，也就是$g$多样性一些，因为这说明着我们学到了新的特性。</p><p>我们怎么才能使得$g$有一些多样性呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221222247281.png" srcset="/img/loading.gif" alt="image-20210221222247281"></p><p>我们比如现在用$u<em>n^{(t)}$和$u_n^{(t+1)}$两份数据分别来训练$g$并得到$g</em>{t}$和$g_{t+1}$，我们希望的多样性就是指这两个预策的结果不是很像。</p><p>那么现在假设我们已经有$g<em>t$了，我们想要获得一个新的$u_n^{(t+1)}$来使得训练得到的$g</em>{t+1}<script type="math/tex">和</script>g_{t}$不太一样：</p><p>我们怎么数学的去衡量这个不一样呢？</p><p>我们用$u_n^{t+1}$这个权重去计算$g_t$算出来的判别结果来加上权重，这样算出来的错误率如果能达到$1/2$,那么说明已经长得很不一样了，因为这样计算出来的错误率和瞎说判别结果得到的错误率已经没区别了(几率都是$1/2$)，那么此时用这个$u_n^{t+1}$去训练数据一定可以得到一个和$g_t$相差比较大的结果。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221223318626.png" srcset="/img/loading.gif" alt="image-20210221223318626"></p><p>现在的问题就是我们希望怎么到达这个$1/2$.</p><p>我们拆开来看这个式子，就是计算错误的次数 </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221224318504.png" srcset="/img/loading.gif" alt="image-20210221224318504"></p><p>我们希望在$u_n^{t+1}$的数据下用$g_t$来预测，最后得到结果这样的结果：错的数据数 占 总数据数的一半。那么怎么调节呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210221234903979.png" srcset="/img/loading.gif" alt="image-20210221234903979"></p><p>​    比如我们在$u<em>n^{(t)}$下我们错误数是1126，正确数是6211，我们调整一下下一次的权重对于犯错的点权重调整为：$u_n^{(t+1)} = u_n^{(t)}<em>6211$，同理，对于正确的点调整为：$u_n^{(t+1)} = u_n^{(t)}</em>1126$。我们就可以得到一个全新的$u_n^{(t+1)}$，这个就保证$g</em>{t+1}$和$g_{t}$的不同。</p><h2 id="Adaptive-Boosting-Algorithm"><a href="#Adaptive-Boosting-Algorithm" class="headerlink" title="Adaptive Boosting Algorithm"></a>Adaptive Boosting Algorithm</h2><p>我们把上节最后的内容用一个<code>scaling factor</code>来统一下这样的操作：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222003828364.png" srcset="/img/loading.gif" alt="image-20210222003828364"></p><p>这个<code>scaling factor</code> 很好的统一了两种操作。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222004452365.png" srcset="/img/loading.gif" alt="image-20210222004452365"></p><p>就像这个放大错误就像是第一节老师所起到的作用一样。</p><p>我们现在提出我们的算法的一个大致思路：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222004900270.png" srcset="/img/loading.gif" alt="image-20210222004900270"></p><p>但有两个问题：</p><ul><li><p>$u^{(1)}$怎么选择呢？   我们想让$g_1$表现最好，一个比较直观的就是让$u_n^{(1)} = 1/N$.也就是我们不做干涉。</p></li><li><p>那我们怎么得到$G(x)$呢？也就是怎么融合得到的$g$呢？    </p><ul><li>uniform ？ 这不是一个很好的方法，因为我们前面已经说了，$g$和$g$之间差别很大，这样得到的效果会很差</li><li>我们可以linear，no-linear的来组合</li><li>其实我们可以用一种特别的算法来aggregate这些$g$, 并且还是linearly，实时的来aggregate这些$g$。</li></ul></li></ul><p>我们希望这种算法是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222005833329.png" srcset="/img/loading.gif" alt="image-20210222005833329"></p><p>这种算法可以边算$g$边给出权重$\alpha$.</p><ul><li>我们希望好的$g$占的权重可以大一些,我们可以让$\alpha_t=ln(♦_t)$:<ul><li>错误率$\epsilon_t=1/2 \to ♦_t=1 \to \alpha=0$  :也就是说表现差的g不要，权重是0</li><li>错误率$\epsilon_t=0 \to ♦_t=∞ \to \alpha=∞$  :也就是说表现完美直接权重拉满！</li></ul></li></ul><p>因此Adaptive Aggregation的算法是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222011244963.png" srcset="/img/loading.gif" alt="image-20210222011244963"></p><p>其实这个算法就是三部分组成：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222011305837.png" srcset="/img/loading.gif" alt="image-20210222011305837"></p><p>比较弱的算法$A$,老师进行权重调整，最后aggregate到一起。</p><p><strong><code>AdaBoost</code>的理论保证：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222011622233.png" srcset="/img/loading.gif" alt="image-20210222011622233"></p><ul><li>AdaBoost的作者给出了迭代$logN$轮后即可让$E_{in}$几乎等于0</li><li>我们把$T=logN$带入VC bound后半部分的式子就会发现后半部分式子很小</li><li>这样VC Bound就告诉我们，AdaBoost算法让$E<em>{in}$几乎等于0，并且还可以得到很好的$E</em>{out}$</li></ul><h2 id="Adaptive-Boosting-in-Action"><a href="#Adaptive-Boosting-in-Action" class="headerlink" title="Adaptive Boosting in Action"></a>Adaptive Boosting in Action</h2><p>回到上次的AdaBoositng算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222011244963.png" srcset="/img/loading.gif" alt="image-20210222011244963"></p><p>我们希望让找一种比较弱的算法，可以使得表现的效果过好一点，但不用特别好，因为我们上节提到，几个比较准确率大于$1/2$的算法就可以aggregate一个不错的算法了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222013450922.png" srcset="/img/loading.gif" alt="image-20210222013450922"></p><p>一种比较常用的方法是：<code>decision stump</code>​</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222013930476.png" srcset="/img/loading.gif" alt="image-20210222013930476"></p><p>这种方法是：在不同维度的feature上做简单的二元分类，分割线在二维面上只有水平/竖直 分割线。</p><p>但是效率非常高: 每次我们对每个维度去排序$O(NlogN)$，然后$O(n)$去遍历最好的分割点，对每一个维度都这么操作，$d$个维度，那么复杂度就是$O(d*Nlog N)$</p><p>举个例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222014339370.png" srcset="/img/loading.gif" alt="image-20210222014339370"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222014415538.png" srcset="/img/loading.gif" alt="image-20210222014415538"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222014445932.png" srcset="/img/loading.gif" alt="image-20210222014445932"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222014520776.png" srcset="/img/loading.gif" alt="image-20210222014520776"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210222014526907.png" srcset="/img/loading.gif" alt="image-20210222014526907"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH7：Blending and Bagging</title>
    <link href="/2021/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH7%EF%BC%9ABlending-and-Bagging/"/>
    <url>/2021/02/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH7%EF%BC%9ABlending-and-Bagging/</url>
    
    <content type="html"><![CDATA[<h1 id="CH7：Blending-and-Bagging"><a href="#CH7：Blending-and-Bagging" class="headerlink" title="CH7：Blending and Bagging"></a>CH7：Blending and Bagging</h1><h2 id="Motivation-of-Aggregation"><a href="#Motivation-of-Aggregation" class="headerlink" title="Motivation of Aggregation"></a>Motivation of Aggregation</h2><p>现在有这样一个问题：有15个人来指导我买股票，我怎么选则是否买呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219182732400.png" srcset="/img/loading.gif" alt="image-20210219182732400"></p><ul><li><p>首先是最直观的 ：选择一个以前买股票表现最好的的，也就是在做validation时最好的那一个：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219182934647.png" srcset="/img/loading.gif" alt="image-20210219182934647"></p></li><li><p>让他们投票说明股票是否会涨，每个人一票：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219183055774.png" srcset="/img/loading.gif" alt="image-20210219183055774"></p></li><li><p>由于一些人水平会高一些，每个人的票数不应该一样：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219183133570.png" srcset="/img/loading.gif" alt="image-20210219183133570"></p><p>这里面是包含了以上两种的选择方式的。</p></li><li><p>有些人在某些专业领域比较在行，所以不同股票每个人权重不应该一样：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219183331178.png" srcset="/img/loading.gif" alt="image-20210219183331178"></p></li></ul><p>我们回顾一下select by validation：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219184644702.png" srcset="/img/loading.gif" alt="image-20210219184644702"></p><ul><li>简单/常用</li><li>我们可以用$E<em>{in}(g_t)$来代替$E</em>{val}(g_t^-)$, 但是这样会花费很大的复杂度代价</li><li>同时使用validation的时候，一般是会存在一种模型$g<em>t^-$使得$E</em>{val}$很小。</li></ul><p>也就是说：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219195047584.png" srcset="/img/loading.gif" alt="image-20210219195047584"></p><p>select by validation是需要有一个不错的hypothesis在set种才有意义，一堆垃圾选出来最好的也没有什么意义。</p><p>而aggregation(聚合)：我们用一些一般的hypothesis来聚合成一个比较好的模型。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219195208545.png" srcset="/img/loading.gif" alt="image-20210219195208545"></p><p>首先我们考虑为什么这个idea 可能work：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219195444893.png" srcset="/img/loading.gif" alt="image-20210219195444893"></p><p>比如我们只能用垂直和水平的线来做分类，那么任何一种线似乎都无法做到完美，但是当我们把几种线聚合在一起，那么我们是有机会完美分开这两种的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219195939027.png" srcset="/img/loading.gif" alt="image-20210219195939027"></p><p>这有点类似在做feature transform。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219200014487.png" srcset="/img/loading.gif" alt="image-20210219200014487"></p><p>我们比如这样一个数据：我们跑PLA会得到灰色线（许多条），那么我们用aggregation来做投票后，我们得到的是一个在中间的线，这好像和SVM理论相似，找胖胖的边界，同时这也会带来regularization，容忍错误。</p><p>但是在之前的课程来看，我们基石中提到的feature transform好像和regularzation是一个矛盾的概念，因为我们认为feature transform会使得我的模型过于复杂最后overfit，从而导致容忍错误的能力差，鲁棒性差，直观反应就是regularzation没有做到。而在这里这两个概念似乎很好的平衡了。</p><h2 id="Uniform-Blending-一致融合"><a href="#Uniform-Blending-一致融合" class="headerlink" title="Uniform Blending(一致融合)"></a>Uniform Blending(一致融合)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219201025271.png" srcset="/img/loading.gif" alt="image-20210219201025271"></p><p>一致代表着每个人都有一票，融合就是把所有人的投票都融合在一起。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219201400256.png" srcset="/img/loading.gif" alt="image-20210219201400256"></p><p>​    这个的$G(x)$定义就是 比如有K个类别的结果，我们投票发现那儿一类得票数最多，最多的作为最后的投票结果。</p><p>​    </p><p>那么在regression问题中uniform blending得到的$G(x)$一般长这个样子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219202306524.png" srcset="/img/loading.gif" alt="image-20210219202306524"></p><p>我们考虑对具体某一种输入$x$来看，他们的squre error的区别：</p><p><strong>每个人预策结果和真实结果的squre error的平均值</strong> 与 <strong>每个人平均预策结果的平均值和真实结果的差值</strong> 的大小关系</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219202910515.png" srcset="/img/loading.gif" alt="image-20210219202910515"></p><p>这是对某一个$x$的得到的结果，如果是所有的$x$,那么就得到如下的式子，其中$\epsilon$表示期望。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219204116058.png" srcset="/img/loading.gif" alt="image-20210219204116058"></p><p>这样告诉我们，我们里<strong>用uniform blending求出的G去做预测的错误率</strong>真的会小于<strong>随便选一个$g_t$去做预测的错误率低。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219205117801.png" srcset="/img/loading.gif" alt="image-20210219205117801"></p><p>我们进行T轮迭代：</p><p>每次迭代都是新的N个数据，用算法来求出$g_t$,如果迭代T轮后我们就有T个$g_t$，于是我们可以求出一个$g_t$的平均作为$G$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219205433604.png" srcset="/img/loading.gif" alt="image-20210219205433604"></p><p>如果我们的迭代轮数T趋于无穷，那么：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219205534453.png" srcset="/img/loading.gif" alt="image-20210219205534453"></p><p>因此这是一个g的平均就是 = 产生资料过程的平均。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219205851642.png" srcset="/img/loading.gif" alt="image-20210219205851642"></p><ul><li>$avg(E_{out})$就是算法$A$得到的结果的期望</li><li>$E_{out}( \overline{g})$表示着各个hypothesis给出的结果的综合表现</li><li>$avg(\epsilon(g_t - \overline{g}))$  表示上述两个结果 的偏差 </li></ul><p>当 偏差消失，我们的算法得到的结果就会变好。</p><h2 id="Linear-and-Any-Blending"><a href="#Linear-and-Any-Blending" class="headerlink" title="Linear and Any Blending"></a>Linear and Any Blending</h2><p>Linear Blending是这样的一个问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219215358741.png" srcset="/img/loading.gif" alt="image-20210219215358741"></p><p>怎么样的$\alpha _t$的选择才是好的呢？</p><p>一个直观的想法就是我们取得这个最好的$\alpha$后我们可以得到最低的$E_{in}$。</p><p>Linear Blending 来组测回归问题就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219215452689.png" srcset="/img/loading.gif" alt="image-20210219215452689"></p><p>LinReg+feature transform似乎和他长得很像</p><p>我们可以把linear blending 看作 线性模型上加上一个feature transform，并且还有一个限制 那就是$\alpha\ge0$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219220416657.png" srcset="/img/loading.gif" alt="image-20210219220416657"></p><p>如果没有这个constraint，我们可以直接用Linear regression那一套同样的方法计算即可，但是现在我们有这个constraint，他有什么作用呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219220845548.png" srcset="/img/loading.gif" alt="image-20210219220845548"></p><p>如果对于一个$\alpha&lt;0$，我们可以转换为$|\alpha_t|(-g_t(x))$, 可是这样的转换会让这个$-g_t(x)$在预测时分类得到相反的结果，然而对于二分类来说，这种是无所谓的，我们看反面即可。</p><p>因此我们可以忽略constraint。</p><p>我们比较一下 Linear Blending 和 Seletion的区别</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219222228633.png" srcset="/img/loading.gif" alt="image-20210219222228633"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219222825870.png" srcset="/img/loading.gif" alt="image-20210219222825870"></p><ul><li><p>Selection by $E<em>{in}$ :这种方法我们首先是在不同的hypotheset中分别训练一个最好的g，然后用分别用自己得到的 $g$ 算$E</em>{in}$, 找到一个最小的$E<em>{in}$作为我们最好的g，这是一种best of best的想法，付出的代价是$d</em>{VC}(\cup_{t=1}^T H_t)$</p></li><li><p>Linear Blending：这种方法是找一个最好的 $\alpha$ 使得使得$E<em>{val}(g_t^-)$最小。复杂度是Linear blending with $E</em>{in}$, 也就是aggregation of best，把最好的汇聚在一起，这个复杂度是大于Selection by $E_{in}$的。</p></li><li>像selection方法一样，我们的blending方法经常用$E_{val}(g_t^-)$</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219225054001.png" srcset="/img/loading.gif" alt="image-20210219225054001"></p><p>如果我们可以做到Linear Blending,那么我们就可以做到any Blending</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210219234928095.png" srcset="/img/loading.gif" alt="image-20210219234928095"></p><h2 id="Bagging-Bootstrap-Aggregation"><a href="#Bagging-Bootstrap-Aggregation" class="headerlink" title="Bagging(Bootstrap Aggregation)"></a>Bagging(Bootstrap Aggregation)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220011650295.png" srcset="/img/loading.gif" alt="image-20210220011650295"></p><p>我们现在是学习完所有的$g$后开聚合，那么我们可以边学边聚合吗？这是我们接下来要考虑得问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220011814930.png" srcset="/img/loading.gif" alt="image-20210220011814930"></p><p>我们不一样的$g$可以来自很多方面：</p><ul><li>模型不同得到的$g$不同</li><li>不同的参数得到的$g$不同</li><li>算法本身就带有随机性，每次得出来的$g$不太一样，比如PLA的起始点不同</li><li>数据的随机性，比如within-cross-validation 通过不同的$g_{val}^-$肯定得到不同的结果</li></ul><p>如果我们就这有一份资料，想做blending，也就是说我们想过一份资料做data randomness得到不同的数据，用这些数据做blending，但是我们不希望用$g^-$的方法，因为这种方法得到的$g-$是比较次级的。</p><p>我们回顾一下上节的问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220013032954.png" srcset="/img/loading.gif" alt="image-20210220013032954"></p><p>也就是说一堆$g$的共同作用来判断的效果是好于单一的一个$g$来做判断的期望效果。</p><p>但是这是有一个前提的：</p><ul><li><p>首先迭代次数要趋于无穷，这里我们妥协一下，T改为一个很大的数，但是是有限的</p></li><li><p>其次，我们要保证资料是新鲜的，每次都从分布中得到新的资料，而我们现在只有一笔资料，这里我们可以用bootstrapping这个方法。</p></li></ul><p><strong>bootstrapping：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220013627953.png" srcset="/img/loading.gif" alt="image-20210220013627953"></p><p>这其实是一种统计学里的方法，这种方法就是有放回的抽取N个资料，每次抽取分别作为第$1，2，3…..T$笔训练资料。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220014000067.png" srcset="/img/loading.gif" alt="image-20210220014000067"></p><p>上图是一个实际的aggregation的方法和bootstrap aggregation的比较。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220014230295.png" srcset="/img/loading.gif" alt="image-20210220014230295"></p><p><strong>bootstrap aggregation也叫 BAGging</strong>，</p><p><strong>bootstrap aggregation就是一种先用bootstrap生成许多组的数据，然后用uniform的方法合起来。</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210220014514200.png" srcset="/img/loading.gif" alt="image-20210220014514200"></p><p>如果我们的<strong>algorithm对data randomness很敏感</strong>，那么我们就可以通过bootstrap得到较高质量的不同数据，此时我们的bagging效果会比较出色。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH6：Support Vector Regression</title>
    <link href="/2021/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH6%EF%BC%9ASupport-Vector-Regression/"/>
    <url>/2021/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH6%EF%BC%9ASupport-Vector-Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="CH6：Support-Vector-Regression"><a href="#CH6：Support-Vector-Regression" class="headerlink" title="CH6：Support Vector Regression"></a>CH6：Support Vector Regression</h1><h2 id="Kernel-Ridge-Regression"><a href="#Kernel-Ridge-Regression" class="headerlink" title="Kernel Ridge Regression"></a>Kernel Ridge Regression</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218193051184.png" srcset="/img/loading.gif" alt="image-20210218193051184"></p><p>如上一节所说，我们可以把最优解的$w_*$看作$z_n$的线性组合</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218195158615.png" srcset="/img/loading.gif" alt="image-20210218195158615"></p><p>因此我们可以解最优的$\beta$即可求出$w_*$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218195253023.png" srcset="/img/loading.gif" alt="image-20210218195253023"></p><p>这部分我们怎么求来的呢？</p><p>首先第一部分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218195430992.png" srcset="/img/loading.gif" alt="image-20210218195430992"></p><p>我们可以化为矩阵的形式来表达这个式子：$\beta K\beta$, 其中$\beta$是一个$1<em>N$矩阵，$K$是一个$N</em>N$的矩阵，其中$K_{n,m}$代表着$K(x_n,x_m)$。</p><p>第二部分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218195840382.png" srcset="/img/loading.gif" alt="image-20210218195840382"></p><p>平方和我们可以看作 一个向量的内积，即：$||y_n-\beta K||^2$,两部分都带入展开即可得到下式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218200017063.png" srcset="/img/loading.gif" alt="image-20210218200017063"></p><p>求梯度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218200336209.png" srcset="/img/loading.gif" alt="image-20210218200336209"></p><p>要求最小值，使得梯度=0，那么：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218200456794.png" srcset="/img/loading.gif" alt="image-20210218200456794"></p><p>我们来看一下<strong>Linear ridge regression和kernel ridge regression的区别：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218202359444.png" srcset="/img/loading.gif" alt="image-20210218202359444"></p><ul><li>在Linear ridge regression种我们训练的时间包含两部分，一个是求$d<em>d$矩阵的逆，所以复杂度是$O(d^3)$, 然后就是$d</em>d$的矩阵与$N*d$的矩阵相乘需要复杂度$O(d^2N)$， 我们预测的复杂度是：$O(d)$,即数据的维度和我们的$w$相乘即可</li><li>而在Kernel ridge regression种，我们需要对$N*N$的矩阵求逆，那么复杂度是$O(N^3)$, 预策复杂度就是$O(N)$。</li></ul><p>不难看出这又是一个trade-off：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218203159805.png" srcset="/img/loading.gif" alt="image-20210218203159805"></p><h2 id="Support-Vector-Regression-Primal"><a href="#Support-Vector-Regression-Primal" class="headerlink" title="Support Vector Regression Primal"></a>Support Vector Regression Primal</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218203642470.png" srcset="/img/loading.gif" alt="image-20210218203642470"></p><p>LSSVM 和 soft-margin SVM看起来的得出的结果差不多，但是正方形标出的是support vector，也就是说LSSVM的每个点都是support vector。这就导致了预测很慢。</p><p>我们可不可以像标准的soft-margin SVM一样，减少一点Support vector，也就是减少一些$\beta$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218205434104.png" srcset="/img/loading.gif" alt="image-20210218205434104"></p><p>我们还是考虑距离作为错误的衡量方式：</p><p>在margin里的说明没有错误，在margin外的错误就是$|s-y|$是到tube中心的长度，$\epsilon$是边界到tube中心的长度，那么错误就是$|s-y|-\epsilon$</p><p>我们对比一下这种error measure和squred error measure的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218205948947.png" srcset="/img/loading.gif" alt="image-20210218205948947"></p><p>我们发现在$S=y$附近, 两者并无太大的区别，远离$s$我们就会发现tube这种错误率增长速度慢于squred。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218210624355.png" srcset="/img/loading.gif" alt="image-20210218210624355"></p><p>因此我们想用standard SVM的方法来解决这个问题：</p><p>我们首先考虑转化成standard SVM的形式</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218214659612.png" srcset="/img/loading.gif" alt="image-20210218214659612"></p><p>$\xi_n$分为两种，一种是tube上方的，另一种是tube下方的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218215127334.png" srcset="/img/loading.gif" alt="image-20210218215127334"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218215237124.png" srcset="/img/loading.gif" alt="image-20210218215237124"></p><p>这个$C$代表在乎regularization多一些还是tube violation多一些</p><p>与SVM不同的是，除了$C$我们还有一个系数$\epsilon$需要确定。</p><h2 id="Support-Vector-Regression-Dual"><a href="#Support-Vector-Regression-Dual" class="headerlink" title="Support Vector Regression Dual"></a>Support Vector Regression Dual</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218220152653.png" srcset="/img/loading.gif" alt="image-20210218220152653"></p><p>和Lecture 4一样 写出KKT:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218220211505.png" srcset="/img/loading.gif" alt="image-20210218220211505"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218220603387.png" srcset="/img/loading.gif" alt="image-20210218220603387"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210525202611489.png" srcset="/img/loading.gif" alt="image-20210525202611489"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218221322480.png" srcset="/img/loading.gif" alt="image-20210218221322480"></p><p>我们来观察tube里的情况推到最后发现$\beta = 0$ ,那么说明这些不会对$w$有贡献,也就是说support vector只包括在tube上或者在tube外的点，因此这样的SVR是稀疏的(sparse)。</p><h2 id="Summary-of-Kernel-Model"><a href="#Summary-of-Kernel-Model" class="headerlink" title="Summary of Kernel Model"></a>Summary of Kernel Model</h2><p>首先是<strong>Linear Models的总结：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218221802181.png" srcset="/img/loading.gif" alt="image-20210218221802181"></p><p>橙色是我们在基石中学到的问题。</p><p>后来我们又加上了Linear soft-margin SVM和Linear SVR</p><p>绿色/黄色/红色 代表着三种不同的问题。</p><p>就像feature transform一样，我们有了linear的模型就可以延伸到kernel的模型：</p><p>我们总结一下kernel model：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210218222405331.png" srcset="/img/loading.gif" alt="image-20210218222405331"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH5：Kernel Logistic Regression</title>
    <link href="/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH5%EF%BC%9AKernel-Logistic-Regression/"/>
    <url>/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH5%EF%BC%9AKernel-Logistic-Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="CH5：Kernel-Logistic-Regression"><a href="#CH5：Kernel-Logistic-Regression" class="headerlink" title="CH5：Kernel Logistic Regression"></a>CH5：Kernel Logistic Regression</h1><h2 id="Soft-Margin-SVM-as-Regularzied"><a href="#Soft-Margin-SVM-as-Regularzied" class="headerlink" title="Soft-Margin SVM as Regularzied"></a>Soft-Margin SVM as Regularzied</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217182704686.png" srcset="/img/loading.gif" alt="image-20210217182704686"></p><p>当$(x_n,y_n)$越过边界时，错误就是$1-y_n(w^Tz_n+b)$,当$(x_n,y_n)$没有越过边界时，说明他是正确的没有错误，即$\xi=0$,那么我们综上所述：可以把$\xi$换成另一种写法：$max(1-y_n(w^Tz_n+b),0)$</p><p>此时我们的SVM可以这么写:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217183252584.png" srcset="/img/loading.gif" alt="image-20210217183252584"></p><p>这样一来，我们把之前抽象的$\xi$概念转化为了具体的式子，同时我们现在可以通过 $b,w$的不同取值最小化下式的soft-margin SVM问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217183428181.png" srcset="/img/loading.gif" alt="image-20210217183428181"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217183541395.png" srcset="/img/loading.gif" alt="image-20210217183541395"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217184542732.png" srcset="/img/loading.gif" alt="image-20210217184542732"></p><p>因此soft-margin SVM就是一个L2 regularization的问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217185054053.png" srcset="/img/loading.gif" alt="image-20210217185054053"></p><p>他们之间有一些相互的关系：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217185144879.png" srcset="/img/loading.gif" alt="image-20210217185144879"></p><h2 id="SVM-versus-Logistic-Regression"><a href="#SVM-versus-Logistic-Regression" class="headerlink" title="SVM versus Logistic  Regression"></a>SVM versus Logistic  Regression</h2><p>首先我们对比一下0-1error 和 SVM中的error measure的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217190201303.png" srcset="/img/loading.gif" alt="image-20210217190201303"></p><p>不难看出：SVM中的error measure总是大于0-1error measure。</p><p>之前在logistic regression中所用到的error measure方法叫做：scaled cross-entropy error ，详细推导见：<a href="https://chillstepp.github.io/2021/01/20/CH10%EF%BC%9ALogistic-Regression/">logistic regression</a>。</p><p>首先有个概念叫做：cross entropy</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217190950840.png" srcset="/img/loading.gif" alt="image-20210217190950840"></p><p>但是为了图像对比，改进成了<strong>scaled cross-entropy</strong>,即$ln$换成了$log_2$</p><p>我们对比一下三者：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217191214795.png" srcset="/img/loading.gif" alt="image-20210217191214795"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217191744126.png" srcset="/img/loading.gif" alt="image-20210217191744126"></p><p>这样看来： SVM的error measure方法和logistic regression的error measure方法很相似。</p><p>SVM此时可以看作: 有着L2-regularized的logistic regression</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217191912311.png" srcset="/img/loading.gif" alt="image-20210217191912311"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217192206685.png" srcset="/img/loading.gif" alt="image-20210217192206685"></p><p>因此现在我们有了一个新的想法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217192312492.png" srcset="/img/loading.gif" alt="image-20210217192312492"></p><p>当我们求出SVM的解的时候，我们是否可以通过SVM的解来反映logistics regression里的几率问题呢？</p><h2 id="SVM-for-Soft-Binary"><a href="#SVM-for-Soft-Binary" class="headerlink" title="SVM for Soft Binary"></a>SVM for Soft Binary</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217210724051.png" srcset="/img/loading.gif" alt="image-20210217210724051"></p><ul><li><p>我们跑soft-margin SVM然后得到$b，w$, 然后传回到g(x)当作分类器，相当于是利用了SVM来直接算出Logistic regression问题。这样的方法表现得一般不错，但是<strong>少了一些逻辑回归的特点，logistics regression体现了极大似然估计相关的一些想法，且梯度下降强调的是maximum(最大)，但是现在SVM跑出来的肯定和最大有一点点的差距。</strong></p></li><li><p>我们还有一种想法就是： 我们做逻辑回归时需要选一个起始点然后去做SGD/GD(梯度下降)，那么我们可以把SVM求出来的结果当作迭代的起始点，然后再去做SGD/GD。但是这样的做法会使得我们<strong>SVM中的kernel的特点没法用到，也就是遇到non-linear的情况会无法解决。</strong></p></li></ul><p>我们想着补全两者的缺点，一个想法是添加上两个自由度A,B：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217212417123.png" srcset="/img/loading.gif" alt="image-20210217212417123"></p><ul><li><p>用A,B去微调hyperplane 使得其满足maximum likelihood的特性。</p></li><li><p>同时我们由于保留了$\phi$,所以kernel的特点也保留了下来。</p></li></ul><p>同时我们也要注意到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217212635731.png" srcset="/img/loading.gif" alt="image-20210217212635731"></p><p>A一般大于0，如果你的A小于0，说明你的$w_{SVM}$求得有问题。B一般约等于0，他只是平移hyperplane，由于我们SVM求出的已经比较准确了，所以一般不会有什么太大的动作。</p><p>那现在只需要优化这个A,B即可，用logistic regression的目标优化方程套进去即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217212616360.png" srcset="/img/loading.gif" alt="image-20210217212616360"></p><p>我们观察这个式子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217213032621.png" srcset="/img/loading.gif" alt="image-20210217213032621"></p><p>这个操作将一个多维的数据$x_n$转换为了一个具体的数:</p><p>$\phi<em>{SVM}(x_n)=w</em>{SVM}^T\phi(x<em>n)+b</em>{SVM}$</p><p>我们再用这个值作为训练数据来用A,B做调整即可，此时logistics regression此时只需要做A,B两个维度即可。</p><p>其实Platt Model种提出的Probablistic SVM和这个很相似，只不过多了一些正则化，我们这里不讲platt提出的这些细节。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217215153765.png" srcset="/img/loading.gif" alt="image-20210217215153765"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217222127484.png" srcset="/img/loading.gif" alt="image-20210217222127484"></p><p>但是这样得到的不是Z空间的最优解，只是一个经过A,B调整后比较好的解。</p><h2 id="Kernel-Logistic-Regression"><a href="#Kernel-Logistic-Regression" class="headerlink" title="Kernel Logistic Regression"></a>Kernel Logistic Regression</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217222608350.png" srcset="/img/loading.gif" alt="image-20210217222608350"></p><p>最优解的$w$中也包含核技巧，并且也是$z_n$的线性组合</p><p>其实无论是SVM，PLA还是logReg by SGD都是$z_n$的线性组合：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217222735537.png" srcset="/img/loading.gif" alt="image-20210217222735537"></p><p>所以我们得出结论：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217232135387.png" srcset="/img/loading.gif" alt="image-20210217232135387"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217232208332.png" srcset="/img/loading.gif" alt="image-20210217232208332"></p><p>​    我们的最佳的$w_*$一定是由两部分组成的，一部分是$z_n$所张成的空间，另一部分是垂直于这个张成的空间。</p><p>​    我们肯定希望垂直于张成的空间的w部分，即$w<em>⊥=0$，因为做到$w</em>⊥=0$时说明我们最优化的$w_*$可以全部用$z_n$来表示了。</p><p>我们思考一下$w_⊥$到底会影响到什么？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210521173805544.png" srcset="/img/loading.gif" alt="image-20210521173805544"></p><p>考虑目标优化函数的两部分，一部分是err() ,另一部分是$w^Tw$。</p><p>如果$w_⊥\ne 0$会得到什么结果呢？我们考虑一下下面两个部分：</p><ul><li>第一部分：err()</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217232702845.png" srcset="/img/loading.gif" alt="image-20210217232702845"></p><p>我们发现这部分并不会被影响因为$w_⊥z_n=0$是一个事实，垂直于$z_n$的向量和$z_n$相乘当然等于0。</p><ul><li><p>第二部分：$w^Tw$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217232836583.png" srcset="/img/loading.gif" alt="image-20210217232836583"></p><p>当考虑$w$大小时就出现了问题，可以看出向量会大一些。但是这就出现了问题，这提示我们$w<em>*^Tw</em>*&gt;w<em>∥^Tw</em>∥$,这说明我们的最优解不是最优解了竟然，这意味着我们的最优w中：w$w_⊥=0$是恒成立的。</p></li></ul><p>$w<em>⊥=0$是恒成立的就意味着：**我们的$w</em><em>$一定是由$z_n$的线性组合得来的。*</em></p><p>这样一来我们就可以加上核技巧了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217233615892.png" srcset="/img/loading.gif" alt="image-20210217233615892"></p><p>此时我们求解$\beta$即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217233704780.png" srcset="/img/loading.gif" alt="image-20210217233704780"></p><p>怎么求呢？ GD/SGD都是很好的选择。</p><p>另一种视角：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217234001203.png" srcset="/img/loading.gif" alt="image-20210217234001203"></p><ul><li><p>相当于权重$\beta$和做feature transform后的数据的乘积。</p></li><li><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210217234232883.png" srcset="/img/loading.gif" alt="image-20210217234232883">这部分可以看作一种特殊的正则化。</p></li><li><p>因此Kernel Logistic Regression可以看作$\beta$的线性模型，只不过它是通过kernel transform后的数据和一种特殊的kernel regularizer 得到的结果。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法Quiz1(homework+code)</title>
    <link href="/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95Quiz1-homework-code/"/>
    <url>/2021/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95Quiz1-homework-code/</url>
    
    <content type="html"><![CDATA[<h1 id="QUIZ-1"><a href="#QUIZ-1" class="headerlink" title="QUIZ 1:"></a>QUIZ 1:</h1><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208171228244.png" srcset="/img/loading.gif" alt="image-20210208171228244"></p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208171244423.png" srcset="/img/loading.gif" alt="image-20210208171244423"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">z1</span><span class="hljs-params">(x1,x2)</span>:</span><br>    <span class="hljs-keyword">return</span> x2**<span class="hljs-number">2</span> - <span class="hljs-number">2</span>*x1 + <span class="hljs-number">3</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">z2</span><span class="hljs-params">(x1,x2)</span>:</span><br>    <span class="hljs-keyword">return</span> x1**<span class="hljs-number">2</span> - <span class="hljs-number">2</span>*x2 - <span class="hljs-number">3</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    x = np.asarray([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>]])<br>    y = [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    z = []<br>    <span class="hljs-keyword">for</span> vec <span class="hljs-keyword">in</span> x:<br>        z.append([z1(vec[<span class="hljs-number">0</span>], vec[<span class="hljs-number">1</span>]), z2(vec[<span class="hljs-number">0</span>], vec[<span class="hljs-number">1</span>])])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(y)):<br>        <span class="hljs-keyword">if</span> y[i] == <span class="hljs-number">-1</span>:<br>            plt.scatter(z[i][<span class="hljs-number">0</span>], z[i][<span class="hljs-number">1</span>], color=<span class="hljs-string">'blue'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            plt.scatter(z[i][<span class="hljs-number">0</span>], z[i][<span class="hljs-number">1</span>], color=<span class="hljs-string">'red'</span>)<br>    plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208171255884.png" srcset="/img/loading.gif" alt="image-20210208171255884"></p><p>不难看出是在$z_1=4.5$处为分界面</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208200355862.png" srcset="/img/loading.gif" alt="image-20210208200355862"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208173247333.png" srcset="/img/loading.gif" alt="image-20210208173247333"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kernel</span><span class="hljs-params">(x1, x2)</span>:</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + np.dot(x1.T, x2))**<span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    x = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>]])<br>    y = np.array([<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<br>    Q = np.zeros((<span class="hljs-number">7</span>, <span class="hljs-number">7</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>            Q[i][j] = y[i] * y[j] * kernel(x[i], x[j])<br>    P = -np.ones(<span class="hljs-number">7</span>)<br>    A = np.zeros((<span class="hljs-number">9</span>, <span class="hljs-number">7</span>))<br>    A[<span class="hljs-number">0</span>] = y<br>    A[<span class="hljs-number">1</span>] = -y<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>):<br>        A[i][i<span class="hljs-number">-2</span>] = <span class="hljs-number">-1</span><br>    C = np.zeros(<span class="hljs-number">9</span>)<br><br>    Q = matrix(Q)<br>    P = matrix(P)<br>    A = matrix(A)<br>    C = matrix(C)<br><br>    alphas = solvers.qp(Q, P, A, C)<br>    print(<span class="hljs-string">'max alpha:'</span>, np.max(alphas[<span class="hljs-string">'x'</span>]))<br>    print(<span class="hljs-string">'alpha sum:'</span>, np.sum(alphas[<span class="hljs-string">'x'</span>]))<br>    print(<span class="hljs-string">'min alpha:'</span>, np.min(alphas[<span class="hljs-string">'x'</span>]))<br>    print(<span class="hljs-string">'alphas:'</span>, alphas[<span class="hljs-string">'x'</span>])<br></code></pre></div></td></tr></table></figure><p>这里要注意下：cvxopt做二次规划和林轩田老师ppt上的</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208200148937.png" srcset="/img/loading.gif" alt="image-20210208200148937"></p><p>符号方向是相反的。</p><p><strong>运行结果：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">max alpha:</span> <span class="hljs-number">0.8888888987735439</span><br><span class="hljs-attr">alpha sum:</span> <span class="hljs-number">2.814814850082614</span><br><span class="hljs-attr">min alpha:</span> <span class="hljs-number">6.390795094251015e-10</span><br><span class="hljs-attr">alphas:</span> <span class="hljs-string">[</span> <span class="hljs-number">6.69e-09</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">7.04e-01</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">7.04e-01</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">8.89e-01</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">2.59e-01</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">2.59e-01</span><span class="hljs-string">]</span><br><span class="hljs-string">[</span> <span class="hljs-number">6.39e-10</span><span class="hljs-string">]</span><br></code></pre></div></td></tr></table></figure><p>故1，2是正确的。</p><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208205053236.png" srcset="/img/loading.gif" alt="image-20210208205053236"></p><p>我们已知道$\alpha$，去求b即可，然后带回$g_{SVM}$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208204936807.png" srcset="/img/loading.gif" alt="image-20210208204936807"></p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy as np<br><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><br>def kernel(x1, x2):<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + np.dot(x1.T, x2))**<span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    x = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>]])<br>    y = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<br>    Q = np.zeros((<span class="hljs-number">7</span>, <span class="hljs-number">7</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>            Q[i][j] = y[i] * y[j] * kernel(x[i], x[j])<br>    P = -np.ones(<span class="hljs-number">7</span>)<br>    A = np.zeros((<span class="hljs-number">9</span>, <span class="hljs-number">7</span>))<br>    A[<span class="hljs-number">0</span>] = y<br>    A[<span class="hljs-number">1</span>] = -y<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>):<br>        A[i][i<span class="hljs-number">-2</span>] = <span class="hljs-number">-1</span><br>    C = np.zeros(<span class="hljs-number">9</span>)<br><br>    Q = matrix(Q)<br>    P = matrix(P)<br>    A = matrix(A)<br>    C = matrix(C)<br><br>    alphas = solvers.qp(Q, P, A, C)<br>    alphas = alphas[<span class="hljs-string">'x'</span>]<br><br>    def kernelParameters(x):<br>        <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">array</span>([x[<span class="hljs-number">0</span>] * x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>] * x[<span class="hljs-number">1</span>], <span class="hljs-number">2</span> * x[<span class="hljs-number">0</span>] * x[<span class="hljs-number">1</span>], <span class="hljs-number">2</span> * x[<span class="hljs-number">0</span>], <span class="hljs-number">2</span> * x[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>])<br><br>    w = np.zeros(<span class="hljs-number">6</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>        w += alphas[i] * y[i] * kernelParameters(x[i])<br><br>    b = y[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):<br>        b = b - alphas[i] * y[i] * kernel(x[i], x[<span class="hljs-number">1</span>])<br><br>    print(<span class="hljs-string">'x1*x1:'</span>, w[<span class="hljs-number">0</span>], <span class="hljs-string">'x2*x2:'</span>, w[<span class="hljs-number">1</span>], <span class="hljs-string">'x1*x2:'</span>, w[<span class="hljs-number">2</span>], <span class="hljs-string">'x1:'</span>, w[<span class="hljs-number">3</span>], <span class="hljs-string">'x2:'</span>, w[<span class="hljs-number">4</span>], <span class="hljs-string">'1:'</span>, w[<span class="hljs-number">5</span>])<br>    print(<span class="hljs-string">'b:'</span>, b)<br></code></pre></div></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">x1*x1: <span class="hljs-number">0.8888888946403547</span> x2*x2: <span class="hljs-number">0.666666683766254</span> x1*x2: <span class="hljs-number">0.0</span> x1: <span class="hljs-number">-1.7777778134824205</span> x2: <span class="hljs-number">-3.3306690738754696e-15</span> <span class="hljs-number">1</span>: <span class="hljs-number">-1.586721330977244e-10</span><br>b: <span class="hljs-number">-1.6666666836075785</span><br></code></pre></div></td></tr></table></figure><p>即第三个。</p><h2 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208205446378.png" srcset="/img/loading.gif" alt="image-20210208205446378"></p><h2 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208210536028.png" srcset="/img/loading.gif" alt="image-20210208210536028"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208210408313.png" srcset="/img/loading.gif" alt="image-20210208210408313"></p><p>根据上面的ppt用lagrange multiplier转化为lagrange function即可：</p><p>要注意的是 ppt里给的是$\ge$, 而题目里是$\le$, 两边同加上负号，让符号方向就会转回来即可。</p><p>答案是第一个。</p><h2 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210208221238672.png" srcset="/img/loading.gif" alt="image-20210208221238672"></p><p>我们仿写KKT条件：</p><p>$\frac{\partial L(R,c,\lambda)}{\partial R}= R(1-\Sigma_{n=1}^N \lambda_n)=0$</p><p>$\frac{\partial L(R,c,\lambda)}{\partial c<em>i}=0 \to c_i\Sigma</em>{n=1}^N\lambda<em>n =\Sigma</em>{n=1}^N\lambda_nx_n^{(i)} $</p><p>这样就推出了第1，3个是正确的。</p><p>然后为来看第五个，就是KKT条件中所提到的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/${JUD@8JTDLAK_D_C}%E{FA.png" srcset="/img/loading.gif" alt="img"></p><p>我们仿写就是：$\lambda_n(||x_n-c||^2-R^2) = 0$</p><p>那么第5个也正确。</p><p>所以答案是1，3，5。</p><h2 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209011350773.png" srcset="/img/loading.gif" alt="1"></p><p><strong>解析：</strong></p><p>题目提到$R&gt;0$，由Q7可知：$R(1-\Sigma<em>{n=1}^N \lambda_n)=0$,故$1-\Sigma</em>{n=1}^N \lambda_n=0$</p><p>原始的Lagrange Function在Q6中提到了：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209010640077.png" srcset="/img/loading.gif" alt="image-20210209010640077"></p><p>我们把$1-\Sigma_{n=1}^N \lambda_n=0$带入：</p><p>$\ \ \   R^2 + \Sigma<em>{n=1}^N\lambda_n(||x_n-c||^2-R^2)\ = R^2 + \Sigma</em>{n=1}^N\lambda<em>n||x_n-c||^2-\Sigma</em>{n=1}^N\lambda<em>nR^2 \=\Sigma</em>{n=1}^N\lambda_n||x_n-c||^2$</p><p>我们又由Q7中的式子：</p><p>$\frac{\partial L(R,c,\lambda)}{\partial c<em>i}=0 \to c_i\Sigma</em>{n=1}^N\lambda<em>n =\Sigma</em>{n=1}^N\lambda_nx_n^{(i)} $</p><p>又因为$1-\Sigma_{n=1}^N \lambda_n=0$，得到：</p><p>$c<em>i\Sigma</em>{n=1}^N\lambda<em>n =\Sigma</em>{n=1}^N\lambda<em>nx_n^{(i)} \\to c_i =  \Sigma</em>{n=1}^N\lambda_nx_n^{(i)}$</p><p>带入$\Sigma_{n=1}^N\lambda_n||x_n-c||^2$得到第5个为正确答案：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209011310332.png" srcset="/img/loading.gif" alt="image-20210209011310332"></p><h2 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209012631861.png" srcset="/img/loading.gif" alt="image-20210209012631861"></p><p><strong>解析：</strong></p><p>从Q8的结果加上kernel技巧就好：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209011857250.png" srcset="/img/loading.gif" alt="image-20210209011857250"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209012611033.png" srcset="/img/loading.gif" alt="image-20210209012611033"></p><h2 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209151933569.png" srcset="/img/loading.gif" alt="image-20210209151933569"></p><p><strong>解析：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209151912720.png" srcset="/img/loading.gif" alt="image-20210209151912720"></p><p>选择$\lambda\ne 0 $的SV。</p><h2 id="Q11"><a href="#Q11" class="headerlink" title="Q11"></a>Q11</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209163047123.png" srcset="/img/loading.gif" alt="image-20210209163047123"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209163059245.png" srcset="/img/loading.gif" alt="image-20210209163059245"></p><h2 id="Q12"><a href="#Q12" class="headerlink" title="Q12"></a>Q12</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209163525843.png" srcset="/img/loading.gif" alt="image-20210209163525843"></p><p><strong>解析：</strong></p><p>下面这些都可以：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209163514687.png" srcset="/img/loading.gif" alt="image-20210209163514687"></p><h2 id="Q13"><a href="#Q13" class="headerlink" title="Q13"></a>Q13</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209164101993.png" srcset="/img/loading.gif" alt="image-20210209164101993"></p><h2 id="Q14"><a href="#Q14" class="headerlink" title="Q14"></a>Q14</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209175524211.png" srcset="/img/loading.gif" alt="image-20210209175524211"></p><p>$K(x,x’)=z^Tz $,这里把$K(x,x’)$改写为$pK(x,x’)+q$后，怎样改写$C$才能使得不影响分类效果呢？</p><p>这个是soft-margin SVM的原问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209175847416.png" srcset="/img/loading.gif" alt="image-20210209175847416"></p><p>我们知道用核技巧，其实就是把$x$映射到$z$空间上,而$pK(x,x’)+q$这样的改变中，$q$平移空间是不会影响结果的，而$p$拉伸空间是可以改变结果的，所以我们只考虑$p$即可。</p><p>$K$变成原来的$p$倍，那么$z$就是原来的$\sqrt{p}$倍，这样我们为了这个不变化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209180225533.png" srcset="/img/loading.gif" alt="image-20210209180225533"></p><p>$w$就要变成原来的$\frac{1}{\sqrt{p}}$倍，那么为了使下式子不被影响到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209180329037.png" srcset="/img/loading.gif" alt="image-20210209180329037"></p><p>由于$\frac{1}{2}w^Tw$变为了原来的$\frac{1}{p}$倍，那么C也要变为原来的$\frac{1}{p}$倍。</p><p>即答案为第五个。</p><h2 id="Q15"><a href="#Q15" class="headerlink" title="Q15"></a>Q15</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209232600273.png" srcset="/img/loading.gif" alt="image-20210209232600273"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209232614619.png" srcset="/img/loading.gif" alt="image-20210209232614619"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(path)</span>:</span><br>    txt = open(path)<br>    data_y = []<br>    data_x = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> txt:<br>        linesplit = line.split()<br>        data_y.append(int(float(linesplit[<span class="hljs-number">0</span>])))<br>        data_x.append([float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    <span class="hljs-keyword">return</span> np.array(data_x), np.array(data_y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificationFunction</span><span class="hljs-params">(dataOfy, target)</span>:</span><br>    newdata_y = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataOfy:<br>        <span class="hljs-keyword">if</span> _ == target:<br>            newdata_y.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            newdata_y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> np.array(newdata_y)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    train_data_x, train_data_y = splitData(<span class="hljs-string">"train.dat"</span>)<br>    train_data_y = classificationFunction(train_data_y, <span class="hljs-number">0</span>)<br><br>    clf = svm.SVC(C=<span class="hljs-number">0.01</span>, kernel=<span class="hljs-string">'linear'</span>)<br>    clf.fit(train_data_x, train_data_y)<br>    w = clf.coef_<br>    print(np.sqrt(np.sum(np.square(w))))<br>    <br>    <span class="hljs-comment">#0.5713171494256942</span><br></code></pre></div></td></tr></table></figure><h2 id="Q16"><a href="#Q16" class="headerlink" title="Q16"></a>Q16</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209233841082.png" srcset="/img/loading.gif" alt="image-20210209233841082"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(path)</span>:</span><br>    txt = open(path)<br>    data_y = []<br>    data_x = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> txt:<br>        linesplit = line.split()<br>        data_y.append(int(float(linesplit[<span class="hljs-number">0</span>])))<br>        data_x.append([float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    <span class="hljs-keyword">return</span> np.array(data_x), np.array(data_y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificationFunction</span><span class="hljs-params">(dataOfy, target)</span>:</span><br>    newdata_y = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataOfy:<br>        <span class="hljs-keyword">if</span> _ == target:<br>            newdata_y.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            newdata_y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> np.array(newdata_y)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    Ein = <span class="hljs-number">1</span><br>    SelectClassway = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>):<br>        test_data_x, test_data_y = splitData(<span class="hljs-string">"test.dat"</span>)<br>        train_data_x, train_data_y = splitData(<span class="hljs-string">"train.dat"</span>)<br>        train_data_y = classificationFunction(train_data_y, i)<br>        test_data_y = classificationFunction(test_data_y, i)<br>        clf = svm.SVC(C=<span class="hljs-number">0.01</span>, kernel=<span class="hljs-string">'poly'</span>, degree=<span class="hljs-number">2</span>, gamma=<span class="hljs-string">'auto'</span>)<br>        clf.fit(train_data_x, train_data_y)<br>        y_hat = clf.predict(test_data_x)<br>        correct_num = np.sum(y_hat == test_data_y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>] &lt; Ein:<br>            Ein = <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>]<br>            SelectClassway = i<br>    print(i)<br>    <span class="hljs-comment">#8</span><br></code></pre></div></td></tr></table></figure><h2 id="Q17"><a href="#Q17" class="headerlink" title="Q17"></a>Q17</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210209234211953.png" srcset="/img/loading.gif" alt="image-20210209234211953"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(path)</span>:</span><br>    txt = open(path)<br>    data_y = []<br>    data_x = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> txt:<br>        linesplit = line.split()<br>        data_y.append(int(float(linesplit[<span class="hljs-number">0</span>])))<br>        data_x.append([float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    <span class="hljs-keyword">return</span> np.array(data_x), np.array(data_y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificationFunction</span><span class="hljs-params">(dataOfy, target)</span>:</span><br>    newdata_y = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataOfy:<br>        <span class="hljs-keyword">if</span> _ == target:<br>            newdata_y.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            newdata_y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> np.array(newdata_y)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    Ein = <span class="hljs-number">1</span><br>    SelectClassway = <span class="hljs-number">0</span><br>    maxxalpha = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>):<br>        test_data_x, test_data_y = splitData(<span class="hljs-string">"test.dat"</span>)<br>        train_data_x, train_data_y = splitData(<span class="hljs-string">"train.dat"</span>)<br>        train_data_y = classificationFunction(train_data_y, i)<br>        test_data_y = classificationFunction(test_data_y, i)<br>        clf = svm.SVC(C=<span class="hljs-number">0.01</span>, kernel=<span class="hljs-string">'poly'</span>, degree=<span class="hljs-number">2</span>, gamma=<span class="hljs-string">'auto'</span>)<br>        clf.fit(train_data_x, train_data_y)<br>        y_hat = clf.predict(test_data_x)<br>        correct_num = np.sum(y_hat == test_data_y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>] &lt; Ein:<br>            Ein = <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>]<br>            SelectClassway = i<br>        <span class="hljs-keyword">if</span> np.sum(np.fabs(clf.dual_coef_)) &gt; maxxalpha:<br>            maxxalpha = np.sum(np.fabs(clf.dual_coef_))<br>    print(maxxalpha)<br>    <span class="hljs-comment">#23.88</span><br></code></pre></div></td></tr></table></figure><h2 id="Q18"><a href="#Q18" class="headerlink" title="Q18"></a>Q18</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210210002831071.png" srcset="/img/loading.gif" alt="image-20210210002831071"></p><h2 id="Q19"><a href="#Q19" class="headerlink" title="Q19"></a>Q19</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210210004623282.png" srcset="/img/loading.gif" alt="image-20210210004623282"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(path)</span>:</span><br>    txt = open(path)<br>    data_y = []<br>    data_x = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> txt:<br>        linesplit = line.split()<br>        data_y.append(int(float(linesplit[<span class="hljs-number">0</span>])))<br>        data_x.append([float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    <span class="hljs-keyword">return</span> np.array(data_x), np.array(data_y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificationFunction</span><span class="hljs-params">(dataOfy, target)</span>:</span><br>    newdata_y = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataOfy:<br>        <span class="hljs-keyword">if</span> _ == target:<br>            newdata_y.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            newdata_y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> np.array(newdata_y)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    Eout = <span class="hljs-number">1</span><br>    Select = <span class="hljs-number">0</span><br>    maxxalpha = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> gamma <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>]:<br>        print(gamma)<br>        test_data_x, test_data_y = splitData(<span class="hljs-string">"test.dat"</span>)<br>        train_data_x, train_data_y = splitData(<span class="hljs-string">"train.dat"</span>)<br>        train_data_y = classificationFunction(train_data_y, <span class="hljs-number">0</span>)<br>        test_data_y = classificationFunction(test_data_y, <span class="hljs-number">0</span>)<br>        clf = svm.SVC(C=<span class="hljs-number">0.1</span>, kernel=<span class="hljs-string">'rbf'</span>, gamma=gamma)<br>        clf.fit(train_data_x, train_data_y)<br>        y_hat = clf.predict(test_data_x)<br>        correct_num = np.sum(y_hat == test_data_y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>] &lt; Eout:<br>            Eout = <span class="hljs-number">1</span> - correct_num/test_data_y.shape[<span class="hljs-number">0</span>]<br>            Select = gamma<br>    print(Select)<br>    <span class="hljs-comment">#10</span><br></code></pre></div></td></tr></table></figure><h2 id="Q20"><a href="#Q20" class="headerlink" title="Q20"></a>Q20</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210210010309503.png" srcset="/img/loading.gif" alt="image-20210210010309503"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cvxopt <span class="hljs-keyword">import</span> solvers, matrix<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> sklearn.svm <span class="hljs-keyword">as</span> svm<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitData</span><span class="hljs-params">(path)</span>:</span><br>    txt = open(path)<br>    data_y = []<br>    data_x = []<br>    data = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> txt:<br>        linesplit = line.split()<br>        data.append([int(float(linesplit[<span class="hljs-number">0</span>])), float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    random.shuffle(data)<br><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data:<br>        linesplit = line<br>        data_y.append(int(float(linesplit[<span class="hljs-number">0</span>])))<br>        data_x.append([float(linesplit[<span class="hljs-number">1</span>]), float(linesplit[<span class="hljs-number">2</span>])])<br>    <span class="hljs-keyword">return</span> np.array(data_x), np.array(data_y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificationFunction</span><span class="hljs-params">(dataOfy, target)</span>:</span><br>    newdata_y = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataOfy:<br>        <span class="hljs-keyword">if</span> _ == target:<br>            newdata_y.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            newdata_y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> np.array(newdata_y)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    g = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">0</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0</span>, <span class="hljs-number">100</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>: <span class="hljs-number">0</span>, <span class="hljs-number">10000</span>: <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>        Eout = <span class="hljs-number">1</span><br>        Select = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> gamma <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>]:<br>            train_data_x, train_data_y = splitData(<span class="hljs-string">"train.dat"</span>)<br>            train_data_y = classificationFunction(train_data_y, <span class="hljs-number">0</span>)<br>            clf = svm.SVC(C=<span class="hljs-number">0.1</span>, kernel=<span class="hljs-string">'rbf'</span>, gamma=gamma)<br>            clf.fit(train_data_x[<span class="hljs-number">0</span>:<span class="hljs-number">1000</span>], train_data_y[<span class="hljs-number">0</span>:<span class="hljs-number">1000</span>])<br>            y_hat = clf.predict(train_data_x[<span class="hljs-number">0</span>:<span class="hljs-number">1000</span>])<br>            correct_num = np.sum(y_hat == train_data_y[<span class="hljs-number">0</span>:<span class="hljs-number">1000</span>])<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> - correct_num/<span class="hljs-number">1000</span> &lt; Eout:<br>                Eout = <span class="hljs-number">1</span> - correct_num/<span class="hljs-number">1000</span><br>                Select = gamma<br>        print(Select)<br>        g[Select] += <span class="hljs-number">1</span><br>    print(g)<br>    <span class="hljs-comment">#10</span><br>    <span class="hljs-comment">#&#123;1: 1, 10: 97, 100: 1, 1000: 1, 10000: 0&#125;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH4：Soft-Margin Support Vector Machine</title>
    <link href="/2021/02/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH4%EF%BC%9ASoft-Margin-Support-Vector-Machine/"/>
    <url>/2021/02/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH4%EF%BC%9ASoft-Margin-Support-Vector-Machine/</url>
    
    <content type="html"><![CDATA[<h1 id="CH4：Soft-Margin-Support-Vector-Machine"><a href="#CH4：Soft-Margin-Support-Vector-Machine" class="headerlink" title="CH4：Soft-Margin Support Vector Machine"></a>CH4：Soft-Margin Support Vector Machine</h1><h2 id="Motivation-and-Primal"><a href="#Motivation-and-Primal" class="headerlink" title="Motivation and Primal"></a>Motivation and Primal</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206215810111.png" srcset="/img/loading.gif" alt="image-20210206215810111"></p><p>我们不能一直追求全部正确，数据也不一定可分。</p><p>在pocket中我们选择容忍一些错误：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206220144485.png" srcset="/img/loading.gif" alt="image-20210206220144485"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206220242382.png" srcset="/img/loading.gif" alt="image-20210206220242382"></p><p>​    因此我们让SVM上min的目标不仅包含$\frac{1}{2}w^Tw$ ,也包括错误的数量，这个C代表着这两者的权衡，如果你不在意多错一点，想要使得$\frac{1}{2}w^Tw$最小(即胖胖的间隔更宽)，那么C就可以小一点，反之同理。</p><p>​    这是又一个trade-off： 在<strong>更宽的边界</strong>和<strong>噪声容忍度</strong>上的权衡。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206220835057.png" srcset="/img/loading.gif" alt="image-20210206220835057"></p><p>上面这个式子想法很好，但是有几个问题：</p><ul><li>$[·]$不是一个线性函数，QP(二次规划)没法解决。</li><li>我们无法区分错误的严重程度，大的错误和小的错误被认为相同。</li></ul><p>我们首先把不同的错误程度用$\xi$代表，这样我们就把记录错误的数量转换为了记录多大的错误。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206222135854.png" srcset="/img/loading.gif" alt="image-20210206222135854"></p><p>这个$\xi$代表着错误程度，如下图代表着距离胖胖额外边界的长度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206222224142.png" srcset="/img/loading.gif" alt="image-20210206222224142"></p><p>C大小的意义：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206222330636.png" srcset="/img/loading.gif" alt="image-20210206222330636"></p><p>现在的问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206222346294.png" srcset="/img/loading.gif" alt="image-20210206222346294"></p><p>有了这个以后我们做对偶的QP问题，把$\tilde{d}$拿掉。</p><h2 id="Dual-Problem"><a href="#Dual-Problem" class="headerlink" title="Dual Problem"></a>Dual Problem</h2><p>和之前一样，先求<strong>lagrange fuction：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206223201183.png" srcset="/img/loading.gif" alt="image-20210206223201183"></p><p>化简一下$\xi$和$\beta$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206231915121.png" srcset="/img/loading.gif" alt="image-20210206231915121"></p><p>和之前算Dual SVM一样，对不同变量进行求偏导：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206232123454.png" srcset="/img/loading.gif" alt="image-20210206232123454"></p><p>最后我们转化为了如下的问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206232229963.png" srcset="/img/loading.gif" alt="image-20210206232229963"></p><p>这里的soft margin推导和我们之前所提到的hard margin区别就是：$\alpha$多了一个上界。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206232318466.png" srcset="/img/loading.gif" alt="image-20210206232318466"></p><h2 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206232621996.png" srcset="/img/loading.gif" alt="image-20210206232621996"></p><p>和我们做hard-margin的过程一样，但是这个里的b怎么求呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206233104839.png" srcset="/img/loading.gif" alt="image-20210206233104839"></p><ul><li>和之前hard-margin只用第一个条件，那么我们求出来的SV:终于有b和$\xi$两个未知的是无法求出b的。</li><li>我们考虑用第二个式子，当$\alpha&lt;C$的时候，$\xi=0$，那么我们就可以求出解了：</li></ul><p>用free SV可以求出$b$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206234440681.png" srcset="/img/loading.gif" alt="image-20210206234440681"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206234702474.png" srcset="/img/loading.gif" alt="image-20210206234702474"></p><p><strong>C越来越大</strong>，我们做的<strong>正确的会越来越多</strong>，但是<strong>边界会越来越瘦</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206235114218.png" srcset="/img/loading.gif" alt="image-20210206235114218"></p><ul><li><p>不是支持向量的：原理fat boundary的那些点</p></li><li><p>free SV：fat boundary的边界点</p></li><li><p>bounded SV：越界的点，比如：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206235600471.png" srcset="/img/loading.gif" alt="image-20210206235600471"></p><p>上图中红叉的距离没有在红色边界的一遍，他的错误程度就是紫色线的距离。</p></li></ul><h2 id="Model-Selection"><a href="#Model-Selection" class="headerlink" title="Model Selection"></a>Model Selection</h2><p>我们在用Gauss核的时候有两个要选的：$C$和$\gamma$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210206235917018.png" srcset="/img/loading.gif" alt="image-20210206235917018"></p><p>怎么选择合适的呢？</p><p>做validation即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210207000306700.png" srcset="/img/loading.gif" alt="image-20210207000306700"></p><p>有趣的是在做Leave-One-Out Cross Validation的时候有一些新的值得注意的东西：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210207000617644.png" srcset="/img/loading.gif" alt="image-20210207000617644"></p><p>我们取出来的One是$\alpha=0$的，即non SV ，这些不是支持向量，因此加上也不会使得结果更准确。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210207001851833.png" srcset="/img/loading.gif" alt="image-20210207001851833"></p><p>我们的non-SV 一定都是正确的，而SV的错误率最多也就是1而已。加入我们一共有N个向量，那么我们同体的错误肯定小于$SV的数量  /  N$.</p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210207002056807.png" srcset="/img/loading.gif" alt="image-20210207002056807"></p><p>这也侧面告诉我们可以通过SV的数量来做安全检查：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210207002206915.png" srcset="/img/loading.gif" alt="image-20210207002206915"></p><p>特别大的SV数量我们就要小心用了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH3：Kernel-Support-Vector-Machine</title>
    <link href="/2021/02/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH3%EF%BC%9AKernel-Support-Vector-Machine/"/>
    <url>/2021/02/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH3%EF%BC%9AKernel-Support-Vector-Machine/</url>
    
    <content type="html"><![CDATA[<h1 id="CH3：Kernel-Support-Vector-Machine"><a href="#CH3：Kernel-Support-Vector-Machine" class="headerlink" title="CH3：Kernel Support Vector Machine"></a>CH3：Kernel Support Vector Machine</h1><h2 id="Kernel-Trick"><a href="#Kernel-Trick" class="headerlink" title="Kernel Trick"></a>Kernel Trick</h2><p>回顾上节的内容：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205185427247.png" srcset="/img/loading.gif" alt="image-20210205185427247"></p><p>我们看似Dual SVM已经与$\tilde{d}$无关了，可是在计算时我们会发现$q_{n,m}=y_my_mz_n^Tz_m$这个式子中的$z$却包含了$\tilde{d}$, 如果这个$\tilde{d}$非常大，我们算的还是非常慢。</p><p>我们想做的是这一步，做得快一点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205185809028.png" srcset="/img/loading.gif" alt="image-20210205185809028"></p><p>$\phi$是在做feature transform</p><p>我们考虑一个二次的转化：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205211553134.png" srcset="/img/loading.gif" alt="image-20210205211553134"></p><p>这里的$\tilde{d}=d^2$, 因为他是任意两个的组合，因此如果直接算复杂度是$O(d^2)$。</p><p>我们通过上图的整理，可以把复杂度边为$O(d)$,因为我们只需要算$x^Tx’$就好了。</p><p>所以这里我们就找到了这样的一个$\phi$所对应的<strong>kernel function：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205211927953.png" srcset="/img/loading.gif" alt="image-20210205211927953"></p><p>我们就可以用kernel function来做这样的事情：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205212100994.png" srcset="/img/loading.gif" alt="image-20210205212100994"></p><p>那么b怎么算呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205212231425.png" srcset="/img/loading.gif" alt="image-20210205212231425"></p><p>$g_{SVM}$同上，把$w^T$换掉：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205212334210.png" srcset="/img/loading.gif" alt="image-20210205212334210"></p><p>最后我们把上述的总结一下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205212610558.png" srcset="/img/loading.gif" alt="image-20210205212610558"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205212719512.png" srcset="/img/loading.gif" alt="image-20210205212719512"></p><h2 id="Polynomial-Kernel（多项式核）"><a href="#Polynomial-Kernel（多项式核）" class="headerlink" title="Polynomial Kernel（多项式核）"></a>Polynomial Kernel（多项式核）</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205213534481.png" srcset="/img/loading.gif" alt="image-20210205213534481"></p><p>我们因为转换到的空间相同，他们能够做的事情是相同的。</p><p>我们最常用的就是$K_2$：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205213732329.png" srcset="/img/loading.gif" alt="image-20210205213732329"></p><p>但是这样的两个转换$\phi$虽然能够做的事情都一样，但是他们的内积肯定是不同的，而内积会影响margin，也就是说两个$\phi$虽然再同一个空间里，但是可能边界不相同。</p><p>比如下图，不同的二次多项式核就有不同的结果：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205214121194.png" srcset="/img/loading.gif" alt="image-20210205214121194"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205214152297.png" srcset="/img/loading.gif" alt="image-20210205214152297"></p><ul><li>也就是不同的$\phi$会带来$g_{SVM}$的不同，那么他们的支持向量(SV)也会不同</li><li>但是我们很难知道那儿一个比较好</li></ul><p>不同次数的多项式核：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205214421507.png" srcset="/img/loading.gif" alt="image-20210205214421507"></p><p><strong>$K_1$就是Linear Kernel：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205214649362.png" srcset="/img/loading.gif" alt="image-20210205214649362"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205214702765.png" srcset="/img/loading.gif" alt="image-20210205214702765"></p><h2 id="Gaussian-Kernel-高斯核"><a href="#Gaussian-Kernel-高斯核" class="headerlink" title="Gaussian Kernel  (高斯核)"></a>Gaussian Kernel  (高斯核)</h2><p>我们现在由于计算复杂度和维度没关系了，那么我们如果做feature tranform到一个无穷多维度的空间上会怎么样呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205215507029.png" srcset="/img/loading.gif" alt="image-20210205215507029"></p><p>我们上图把$exp(-(x-x’)^2)$看做核，然后反着取做转化，化为$\phi(x)^T\phi(x’)$的形式，那么此时的$\phi(x)$竟然代表了一个无穷多维的转化。</p><p>我们称这种为<strong>高斯核：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205215801155.png" srcset="/img/loading.gif" alt="image-20210205215801155"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205220015086.png" srcset="/img/loading.gif" alt="image-20210205220015086"></p><p><strong>不同的$\gamma$可能会造成overfitting:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205220220185.png" srcset="/img/loading.gif" alt="image-20210205220220185"></p><p>我们不建议用很大的$\gamma$。</p><h2 id="Comparison-of-Kernels"><a href="#Comparison-of-Kernels" class="headerlink" title="Comparison of Kernels"></a>Comparison of Kernels</h2><p>我们这一节来比较一下不同的kernel：</p><p><strong>Linear Kernel：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205220520589.png" srcset="/img/loading.gif" alt="image-20210205220520589"></p><p><strong>Polynomial Kernel：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205220650202.png" srcset="/img/loading.gif" alt="image-20210205220650202"></p><p><strong>Gaussian Kernel：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205220844882.png" srcset="/img/loading.gif" alt="image-20210205220844882"></p><p>那我们自己可以定义一个kernel吗？</p><p>可以，但是kernel有一定的条件，<strong>Mercer’s condition</strong>就是是否为一个kernel的评判标准：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205221253438.png" srcset="/img/loading.gif" alt="image-20210205221253438"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH2：Dual Support Vector Machine</title>
    <link href="/2021/02/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH2%EF%BC%9ADual-Support-Vector-Machine/"/>
    <url>/2021/02/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH2%EF%BC%9ADual-Support-Vector-Machine/</url>
    
    <content type="html"><![CDATA[<h1 id="CH2：Dual-Support-Vector-Machine"><a href="#CH2：Dual-Support-Vector-Machine" class="headerlink" title="CH2：Dual Support Vector Machine"></a>CH2：Dual Support Vector Machine</h1><h2 id="Motivation-of-Dual-SVM"><a href="#Motivation-of-Dual-SVM" class="headerlink" title="Motivation of Dual SVM"></a>Motivation of Dual SVM</h2><p>我们上节提到过，如果想让<strong>SVM来做非线性的分类</strong>，那么我们是需要feature transform的，此时的问题变为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204180416185.png" srcset="/img/loading.gif" alt="image-20210204180416185"></p><p>这个$\phi(x_n)$就是对原来的$x_n$做了feature transform。</p><p>我们的二次规划问题也变为了:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204180544571.png" srcset="/img/loading.gif" alt="image-20210204180544571"></p><p>​    为什么想到用SVM来做这件事情呢，因为在之前我们的linear regression中我们了解到，如果去做feature transform会导致$d_{vc}$变大的，也就是hypothesis set也会更大。而在SVM中，他有一个很好的性质就是由于分界面有厚度，导致一些hypothesis是不成立的，这就帮我们控制了模型的复杂度，我们就可以很好的使用feature transform了。</p><p>这里我们提出SVM的对偶问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204181204149.png" srcset="/img/loading.gif" alt="image-20210204181204149"></p><p>我们这里把原来的$d+1$维转化为了一个只与N有关的维度。</p><p>提示：下面的内容许多包含最优化的问题，因此我们不会着重讲这些，而是当作现成的理论。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204181341890.png" srcset="/img/loading.gif" alt="image-20210204181341890"></p><p>我们这里用到了一个工具叫做拉格朗日乘子（Largrange Multiplier）：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204181523106.png" srcset="/img/loading.gif" alt="image-20210204181523106"></p><p>在之前的正则化问题中，我的的$\lambda$是给好的，但是在dual SVM问题中$\lambda$被我们看作给出的约束，并且我们需要去解$\lambda$。</p><p>在SVM中有N个constraint，那么也就是说有N个不同的$\lambda$。</p><p>我们把原问题<strong>转化为lagrange function</strong>:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204185856288.png" srcset="/img/loading.gif" alt="image-20210204185856288"></p><p>（要注意，学术文献一般喜欢用$\alpha$而不是$\lambda$，下面我们将替换掉$\lambda$）</p><p>我们直接给出SVM问题的数学表达：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204190400644.png" srcset="/img/loading.gif" alt="image-20210204190400644"></p><p>这个怎么理解呢？</p><p>我们拆开来看：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204190426015.png" srcset="/img/loading.gif" alt="image-20210204190426015"></p><p>如果今天我们计算蓝色部分也就是<img src="C:\Users\49815\AppData\Roaming\Typora\typora-user-images\image-20210204191000863.png" srcset="/img/loading.gif" alt="">这部分时，算出来是正数，也就代表$y_n(w^Tz_n+b)&lt;1$,那么说明这是不符合我们constraint的，这是一个非法解。同时我们来看这样算出来的肯定会趋于正无穷的：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204190834365.png" srcset="/img/loading.gif" alt="image-20210204190834365"></p><p>因为蓝色部分是正的，我们的$a_n$取无穷大就好喽，这样就达到max了。</p><p>反之同理，如果<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204191000863.png" srcset="/img/loading.gif" alt="">这部分小于0，最后加算出来的值就是$\frac{1}{2}w^Tw$ , 也就说这部分是符合要求的解。我们再来看下SVM的表达式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204191206373.png" srcset="/img/loading.gif" alt="image-20210204191206373"></p><p>也就说这个式子帮我们选到了feasible的$b$和$w$。</p><h2 id="Largange-Dual-SVM"><a href="#Largange-Dual-SVM" class="headerlink" title="Largange Dual SVM"></a>Largange Dual SVM</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204194334889.png" srcset="/img/loading.gif" alt="image-20210204194334889"></p><p>上式是显然成立的。</p><p>上面式子告诉我们任何的$\alpha$取值都会小于左边部分，那么右边最大时也依然会小于左边的式子，即下图的式子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204194519102.png" srcset="/img/loading.gif" alt="image-20210204194519102"></p><p>我们称之为Largange dual problem（拉格朗日对偶问题），其实就是min，max换了一下顺序。</p><p>最优化的一些知识指出，如果我们可以做到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204200031508.png" srcset="/img/loading.gif" alt="image-20210204200031508"></p><p>那么我们就可以给下面的式子画上等号：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204200048825.png" srcset="/img/loading.gif" alt="image-20210204200048825"></p><p>我们现在做右边的即可。</p><p>我们把$L(b,w,\alpha)$展开：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204202433014.png" srcset="/img/loading.gif" alt="image-20210204202433014"></p><p>我们怎么解括号里面这个问题呢？</p><p>可以用梯度下降来做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204202718378.png" srcset="/img/loading.gif" alt="image-20210204202718378"></p><p>所以我们可以把这个式子作为新的constraint。</p><p>即然$\Sigma_{n=1}^Na_ny_n=0$,那么$b$就会被消掉，即问题转化为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204203047742.png" srcset="/img/loading.gif" alt="image-20210204203047742"></p><p>同样我们也可以对w求偏导：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204203401235.png" srcset="/img/loading.gif" alt="image-20210204203401235"></p><p>那么$w =\Sigma_{n=1}^Na_ny_nz_n $ 就是一个新的constraint了。</p><p> 有了上面的等式，我们可以化简为下式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204203620747.png" srcset="/img/loading.gif" alt="image-20210204203620747"></p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204203723946.png" srcset="/img/loading.gif" alt="image-20210204203723946"></p><p>KKT 最优化的情况：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204204253704.png" srcset="/img/loading.gif" alt="image-20210204204253704"></p><h2 id="Solving-Dual-SVM"><a href="#Solving-Dual-SVM" class="headerlink" title="Solving Dual SVM"></a>Solving Dual SVM</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204221824671.png" srcset="/img/loading.gif" alt="image-20210204221824671"></p><p>​    我们通过转化把问题边为上图中下面的部分，这里面为什么没有加上$w$的约束条件呢？因为我们此时要解的问题是求$\alpha$, $w$的这个约束条件可以在我们求得$\alpha$后反求得$w$,但是在这里我们可以先把它隐藏起来。</p><p>​    现在问题转化为了$N+1$个约束条件</p><p>​    接下来我们把它转化为QP（二次规划）问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210204222626601.png" srcset="/img/loading.gif" alt="image-20210204222626601"></p><p>我们发现$Q$是一个N*N的矩阵，这就意味着：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205000001802.png" srcset="/img/loading.gif" alt="image-20210205000001802"></p><p>矩阵在N=30000时就需要3G 的RAM,所以我们需要特解来解。</p><p>我们再来看KTT条件：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205002741555.png" srcset="/img/loading.gif" alt="image-20210205002741555"></p><ul><li>$w$的计算方法：有了$\alpha$我们就可以算出$w$</li><li>$b$的计算方法：从上面第四点可以看出，我们如果求出了一个$\alpha \ne 0$,那么$1-y_n(w^Tz_n+b)$就要等于0，我们就可以很轻易的解出$b$了。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205003033917.png" srcset="/img/loading.gif" alt="image-20210205003033917"></p><h2 id="Messages-behind-Dual-SVM"><a href="#Messages-behind-Dual-SVM" class="headerlink" title="Messages behind Dual SVM"></a>Messages behind Dual SVM</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205003345628.png" srcset="/img/loading.gif" alt="image-20210205003345628"></p><ul><li><p>Dual SVM和SVM一样。</p></li><li><p>对于$\alpha _n&gt;0$的点，肯定是在边界上。</p></li><li>我们称那些$\alpha _n&gt;0$的计算结果$(z_n,y_n)$叫做支持向量（support vector）</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205004352974.png" srcset="/img/loading.gif" alt="image-20210205004352974"></p><p>我们发现SV是SV candidates的一个子集。</p><p>而我们计算的时候只需要考虑SV，即胖胖的边上的点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205004448522.png" srcset="/img/loading.gif" alt="image-20210205004448522"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205004702015.png" srcset="/img/loading.gif" alt="image-20210205004702015"></p><p>​    当我们求得$\alpha$后，我们可以把$w<em>{SVM}$的看作边界上点的线性组合，这个表达形式和PLA中很像，$w</em>{PLA}$就是使得分类错误的点的线性组合，不断改正，$\beta$为调整修改的幅度大小。</p><p><strong>总结一下：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205005205144.png" srcset="/img/loading.gif" alt=""></p><p>我们对比一下原始SVM和Dual SVM的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210205005404552.png" srcset="/img/loading.gif" alt=""></p><p>我们做Dual SVM是为了如果$\tilde{d}$很大，也就是说数据的维数很高，我们就可以用Dual SVM来做，Dual的好处就是它不需要所有数据来解，只需要SV来解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习技法CH1：Linear SVM</title>
    <link href="/2021/02/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH1%EF%BC%9ALinear-SVM/"/>
    <url>/2021/02/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%B3%95CH1%EF%BC%9ALinear-SVM/</url>
    
    <content type="html"><![CDATA[<h1 id="CH1：Linear-SVM"><a href="#CH1：Linear-SVM" class="headerlink" title="CH1：Linear SVM"></a>CH1：Linear SVM</h1><h2 id="Large-Margin-separating-Hyperplane"><a href="#Large-Margin-separating-Hyperplane" class="headerlink" title="Large-Margin separating Hyperplane"></a>Large-Margin separating Hyperplane</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203201812968.png" srcset="/img/loading.gif" alt="image-20210203201812968"></p><p>这三种线都可以把这些点分开。</p><ul><li><p>PLA算法不一定会得出哪儿一种线</p></li><li><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203202005352.png" srcset="/img/loading.gif" alt="image-20210203202005352"></p><p>从我们的VC Bound来看，$E<em>{in}=0$都一样，$d</em>{VC}$=也一样，那么 VC Bound所带来的保证$E_{out}$都相同。</p></li></ul><p>​    但其实我们的直觉告诉我们第三种好一点，因为他如果有一些数据有误差，那么也不会影响结果，因此我们一般认为第三条线对错误容忍度高一些。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203202331691.png" srcset="/img/loading.gif" alt="image-20210203202331691"></p><p>​    简单理解就是如果<strong>点距离分割面/分割线越远</strong>，那么他容忍noise的力度越大，我们在基石课中学到，noise是造成overfittng的原因，容忍noise能力越强则<strong>更不容易带来overfitting</strong>。</p><hr><p>因此我们想找健壮性更强一些的线，什么是健壮性更强的呢？就是<strong>点距离分割面/分割线越远</strong>。我们直观理解就是这条线可以有多<strong>胖</strong>。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203010157.png" srcset="/img/loading.gif" alt="image-20210203203010157"></p><p>灰色就代表这条线有多胖，这条线越胖越说明我们的健壮性越强。</p><p>那么我们现在可以给健壮性一个定义：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203149201.png" srcset="/img/loading.gif" alt="image-20210203203149201"></p><p>健壮性就是点距离分割线/分割面 最近的距离。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203422827.png" srcset="/img/loading.gif" alt="image-20210203203422827"></p><p>那么现在我们要做的就是<strong>最大化fatness(w)</strong>。</p><p>但是这个”胖“的说法似乎不太专业，这里我们给出真正的名字margin</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203619396.png" srcset="/img/loading.gif" alt="image-20210203203619396"></p><p>因此我们想要做到下面两点：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203704673.png" srcset="/img/loading.gif" alt="image-20210203203704673"></p><ul><li>Margin越大越好</li><li>分类正确</li></ul><h2 id="Standard-Large-Margin-Problem"><a href="#Standard-Large-Margin-Problem" class="headerlink" title="Standard Large-Margin Problem"></a>Standard Large-Margin Problem</h2><p>我们要解决的问题是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203203955323.png" srcset="/img/loading.gif" alt="image-20210203203955323"></p><p>我们首先要知道距离怎么算。</p><p>我们之前算的时候是需要在数据第一列加上一列1的，然后用$sign(w^Tx)$计算分类结果，但是这里我们不在加上第一列1了，把w的第一列拆出来，那么判断就变成了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203204800204.png" srcset="/img/loading.gif" alt="image-20210203204800204"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205335953.png" srcset="/img/loading.gif" alt="image-20210203205335953"></p><p>这个图上的$x’$和$x’’$一定是符合 $w^Tx + b = 0$ 的</p><p>因此:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205451314.png" srcset="/img/loading.gif" alt="image-20210203205451314"></p><p>我们的这个权重向量一点是是分割面的法向量的。</p><p>我们接下来算距离：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205558354.png" srcset="/img/loading.gif" alt="image-20210203205558354"></p><p>首先$(x-x’)$代表着这个蓝色向量，然后让他做投影，投影到w的方向。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205706594.png" srcset="/img/loading.gif" alt="image-20210203205706594"></p><p>投影后的距离就是<strong>距离分割面的距离：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205818953.png" srcset="/img/loading.gif" alt="image-20210203205818953"></p><p>对于可分的平面来说：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203205949602.png" srcset="/img/loading.gif" alt="image-20210203205949602"></p><p>因此我们可以脱去绝对值：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210005363.png" srcset="/img/loading.gif" alt="image-20210203210005363"></p><p>那么现在我们的问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210025215.png" srcset="/img/loading.gif" alt="image-20210203210025215"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210208708.png" srcset="/img/loading.gif" alt="image-20210203210208708"></p><p>一条线是可以有多种表达方式的，我们这里只要保持$\frac{w^T}{||w||}$不变即可，因此我们放缩$w^T$,使其符合下面这个式子。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210424443.png" srcset="/img/loading.gif" alt="image-20210203210424443"></p><p>那么此时我们的距离就变成了$\frac{1}{||w||}$。</p><p>问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210545690.png" srcset="/img/loading.gif" alt="image-20210203210545690"></p><p>我们这里发现 <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210608829.png" srcset="/img/loading.gif" alt="image-20210203210608829"></p><p>下面这个条件包含上面的条件了，因此只需要下面的条件即可。</p><p>现在问题转化为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203210649123.png" srcset="/img/loading.gif" alt="image-20210203210649123"></p><hr><p>到现在位置问题中的min还是很难搞，我们如果可以放宽一些他的条件，但是结果还在当前条件的限制之下，那么我们的问题就好解决了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203211159268.png" srcset="/img/loading.gif" alt="image-20210203211159268"></p><p>我们用蓝色的条件代替紫色的，但这样很可能会导致</p><p>$y_n(w^T+b)$全部都大于1，导致最小的也不等于1了，那么这样放大了条件是没有什么意义的。</p><p>我们考虑假如真的全部都大于1，比如都大于1.126.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203211345197.png" srcset="/img/loading.gif" alt="image-20210203211345197"></p><p>我们可以调整$w$和$b$的大小使得其重新满足条件，那么这个条件放大一些是不影响结果的。</p><p>那么此时问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203211544842.png" srcset="/img/loading.gif" alt="image-20210203211544842"></p><p>做一些小的数学变换，（这个$\frac{1}{2}$就是为了后面方便计算的常数，最大化最小化问题中常数不影响最优的结果）</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203211652281.png" srcset="/img/loading.gif" alt="image-20210203211652281"></p><h2 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203211851541.png" srcset="/img/loading.gif" alt="image-20210203211851541"></p><p>我们以上图为例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203212202907.png" srcset="/img/loading.gif" alt="image-20210203212202907"></p><p>我们不难得出下面两个式子</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203212247035.png" srcset="/img/loading.gif" alt="image-20210203212247035"></p><p>所以$w_1^2+w_2^2\ge2$,即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203212331579.png" srcset="/img/loading.gif" alt="image-20210203212331579"></p><p>因此我们就可以算出这个最胖的线：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203212543635.png" srcset="/img/loading.gif" alt="image-20210203212543635"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203212649585.png" srcset="/img/loading.gif" alt="image-20210203212649585"></p><p>我们直观理解这个问题就是，我们通过支持向量(support vector)，也就是胖胖的线上边缘的那些点来算得这个胖胖的线。</p><hr><p>但是上面是4个点，比较简单，那么如果包含多个点我们怎么做呢？</p><p>幸运的是，这是一种二次规划问题，我们有现成的工具可以解决，我们只需要把我们现在的公式转换为标准的二次规划问题表达形式即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203213319550.png" srcset="/img/loading.gif" alt="image-20210203213319550"></p><p>我们只要找到左边的参数即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203213601556.png" srcset="/img/loading.gif" alt="image-20210203213601556"></p><p>那么我们的Linear Hard-Margin SVM算法就搞定了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203213818582.png" srcset="/img/loading.gif" alt="image-20210203213818582"></p><p>怎么做非线性的呢？还记得基石里讲到的方法吗，做feature transform就好了。</p><h2 id="Reasons-behind-Large-Margin-Hyperplane"><a href="#Reasons-behind-Large-Margin-Hyperplane" class="headerlink" title="Reasons behind Large-Margin Hyperplane"></a>Reasons behind Large-Margin Hyperplane</h2><p>有趣的事情是，我们发现：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203214239916.png" srcset="/img/loading.gif" alt="image-20210203214239916"></p><p>SVM怎么和regularization做的是相似的事情，都考虑了两个事情：</p><p>原来regularization做的事情可以防止overfit的原因体现在了SVM里。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203214819040.png" srcset="/img/loading.gif" alt="image-20210203214819040"></p><p>我们在之前的线性分类模型中hypothesis的数量可能很多，但是在SVM中比如我们要求这个分割面足够的胖，那么有一些在线性分类模型中的hypothesis在SVM中是不成立的(如上图)，因此<strong>VC Dimension会小一些，因此他的泛化能力更好一些</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203221636904.png" srcset="/img/loading.gif" alt="image-20210203221636904"></p><p>对于上图三个点，如果不考虑胖瘦，那么$d<em>{vc}=3$，但是如果要求宽度大于某个常数，那么$d</em>{vc}&lt;3$.</p><p>我们这里有一个现成的结果：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203221816559.png" srcset="/img/loading.gif" alt="image-20210203221816559"></p><p>$\rho$代表SVM中的线的宽度，$R$代表半径，因此我们多了一种控制复杂度的方式。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203222213241.png" srcset="/img/loading.gif" alt="image-20210203222213241"></p><p>我们有了large-margin hyperplane 我们可以同时做到 hypothesis set很小 并且 分界也更精细，即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210203222433887.png" srcset="/img/loading.gif" alt="image-20210203222433887"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH16：Three Learning Principle(完结)</title>
    <link href="/2021/01/27/CH16%EF%BC%9AThree-Learning-Principle/"/>
    <url>/2021/01/27/CH16%EF%BC%9AThree-Learning-Principle/</url>
    
    <content type="html"><![CDATA[<h2 id="CH16：Three-Learning-Principle"><a href="#CH16：Three-Learning-Principle" class="headerlink" title="CH16：Three Learning Principle"></a>CH16：Three Learning Principle</h2><h2 id="Occam’s-Razor-奥卡姆剃刀"><a href="#Occam’s-Razor-奥卡姆剃刀" class="headerlink" title="Occam’s Razor(奥卡姆剃刀)"></a>Occam’s Razor(奥卡姆剃刀)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127161602889.png" srcset="/img/loading.gif" alt="image-20210127161602889"></p><p>对数据最简单的解释也是最有说服力的解释。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127161637606.png" srcset="/img/loading.gif" alt="image-20210127161637606"></p><p>我们肯定认为左边的好一些。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127161802326.png" srcset="/img/loading.gif" alt="image-20210127161802326"></p><p>什么叫做simple model，hypothesis很简单的model，hypothesis set里的hypothesis不是很多。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127162135611.png" srcset="/img/loading.gif" alt="image-20210127162135611"></p><p>如果我们的资料很乱随机给出，毫无规律可循，那么我们可以完美的分开这些资料的概率是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127162447936.png" srcset="/img/loading.gif" alt="image-20210127162447936"></p><p>但是如果我们今天通过机器学习分开了这些资料，这意味着大概率我们的资料是可分的，因此这样的机器学习是合理的(资料是可分的,而不是随机的)。</p><h2 id="Sampling-Bias-（抽样偏差）"><a href="#Sampling-Bias-（抽样偏差）" class="headerlink" title="Sampling Bias （抽样偏差）"></a>Sampling Bias （抽样偏差）</h2><p>在美国总统竞选时，Dewey和Truman到了最后选举时，当时已经投完票了，所以进行电话民调，结果显示Dewey会战胜Truman。但最后结果确实相反。</p><p>这不是因为bad luck，因为抽样次数还是很多的。也不是编辑部的搞错了的问题。</p><p>而是当时电话很贵，富人支持Dewey的比较多，导致了<strong>抽样偏差</strong>。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127163150993.png" srcset="/img/loading.gif" alt="image-20210127163150993"></p><p>因此我们的<strong>训练和测试集要来自同样的分布</strong>。</p><p>​    同样我们之前说的信用卡发放问题，我们对这个人如果曾经有信用卡和还款情况等因素做了估计，但是我们其实放到实际应用会发现其实效果不是很好，因为我们一直在考虑对有信用卡的人的要求，而那些没有信用卡的人如果有了信用卡会不会还不上这样的问题没有做考虑。</p><p>​    同样我们预策喜欢电影的类型给你10部电影，预策观众喜欢看什么，我们做validation的时候，前7部用来训练model，后3部用来test我们的model，但其实我们没有考虑到模型的时间问题，也就是说一个人看电影在前7部和后面3部电影对这个观众的影响是不同的。比如我们以前喜欢看言情剧，偶然解除了科幻，我们开始看科幻多一些，可是后面三部电影却和前面7部每一部的权重是相同的，这显然不合理，一个观众越后面看的电影应该在预策中影响的权重越大，而不应该是相同的，这也是一种sampling Bias。</p><h2 id="Data-Snooping-数据窥测"><a href="#Data-Snooping-数据窥测" class="headerlink" title="Data Snooping(数据窥测)"></a>Data Snooping(数据窥测)</h2><p>不要让我们的大脑来做选择，不要偷看资料自己去选择。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127164553062.png" srcset="/img/loading.gif" alt="image-20210127164553062"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127164917669.png" srcset="/img/loading.gif" alt="image-20210127164917669"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165112869.png" srcset="/img/loading.gif" alt="image-20210127165112869"></p><p>​       在写论文中同样存在这个问题，如果一个数据集不变，paper里的效果越来越好，但是这都是因为我们看到了前人的论文，看到了他们的模型，这个看到别人的模型也是一种Data Snooping，我们不断地修正这个模型，加了越来越多的东西，只会在某个数据集上做的很好，但是其实泛化能力已经非常差了，放到业界新的数据上，这个模型不一定work。</p><p>​    </p><h2 id="Power-of-Three"><a href="#Power-of-Three" class="headerlink" title="Power of Three"></a>Power of Three</h2><p><strong>机器学习所相关的三个领域：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165721868.png" srcset="/img/loading.gif" alt="image-20210127165721868"></p><p><strong>三个Bound：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165745509.png" srcset="/img/loading.gif" alt="image-20210127165745509"></p><p><strong>三个模型：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165810730.png" srcset="/img/loading.gif" alt="image-20210127165810730"></p><p><strong>三个关键的工具：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165856142.png" srcset="/img/loading.gif" alt="image-20210127165856142"></p><p><strong>三个机器学习原则：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127165931680.png" srcset="/img/loading.gif" alt="image-20210127165931680"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH15：Validation</title>
    <link href="/2021/01/27/CH15%EF%BC%9AValidation/"/>
    <url>/2021/01/27/CH15%EF%BC%9AValidation/</url>
    
    <content type="html"><![CDATA[<h2 id="CH15：Validation"><a href="#CH15：Validation" class="headerlink" title="CH15：Validation"></a>CH15：Validation</h2><h2 id="Model-Select-Problem"><a href="#Model-Select-Problem" class="headerlink" title="Model Select Problem"></a>Model Select Problem</h2><p><strong>选择的依据：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210126171516245.png" srcset="/img/loading.gif" alt="image-20210126171516245"></p><ul><li>第一种：只做$E_{in}$ 做低一些，这样选模型肯定不是很好</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210126171533963.png" srcset="/img/loading.gif" alt="image-20210126171533963"></p><ul><li><p>第二种：选择在最终测试集上的一部分数据，然后对每个模型进行测试，然后选取准确率最高的。<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127132326729.png" srcset="/img/loading.gif" alt="image-20210127132326729"></p><p>由hoeffding不等式来看，这样的结果还不错：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127132602757.png" srcset="/img/loading.gif" alt="image-20210127132602757"></p><p>但是现实中我们几乎不能拿到最终测试集的，这是一个自欺欺人的做法。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127132804528.png" srcset="/img/loading.gif" alt="image-20210127132804528"></p><p>以上两种方法都不是很好，或许我们可以折中一下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127132905071.png" srcset="/img/loading.gif" alt="image-20210127132905071"></p><p>​    我们留一部分资料，但是这一部分的资料不用于训练。然后我们用其他资料训练，然后训练完的模型再测试刚刚的资料。</p><p>​    </p><h2 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127133357774.png" srcset="/img/loading.gif" alt="image-20210127133357774"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127133614744.png" srcset="/img/loading.gif" alt="image-20210127133614744"></p><p>从霍夫定不等式不难得出这样的保证：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127133632974.png" srcset="/img/loading.gif" alt="image-20210127133632974"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127134225542.png" srcset="/img/loading.gif" alt="image-20210127134225542"></p><p>​    我们选择错误率最小的即可，但是选择完后，比如第27个hypothesis的错误率最低，这个模型最好。那么我们直接27个hypothesis直接输出就OK了。</p><p>​    但也许我们可以做的更好一些，反正已经知道这个模型做的最好了，为什么不训练的时候直接把测试集也扔进去训练呢？我们的learning curse告诉我们，当模型确定，资料越多准确率越高，反正我们已经确定了模型，那不如<strong>把模型重新用所有数据训练一次</strong>。</p><p>​    数学语言来表示就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127134833489.png" srcset="/img/loading.gif" alt="image-20210127134833489"></p><p>这是我们validation的过程：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127134859426.png" srcset="/img/loading.gif" alt="image-20210127134859426"></p><p>我们观察不等式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127134833489.png" srcset="/img/loading.gif" alt="image-20210127134833489"></p><p>其实就是两次的约等于：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127135347261.png" srcset="/img/loading.gif" alt="image-20210127135347261"></p><p>但是左边是想要一个小的K的，而右边想要一个大的K。</p><p>这就成为了一个有些矛盾的地方，经验之谈，一般K取数据量的五分之一：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127135524269.png" srcset="/img/loading.gif" alt="image-20210127135524269"></p><h2 id="Leave-One-Out-Cross-Validation"><a href="#Leave-One-Out-Cross-Validation" class="headerlink" title="Leave-One-Out Cross Validation"></a>Leave-One-Out Cross Validation</h2><p>今天我们考虑一种比较极端的情形：</p><p>K非常小，$K=1$：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127140135698.png" srcset="/img/loading.gif" alt="image-20210127140135698"></p><p>$D_{val}^{(n)}$: 代表除去第n个资料的资料集。</p><p>$E<em>{val}^{(n)}(g_n^-):$ 代表用$D</em>{val}^{(n)}$训练出来的model做validation的时候的错误率是多少，这个错误率由于只有一个测试数据，那么这个值要么是0要么是1。</p><p>$E_{val}^{(n)}(g_n^-)$  要么是0要么是1，这样肯定是无法反映一个model的好坏的。那么如果我们有很多个$e_n$，即去掉不同的数据分别测试结果，就可以解决这个问题了。 </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127140604510.png" srcset="/img/loading.gif" alt="image-20210127140604510"></p><p>我们希望得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127140703980.png" srcset="/img/loading.gif" alt="image-20210127140703980"></p><p>举一个简单的例子：</p><p>比如数据集一共三个数据，我们有两种model，分别是 线性模型和常数模型：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127140930385.png" srcset="/img/loading.gif" alt="image-20210127140930385"></p><p>不难看出常数模型效果更好。</p><p>我们想要说明一些$E<em>{loocv}(H,A)$和$E</em>{out}$的关系：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127141717364.png" srcset="/img/loading.gif" alt="image-20210127141717364"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127145719774.png" srcset="/img/loading.gif" alt="image-20210127145719774"></p><p>我们可以发现<strong>cross validation所作出来的错误率和$E_{out}$很相近。</strong></p><h2 id="V-Fold-Cross-Validation"><a href="#V-Fold-Cross-Validation" class="headerlink" title="V-Fold Cross Validation"></a>V-Fold Cross Validation</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127155434364.png" srcset="/img/loading.gif" alt="image-20210127155434364"></p><p>​     上次提到的Leave-One-Out cross validation的方法复杂度有些高。每次都要送进去算一次，但是如果是线性回归的话，每次做都是有闭式解的还比较快一些。因此线性回归比较适合Leave-One-Out cross validation，但是有些模型我们是没有办法很快算出来的。</p><p>​    </p><p>Leave-One-Out cross validation还有一个缺点就是他的跳动比较大，因为每个的取值不是0就是1，这样就造成了得出来的错误率不太平滑，也不够稳定，如下图黑线上下跳动：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127155650378.png" srcset="/img/loading.gif" alt="image-20210127155650378"></p><p>所以Leave-One-Out cross validation并不是很常用，只有某些特定情况下才会使用。</p><hr><p>那么怎么减少计算量呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127155955904.png" srcset="/img/loading.gif" alt="image-20210127155955904"></p><p>比如1000个数据，我们不再切1000份去做Leave-One-Out cross validation，而是选择等量的分成10个部分。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127160109880.png" srcset="/img/loading.gif" alt="image-20210127160109880"></p><p>然后用每份去做平均，而不是单单的一个一个的去做平均。这样一定程度会加速计算，减少计算量。</p><p>我们一般分成10份：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127160215678.png" srcset="/img/loading.gif" alt="image-20210127160215678"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210127160625904.png" srcset="/img/loading.gif" alt="image-20210127160625904"></p><ul><li><p>我们先是选择一个好的model在所有的hypothesis</p></li><li><p>然后用cross validation的去训练我们的模型，并选出一个调成最好的参数。</p></li><li>然后去用这个训练好的模型测试真正的结果$E_{out}$效果如何</li></ul><p>我们要记住 我们选择去做validation只是因为他可以保证我们的模型做出来效果不会太差，但是模型真正的好与坏 只依据$ E_{out}$</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH14：Regularization</title>
    <link href="/2021/01/25/CH14%EF%BC%9ARegularization/"/>
    <url>/2021/01/25/CH14%EF%BC%9ARegularization/</url>
    
    <content type="html"><![CDATA[<h2 id="CH14：Regularization"><a href="#CH14：Regularization" class="headerlink" title="CH14：Regularization"></a>CH14：Regularization</h2><h2 id="Regularized-Hypothesis-Set"><a href="#Regularized-Hypothesis-Set" class="headerlink" title="Regularized Hypothesis  Set"></a>Regularized Hypothesis  Set</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125140912557.png" srcset="/img/loading.gif" alt="image-20210125140912557"></p><p>我们之前由于overfit造成了右边图所示的状况，我们今天要把右图转化为左图通过：Regularization</p><p>因此我们要从高次的hypothesis走回到低次的hypothesis，因此我们想找一种方法可以提供一种指标使得高次走回到低次。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125141339343.png" srcset="/img/loading.gif" alt="image-20210125141339343"></p><p>因此我们可以看出：低次多项式其实就是高次多项式 <strong>加上了一些限制</strong></p><p>比如上图的限制就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125141439152.png" srcset="/img/loading.gif" alt="image-20210125141439152"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125141629439.png" srcset="/img/loading.gif" alt="image-20210125141629439"></p><p>因此我们上文所说的让高次走回到低次就是通过这个<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125141718789.png" srcset="/img/loading.gif" alt="image-20210125141718789">constraint来做到的。</p><p>那为什么不直接用3维呢？</p><p>其实我们的这个constraint是可以looser一些的：</p><p>比如我们可以不控制具体哪儿个$w$是0，而是限制$w=0$的数量</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125141917417.png" srcset="/img/loading.gif" alt="image-20210125141917417"></p><p>那么我们此时得到这个新的hypothesis $H_2’$ 的特点是：</p><ul><li>比$H_2$ 要更宽松一些</li><li>比$H_{10}$要严格一些</li></ul><p>但可惜：这个$H_2’$ 的解是一个NP-hard 问题</p><p>我们可以找一个和这个类似的looser的constraint，比如：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125143057847.png" srcset="/img/loading.gif" alt="image-20210125143057847"></p><p>我们对每个w的和进行限制。</p><p>我们称这样的hypothesis为$H(C)$:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125143202487.png" srcset="/img/loading.gif" alt="image-20210125143202487"></p><p>观察不难发现，通过调节$H(C)$ 它可以在H(0) 到$H_{10}$之间，太好了这样不就让他自己去寻找适合的复杂度了吗！</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125143239879.png" srcset="/img/loading.gif" alt="image-20210125143239879"></p><p>我们称H(C):  <strong>regularized hypothesis set</strong></p><h2 id="Weight-Decay-Regularization"><a href="#Weight-Decay-Regularization" class="headerlink" title="Weight Decay Regularization"></a>Weight Decay Regularization</h2><p>我们把$H(C)$写成矩阵形式：<br><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125144549879.png" srcset="/img/loading.gif" alt="image-20210125144549879"></p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125144616152.png" srcset="/img/loading.gif" alt="image-20210125144616152"></p><p>我们还是考虑用梯度下降法来做这个问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125144734612.png" srcset="/img/loading.gif" alt="image-20210125144734612"></p><p>​    梯度下降会滚到我们做linear regressions的划分处，但是我们还有一个条件：</p><p>$w^Tw\le C$  .</p><p>​    我们可以这么想如果你要进行梯度下降，你的方向不能沿着normal(上图红色的线)防线，要你沿着圆的切线下降，即绿色的箭头。</p><p>也就是说直到w向量与梯度反方向平行时，我们没有w向量的法向量方向的分量了，此时就不用在更新了。用数学表达这个问题就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125150047655.png" srcset="/img/loading.gif" alt="image-20210125150047655"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125150101900.png" srcset="/img/loading.gif" alt="image-20210125150101900"></p><p>我们此时要解决 这个问题：<br><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125150218665.png" srcset="/img/loading.gif" alt="image-20210125150218665"></p><p>我们把梯度算出来带进去直接（线性回归那节的内容）：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125150454479.png" srcset="/img/loading.gif" alt="image-20210125150454479"></p><p>我们消掉无关的N，2,得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125150935120.png" srcset="/img/loading.gif" alt="image-20210125150935120"></p><p>称为<strong>ridge regression岭回归</strong></p><p>我们理解一下这个问题：</p><p>原来我们在做linear regression的时候：</p><p>我们做到梯度<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125152552782.png" srcset="/img/loading.gif" alt="image-20210125152552782">等于0时，说明了$E_{in}$此时最小。</p><p>我们类比一下，我们现在做的这个就相当于：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125152820610.png" srcset="/img/loading.gif" alt="image-20210125152820610"></p><p>我们要解$w$, 不妨用上图中下面的式子来做：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125153240391.png" srcset="/img/loading.gif" alt="image-20210125153240391"></p><p>因此只要给我$\lambda$ ，我们就可以解了。</p><p>我们来看一下不同$\lambda$对结果的影响。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125153338741.png" srcset="/img/loading.gif" alt="image-20210125153338741"></p><p>我们发现$\lambda$ 很小的时候就可以做到很好的结果。</p><p>因此说明我们加上一点点的regularization就可以让效果变得很好。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125153652218.png" srcset="/img/loading.gif" alt="image-20210125153652218">$\lambda$ 越大，向量w越短，C越小。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125154109395.png" srcset="/img/loading.gif" alt="image-20210125154109395"></p><p>这个东西像是在惩罚。</p><p>（Legendre Polynomials）勒让德多项式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125161208835.png" srcset="/img/loading.gif" alt="image-20210125161208835"></p><p>我们让不同方向的x做一下规格化正交，成为规格化正交的方程（orthonormal basic functions），也叫（Legendre Polynomials）勒让德多项式。这样效果会好一些。</p><h2 id="Regularization-and-VC-Theory"><a href="#Regularization-and-VC-Theory" class="headerlink" title="Regularization and VC Theory"></a>Regularization and VC Theory</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125162239412.png" srcset="/img/loading.gif" alt="image-20210125162239412"></p><ul><li><p>我们把问题<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125162500961.png" srcset="/img/loading.gif" alt="image-20210125162500961">转化为了问题：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125162518231.png" srcset="/img/loading.gif" alt="image-20210125162518231">，这个C通过$\lambda$来表现。</p></li><li><p>我们的VC保证是：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125162706267.png" srcset="/img/loading.gif" alt="image-20210125162706267"></p></li></ul><p>我们仔细观察发现 这个Augmented Error 和 VC Bound长得有点像：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125162911119.png" srcset="/img/loading.gif" alt="image-20210125162911119"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125163003820.png" srcset="/img/loading.gif" alt="image-20210125163003820"></p><ul><li><p>我们的<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125163021855.png" srcset="/img/loading.gif" alt="image-20210125163021855">代表的是具体的一个hypothesis多么多么的复杂，比如多项式次数很高</p></li><li><p>VC bound中的<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125163116176.png" srcset="/img/loading.gif" alt="image-20210125163116176">代表的是hypothesis set有多么多么复杂。</p></li><li><p>因此我们发现，如果一个hypothesis非常复杂，那么他所属于的hypothesis set也不会很简单。</p><p>因此<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125163237168.png" srcset="/img/loading.gif" alt="image-20210125163237168">这是一个很好的替代品。</p></li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125203836774.png" srcset="/img/loading.gif" alt="image-20210125203836774"></p><p>我们通过regularized（正则化）后，$d<em>{VC}$ 会变小的，我们称为：$d</em>{EFE}$。</p><p>即：Effective VC Dimension，这个$d<em>{EFE}$ 会小很多相比于原来$d</em>{VC}(H)$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125204841167.png" srcset="/img/loading.gif" alt="image-20210125204841167"></p><h2 id="General-Regularizers"><a href="#General-Regularizers" class="headerlink" title="General Regularizers"></a>General Regularizers</h2><p>我们一般加上怎么样的正则项(Regularizers)呢？</p><p>比如我们今天训练一个模型，我们认为最后的target function是一个类似于<strong>偶函数</strong>的function。那么我们训练一个多项式的时候，偶数幂次项系数不用管，奇数幂次项系数尽可能小，才能使最后训练出来的函数类似于偶函数，那么此时的正则项就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125214648419.png" srcset="/img/loading.gif" alt="image-20210125214648419"></p><p>比如我们想要选出比较<strong>平滑/简单</strong>的hypothesis，就加上这样的正则项：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125214751325.png" srcset="/img/loading.gif" alt="image-20210125214751325"></p><p>比如我们想让最优化时比较方便那么我们就加上这样的正则项：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125214914486.png" srcset="/img/loading.gif" alt="image-20210125214914486"></p><hr><p><strong>L2正则：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125215153818.png" srcset="/img/loading.gif" alt="image-20210125215153818"></p><p>处处可微分，所以容易找最优解。</p><p><strong>L1正则：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125220118493.png" srcset="/img/loading.gif" alt="image-20210125220118493"></p><ul><li><p>他不是处处可导的</p></li><li><p>解很稀疏，这是因为由于梯度下降，会沿着正方形边缘来走，直到正方形的角，才有最优解。我们再来思考一下这个方形的角有什么特点呢？特点就是它会使大部分w项=0，少部分w项非0，因此他求的是一个稀疏的解。</p></li><li>举一个生动的例子：我们训练了一个1000多维的模型，但是我们不想让解这么麻烦，怎么办呢? 我们只需要做一个L1正则化，让解稀疏一些，比如1000项的w可能900多项都会变成0，那么我们计算的速度就加快了很多。</li></ul><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125222040229.png" srcset="/img/loading.gif" alt="image-20210125222040229"></p><p>我们结合上面两个图发现：噪声越大，$\lambda$越大，这个不难理解，路越陡峭，就要多踩刹车。</p><p>但是我们一般是不知道噪声是多大的？所以我们也没法选择正确的$\lambda$，这也是下一节要解决的问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210125222810629.png" srcset="/img/loading.gif" alt="image-20210125222810629"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH13：Hazard of Overfitting</title>
    <link href="/2021/01/24/CH13%EF%BC%9AHazard-of-Overfitting/"/>
    <url>/2021/01/24/CH13%EF%BC%9AHazard-of-Overfitting/</url>
    
    <content type="html"><![CDATA[<h1 id="CH13：Hazard-of-Overfitting"><a href="#CH13：Hazard-of-Overfitting" class="headerlink" title="CH13：Hazard of Overfitting"></a>CH13：Hazard of Overfitting</h1><h2 id="What-is-overfitting"><a href="#What-is-overfitting" class="headerlink" title="What is overfitting"></a>What is overfitting</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124183710854.png" srcset="/img/loading.gif" alt="image-20210124183710854"></p><p>比如我们现在的数据是通过一个二次曲线+noise 造出来的数据，然后我们用这个数据进行机器学习，假如你用了5次曲线（即一定可以经过上述的五个点），那么我们就会画出图中红色的曲线(且$E_{in}=0$)</p><p>但是她和我们的target function蓝色线差距很大。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124184037480.png" srcset="/img/loading.gif" alt="image-20210124184037480"></p><p>一个overfitting的例子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124184123156.png" srcset="/img/loading.gif" alt="image-20210124184123156"></p><p>overfitting出现的原因：</p><p>我们以出车祸为例子。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124184304069.png" srcset="/img/loading.gif" alt="image-20210124184304069"></p><ul><li>用的$d_{VC}$太大，开的太快</li><li>噪声，路不平</li><li>资料少，路况不清楚</li></ul><h2 id="The-Role-of-Noise-and-Data-Size"><a href="#The-Role-of-Noise-and-Data-Size" class="headerlink" title="The Role of Noise and Data Size"></a>The Role of Noise and Data Size</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124184610253.png" srcset="/img/loading.gif" alt="image-20210124184610253"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124184714999.png" srcset="/img/loading.gif" alt="image-20210124184714999"></p><p>我们发现10次多项式还是发生了over fitting，在$E_{out}$表现很差。</p><p>我们会经常发现，有时候即使如果target function是10次的，我们用十次模型的效果竟然没有二次模型表现好，这是为什么呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124210357613.png" srcset="/img/loading.gif" alt="image-20210124210357613"></p><p>我们看右面的图，会发现在灰色部分 $E_{out}$表现非常差 ，这是一种聪明反被聪明误的特点，因为hypothesis太多了，在数据较少时很难寻出来一个好的模型。</p><h2 id="Deterministic-Noise"><a href="#Deterministic-Noise" class="headerlink" title="Deterministic Noise"></a>Deterministic Noise</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124210959772.png" srcset="/img/loading.gif" alt="image-20210124210959772"></p><p>我们给出的数据y由两部分合成：target function+noise。这里noise符合高斯分布来看。</p><p>我们想研究影响overfit的因素，首先要确定overfit的measure方法</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124211605335.png" srcset="/img/loading.gif" alt="image-20210124211605335"></p><p>这里我们想到，如果overfit的越厉害，那么反映在$E_{out}$上来看就是差距很大：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124211910008.png" srcset="/img/loading.gif" alt="image-20210124211910008"></p><p>下面我们来看不同不同影响因素造成的overift情况：</p><p>注：$Q_f$代表用的target function是几次的函数。</p><p>我们先看noise 和 数据量带来的影响</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124212725316.png" srcset="/img/loading.gif" alt="image-20210124212725316"></p><ul><li>左上方深红色，不难理解，noise很多数据很少，差距肯定比较大，表现不好</li><li>蓝色部分数据多，noise少，肯定表现得不错。</li></ul><p>我们看一下 target function的次数($Q_f$) 和 数据量带来的影响</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124213600549.png" srcset="/img/loading.gif" alt="image-20210124213600549"></p><ul><li>深红色，我们的目标函数非常复杂时，且数据数量又少肯定我们做不好。</li></ul><p>从上面两个图，我们总结一下overfit的情况：</p><ul><li><p>数据太少，<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124213933689.png" srcset="/img/loading.gif" alt="image-20210124213933689"></p></li><li><p>stochastic noise太多，<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124214021109.png" srcset="/img/loading.gif" alt="image-20210124214021109"></p></li><li><p>deterministic noise 太多</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124214111834.png" srcset="/img/loading.gif" alt="image-20210124214111834"></p></li><li><p>excessive power造成的overfit，因为target function的复杂度很小时，我们用一个10次的多项式去拟合，因为他的能力太强了，肯定会把noise也拟合出来，这样就造成overfit</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124214318637.png" srcset="/img/loading.gif" alt="image-20210124214318637"></p></li></ul><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124215438229.png" srcset="/img/loading.gif" alt="image-20210124215438229"></p><ul><li>当我们的hypothesis(红线)的复杂度小于target function(蓝线)时，他们之间肯定会有差距，即灰色的部分，我们一般称这个差距就是deterministic noise</li><li>其实所有的 stochastic noise都是电脑伪随机出来的，其实本质上也是deterministic noise。</li></ul><h2 id="Dealing-with-Overfitting"><a href="#Dealing-with-Overfitting" class="headerlink" title="Dealing with Overfitting"></a>Dealing with Overfitting</h2><p>我们之前讨论了产生overfit的原因，我们反向思维即可，得出解决的方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124220923975.png" srcset="/img/loading.gif" alt="image-20210124220923975"></p><ul><li>简单的模型</li><li>数据清洗/去除</li><li>多一点数据</li></ul><p>除此之外，我们还可以用以下方法：</p><ul><li>regularization（下一节说）</li><li>validation（下一节说）</li></ul><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124221352225.png" srcset="/img/loading.gif" alt="image-20210124221352225"></p><p>比如左上方的<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124221410605.png" srcset="/img/loading.gif" alt="image-20210124221410605">，这个居然认作5，这肯定是错误的，因此我们想要去掉这种离谱的错误。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124221511027.png" srcset="/img/loading.gif" alt="image-20210124221511027"></p><p>可以这样解决：</p><ul><li>如果监测到了5，但是他很接近1（身边都是被认作1的点），或者说这个点距离其他5的数据点太远，那么我们大概就可以认为这个数据可能是错误的。</li><li><p>我们直接改成他的label即可，我们称这样的操作为data cleaning</p></li><li><p>或者我们直接扔掉这个example，我们称这样的操作为data pruning</p></li></ul><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124222231925.png" srcset="/img/loading.gif" alt="image-20210124222231925"></p><p>如果我们手上的数据有限，我们又想多一些资料，可以这么做：</p><ul><li>对原来的资料进行轻微的旋转/平移操作，但不改变资料的实际意义</li><li>添加到数据集中，我们称之为data hinting（数据微调）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《线性代数及其应用》CH3：行列式</title>
    <link href="/2021/01/24/CH3%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <url>/2021/01/24/CH3%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-行列式"><a href="#第三章-行列式" class="headerlink" title="第三章 行列式"></a>第三章 行列式</h1><h2 id="3-1-行列式介绍"><a href="#3-1-行列式介绍" class="headerlink" title="3.1 行列式介绍"></a>3.1 行列式介绍</h2><p><strong>注: $det \ A$ 代表行列式A的值</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123211012471.png" srcset="/img/loading.gif" alt="image-20210123211012471"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123211916674.png" srcset="/img/loading.gif" alt="image-20210123211916674"></p><p><strong>一个矩阵展开成代数余子式可以按行或者列展开（即 定理1）</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123212024954.png" srcset="/img/loading.gif" alt="image-20210123212024954"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123212029018.png" srcset="/img/loading.gif" alt="image-20210123212029018"></p><p><strong>定理2：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123212158330.png" srcset="/img/loading.gif" alt="image-20210123212158330"></p><h2 id="3-2-行列式的性质"><a href="#3-2-行列式的性质" class="headerlink" title="3.2 行列式的性质"></a>3.2 行列式的性质</h2><p>行变换的性质：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123212455546.png" srcset="/img/loading.gif" alt="image-20210123212455546"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213023927.png" srcset="/img/loading.gif" alt="image-20210123213023927"></p><p><strong>可逆与行列式的联系：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213048182.png" srcset="/img/loading.gif" alt="image-20210123213048182"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213125264.png" srcset="/img/loading.gif" alt="image-20210123213125264"></p><p><strong>列变换：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213235115.png" srcset="/img/loading.gif" alt="image-20210123213235115"></p><p>有了定理5我们不难想到，行列变换规则是一样的。</p><p><strong>行列式乘积：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213402961.png" srcset="/img/loading.gif" alt="image-20210123213402961"></p><p>例题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123213423075.png" srcset="/img/loading.gif" alt="image-20210123213423075"></p><p><strong>行列式函数的一个有趣的线性性质：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123220005342.png" srcset="/img/loading.gif" alt="image-20210123220005342"></p><p>证明：(2)这个其实就是列变换，显而易见  </p><p>​           (3)我们可以按照$x$所在的列进行展开，就很好证了。</p><h2 id="3-3-克拉默法则，体积和线性变换"><a href="#3-3-克拉默法则，体积和线性变换" class="headerlink" title="3.3 克拉默法则，体积和线性变换"></a>3.3 克拉默法则，体积和线性变换</h2><p><strong>克拉默法则：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123220738837.png" srcset="/img/loading.gif" alt="image-20210123220738837"></p><p>证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123220905100.png" srcset="/img/loading.gif" alt="image-20210123220905100"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123221224871.png" srcset="/img/loading.gif" alt="image-20210123221224871"></p><p>例题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123221417790.png" srcset="/img/loading.gif" alt="image-20210123221417790"></p><p><strong>逆矩阵公式：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124152611196.png" srcset="/img/loading.gif" alt="image-20210124152611196"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124152604162.png" srcset="/img/loading.gif" alt="image-20210124152604162"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124152727431.png" srcset="/img/loading.gif" alt="image-20210124152727431"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124152739484.png" srcset="/img/loading.gif" alt="image-20210124152739484"></p><p><strong>行列式表示面积/体积：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124165403715.png" srcset="/img/loading.gif" alt="image-20210124165403715"></p><p>矩形很好证明这个问题，但是如果是平行四边形，我们化成对角矩阵计科。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124165828374.png" srcset="/img/loading.gif" alt="image-20210124165828374"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124165841321.png" srcset="/img/loading.gif" alt="image-20210124165841321"></p><p>这个结合图也可以直观的理解，这是不会改变面积的。</p><p>如果是3*3的矩阵：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124170411719.png" srcset="/img/loading.gif" alt="image-20210124170411719"></p><p>这个也不难理解，我们可以通过行列变换把平行六面体变成正方体。</p><p><strong>线性变换：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124182426337.png" srcset="/img/loading.gif" alt="image-20210124182426337"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124182612673.png" srcset="/img/loading.gif" alt="image-20210124182612673"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124182912856.png" srcset="/img/loading.gif" alt="image-20210124182912856"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210124182922242.png" srcset="/img/loading.gif" alt="image-20210124182922242"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH12：Nonlinear Transformation</title>
    <link href="/2021/01/23/CH12%EF%BC%9ANonlinear-Transformation/"/>
    <url>/2021/01/23/CH12%EF%BC%9ANonlinear-Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="CH12：Nonlinear-Transformation"><a href="#CH12：Nonlinear-Transformation" class="headerlink" title="CH12：Nonlinear Transformation"></a>CH12：Nonlinear Transformation</h1><h2 id="Quadratic-Hypotheses（二次假设）"><a href="#Quadratic-Hypotheses（二次假设）" class="headerlink" title="Quadratic Hypotheses（二次假设）"></a>Quadratic Hypotheses（二次假设）</h2><p>Linear Hypothesis </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123141912732.png" srcset="/img/loading.gif" alt="image-20210123141912732"></p><p>线性模型可以算一个分数，它最大的好处是$d_{VC}$ 可以被控制，当然线性模型在某些数据上每条线都做不到效果很好。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123142255944.png" srcset="/img/loading.gif" alt="image-20210123142255944"></p><p>我们这里用一个圈就可以很好地进行分类。</p><p>那么我们可以设一个圆形的PLA,可是图形是千变万化的，我们不可能每个都设计出来一个PLA，那么我们可以系统化的设计一个。</p><p>我们可以把式子化为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123142856750.png" srcset="/img/loading.gif" alt="image-20210123142856750"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123142957261.png" srcset="/img/loading.gif" alt="image-20210123142957261"></p><p>我们可以把$x_1$ 对应到右边的$x_1^2$,那么就想到于把以<strong>x为基地的左图</strong>转为<strong>以z为基底的右图</strong>。</p><p>惊喜的发现，我们又把问题转化到了线性的问题。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123143708871.png" srcset="/img/loading.gif" alt="image-20210123143708871"></p><p>不同的w赋值可以代表不同的model，这是一个很好的系统性的总结。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123143852910.png" srcset="/img/loading.gif" alt="image-20210123143852910"></p><p>那么什么样的x图像都可以用z表示吗？</p><p>当然不是，如果我们细心会发新$h(x)=sign(w_0+w_1x_1^2+w_2x_2^2)$ 没用关于x的一次项，也就是说这个圆形是不可以平移的。</p><p>因此只有一部分特殊可以利用这个系统：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123144112039.png" srcset="/img/loading.gif" alt="image-20210123144112039"></p><p>我们想要扩展到任意图形：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123144148424.png" srcset="/img/loading.gif" alt="image-20210123144148424"></p><p>那我们就加上一次项。</p><h2 id="Nonlinear-Transform"><a href="#Nonlinear-Transform" class="headerlink" title="Nonlinear Transform"></a>Nonlinear Transform</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123145808828.png" srcset="/img/loading.gif" alt="image-20210123145808828"></p><p>因此我们想这么做一个过程：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123145849255.png" srcset="/img/loading.gif" alt="image-20210123145849255"></p><p>最后一个反运算$\phi ^{-1}$虽然不一定成立，但一般不会影响我们的结果，因为我们早早建立了每个点在新的以z为基地的坐标系下的映射坐标是什么，我们既然已经算出来了下图：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123150011588.png" srcset="/img/loading.gif" alt="image-20210123150011588"></p><p>我们可以直接去找他对应的点是什么，无需做反变换。图中这么表示这是为了理解。</p><p>这个转化做完所有学的线性模型都可以用了。</p><p>但是这么做有没有什么代价呢？</p><h2 id="Price-of-Nonlinear-Transform"><a href="#Price-of-Nonlinear-Transform" class="headerlink" title="Price of Nonlinear Transform"></a>Price of Nonlinear Transform</h2><p>如果是一个Q次的多项式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123165350481.png" srcset="/img/loading.gif" alt="image-20210123165350481"></p><p>那么我们需要多少项来表示呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123165631087.png" srcset="/img/loading.gif" alt="image-20210123165631087"></p><p>这个量级大概是$O（Q^d）$,即w大概要这么多项，这个w大概就是$d_{VC}$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123170213343.png" srcset="/img/loading.gif" alt="image-20210123170213343"></p><ul><li>所以Q很大时，即用了一个高次的函数来划分类别，$d<em>{VC}$就会很大，这样导致了$E</em>{in}$和$E_{out}$差距就很大了，但是这种效果往往在训练的数据集上表现得很好。</li><li>反之，如果我们选一个很简单的低次函数来划分，$d<em>{VC}$小一些，虽然$E</em>{in}$和$E_{out}$比较接近了,当然这会使得我们的训练效果很差。</li></ul><p>这是一个机器学习中很重要的trade-off(权衡)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123170857408.png" srcset="/img/loading.gif" alt="image-20210123170857408"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123171118823.png" srcset="/img/loading.gif" alt="image-20210123171118823"></p><p>我们看上图可以发现，我们最后甚至提出了一个$d_{VC}=1$的方法，真是太好了。</p><p>但其实我们仔细想想，能提出这样一个想法，是因为你看到了这个数据图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123171324613.png" srcset="/img/loading.gif" alt="image-20210123171324613"></p><p>你看到长得像圆形，没有偏离原点，所以你说我们不需要<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123171353444.png" srcset="/img/loading.gif" alt="image-20210123171353444"></p><p>这种的变换。</p><p>那如果是一个超高维的数据，你分类就不可能看到数据情况了，你也想象不到高维体的样子，所以你只能老老实实的用$d_{VC}$大一些的方法。而我们直接提出的<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123171536529.png" srcset="/img/loading.gif" alt="image-20210123171536529"></p><p>这种方式，是经过人human learning 学到的，不是machine leaning学到的。</p><h2 id="Structed-Hypothesis-Sets"><a href="#Structed-Hypothesis-Sets" class="headerlink" title="Structed Hypothesis Sets"></a>Structed Hypothesis Sets</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123172722949.png" srcset="/img/loading.gif" alt="image-20210123172722949"></p><p>我们转换到新的坐标下，新坐标下的Hypothesis肯定是有包含关系的，如下图。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123172842740.png" srcset="/img/loading.gif" alt="image-20210123172842740"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123174003440.png" srcset="/img/loading.gif" alt="image-20210123174003440"></p><p>同理我们不难推理到$E_{in}$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210123174011453.png" srcset="/img/loading.gif" alt="image-20210123174011453"></p><p>从上图我们可以看出转换到一个很大的$d_{VC}$，并不是很好。</p><p><strong>比较安全的做法是：</strong>从$H<em>1$ 开始一个一个增加 ，直到$H_t$计算出的$E</em>{in}(g_t)$足够好</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH11：Linear Models for Classification</title>
    <link href="/2021/01/21/CH11%EF%BC%9ALinear-Models-for-Classification/"/>
    <url>/2021/01/21/CH11%EF%BC%9ALinear-Models-for-Classification/</url>
    
    <content type="html"><![CDATA[<h1 id="CH11：Linear-Models-for-Classification"><a href="#CH11：Linear-Models-for-Classification" class="headerlink" title="CH11：Linear Models for Classification"></a>CH11：Linear Models for Classification</h1><h2 id="Binary-Classification"><a href="#Binary-Classification" class="headerlink" title="Binary Classification"></a>Binary Classification</h2><p>我们回顾一下线性模型：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121114057461.png" srcset="/img/loading.gif" alt="image-20210121114057461"></p><p>我们看一下三个error function在做classification时的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121114816534.png" srcset="/img/loading.gif" alt="image-20210121114816534"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121115146949.png" srcset="/img/loading.gif" alt="image-20210121115146949"></p><p>$ys$代表着正确的分数。</p><p>下面我们画个图来看一下3个error function的图像：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121115356316.png" srcset="/img/loading.gif" alt="image-20210121115356316"></p><p>这个cross-entropy可以稍微移动下，移动到ys=0的那个阶梯直角处。</p><p>此时我们称之为 <strong>scaled cross entropy</strong>：（把取ln改为取log2）</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121115838748.png" srcset="/img/loading.gif" alt="image-20210121115838748"></p><p>这么做会让我们的推导容易一些。</p><p>我们来证明一下这个事情，用换底公式不难得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121120115701.png" srcset="/img/loading.gif" alt="image-20210121120115701"></p><p>我们从VC Bound不难得知：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121120309197.png" srcset="/img/loading.gif" alt="image-20210121120309197"></p><p>我们话可以用<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121120424784.png" srcset="/img/loading.gif" alt="image-20210121120424784"></p><p>直接得出：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121120434073.png" srcset="/img/loading.gif" alt="image-20210121120434073"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121120507857.png" srcset="/img/loading.gif" alt="image-20210121120507857"></p><p><strong>注：</strong>上述式子的提出可能会有疑问，之前不是讲得是</p><p><img src="https://i.loli.net/2021/01/15/e4IbzRNaWT5p6xB.png" srcset="/img/loading.gif" alt="image.png"></p><p>单一的让$E<em>{in}$小并不合理,应该找一个合适的不是吗？但我们不难发现这里面说的是$d</em>{VC}$,而我们这里要调的是$w$。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121122259920.png" srcset="/img/loading.gif" alt="image-20210121122259920"></p><p>所以这里我们做完逻辑回归或者线性回归后，传回去的值要加一个sign()即可。</p><p>我们最后总结一下这三个方法的优劣：</p><ul><li>用PLA时，要线性可分，若不是线性可分，那就要跑pocket</li><li>用linear regression时，因为有闭式解，很容易算出w，但是会lose bound（毕竟衡量错误不准确，比一般的0/1 error measure的值全都大）。</li><li>logistic regression同理，gradient descent很容易找到一个最优解，但是也会lose bound</li></ul><p>我们可以通过组合的方法找出一个比较好用的解，比如：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121122818625.png" srcset="/img/loading.gif" alt="image-20210121122818625"></p><p>还有一点，logistic regression用得一般比pocket用的多，这是因为logistic regression的最优化性质比较好用一些。</p><h2 id="Stochastic-Grad-Descent（随机梯度下降）"><a href="#Stochastic-Grad-Descent（随机梯度下降）" class="headerlink" title="Stochastic Grad. Descent（随机梯度下降）"></a>Stochastic Grad. Descent（随机梯度下降）</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121123736533.png" srcset="/img/loading.gif" alt="image-20210121123736533"></p><p>这两种方式每轮迭代的速度是不一样的一个时O(1)一个是O(N)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121124041845.png" srcset="/img/loading.gif" alt="image-20210121124041845"></p><p>我们想用一个随机平均代替连加，这样复杂度就会降下来。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121124254571.png" srcset="/img/loading.gif" alt="image-20210121124254571"></p><p>我们可以把这样一个随机梯度理解为，实际的梯度+平均为0的噪声</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121124329250.png" srcset="/img/loading.gif" alt="image-20210121124329250"></p><p>但是我们经理足够多轮的更新后，还是会非常接近真正的梯度的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121125406460.png" srcset="/img/loading.gif" alt="image-20210121125406460"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121130038979.png" srcset="/img/loading.gif" alt="image-20210121130038979"></p><p>我们来对比一下 ，SGD中是错了多少，而PLA中是有没有错误。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121130140897.png" srcset="/img/loading.gif" alt="image-20210121130140897"></p><p>因此我们一般说SGD logistic regression ≈ soft PLA</p><p>但是问题是，SGD跑到什么时候结束呢？SGD跑到谷底是很难的</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121130413560.png" srcset="/img/loading.gif" alt="image-20210121130413560"></p><ul><li>一般是跑足够多轮</li><li>学习率一般选0.1，如果x的范围不是特别离谱</li></ul><h2 id="Multiclass-via-logistic"><a href="#Multiclass-via-logistic" class="headerlink" title="Multiclass via logistic"></a>Multiclass via logistic</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121131742756.png" srcset="/img/loading.gif" alt="image-20210121131742756"></p><p>我们可以一次只做一种：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121131835446.png" srcset="/img/loading.gif" alt="image-20210121131835446"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121131941507.png" srcset="/img/loading.gif" alt="image-20210121131941507"></p><p>但是在</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121132108920.png" srcset="/img/loading.gif" alt="image-20210121132108920"></p><p>这几个地方会出现都不是四个类别或者属于多个类别的情况。</p><p>那么我们可以作soft classification，告诉我是这个类的概率。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121132316066.png" srcset="/img/loading.gif" alt="image-20210121132316066"></p><p>明暗代表概率，我们取最高概率作为划分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121132353785.png" srcset="/img/loading.gif" alt="image-20210121132353785"></p><p>我们上面用的算法称为：</p><p><strong>One-Versus-All(OVA) Decomposition:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121132621679.png" srcset="/img/loading.gif" alt="image-20210121132621679"></p><p>这个<strong>算法的特点：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121132811971.png" srcset="/img/loading.gif" alt="image-20210121132811971"></p><ul><li>很高效</li><li>当数据量特别大时，可能会造成不平等的问题，比如100类，我们做one versus all的时候就会有99类都当作叉叉，那么会导致分类器直接全当做叉叉就好了。</li></ul><h2 id="Multiclass-via-Binary"><a href="#Multiclass-via-Binary" class="headerlink" title="Multiclass via Binary"></a>Multiclass via Binary</h2><p>刚才说到了 one versus all的不平等问题，纳闷我们可以考虑一半一半的分：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134125030.png" srcset="/img/loading.gif" alt="image-20210121134125030"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134257356.png" srcset="/img/loading.gif" alt="image-20210121134257356"></p><p>我们选两种作为圈圈，有上面六种方式。</p><p>我们发现包括方块的有前三个圈圈都包括方块</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134503676.png" srcset="/img/loading.gif" alt="image-20210121134503676"></p><p>这样我们按比例就可以化作方块区域,其他同理即可以做出:</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134540367.png" srcset="/img/loading.gif" alt="image-20210121134540367"></p><p>这个算法称为：</p><p><strong>one-versus-one（OVO） Decomposition：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134642325.png" srcset="/img/loading.gif" alt="image-20210121134642325"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210121134733980.png" srcset="/img/loading.gif" alt="image-20210121134733980"></p><ul><li>好处还是很快</li><li>坏处就是 比起OVA 花的时间更多，需要的空间更多。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH10：Logistic Regression</title>
    <link href="/2021/01/20/CH10%EF%BC%9ALogistic-Regression/"/>
    <url>/2021/01/20/CH10%EF%BC%9ALogistic-Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="CH10：Logistic-Regression"><a href="#CH10：Logistic-Regression" class="headerlink" title="CH10：Logistic Regression"></a>CH10：Logistic Regression</h1><h2 id="Logistic-Regression-Problem-逻辑回归"><a href="#Logistic-Regression-Problem-逻辑回归" class="headerlink" title="Logistic Regression Problem(逻辑回归)"></a>Logistic Regression Problem(逻辑回归)</h2><p>我先我们看两个例子，看一看 他们的不同：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119160823722.png" srcset="/img/loading.gif" alt="image-20210119160823722"></p><p>根据一些指标来预策是否会有心脏病, 很明显是一个分类的问题，我们关心的是错误率为多少。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119160940221.png" srcset="/img/loading.gif" alt="image-20210119160940221"></p><p>再看看看这个问题，求心脏病出现的可能性。</p><p>这不在是一个简单的二元分类问题，而是需要给出概率，我们称之为：</p><p><strong>soft binary classification</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119161131344.png" srcset="/img/loading.gif" alt="image-20210119161131344"></p><hr><p>我们希望得到这种数据：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119161324056.png" srcset="/img/loading.gif" alt="image-20210119161324056"></p><p>告诉我们不同的病例，然后给一个得病的几率，然后我们去做linear regression就好了，可是现实中这个概率是不可能知道的。</p><p><strong>但是现实中我们只有这种普通的病例资料：</strong></p><p>即在知道病人身体状况的情况下，这个病人是否患有心脏病，但是这个患上的概率只有上帝才知道。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119161436903.png" srcset="/img/loading.gif" alt="image-20210119161436903"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119161829435.png" srcset="/img/loading.gif" alt="image-20210119161829435"></p><p>​    我们想到，可以这么来做：首先计算一个 $w$ 权重向量，然后我们用这个权重算一个分数出来（即上图中的$s$）， 我们用这个得分再通过$\theta$ 函数来等价转化为概率。</p><p>即：<strong>logistic hypothesis</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119180058755.png" srcset="/img/loading.gif" alt="image-20210119180058755"></p><p>其中的 $\theta$ 函数我们称之为<strong>Logistic Function:</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119180134195.png" srcset="/img/loading.gif" alt="image-20210119180134195"></p><p><strong>所以logistic regression就是在做下面的事情：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119180434704.png" srcset="/img/loading.gif" alt="image-20210119180434704"></p><h2 id="Logistic-Regression-Error"><a href="#Logistic-Regression-Error" class="headerlink" title="Logistic Regression Error"></a>Logistic Regression Error</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119180718320.png" srcset="/img/loading.gif" alt="image-20210119180718320"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119180804459.png" srcset="/img/loading.gif" alt="image-20210119180804459"></p><p>三个放在一起我们很容易就发现他们的区别是是error measure的不同。</p><p>那么我们如何定义logistic regression的error measure呢？</p><hr><p>首先,target function是长如下样子的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182123293.png" srcset="/img/loading.gif" alt="image-20210119182123293"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182209110.png" srcset="/img/loading.gif" alt="image-20210119182209110"></p><p>考虑换一下后半项为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182252868.png" srcset="/img/loading.gif" alt="image-20210119182252868"></p><p>我们假设h可以产生相同资料：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182331245.png" srcset="/img/loading.gif" alt="image-20210119182331245"></p><p>如果h和f很接近，那么$h$和$f$产生同一批资料的几率很接近。</p><p>所以我们现在想要做到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182623005.png" srcset="/img/loading.gif" alt="image-20210119182623005"></p><p>让$h$最大程度的接近$f$。</p><p>同时我们注意到$h(x)$的一个性质：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182736543.png" srcset="/img/loading.gif" alt="image-20210119182736543"></p><p>定义<strong>likelihood</strong>为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182753653.png" srcset="/img/loading.gif" alt="image-20210119182753653"></p><p>我们可以把$1-h(x)$换掉,即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119182844516.png" srcset="/img/loading.gif" alt="image-20210119182844516"></p><p>所以这个函数正比于h对于每笔资料的连乘：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119190413845.png" srcset="/img/loading.gif" alt="image-20210119190413845"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119190638118.png" srcset="/img/loading.gif" alt="image-20210119190638118"></p><p>所以我们想找一个$h$使得<strong>likelihood</strong>最大。</p><p>还记得：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119194433344.png" srcset="/img/loading.gif" alt="image-20210119194433344"></p><p>我们替代一下，即求w即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119190928734.png" srcset="/img/loading.gif" alt="image-20210119190928734"></p><p>我们想把连乘-&gt; 连加，那么取ln即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119192636703.png" srcset="/img/loading.gif" alt="image-20210119192636703"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119192846298.png" srcset="/img/loading.gif" alt="image-20210119192846298"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119193041637.png" srcset="/img/loading.gif" alt="image-20210119193041637"></p><p>交叉熵(cross-entropy)</p><h2 id="Gradient-of-Logistic-Regression-Error"><a href="#Gradient-of-Logistic-Regression-Error" class="headerlink" title="Gradient of Logistic Regression Error"></a>Gradient of Logistic Regression Error</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119201700239.png" srcset="/img/loading.gif" alt="image-20210119201700239"></p><p>还是要求梯度：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119202635111.png" srcset="/img/loading.gif" alt="image-20210119202635111"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119202911199.png" srcset="/img/loading.gif" alt="image-20210119202911199"></p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119203010797.png" srcset="/img/loading.gif" alt="image-20210119203010797"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119203046100.png" srcset="/img/loading.gif" alt="image-20210119203046100"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119203125096.png" srcset="/img/loading.gif" alt="image-20210119203125096"></p><p>我们想让这个梯度等于0</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119204405585.png" srcset="/img/loading.gif" alt="image-20210119204405585"></p><ul><li>如果所有的$\theta = 0$，说明$y_nw^Tx_n&gt;&gt;0$,  翻看前面PLA的内容，这个说明了全部做都正确答案了，即 数据是线性可分的。</li><li>反之，我们就需要解这个方程了，且说明了不是线性可分的，不巧的是这个方程很难解，我们需要一些别的方法找出解。</li></ul><p>我们回顾一下PLA：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119220610176.png" srcset="/img/loading.gif" alt="image-20210119220610176"></p><p>我们把上面两个可以写成一个式子：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119220641522.png" srcset="/img/loading.gif" alt="image-20210119220641522"></p><p>也许我们可以用PLA类似的方法更新来迭代出梯度=0的点。</p><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>迭代最优化（iterative optimization）</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119221840734.png" srcset="/img/loading.gif" alt="image-20210119221840734"></p><p>这个$v$, 是纠错的向量，这个$η$ 是修改的步伐的大小。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119223931411.png" srcset="/img/loading.gif" alt="image-20210119223931411"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119224027787.png" srcset="/img/loading.gif" alt="image-20210119224027787"></p><p>我们把Ein拆开，可以得到下面近似等式，这其实就是当$η$足够小的时候的一阶泰勒展开。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119225439197.png" srcset="/img/loading.gif" alt="image-20210119225439197"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119230619589.png" srcset="/img/loading.gif" alt="image-20210119230619589"></p><p>我们现在就要规定$v^T$ 的方向，怎么才能让他最快到达底部呢？很容易沿着梯度相反的方向，即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231048105.png" srcset="/img/loading.gif" alt="image-20210119231048105"></p><p>即这样更新：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231120424.png" srcset="/img/loading.gif" alt="image-20210119231120424"></p><hr><p><strong>$η$ 的选择：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231158061.png" srcset="/img/loading.gif" alt="image-20210119231158061"></p><p>坡度大，跨的大一点，坡度小，跨的小一点。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231245867.png" srcset="/img/loading.gif" alt="image-20210119231245867"></p><p>上述说明：<strong>$η$和梯度的大小正相关是比较好的：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231324162.png" srcset="/img/loading.gif" alt="image-20210119231324162"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231520875.png" srcset="/img/loading.gif" alt="image-20210119231520875"></p><p>我们称紫色的η为：<strong>fixed leaning rate</strong></p><p>所以我们现在更新的方式是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210119231554073.png" srcset="/img/loading.gif" alt="image-20210119231554073"></p><p>因此逻辑回归算法就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210120133222344.png" srcset="/img/loading.gif" alt="image-20210120133222344"></p><p>这样不断迭代，就会找到一个$w$ 使得这个 <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210120140606855.png" srcset="/img/loading.gif" alt="image-20210120140606855">等于0。</p><p>还记得我们为什么要求这个w吗？</p><p>h(x)也就是给出一个身体情况，我们就可以求出他的心脏病的概率，这个$h(x)$的公式如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210120140931168.png" srcset="/img/loading.gif" alt="image-20210120140931168"></p><p>这里面的$w^T$是要求出来才能用这个公式, 到此为止 我们的问题就解决了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH9：Linear Regression</title>
    <link href="/2021/01/18/CH9%EF%BC%9ALinear-Regression/"/>
    <url>/2021/01/18/CH9%EF%BC%9ALinear-Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="CH9-Linear-Regression"><a href="#CH9-Linear-Regression" class="headerlink" title="CH9: Linear Regression"></a>CH9: Linear Regression</h1><h2 id="Linear-Regression-Problem-线性回归"><a href="#Linear-Regression-Problem-线性回归" class="headerlink" title="Linear Regression Problem(线性回归)"></a>Linear Regression Problem(线性回归)</h2><p>首先我们要知道线性回归要反映在一个具体的实数上才可以做回归，因此我们要把数据通过某种方式整合成实数。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118130219356.png" srcset="/img/loading.gif" alt="image-20210118130219356"></p><p>加权计算一个分数是一种方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118130350059.png" srcset="/img/loading.gif" alt="image-20210118130350059"></p><p>$W^T$ 是权重 ，$x$是顾客的信息，这样算出来一个加权的分数。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118130607758.png" srcset="/img/loading.gif" alt="image-20210118130607758"></p><p>所以：</p><ul><li><p>我们的hypothesis对于<strong>二维</strong>时，即我们找了一个$f(x)$,作为计算加权分数，然后找一条<strong>线</strong>来合适的分开这些点。</p></li><li><p>我们的hypothesis对于<strong>三维</strong>时，即我们找了一个$f(x_1,x_2)$,作为计算加权分数，然后找一个<strong>面</strong>来合适的分开这些点。</p></li></ul><p>线性回归的问题是希望这些红色线(即余数)越小越好。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118130922969.png" srcset="/img/loading.gif" alt="image-20210118130922969"></p><hr><p><strong>线性回归的错误衡量方式：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131021641.png" srcset="/img/loading.gif" alt="image-20210118131021641"></p><p>有VC Bound的理论做支撑，保证了$E<em>{in}，E</em>{out}$相差不大，那么下面我们的问题就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131146505.png" srcset="/img/loading.gif" alt="image-20210118131146505"></p><h2 id="Linear-Regression-Algorithm"><a href="#Linear-Regression-Algorithm" class="headerlink" title="Linear Regression Algorithm"></a>Linear Regression Algorithm</h2><p>接着上节的这个问题开始：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131146505.png" srcset="/img/loading.gif" alt="image-20210118131146505"></p><p>首先看一下$E_{in}$的公式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131514104.png" srcset="/img/loading.gif" alt="image-20210118131514104"></p><p>我们首先把$w^Tx_n$ 变化下顺序$x_n^Tw$,当然这个变化是很自然的，并不会改变结果。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131703108.png" srcset="/img/loading.gif" alt="image-20210118131703108"></p><p>接下来我们把$\Sigma$去掉：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118131808754.png" srcset="/img/loading.gif" alt="image-20210118131808754"></p><p>easily, 这个矩阵可以拆成下面这个东西：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132009789.png" srcset="/img/loading.gif" alt="image-20210118132009789"></p><p>接下来的任务就是：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132148743.png" srcset="/img/loading.gif" alt="image-20210118132148743"></p><p>这个w和y都是确定的，w是不确定的。</p><p>画出$E_{in}$随变换的曲线：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132244032.png" srcset="/img/loading.gif" alt="image-20210118132244032"></p><ul><li><p>这是一个凸函数</p></li><li><p>我们在最低点取梯度，梯度是0，即</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132431070.png" srcset="/img/loading.gif" alt="image-20210118132431070"></p></li></ul><p>所以任务变成了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132512503.png" srcset="/img/loading.gif" alt="image-20210118132512503"></p><hr><p>我们把平方展开：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132646552.png" srcset="/img/loading.gif" alt="image-20210118132646552"></p><p>我们设一些变量：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132840451.png" srcset="/img/loading.gif" alt="image-20210118132840451"></p><p>其中：</p><ul><li>A是矩阵</li><li>b是向量</li><li>c是阐述</li></ul><p>接下来就是对向量求导：</p><p>首先我们考虑这样一个简单问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118132955381.png" srcset="/img/loading.gif" alt="image-20210118132955381"></p><p>这个求导是非常简单。</p><p>那我们再看我们要求的东西：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118133051630.png" srcset="/img/loading.gif" alt="image-20210118133051630"></p><p>我们发现这两个是很类似的。</p><p>因此我们得出<strong>梯度的表达式：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118133441075.png" srcset="/img/loading.gif" alt="image-20210118133441075"></p><p>因此<strong>如果$X^TX$可逆</strong>，那么很简单：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118133605008.png" srcset="/img/loading.gif" alt="image-20210118133605008"></p><p>这里有个习惯，我们把<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118133731451.png" srcset="/img/loading.gif" alt="image-20210118133731451">这个称之为pseudo-inverse伪逆矩阵。</p><p>当然，大部分情况这个$X^TX$都是可逆的，因为 $X^TX$ 是(d+1)*(d+1)维的</p><p>当没有逆矩阵时：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118150158176.png" srcset="/img/loading.gif" alt="image-20210118150158176"></p><p>因此我们如果编程语言里有 pseudo-inverse伪逆矩阵，直接用就好了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118150239299.png" srcset="/img/loading.gif" alt="image-20210118150239299"></p><hr><p><strong>最后总结一下算法：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118150616350.png" srcset="/img/loading.gif" alt="image-20210118150616350"></p><h2 id="Generalization-Issue"><a href="#Generalization-Issue" class="headerlink" title="Generalization Issue"></a>Generalization Issue</h2><p>$E_{in}$的计算：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118163034160.png" srcset="/img/loading.gif" alt="image-20210118163034160"></p><p>​    我们一般把$XX^十$ 叫做hat matrix，因为它让y带上了hat，即这个东西乘上y，就是预测的y。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118164327466.png" srcset="/img/loading.gif" alt="image-20210118164327466"></p><p>这个Hay Matrix在做什么？</p><ul><li><p>首先我们可以看出$y\  hat$, 就是$X$列向量所张成的空间里的一个向量。</p></li><li><p>我们希望$y - y \ hat$尽可能小，而$y - y \ hat$ 最小肯定是垂直于span，所以这个几何意义是垂直于span的向量。</p></li><li>H使得取到的最小，所以H干了一件怎么样的事情？ 是的，H把向量y投影到span上形成y hat。</li></ul><p>那么如果有噪声的情况呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118165525095.png" srcset="/img/loading.gif" alt="image-20210118165525095"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118170340121.png" srcset="/img/loading.gif" alt="image-20210118170340121"></p><p>我们可以算出这两个表达式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118170437688.png" srcset="/img/loading.gif" alt="image-20210118170437688"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118170611233.png" srcset="/img/loading.gif" alt="image-20210118170611233"></p><h2 id="for-Binary-Classification"><a href="#for-Binary-Classification" class="headerlink" title="for Binary Classification"></a>for Binary Classification</h2><p>线性分类和线性回归的区别：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118170940600.png" srcset="/img/loading.gif" alt="image-20210118170940600"></p><p>可是我们发现${+1,-1}∈R$，那么是不是可以不用PLA做Linear Classification，而用Linear Regression做呢？这样做的话运行就会很快了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118171853903.png" srcset="/img/loading.gif" alt="image-20210118171853903"></p><p>我们先观察一下两种错误衡量方法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118171934930.png" srcset="/img/loading.gif" alt="image-20210118171934930"></p><p>画图后我们不难发现：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118171948534.png" srcset="/img/loading.gif" alt="image-20210118171948534"></p><p>配合VC Bound可以发现</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210118172023067.png" srcset="/img/loading.gif" alt="image-20210118172023067"></p><p>这么一看 classification的Eout会被regression的Ein和根号项所包围住。</p><p>我们把红色的做好，那么蓝色的效果也不错，所以我们就是损失了一些精度来加快了速度。</p><p>因此这种替换方式是可以的。</p><p><strong>其实我们可以组合两者的优势：</strong></p><p>先用regression来找一个向量，作为一开始的PLA的第一个向量，然后再PLA迭代，也可以大大减少迭代。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《线性代数及其应用》CH2：矩阵代数</title>
    <link href="/2021/01/17/CH2%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%BB%A3%E6%95%B0/"/>
    <url>/2021/01/17/CH2%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="第二章-矩阵代数"><a href="#第二章-矩阵代数" class="headerlink" title="第二章  矩阵代数"></a>第二章  矩阵代数</h1><h2 id="2-1-矩阵运算"><a href="#2-1-矩阵运算" class="headerlink" title="2.1 矩阵运算"></a>2.1 矩阵运算</h2><p><strong>对角矩阵，零矩阵定义：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116150748619.png" srcset="/img/loading.gif" alt="image-20210116150748619"></p><p><strong>矩阵与标量的乘法：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116151001880.png" srcset="/img/loading.gif" alt="image-20210116151001880"></p><p><strong>一些矩阵乘法的相关性质：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116153840948.png" srcset="/img/loading.gif" alt="image-20210116153840948"></p><p><strong>矩阵转置：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116154805235.png" srcset="/img/loading.gif" alt="image-20210116154805235"></p><p><strong>转置的相关性质：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116154834116.png" srcset="/img/loading.gif" alt="image-20210116154834116"></p><p>前三个很简单，最后一个证明从定义入手：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116155736051.png" srcset="/img/loading.gif" alt="image-20210116155736051"></p><h2 id="2-2-矩阵的逆"><a href="#2-2-矩阵的逆" class="headerlink" title="2.2 矩阵的逆"></a>2.2 矩阵的逆</h2><p><strong>矩阵可逆：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116160937237.png" srcset="/img/loading.gif" alt="image-20210116160937237"></p><ul><li>不可逆矩阵 = 奇异矩阵</li><li>可逆矩阵 = 废弃及矩阵</li></ul><p><strong>判断矩阵是否可逆：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116161301492.png" srcset="/img/loading.gif" alt="image-20210116161301492"></p><p><strong>方程唯一解 与 矩阵可逆：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116161736676.png" srcset="/img/loading.gif" alt="image-20210116161736676"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116162136500.png" srcset="/img/loading.gif" alt="image-20210116162136500"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116172308887.png" srcset="/img/loading.gif" alt="image-20210116172308887"></p><p>c.证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117135038734.png" srcset="/img/loading.gif" alt="image-20210117135038734"></p><p><strong>初等变换 的等价:</strong></p><p>对于一个单位矩阵$I$, 我们进行初等变换为 $I$’, 然后再和 矩阵$E$ 相乘 等于$I’E$, 这个等价于直接对$E$做同样的初等变换。</p><p>例如：把单位矩阵的第一行的-4倍加到第3行，得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117140601553.png" srcset="/img/loading.gif" alt="image-20210117140601553"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117140729134.png" srcset="/img/loading.gif" alt="image-20210117140729134"></p><p>然后再和矩阵A相乘得：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117140706336.png" srcset="/img/loading.gif" alt="image-20210117140706336"></p><p>我们观察这个矩阵其实和A直接做初等变换是一样的，都是第一行的-4倍加到第3行。</p><p>这个性质可以求逆：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117142106096.png" srcset="/img/loading.gif" alt="image-20210117142106096"></p><p>我们想让$E_1$ 乘一个矩阵边为单位矩阵，那么可以让矩阵为 第一行的+4倍加到第三行就变成了单位矩阵了，这可以利用上面那个性质。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117142240873.png" srcset="/img/loading.gif" alt="image-20210117142240873"></p><p>这个矩阵相当于对单位矩阵做了第一行的+4倍加到第三行的初等变化，那么乘上$E_1$ 就相当于$E_1$做了 初等变化（第一行的+4倍加到第三行的初等变化），从而变成了单位矩阵，那么$E_1$ 的逆就是 <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117142240873.png" srcset="/img/loading.gif" alt="image-20210117142240873"></p><p>这也就对应上了这个定理：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117142523157.png" srcset="/img/loading.gif" alt="image-20210117142523157"></p><p>简单理解就是一个矩阵如果可以经过初等变换变成单位矩阵，那么他就有逆，且他的逆就是 单位矩阵乘上那些初等变化矩阵。</p><p>因此我们此时就可以提出<strong>求矩阵逆的算法</strong>：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117143114850.png" srcset="/img/loading.gif" alt="image-20210117143114850"></p><p>这个很好理解，还是上边的意思，只不过通过矩阵这种形式化的数学语言做了简要概述，对于一个矩阵A，我通过初等变化变为了单位矩阵，说明对单位矩阵做同样的操作，这个就是A的逆矩阵，</p><p>求矩阵逆的算法的例题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117143414963.png" srcset="/img/loading.gif" alt="image-20210117143414963"></p><h2 id="2-3-可逆矩阵的特征"><a href="#2-3-可逆矩阵的特征" class="headerlink" title="2.3 可逆矩阵的特征"></a>2.3 可逆矩阵的特征</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117144434093.png" srcset="/img/loading.gif" alt="image-20210117144434093"></p><p>证明上述定理只需要证明下述的这个环即可：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117144627136.png" srcset="/img/loading.gif" alt="image-20210117144627136"></p><h2 id="2-4-分块矩阵"><a href="#2-4-分块矩阵" class="headerlink" title="2.4 分块矩阵"></a>2.4 分块矩阵</h2><p>首先是一些基本计算和普通矩阵是没有区别的。</p><p><strong>分块矩阵基本运算：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117150748185.png" srcset="/img/loading.gif" alt="image-20210117150748185"></p><p><strong>分块矩阵的逆：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117150928379.png" srcset="/img/loading.gif" alt="image-20210117150928379"></p><p>不妨设：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117151423411.png" srcset="/img/loading.gif" alt="image-20210117151423411"></p><p>列出方程：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117151458449.png" srcset="/img/loading.gif" alt="image-20210117151458449"></p><p>得到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117162850944.png" srcset="/img/loading.gif" alt="image-20210117162850944"></p><p>知道怎么来的即可，分块求逆有很多公式，对应着不同的情况。</p><h2 id="2-5-矩阵因式分解"><a href="#2-5-矩阵因式分解" class="headerlink" title="2.5 矩阵因式分解"></a>2.5 矩阵因式分解</h2><p><strong>LU分解：</strong></p><p>对于这样的一个问题</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117165207504.png" srcset="/img/loading.gif" alt="image-20210117165207504"></p><p>我们可以一个一个的求解。</p><p>当然，如果A可逆，也可以先算$A^{-1}$, 然后直接算$x = A^{-1}b$,即可算出解。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117165532065.png" srcset="/img/loading.gif" alt="image-20210117165532065"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117173317201.png" srcset="/img/loading.gif" alt="image-20210117173317201"></p><p>我们首先可以解$Ly=b$ 这个方程得出$y$,然后算 $Ux=y$ , 解出$x$, 同时我们注意到由于L,U都是三角矩阵，很容易就可以解出来方程。</p><p><strong>LU分解算法：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117173706927.png" srcset="/img/loading.gif" alt="image-20210117173706927"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117174212590.png" srcset="/img/loading.gif" alt="image-20210117174212590"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117175213667.png" srcset="/img/loading.gif" alt="image-20210117175213667"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117174520420.png" srcset="/img/loading.gif" alt="image-20210117174520420"></p><p>L的计算方法很简单，我们在上述将A变成阶梯型矩阵U的过程中，我们就是把每一列</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117175235905.png" srcset="/img/loading.gif" alt="image-20210117175235905"></p><h2 id="2-7-计算机图形学"><a href="#2-7-计算机图形学" class="headerlink" title="2.7 计算机图形学"></a>2.7 计算机图形学</h2><p>这个在博文《AHU计算机图形学》有详细的解释</p><h2 id="2-8-R-n-的子空间"><a href="#2-8-R-n-的子空间" class="headerlink" title="2.8 $R^n$的子空间"></a>2.8 $R^n$的子空间</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117181653194.png" srcset="/img/loading.gif" alt="image-20210117181653194"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117182335539.png" srcset="/img/loading.gif" alt="image-20210117182335539"></p><p><strong>矩阵的列空间：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117182500074.png" srcset="/img/loading.gif" alt="image-20210117182500074"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117182654579.png" srcset="/img/loading.gif" alt="image-20210117182654579"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117184509730.png" srcset="/img/loading.gif" alt="image-20210117184509730"></p><p><strong>矩阵的零空间：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117190707869.png" srcset="/img/loading.gif" alt="image-20210117190707869"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117191117534.png" srcset="/img/loading.gif" alt="image-20210117191117534"></p><p><strong>子空间的基：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117191239270.png" srcset="/img/loading.gif" alt="image-20210117191239270"></p><p>标准基</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117191307369.png" srcset="/img/loading.gif" alt="image-20210117191307369"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117192242118.png" srcset="/img/loading.gif" alt="image-20210117192242118"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117192259496.png" srcset="/img/loading.gif" alt="image-20210117192259496"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117193137910.png" srcset="/img/loading.gif" alt="image-20210117193137910"></p><p>零空间Null A 其实是保证了它一定是矩阵的基。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117193343288.png" srcset="/img/loading.gif" alt="image-20210117193343288"></p><p>我们可以直接找主元列作为列空间的基，即下面这个定理：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117193535647.png" srcset="/img/loading.gif" alt="image-20210117193535647"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117193745935.png" srcset="/img/loading.gif" alt="image-20210117193745935"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117193729487.png" srcset="/img/loading.gif" alt="image-20210117193729487"></p><h2 id="2-9-维数与秩"><a href="#2-9-维数与秩" class="headerlink" title="2.9 维数与秩"></a>2.9 维数与秩</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117194910951.png" srcset="/img/loading.gif" alt="image-20210117194910951"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117195406233.png" srcset="/img/loading.gif" alt="image-20210117195406233"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117195342734.png" srcset="/img/loading.gif" alt="image-20210117195342734"></p><p><strong>矩阵的秩：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117195552448.png" srcset="/img/loading.gif" alt="image-20210117195552448"></p><p>我们一般称子空间的维数为秩：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117195644510.png" srcset="/img/loading.gif" alt="image-20210117195644510"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117200557919.png" srcset="/img/loading.gif" alt="image-20210117200557919"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117201744608.png" srcset="/img/loading.gif" alt="image-20210117201744608"></p><p><strong>秩与可逆矩阵定理 ：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210117201538673.png" srcset="/img/loading.gif" alt="image-20210117201538673"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH8：Noise and Error</title>
    <link href="/2021/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3CH8%EF%BC%9ANoise%20and%20Error/"/>
    <url>/2021/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3CH8%EF%BC%9ANoise%20and%20Error/</url>
    
    <content type="html"><![CDATA[<h1 id="CH8-Noise-and-Error"><a href="#CH8-Noise-and-Error" class="headerlink" title="CH8: Noise and Error"></a>CH8: Noise and Error</h1><p>[toc]</p><h2 id="Noise-and-Probabilistic-Target"><a href="#Noise-and-Probabilistic-Target" class="headerlink" title="Noise and Probabilistic Target"></a>Noise and Probabilistic Target</h2><p>我们之前对于机器学习的流程如下图：</p><p>那么在加上noise后是否会影响机器学习呢？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116011204209.png" srcset="/img/loading.gif" alt="image-20210116011204209"></p><p>原来的瓶子里抽弹珠是确定的，即输入x，出来就是f(x) ：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116104306921.png" srcset="/img/loading.gif" alt="image-20210116104306921"></p><p>现在出来可能有一些不是f(x)了，即出现了噪声：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116104340142.png" srcset="/img/loading.gif" alt="image-20210116104340142"></p><p>但是这并不影响我们估计一个。</p><p>那么：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116104657159.png" srcset="/img/loading.gif" alt="image-20210116104657159"></p><p>VC Bound依然适用。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116105215672.png" srcset="/img/loading.gif" alt="image-20210116105215672"></p><p>我们以前的机器学习都是target，而今天是一个target distribution，即一个目标分布。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116105037073.png" srcset="/img/loading.gif" alt="image-20210116105037073"></p><p>target distribution的看法</p><ul><li>在这里他把distribution看作是 最理想的目标函数和 noise 的组合(0.7 + 0.3)，所以我们把0.7当作target，然后我们会犯30%的错误。</li></ul><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116105740216.png" srcset="/img/loading.gif" alt="image-20210116105740216"></p><p><strong>新的learning flow：</strong></p><p> <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116105854338.png" srcset="/img/loading.gif" alt="image-20210116105854338"></p><h2 id="Error-Measure"><a href="#Error-Measure" class="headerlink" title="Error Measure"></a>Error Measure</h2><p>错误率的计算方式：</p><ul><li><p>pointwise error measure</p><p>这个就是每个都测一遍，然后统计一下错误率，这也是最常用的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116113306198.png" srcset="/img/loading.gif" alt="image-20210116113306198"></p></li></ul><ul><li><p>two important pointwise error measure(分别是0/1 error 和 squared error)</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116130729797.png" srcset="/img/loading.gif" alt="image-20210116130729797"></p></li></ul><p><strong>举一个0/1 error 和 squared error的区别：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116130448953.png" srcset="/img/loading.gif" alt="image-20210116130448953"></p><p>可以看出不同的错误测量的准则会影响我们选取的结果。</p><p>加上error measure 的leaning flow</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116114212238.png" srcset="/img/loading.gif" alt="image-20210116114212238"></p><h2 id="Algorithmic-Error-Measure"><a href="#Algorithmic-Error-Measure" class="headerlink" title="Algorithmic Error Measure"></a>Algorithmic Error Measure</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116114926707.png" srcset="/img/loading.gif" alt="image-20210116114926707"></p><p>不同的错误方式：对于指纹系统其实是无所谓的，因为我们只需要知道可以不可以进去就OK了，而不在该进去的进不去，不该进去的进去了，这都是致命错误。</p><p>​    但是在超市应用时，两种错误会影响未来的生意：比如我该有折扣，但是因为系统错误没给我折扣，这回lose future business。但是我不该有折扣但是给了我折扣，超市在不亏钱的情况下还收获了跟好的口碑。所以这两者的错误权重不能看作相同的。</p><p>不妨设置为某个数倍的错误：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116115203647.png" srcset="/img/loading.gif" alt="image-20210116115203647"></p><p>但这上面这个错误的衡量方法就一定是10吗，为什么不是100，因此我们在做系统时非专业的人很难给出这个倍数的大小。我们后面会更详细的讲下面这个错误度量方法。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116115652631.png" srcset="/img/loading.gif" alt="image-20210116115652631"></p><h2 id="Weighted-Classification"><a href="#Weighted-Classification" class="headerlink" title="Weighted Classification"></a>Weighted Classification</h2><p>现在我们改写了$E_{in}$的衡量方式，那么会影响我们之前所提到的 分类问题 吗？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116120423493.png" srcset="/img/loading.gif" alt="image-20210116120423493"></p><p>首先是PLA：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116120526891.png" srcset="/img/loading.gif" alt="image-20210116120526891"></p><p>PLA是无所谓的，因为他最后一定是没有错的，权重对他来说没什么用。</p><p>那么如果不是线性可分的呢？</p><p>还是可以用pocket算法，从 原来的比错误个数 改为 比错误权重和，这样合理吗？</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116120610805.png" srcset="/img/loading.gif" alt="image-20210116120610805"></p><p>证明：我们可以这么改写错误的点，对于1000权重的错误，我们可以看作  1000个权重1的错误在同一点，因此这太符合pocket算法了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210116120804782.png" srcset="/img/loading.gif" alt="image-20210116120804782"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH7:The VC Dimension</title>
    <link href="/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3CH7%EF%BC%9AThe%20VC%20Dimension/"/>
    <url>/2021/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3CH7%EF%BC%9AThe%20VC%20Dimension/</url>
    
    <content type="html"><![CDATA[<h1 id="CH7-The-VC-Dimension"><a href="#CH7-The-VC-Dimension" class="headerlink" title="CH7: The VC Dimension"></a>CH7: The VC Dimension</h1><h2 id="Definition-of-VC-Dimension"><a href="#Definition-of-VC-Dimension" class="headerlink" title="Definition of VC Dimension"></a>Definition of VC Dimension</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114183828539.png" srcset="/img/loading.gif" alt="image-20210114183828539"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114184048433.png" srcset="/img/loading.gif" alt="image-20210114184048433"></p><p>上述推导就是VC bound带入了$m_H(N)$的范围。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114184654979.png" srcset="/img/loading.gif" alt="image-20210114184654979"></p><p>因此我们需要什么可以使得$E<em>{out}$和$E</em>{in}$近似呢？</p><ul><li>一个好的$H$,也就是growth function要有break point ，即$m_H(N)$在k处break</li><li>一个好的$D$, 也就是说N要足够大</li></ul><p>要想可以机器学习，不仅要$E<em>{in}=E</em>{out}$ 也要$E_{in}$贴近于0</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114185046785.png" srcset="/img/loading.gif" alt=""></p><p>要$E_{in}$贴近于0，也就是说我们要有一个好的演算法。</p><hr><p><strong>VC Dimension定义：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115153614514.png" srcset="/img/loading.gif" alt="image-20210115153614514"></p><p>这个其实就是$break point - 1$.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115155024097.png" srcset="/img/loading.gif" alt="image-20210115155024097"></p><p>所以现在我们原来认为 有breakpoint的是好的hypothesis，那么现在我们换一种说法：</p><p>$d_{VC}$是有限的.</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115155047241.png" srcset="/img/loading.gif" alt="image-20210115155047241"></p><p>$d_{VC}$是有限的保证了以下的事情：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115155256882.png" srcset="/img/loading.gif" alt="image-20210115155256882"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115155552247.png" srcset="/img/loading.gif" alt="image-20210115155552247"></p><p>这道题的答案我们会误以为是3，但其实是4，因为$d_{VC}$ 对任何一笔资料都不能shatter才能说是3，但是题目中只是一种资料。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115155750666.png" srcset="/img/loading.gif" alt="image-20210115155750666"></p><h2 id="VC-Dimension-of-Perceptron"><a href="#VC-Dimension-of-Perceptron" class="headerlink" title="VC Dimension of Perceptron"></a>VC Dimension of Perceptron</h2><p>以二维的PLA算法来看：</p><p><img src="C:\Users\49815\AppData\Roaming\Typora\typora-user-images\image-20210115160134413.png" srcset="/img/loading.gif" alt="image-20210115160134413"></p><p>最后不难想到：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115160200283.png" srcset="/img/loading.gif" alt="image-20210115160200283"></p><p>那么对于多维的PLA算法：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115160326130.png" srcset="/img/loading.gif" alt="image-20210115160326130"></p><p>我们从1-D 2-D就做出这种假设并不是很聪明，这很有可能是巧合：</p><p>因此证明我们分两个部分： </p><ul><li><p>$d_{VC}\ge d+1$</p><p>证明这个只需证明：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115160654389.png" srcset="/img/loading.gif" alt="image-20210115160654389"></p><p>即存在d+1个的inputs 可以shatter，即$d_{VC}$肯定&gt;=d+1,因为如果小于d+1，那么任何数据集都不能出现shatter。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115162158934.png" srcset="/img/loading.gif" alt="image-20210115162158934"></p><p>上面这个怎么理解呢？</p><p>对于任意一种预测结果$y$，我们都是通过这样的方式算出来的$y$,  $sign(Xw) = y$</p><p>y可以搞出来各种排列组合的结果，现在我们只要证明真的存在这样一个$w$使得公式成立即可。而因为X恰好是可逆的：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115162517423.png" srcset="/img/loading.gif" alt="image-20210115162517423"></p><p>因此$w = X^{-1}y$ 公式恒成立，故证明完成。</p></li></ul><ul><li>$d_{VC}\le d+1$</li></ul><p>证明这个只需证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115162632094.png" srcset="/img/loading.gif" alt="image-20210115162632094"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115171204282.png" srcset="/img/loading.gif" alt="image-20210115171204282"></p><h2 id="physical-intuition-of-VC-Dimension-直观的物理意义"><a href="#physical-intuition-of-VC-Dimension-直观的物理意义" class="headerlink" title="physical intuition of VC Dimension(直观的物理意义)"></a>physical intuition of VC Dimension(直观的物理意义)</h2><p>​    根据之前的推导就将VC Dimesion和d+1维的perceptrons联系起来了。上节中公式里的W称为自由度，自由度如同旋钮一样可以进行调节，就可以有无限种hypothesis（每个旋钮都有无限种可能性），VC Dimesion的物理意义就是hypothesis set在二元分类中的有效自由度。</p><p>​    <img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115173400891.png" srcset="/img/loading.gif" alt="image-20210115173400891"></p><p>VC Dimension就是hypothesis的最大分类能力，最多能shatter的输入数量。</p><p>可以使用旋钮的数量来大概估计VC Dimension。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115173512092.png" srcset="/img/loading.gif" alt="image-20210115173512092"></p><p>如上图，只有一个旋钮a ，VC Dimension=1</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115173541959.png" srcset="/img/loading.gif" alt="image-20210115173541959"></p><p>两个旋钮 l 和r ，VC Dimension=2</p><p>因此我们提出：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115173621439.png" srcset="/img/loading.gif" alt="image-20210115173621439"></p><p>看看有几个可调的旋钮，这是一个很好的大概估计方式，但不是一个always 准确的方法。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115173822573.png" srcset="/img/loading.gif" alt="image-20210115173822573"></p><h2 id="interpreting-VC-Dimension-深入理解"><a href="#interpreting-VC-Dimension-深入理解" class="headerlink" title="interpreting VC Dimension(深入理解)"></a>interpreting VC Dimension(深入理解)</h2><p>首先回顾一下VC Bound的公式</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115174356892.png" srcset="/img/loading.gif" alt="image-20210115174356892"></p><p>我们不妨设$\delta$ = 右边一串式子。</p><p>VC bound的意义我们可以取他的相反面，本来描述的是坏事情发生的最大概率，我们现在反过来求好事情发生的最小概率，即：$E<em>{in}$和$E</em>{out}$ 差距不大（GOOD）时，概率是大于$1- \delta$的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115174855044.png" srcset="/img/loading.gif" alt="image-20210115174855044"></p><p>最后我们首先推出来 $\epsilon$的表达式，那么现在：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115175017049.png" srcset="/img/loading.gif" alt="image-20210115175017049"></p><p>可以改写为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115175027528.png" srcset="/img/loading.gif" alt="image-20210115175027528"></p><p>即代表：我们举一反三(模型泛化 或者说是 in和out有多接近)做的有多好</p><p>我们把不等式绝对值去掉：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115175211529.png" srcset="/img/loading.gif" alt="image-20210115175211529"></p><p>这个公式说明了 ：根号下的这个东西 是和hypothesis或者说是提出的model有关的，这个可能非常强，模型很复杂可以处理高维plane，但是我们在generalization的时候要付出代价(即E的in和out差距比较大)</p><p>所以VC Bound在告诉我们以下的事情：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115175724587.png" srcset="/img/loading.gif" alt="image-20210115175724587"></p><p>我们画一个图来看这个问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115175944612.png" srcset="/img/loading.gif" alt="image-20210115175944612"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115180239416.png" srcset="/img/loading.gif" alt="image-20210115180239416"></p><p>VC Dimension较小，此时$E<em>{in}$ （即你所说的 根据已有数据计算出的风险）会变大的，这是因为shatter的点会变少，点的排列组合会变少找到一个比较好的hypothesis的概率也会比较小，那么$E</em>{in}$就会变大。 所以我们真正要找的是一个合适的VC Dimension，来使得$ E_{out}$ 变小。</p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115180641374.png" srcset="/img/loading.gif" alt="image-20210115180641374"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115180728366.png" srcset="/img/loading.gif" alt="image-20210115180728366"></p><p>一般资料数是10倍的VC Dimension即可就可以获得一个不错的表现。</p><p>那么我们就会奇怪了，理论算出来是10000倍，为什么实际上怎么就需要十倍左右呢?</p><p>这是因为VC Bound 得Looseness. 他的宽松(Looseness)是因为下面四个原因。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210115191052834.png" srcset="/img/loading.gif" alt="image-20210115191052834"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH6:Theory of Generalization</title>
    <link href="/2021/01/14/CH6%20%EF%BC%9ATheory%20of%20Generalization/"/>
    <url>/2021/01/14/CH6%20%EF%BC%9ATheory%20of%20Generalization/</url>
    
    <content type="html"><![CDATA[<h1 id="CH6-Theory-of-Generalization"><a href="#CH6-Theory-of-Generalization" class="headerlink" title="CH6: Theory of Generalization"></a>CH6: Theory of Generalization</h1><h2 id="Restriction-of-break-point"><a href="#Restriction-of-break-point" class="headerlink" title="Restriction of break point"></a>Restriction of break point</h2><p>还是回到上节，我们做出了以下的猜想：</p><p><img src="https://i.loli.net/2021/01/12/3TBh9clC4XJHvUt.png" srcset="/img/loading.gif" alt="image-20210112002301731"></p><p>我们做出了以下的猜想：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113164632541.png" srcset="/img/loading.gif" alt="image-20210113164632541"></p><hr><p>我们思考,当$break \ point = 2$的时候：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113165702360.png" srcset="/img/loading.gif" alt="image-20210113165702360"></p><p>那么 N=1的时候小于break point，所以还是符合$2^N$的规律。</p><p>N=2 ,也就是break point，此时 $m_H(N)&lt;2^N$,也就是说$m_H(N)$最大也就是3.</p><p>接下来考虑，N=3：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113165958230.png" srcset="/img/loading.gif" alt="image-20210113165958230"></p><p>上图这样的情况可以吗？</p><p>当然不可以，因为如果此时我们不要$x_1$这个点了，也就说退化到N=2的时候，$x_2,x_3$此时为4种，也就是$2^N$,但是前面说到了，N=2是breakpoint，最多三种。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113170251771.png" srcset="/img/loading.gif" alt="image-20210113170251771"></p><p>因此上图这种是不可能的，N=3时，dichotomies变成成上图这样是错误的。</p><p>那么我们不难发现，如果要N=3找dichotomies时，要符合N=2的规矩，也就任意两个点不能shatter</p><p>(这里的shatter指，情况等于$2^N$，也就是所有情况都存在，而这对于break point是错误的)。</p><p>那么我们再接着试一试</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113170629990.png" srcset="/img/loading.gif" alt="image-20210113170629990"></p><p>上图这种dichotomies是正确的。</p><p>如果接着加就会发现，无论怎么添加也会产生两个点的shatter，所以最大dichotomies也就是4种了。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113170818798.png" srcset="/img/loading.gif" alt="image-20210113170818798"></p><p>这么一看，break point严重抑制了$m_H$的增长。</p><p>因此接下来我们的证明思路如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113170927679.png" srcset="/img/loading.gif" alt="image-20210113170927679"></p><p>如果证明了是多项式大小的，那么问题就可以解决了。</p><hr><p>最后的课堂问题：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113171037210.png" srcset="/img/loading.gif" alt="image-20210113171037210"></p><p>不难想到是1种，因为<strong>不能出现某一列有两个不同的</strong>，也就是说他们每行都长得一样，即只有一种。</p><h2 id="Bounding-Function"><a href="#Bounding-Function" class="headerlink" title="Bounding Function"></a>Bounding Function</h2><p><strong>Bounding Function的定义如下：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113171503127.png" srcset="/img/loading.gif" alt="image-20210113171503127"></p><p>N个点，breakpoint为k时，$m_H(N)$可能的最大值</p><p>那么下面问题转化为了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113171623047.png" srcset="/img/loading.gif" alt="image-20210113171623047"></p><hr><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113184205356.png" srcset="/img/loading.gif" alt="image-20210113184205356"></p><p><strong>N&lt;k</strong>  不难理解，还没到break point还符合$2^N$规律</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113184345391.png" srcset="/img/loading.gif" alt="image-20210113184345391"></p><p><strong>N=k</strong>，也不难理解</p><p>因为此时：$m_H(N)&lt;2^N$,也就是说$m_H(N)$最大也就是$2^N-1$.</p><p><strong>N&gt;k时：</strong></p><p>我们就要慢慢分析以下这个问题了：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113191405755.png" srcset="/img/loading.gif" alt="image-20210113191405755"></p><p>我们枚举以下发现B(4,3)=9 。然后发现 是B(3,2)和B(3,3)的和。</p><p>我们把这是11个分类一下：如下图</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113191459649.png" srcset="/img/loading.gif" alt="image-20210113191459649"></p><p>其中B(4,3)的组成成分如下：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113192112584.png" srcset="/img/loading.gif" alt="image-20210113192112584"></p><p>我们可以看出橘色的$x_1,x_2,x_3$ 没两个都是相同的(深橘色/浅橘色)，只有$x_4$不同。</p><p>我们仅看前三个$x_1,x_2,x_3 $ ,不难得出：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113192331348.png" srcset="/img/loading.gif" alt="image-20210113192331348"></p><p>也就是说：4个点则不能出现3个点的shatter。</p><p>但是还记得shatter的定义吗，可不是存在，而是任意三个，那玩意三个中包含$x_4$呢？</p><p>对于这个问题我们先考虑，去重后的并不包含$x_4$，如下图</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193409035.png" srcset="/img/loading.gif" alt="image-20210113193409035"></p><p>此时如果存在两个x有shatter  加上x_4会对这一列出现 圈圈/叉叉 ，那不就是三个x的shatter 了吗，那就又不符合定义了。因此我们要阻止2个点在橙色区域shatter的出现。</p><p>即：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193705109.png" srcset="/img/loading.gif" alt="image-20210113193705109"></p><p>那么我们就可以推出：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193721790.png" srcset="/img/loading.gif" alt="image-20210113193721790"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193739859.png" srcset="/img/loading.gif" alt="image-20210113193739859"></p><p>那么对于B(N,k),我们不难推出递推公式：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193818613.png" srcset="/img/loading.gif" alt="image-20210113193818613"></p><p>上式其实是一个多项式的，幂次最大的一项是$N^{k-1}$</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113193934678.png" srcset="/img/loading.gif" alt="image-20210113193934678"></p><p>那么问题到此就解决了。</p><h2 id="A-pictorial-proof-一个形象的证明"><a href="#A-pictorial-proof-一个形象的证明" class="headerlink" title="A pictorial proof(一个形象的证明)"></a>A pictorial proof(一个形象的证明)</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113194852086.png" srcset="/img/loading.gif" alt="image-20210113194852086"></p><p>实际上，我们最后得到其实是 浅绿色框中的公式，怎么来的呢？ 接下来证明：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114001417465.png" srcset="/img/loading.gif" alt="image-20210114001417465"></p><p>$E<em>{in}$的个数不是无穷多个，一共就是$m_H(N)$ 这么多个。而$E</em>{out}$ 是有无穷的多个的。</p><p>所以第一步我们想把$E_{out}$替换掉：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114002307272.png" srcset="/img/loading.gif" alt="image-20210114002307272"></p><p>由于这个E的可能性分布几乎是关于Eout对称的，不妨改写为：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114002445075.png" srcset="/img/loading.gif" alt="image-20210114002445075"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114003129258.png" srcset="/img/loading.gif" alt="image-20210114003129258"></p><p>$E<em>{in}$的$D$ 有N个点 ，$E</em>{out}$的$D’$也有N个点，那么最多也就是$m_H(2N)$种hypothesis</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114003604842.png" srcset="/img/loading.gif" alt="image-20210114003604842"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210114004126453.png" srcset="/img/loading.gif" alt="image-20210114004126453"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《线性代数及其应用》CH1：线性代数中的线性方程组</title>
    <link href="/2021/01/13/CH1%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <url>/2021/01/13/CH1%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第1章-线性代数中的线性方程组"><a href="#第1章-线性代数中的线性方程组" class="headerlink" title="第1章 线性代数中的线性方程组"></a>第1章 线性代数中的线性方程组</h1><h2 id="1-1-线性方程组"><a href="#1-1-线性方程组" class="headerlink" title="1.1 线性方程组"></a>1.1 线性方程组</h2><p><img src="https://i.loli.net/2021/01/12/zxe5JKMqT8yC6Eu.png" srcset="/img/loading.gif" alt="image-20210112120520806"></p><p>线性方程的解有三种情况</p><ul><li>无解</li><li>唯一解</li><li>无穷多解</li></ul><p>当方程组有解，我们称线性方程组是<strong>相容的</strong>。反之无解称之为<strong>不相容的</strong>。</p><p><img src="https://i.loli.net/2021/01/12/TYgD2c7usqd43Z9.png" srcset="/img/loading.gif" alt="image-20210112121306672"></p><p>我们称 <img src="https://i.loli.net/2021/01/12/uIA3WsgNU9PTDnS.png" srcset="/img/loading.gif" alt="image-20210112121548970">为<strong>系数矩阵</strong>，称<img src="https://i.loli.net/2021/01/12/5pzNnmxLWdElbQo.png" srcset="/img/loading.gif" alt="image-20210112121629863">为<strong>增广矩阵</strong>。</p><p>解方程的方法：我们可以通过变换先变成<img src="https://i.loli.net/2021/01/12/XCAOVI1L6U3onRD.png" srcset="/img/loading.gif" alt="image-20210112122354570"></p><p>然后通过第三行消去第二行的$x_3$，然后用只包含$x_2$的第二行和只包含$x_3$的第三行消去第一行的$x_2$和$x_3$</p><p>最后得到：</p><p><img src="https://i.loli.net/2021/01/12/4xaVRu8EX6ArefS.png" srcset="/img/loading.gif" alt="image-20210112122535424"></p><p><img src="https://i.loli.net/2021/01/12/6G87WdMkcZOlxfi.png" srcset="/img/loading.gif" alt="image-20210112122612697"></p><p>直观理解就是三个平面交于一点，这也是线性方程组的几何意义。</p><p><strong>初等变换</strong>主要有三种：</p><ul><li>倍加：把某一行可以以某个倍数加到另一行上</li><li>对换：把两行对换</li><li>倍乘：把某一行的所有元素乘以同一个非零数</li></ul><p><img src="https://i.loli.net/2021/01/12/hn6tZGolMkN1cYP.png" srcset="/img/loading.gif" alt="image-20210112123403474"></p><p>我们通过进行如上提到的变换可以得到：</p><p><img src="https://i.loli.net/2021/01/12/lbH9mwknKsY87TL.png" srcset="/img/loading.gif" alt="image-20210112123421283"></p><h2 id="1-2-行化简与阶梯形矩阵"><a href="#1-2-行化简与阶梯形矩阵" class="headerlink" title="1.2 行化简与阶梯形矩阵"></a>1.2 行化简与阶梯形矩阵</h2><p><strong>阶梯型矩阵：</strong></p><p><img src="https://i.loli.net/2021/01/12/gilsFd2cUBQItGb.png" srcset="/img/loading.gif" alt="image-20210112143300127"></p><p>其实就是下面这样的矩阵：</p><p><img src="https://i.loli.net/2021/01/12/zFL69amXbTCJlMs.png" srcset="/img/loading.gif" alt="image-20210112143334007"></p><p><strong>化简阶梯矩阵：</strong></p><p><img src="https://i.loli.net/2021/01/12/AhGbgX6dItFfQOD.png" srcset="/img/loading.gif" alt="image-20210112145222102"></p><p><strong>定理1： 每个矩阵等价于唯一的化简阶梯形矩阵</strong></p><p><img src="https://i.loli.net/2021/01/12/DqHjUc7m6yzMp5R.png" srcset="/img/loading.gif" alt="image-20210112144420086"></p><p>举个例子来说明一下主元位置和主元列的具体意义：</p><p><img src="https://i.loli.net/2021/01/12/nmQwGoTtJi6yX9z.png" srcset="/img/loading.gif" alt="image-20210112144521767"></p><p>例如上图，我们首先化简为阶梯型</p><p><img src="https://i.loli.net/2021/01/12/AJ9K8FcdvhIRQxS.png" srcset="/img/loading.gif" alt="image-20210112144641912"></p><p>观察上图不难理解主元列就是主元位置所在的列，主元位置就是每行第一个非0的元素所在的位置。</p><p><img src="https://i.loli.net/2021/01/12/TejwAz1uYpf6MOB.png" srcset="/img/loading.gif" alt="image-20210112151652307"></p><p><img src="https://i.loli.net/2021/01/12/lTedBGrxhoD5smZ.png" srcset="/img/loading.gif" alt="image-20210112153514849"></p><p>同理：</p><p><img src="https://i.loli.net/2021/01/12/CxntVEDZK7maR8I.png" srcset="/img/loading.gif" alt="image-20210112153942409"></p><p><strong>存在与唯一性定理：</strong></p><p><img src="https://i.loli.net/2021/01/12/zTQOvP7SaAHkmcx.png" srcset="/img/loading.gif" alt="image-20210112154346769"></p><p><img src="https://i.loli.net/2021/01/12/w9zqsfhRt5MkWTB.png" srcset="/img/loading.gif" alt="image-20210112154655355"></p><h2 id="1-3-向量方程"><a href="#1-3-向量方程" class="headerlink" title="1.3 向量方程"></a>1.3 向量方程</h2><p><strong>定义：</strong></p><p><img src="https://i.loli.net/2021/01/12/eh4HRLs1IpMSvnZ.png" srcset="/img/loading.gif" alt="image-20210112155216842"></p><p><img src="https://i.loli.net/2021/01/12/HeuVmELOzjysNa8.png" srcset="/img/loading.gif" alt="image-20210112155256513"></p><p><strong>几何表示：</strong></p><p><img src="https://i.loli.net/2021/01/12/UQ1IpXdBRyNMKxL.png" srcset="/img/loading.gif" alt="image-20210112155428557"></p><p>同理$R^3$中的3<em>1的矩阵可以看作<em>*立体空间中的向量</em></em>。</p><p>不难发现可以推广到$R^3$</p><p><img src="https://i.loli.net/2021/01/12/JgRlLVK5QyoBS9b.png" srcset="/img/loading.gif" alt="image-20210112160252410"></p><p>线性组合其实本质也是解方程组问题，如下：</p><p><img src="https://i.loli.net/2021/01/12/7Gx6hYFac8I39Vb.png" srcset="/img/loading.gif" alt="image-20210112160640059"></p><p><img src="https://i.loli.net/2021/01/12/vzTymN6co5deODp.png" srcset="/img/loading.gif" alt="image-20210112160713322"></p><p>定义：向量组张成的空间中的子集</p><p><img src="https://i.loli.net/2021/01/12/wKdtGaxh4yzrpbE.png" srcset="/img/loading.gif" alt="image-20210112161041658"></p><p>因此我们判断一个向量是否属于$Span{v_1,v_2,v_3…,v_p}$,我们只需要判断</p><p>​    $x_1v_1+x_2v_2+x_3v_3…x_pv_p=b$  是否有解即可。</p><p>不难理解$Span{v_1}$就是一条线 ，$Span{v_1，v_2}$就成为了一个二维平面（当然前提$v_1,v_2$方向即不是相同同，也不是相反，因为符合该条件的两个向量本质是一个方向的东西，并不能张成一个二维平面）</p><h2 id="1-4-矩阵方程-Ax-b"><a href="#1-4-矩阵方程-Ax-b" class="headerlink" title="1.4 矩阵方程$Ax = b$"></a>1.4 矩阵方程$Ax = b$</h2><p><img src="https://i.loli.net/2021/01/12/SC8DX6JPcrR4Et2.png" srcset="/img/loading.gif" alt="image-20210112162048243"></p><p>以下四个定义不难理解是等价的：</p><p><img src="https://i.loli.net/2021/01/12/czRWEpLxlNM5PwT.png" srcset="/img/loading.gif" alt="image-20210112180444746"></p><p>注意：定理四所提到的等价是<strong>A为系数矩阵</strong>的情况下，若为增广矩阵$[A\  b]$,则不一定适合，比如若增广矩阵最后一行为  [0 0 0 … 0 4] 那么显然最后一行是有主元的，但是这个方程肯定是无解的，因为 0*x不可能等于4。</p><p><strong>Ax的计算方法：</strong>  本质就是矩阵乘法的一种特殊情况</p><p><img src="https://i.loli.net/2021/01/12/H58VgxDn42ePmGF.png" srcset="/img/loading.gif" alt="image-20210112181316398"></p><p><strong>一些显而易见的结论：</strong></p><p><img src="https://i.loli.net/2021/01/12/9fnXwUcNgbGKLoJ.png" srcset="/img/loading.gif" alt="image-20210112181516999"></p><h2 id="1-5-线性方程组的解集"><a href="#1-5-线性方程组的解集" class="headerlink" title="1.5 线性方程组的解集"></a>1.5 线性方程组的解集</h2><p><strong>齐次线性方程组：</strong></p><p><a href="https://imgchr.com/i/sYev59" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/12/sYev59.png" srcset="/img/loading.gif" alt="sYev59.png"></a></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210112183931424.png" srcset="/img/loading.gif" alt="image-20210112183931424"></p><p>上面这句话很好理解，如果没有自由变量就说明解就只有一个，也就是说这一个解肯定是那个全为0的平凡解。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210112184834628.png" srcset="/img/loading.gif" alt="image-20210112184834628"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210112184906243.png" srcset="/img/loading.gif" alt="image-20210112184906243"></p><p>因此$Ax=0$的每一个解都是$v$的倍数。</p><p>同理：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210112185053698.png" srcset="/img/loading.gif" alt="image-20210112185053698"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113000915728.png" srcset="/img/loading.gif" alt="image-20210113000915728"></p><p>对于这样一个解空间： </p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113001547590.png" srcset="/img/loading.gif" alt="image-20210113001547590"></p><p>我们不难发现这个$x$可以看作 $p$ 的位移，如下图：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113001646589.png" srcset="/img/loading.gif" alt="image-20210113001646589"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113001823484.png" srcset="/img/loading.gif" alt="image-20210113001823484"></p><p>我们不难发现，如果是$Ax=0$, 那么 p这一项消失了就会，但是由于$tv$并不会改变，所以平面方向是不会变的，两个解平面应该是平行的。</p><p>注意 : 当然我们上面所讨论的一切建立于方程$Ax=0$至少有一个非零解，我们拆成两部分来看这个非零解：</p><ul><li>首先肯定是不能无解的，如果是无解就没有解平面了。</li><li>再看非零这个约束，非零是防止$Ax=0$中出现了平凡解，平凡解没有什么意义，因为$Ax=0$所构造的超平面一定是过原点的。</li></ul><h2 id="1-6-线性方程组的应用"><a href="#1-6-线性方程组的应用" class="headerlink" title="1.6 线性方程组的应用"></a>1.6 线性方程组的应用</h2><p>这也是体现了本书的特点Application的一章。</p><p>以化学方程式配平为例：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113002811439.png" srcset="/img/loading.gif" alt="image-20210113002811439"></p><p>这里就不写太多了，都是一些线性代数中线性方程组的application</p><h2 id="1-7-线性无关"><a href="#1-7-线性无关" class="headerlink" title="1.7 线性无关"></a>1.7 线性无关</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113003038478.png" srcset="/img/loading.gif" alt="image-20210113003038478"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113004043615.png" srcset="/img/loading.gif" alt="image-20210113004043615"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113004051471.png" srcset="/img/loading.gif" alt="image-20210113004051471"></p><p>第一问很简单，我们扔进$Ax=0$看看有没有解即可，即增广矩阵变换一下算出解即可。</p><p>b.  因为$x_3$为自由变量，直接随便带入一个即可。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113012248277.png" srcset="/img/loading.gif" alt="image-20210113012248277"></p><p>两个2维向量a,b构成的向量组线性相关的几何意义是: a,b共线<br>三个3维向量a,b,c构成的向量组线性相关的几何意义是: a,b,c共面/a,b,c共线</p><p>不难发现：  <strong>n个向量所张成的空间维度小于n，那么这n个向量就是线性相关的。</strong></p><p>也就是说：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113012923541.png" srcset="/img/loading.gif" alt="image-20210113012923541"></p><p>​    其实不难理解，为什么n个向量所张成的空间维度小于n呢？因为有些向量是“假的”，它可以通过其它来的向量来表示，也就是说这个向量可有可无，这样n个向量就会变成n-1，张成空间的维度显然会下降。</p><p><strong>一个显而易见的定理：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113013506696.png" srcset="/img/loading.gif" alt="image-20210113013506696"></p><p>直观理解就是一个零向量其实是可有可无的，因此维度自然会下降，因此n个向量所张成的空间维度小于n，那么这n个向量就是线性相关的。</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113015916689.png" srcset="/img/loading.gif" alt="image-20210113015916689"></p><p>这个定理通过构造达到了线性相关的定义，本质还是如下定理：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113012923541.png" srcset="/img/loading.gif" alt="image-20210113012923541"></p><h2 id="1-8-线性变换介绍"><a href="#1-8-线性变换介绍" class="headerlink" title="1.8 线性变换介绍"></a>1.8 线性变换介绍</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113020518364.png" srcset="/img/loading.gif" alt="image-20210113020518364"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113020532379.png" srcset="/img/loading.gif" alt="image-20210113020532379"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113020713436.png" srcset="/img/loading.gif" alt="image-20210113020713436"></p><p>我们看一个几何意义：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113021209341.png" srcset="/img/loading.gif" alt="image-20210113021209341"></p><p>这个也属于计算机图形学的矩阵变换的内容。</p><p><strong>线性变换：</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113021406867.png" srcset="/img/loading.gif" alt="image-20210113021406867"></p><p>推论：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113021447482.png" srcset="/img/loading.gif" alt="image-20210113021447482"></p><p>图像旋转（同样属于计算机图形学的内容）：</p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113021551909.png" srcset="/img/loading.gif" alt="image-20210113021551909"></p><h2 id="1-9-线性变换的矩阵"><a href="#1-9-线性变换的矩阵" class="headerlink" title="1.9 线性变换的矩阵"></a>1.9 线性变换的矩阵</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123134529.png" srcset="/img/loading.gif" alt="image-20210113123134529"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123439184.png" srcset="/img/loading.gif" alt="image-20210113123439184"></p><p><strong>$R^2$中的几何线性变换</strong></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123607215.png" srcset="/img/loading.gif" alt="image-20210113123607215"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123649037.png" srcset="/img/loading.gif" alt="image-20210113123649037"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123709236.png" srcset="/img/loading.gif" alt="image-20210113123709236"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123717581.png" srcset="/img/loading.gif" alt="image-20210113123717581"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113123725208.png" srcset="/img/loading.gif" alt="image-20210113123725208"></p><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113130357545.png" srcset="/img/loading.gif" alt="image-20210113130357545"></p><p><strong>总结一下：</strong></p><p>这一小节一直在讲映射的问题，其实也是一个降维的问题，比如A 是一个3*4的矩阵，x是一个4*1的矩阵，Ax变换后成为了3*1的向量，这是一个降维的过程。但是者可以称之为一个很好的降维方法吗？如果多个4维向量都映射到了同一个三维向量，那么这种不是一对一的映射（单射）是不够优秀的，因此比如：<img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20210113131535375.png" srcset="/img/loading.gif" alt="image-20210113131535375"></p><p>这个矩阵是有自由变元的，也就是说$Ax=b$ 时，一个b会因为自由变元使得多个x都映射在b上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石Ch5：Training VS Testing</title>
    <link href="/2021/01/12/CH5%EF%BC%9ATraining%20VS%20Testing/"/>
    <url>/2021/01/12/CH5%EF%BC%9ATraining%20VS%20Testing/</url>
    
    <content type="html"><![CDATA[<h1 id="Ch5：Training-VS-Testing"><a href="#Ch5：Training-VS-Testing" class="headerlink" title="Ch5：Training VS Testing"></a>Ch5：Training VS Testing</h1><h2 id="Recap-and-preview-回顾"><a href="#Recap-and-preview-回顾" class="headerlink" title="Recap and preview 回顾"></a>Recap and preview 回顾</h2><p><img src="https://i.loli.net/2021/01/11/TRGceul2MPAOfa8.png" srcset="/img/loading.gif" alt="image-20210111230212927"></p><p>上图是我们所希望做到的。</p><p><img src="https://i.loli.net/2021/01/11/824psLJKdMtUC1R.png" srcset="/img/loading.gif" alt="image-20210111230757095"></p><p>回到第四章问题：如果$M$变为无限大，怎么办呢？</p><p>我们所想做到的：</p><p><img src="https://i.loli.net/2021/01/11/JvQOEP9WMVFmac5.png" srcset="/img/loading.gif" alt="image-20210111231128141"></p><ul><li>建立一种有限的量替代M</li><li>证明M为无限时学习的可行性</li><li>这个$m_H$的选择会帮助我们更好的学习hypothesis的选择</li></ul><h2 id="Effective-Number-Of-Lines"><a href="#Effective-Number-Of-Lines" class="headerlink" title="Effective Number Of Lines"></a>Effective Number Of Lines</h2><p><img src="https://i.loli.net/2021/01/11/t8ViHIj42wYGxWs.png" srcset="/img/loading.gif" alt="image-20210111232329199"></p><p>我们在以上不等式 用了union bound，但是M无穷大时出了问题。</p><hr><p><img src="https://i.loli.net/2021/01/11/Tx3bD7jgk8hlLzV.png" srcset="/img/loading.gif" alt="image-20210111232659335"></p><p>我们看上图可知，一般相近的两个hypothesis的结果是没有什么太大区别的，因此多个h之间很大一部分都是重叠的（如上图：三个圆圈有重叠），而我们的union bound是把他们直接相加的，造成了over-estimating（过度估计）。</p><hr><p><img src="https://i.loli.net/2021/01/11/zqcioRpItn8mHuM.png" srcset="/img/loading.gif" alt="image-20210111233228291"></p><p>我们来考虑一下上图有几个h，即有几种线可以划分出不同的结果。</p><p>不难看出是四种分类结果。</p><p><img src="https://i.loli.net/2021/01/11/7WiUI2ey6bLAYEH.png" srcset="/img/loading.gif" alt="image-20210111233324728"></p><p>同理，若有三个点，则有8种。那么规律是$2^n$吗？</p><p>我们观察下图:</p><p><img src="https://i.loli.net/2021/01/12/WkPceVDdanXIgjO.png" srcset="/img/loading.gif" alt="image-20210111233427807"></p><p>上图我们可以发现，粉色花圈的两个不可能用一条线做到，因此只有6种.</p><hr><p><img src="https://i.loli.net/2021/01/11/suFIYN6xyldzO4Z.png" srcset="/img/loading.gif" alt="image-20210111233811256"></p><p>对于四个点，其实最多只有14种方式。</p><p><img src="https://i.loli.net/2021/01/11/UgYGB3VDnef7tjp.png" srcset="/img/loading.gif" alt="image-20210111233858816"></p><p>我们猜测：无限多的线可以划分为有限的种类。同种类的线就不需要union bound加在一起了。</p><p>希望做到上图所提到的公式，找到一个$effective(N)$</p><p>如果$effective(N)$可以做到下的两点，那么我们说学习是可能的。</p><p><img src="https://i.loli.net/2021/01/11/baHm1zYTfX9tLKg.png" srcset="/img/loading.gif" alt="image-20210111234037199"></p><hr><h2 id="Effective-Number-of-Hypothesis"><a href="#Effective-Number-of-Hypothesis" class="headerlink" title="Effective Number of Hypothesis"></a>Effective Number of Hypothesis</h2><p><img src="https://i.loli.net/2021/01/11/7x1paYGMiwzPejB.png" srcset="/img/loading.gif" alt="image-20210111234559377"></p><p>这里我们引入了新的Dichotomies，他和hypothesis的区别是dichotomies代表种类的多少，是有限的。</p><hr><p><img src="https://i.loli.net/2021/01/11/EajtHQ2fYG9uZpT.png" srcset="/img/loading.gif" alt="image-20210111234919017"></p><p>这里对于不同的样本，线的种类数量可能不是确定的，如三个点，可能是6，也可能是8种。</p><p>那么不妨考虑最坏情况，我们取这些不同种类种最大的一个：</p><p>即<img src="https://i.loli.net/2021/01/11/HNzqWvw9TsKcBX7.png" srcset="/img/loading.gif" alt="image-20210111235110535">。</p><p>我们称之为$growth \ function$成长函数。</p><hr><p><img src="https://i.loli.net/2021/01/11/4Ai6gvVWrCQ8tDP.png" srcset="/img/loading.gif" alt="image-20210111235746549"></p><p>对于这种模型，我们有几种切法呢？</p><p>不难发现左边0个，右边N个，左边1个，右边N-1个….. 这样递推，因此：</p><p><img src="https://i.loli.net/2021/01/11/ivYzqwDEJp3TR42.png" srcset="/img/loading.gif" alt="image-20210111235810729"></p><p>$m_H=N+1$</p><p>如果对下图这种h来说：</p><p><img src="https://i.loli.net/2021/01/12/v9TFQ6PC4OsdIBb.png" srcset="/img/loading.gif" alt="image-20210112000215920"></p><p>就有：</p><p><img src="https://i.loli.net/2021/01/12/DTiIJkg5wmXRpPh.png" srcset="/img/loading.gif" alt="image-20210112000112025"></p><p>这么多种。</p><p><img src="https://i.loli.net/2021/01/12/AoC9EraYu2Pn3ws.png" srcset="/img/loading.gif" alt="image-20210112000450979"></p><p>那么如果对于一个 二维的分类，并别h也是区域覆盖，那么$m_H=2^N$,即成长函数growth function为$2^N$。</p><h2 id="Break-point"><a href="#Break-point" class="headerlink" title="Break point"></a>Break point</h2><p><img src="https://i.loli.net/2021/01/12/49lDr1GYjcENxSA.png" srcset="/img/loading.gif" alt="image-20210112001312073"></p><p>我们回顾一下不同模型的growth function的不同。</p><p><img src="https://i.loli.net/2021/01/12/x6UDzIgYvyBEKdk.png" srcset="/img/loading.gif" alt="image-20210112001459983"></p><p>​    因此如果M的替代量是一个多项式(polynomial)，那么这是一个很好的替代，它的变化远不及后面e的指数的变化，因此这是可以学习的。但是也有可能是指数型(exponential)的，这就不一定会是可以学习了，因为后面的也是e的指数，在一起可能是不收敛的。</p><p>​    那么对于一个2维感知机问题，增长函数是多项式形式的吗？</p><hr><p><img src="https://i.loli.net/2021/01/12/eROUz6SGPDmXCsL.png" srcset="/img/loading.gif" alt="image-20210112001952796"></p><p>这里我们引入$break\  point$，在二维感知机分类中，从4个点开始我们发现无法做到$2^N$种情况，即16种，最多只能找到14种，无论这四个点怎么排列。我们称4为break point。</p><p><img src="https://i.loli.net/2021/01/12/3TBh9clC4XJHvUt.png" srcset="/img/loading.gif" alt="image-20210112002301731"></p><p>我们观察到，这个break point好像和增长函数有如上的关系，那么真的有吗？下一节会从数学角度解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH4:Feasibility of Learning（学习可行性）</title>
    <link href="/2021/01/11/CH4%EF%BC%9AFeasibility%20of%20Learning%EF%BC%88%E5%AD%A6%E4%B9%A0%E5%8F%AF%E8%A1%8C%E6%80%A7%EF%BC%89/"/>
    <url>/2021/01/11/CH4%EF%BC%9AFeasibility%20of%20Learning%EF%BC%88%E5%AD%A6%E4%B9%A0%E5%8F%AF%E8%A1%8C%E6%80%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="CH4-Feasibility-of-Learning（学习可行性）"><a href="#CH4-Feasibility-of-Learning（学习可行性）" class="headerlink" title="CH4:Feasibility of Learning（学习可行性）"></a>CH4:Feasibility of Learning（学习可行性）</h1><h2 id="Learning-is-impossible？"><a href="#Learning-is-impossible？" class="headerlink" title="Learning is  impossible？"></a>Learning is  impossible？</h2><p>对于有些问题，机器学习给出的答案可能并不是对的，因为样本自身可能符合多个hypothesis，对于不同的hypothesis有不同的结果，这使得结果具有不确定性。</p><h2 id="Probability-to-the-Rescue"><a href="#Probability-to-the-Rescue" class="headerlink" title="Probability to the Rescue"></a>Probability to the Rescue</h2><p><img src="https://i.loli.net/2021/01/10/tvlKCAyiIWYRJZS.png" srcset="/img/loading.gif" alt="image-20210110222508982"></p><p>我们估测一个大瓶子里的橘色圆球占比可以通过随机抓一把求橘色圆球占比来估计</p><p><img src="https://i.loli.net/2021/01/10/nV812sjfPtIkS5Z.png" srcset="/img/loading.gif" alt="image-20210110222641205"></p><p>这个依据称为$ Hoeffding$ 霍夫丁不等式。从不等式可以看出当数量N越大，这个准确率是越准确的。</p><p><img src="https://i.loli.net/2021/01/10/AZH3qv5nz81xmVP.png" srcset="/img/loading.gif" alt="image-20210110223003852"></p><h2 id="Connection-to-Learning"><a href="#Connection-to-Learning" class="headerlink" title="Connection to Learning"></a>Connection to Learning</h2><p><img src="https://i.loli.net/2021/01/10/ZiPGhDmRI3fSwje.png" srcset="/img/loading.gif" alt="image-20210110223448087"></p><p>​        将其转换为机器学习的问题:</p><ul><li><p>机器学习中$hypothesis$与目标函数相等的可能性类比于罐子中橙色弹珠的概率问题 </p></li><li><p>将罐子中的一颗颗弹珠类比于机器学习中的样本空间x，橙色弹珠类比于$h(x)$和$f(x)$结果不相同，绿色弹珠类比于$h(x)$和$f(x)$结果相同</p></li><li><p>从罐子中抽取的N个弹珠类比于机器学习中的训练样本D，且这两种抽样的样本与总体样本之间是独立同分布的，假设样本的数量N够大且是独立同分布的，可以通过样本中hx和fx不一样的几率大概推断出样本外的样本数据中hx和fx不一样的几率。</p></li></ul><hr><p><img src="https://i.loli.net/2021/01/10/qbT4EV2fvlBUgZ5.png" srcset="/img/loading.gif" alt="image-20210110224158726"></p><p>因此机器学习可以类比为，$E<em>{in}(h)$代表着真正的目标函数$f$, 而我们自己提出来的hypothesis在一部分样本上运行效果不错的hypothesis  $g$代表着$E</em>{in}(h)$，机器学习就是一个这样的概率问题，在罐子中用一部分球就可以大致的求出概率，机器学习中用一些样本就可以学得和target function差不多的预测函数g。</p><p>$E<em>{in}$代表着人手上样本的错误率，$E</em>{out}代表所有的数据的错误率$</p><p><img src="https://i.loli.net/2021/01/10/ZmYVCiSHx1qravh.png" srcset="/img/loading.gif" alt="image-20210110224455052"></p><p>类比可知，我们在一个比较大的样本所做到的算法效果很好，那么在所有数据上也会比较好。</p><hr><p>那么按照上面的说法，我们一定可以找到机器学习比较好的学习效果了，这是和之前所说的<strong>Learning is impossible？</strong>中的的说法不太一样。我们仔细回想可以发现，这个g并没有人告诉我们，我们要从hypothesis中一大堆的g中选出这个g后，才可以进行我们之前所提到的工作。也就是说你不一定可以找一个在样本上表现很好的（即$E_{in}$ 比较小）的算法。</p><p>因此这个并不是学习，而是Verification验证表现，也就是说确认表现好不好（如果在样本表现好，那么很大可能在所有数据上表现很好）。</p><h2 id="Connection-to-Real-Learning"><a href="#Connection-to-Real-Learning" class="headerlink" title="Connection to Real Learning"></a>Connection to Real Learning</h2><p><img src="https://i.loli.net/2021/01/10/lhmIPiJLDOSWsaC.png" srcset="/img/loading.gif" alt="image-20210110225230417"></p><p>我们的hypothesis中有许多h，那么我们从每个选择十个球来测量绿球的占比，那么这样得出的结果可能不一定是正确的。</p><p><img src="https://i.loli.net/2021/01/10/OdtWCBzE4sxZmRT.png" srcset="/img/loading.gif" alt="image-20210110225643569"></p><p>上图的表我们可以看做，抽x个球来估计概率时多少种不同的抽法，得出来的数据有差距时我们认为这就是一个BAD的资料。即$E<em>{in}(h)$和$E</em>{out}(h)$差距比较大时，我们认为这是一个bad的资料。</p><p><strong>因此用来训练的资料/数据集 要是比较正确的才可以训练出好的模型。</strong></p><p><img src="https://i.loli.net/2021/01/10/oLwBuCmjTI46UJy.png" srcset="/img/loading.gif" alt="image-20210110230400881"></p><p>上述列表中D代表着不同的资料/数据训练集， 只要有一个资料对h来说是bad的，我们就认为这个资料为bad的。</p><p><img src="https://i.loli.net/2021/01/10/xNVK9nQchgzjSTv.png" srcset="/img/loading.gif" alt="image-20210110230752309"></p><p>因此：</p><ul><li><p>要么N大一些，即资料够多，可以进行机器学习。</p></li><li><p>或者我们找到了一个g可以让$E<em>{in}≈0$，那么我们也可以估计到整体$E</em>{out}$也约等于0。那么这个也是一个犯错很少的方法。因此可以进行机器学习。</p></li></ul><p>那么这里我们默认M为finite（有限的），那么对于无限的M呢？如感知机perceptron，这里对应着下一章的内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH3：Types of Learning</title>
    <link href="/2020/11/26/CH3%EF%BC%9ATypes%20of%20Learning/"/>
    <url>/2020/11/26/CH3%EF%BC%9ATypes%20of%20Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="CH3：Types-of-Learning"><a href="#CH3：Types-of-Learning" class="headerlink" title="CH3：Types of Learning"></a>CH3：Types of Learning</h1><h2 id="Learning-with-Different-Output-Space"><a href="#Learning-with-Different-Output-Space" class="headerlink" title="Learning with Different Output Space"></a>Learning with Different Output Space</h2><p>二元分类我们成为<strong>Binary Classification</strong> </p><p>多分类问题：</p><p><a href="https://imgchr.com/i/Dwma2n" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/Dwma2n.png" srcset="/img/loading.gif" alt="Dwma2n.png"></a></p><p>回归预策分析问题：</p><p>结构学习：例如自然语言</p><p><a href="https://imgchr.com/i/Dwn5Ss" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/Dwn5Ss.png" srcset="/img/loading.gif" alt="Dwn5Ss.png"></a></p><p><a href="https://imgchr.com/i/DwuKnP" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwuKnP.png" srcset="/img/loading.gif" alt="DwuKnP.png"></a></p><h2 id="Learning-with-Different-Data-Label"><a href="#Learning-with-Different-Data-Label" class="headerlink" title="Learning with Different Data Label"></a>Learning with Different Data Label</h2><p><strong>监督学习/无监督学习：</strong>  </p><p><a href="https://imgchr.com/i/DwKPvn" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwKPvn.png" srcset="/img/loading.gif" alt="DwKPvn.png"></a></p><p><strong>半监督学习：</strong></p><p><a href="https://imgchr.com/i/DwKDqP" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwKDqP.png" srcset="/img/loading.gif" alt="DwKDqP.png"></a></p><p><strong>强化学习：</strong></p><p><a href="https://imgchr.com/i/DwMpdK" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwMpdK.png" srcset="/img/loading.gif" alt="DwMpdK.png"></a></p><h2 id="Learning-with-Different-Protocol"><a href="#Learning-with-Different-Protocol" class="headerlink" title="Learning with Different Protocol"></a>Learning with Different Protocol</h2><p><strong>Batch Learning 批量学习：</strong></p><p><a href="https://imgchr.com/i/DwMXtS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwMXtS.png" srcset="/img/loading.gif" alt="DwMXtS.png"></a></p><p><strong>Online Learning 在线学习：</strong></p><p><a href="https://imgchr.com/i/DwQS6s" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/DwQS6s.png" srcset="/img/loading.gif" alt="DwQS6s.png"></a></p><p>线上学习是一种passive学习方式，而批量学习是一种填鸭式学习。</p><h2 id="Learning-with-Different-Input-Space"><a href="#Learning-with-Different-Input-Space" class="headerlink" title="Learning with Different Input Space"></a>Learning with Different Input Space</h2><p>对于这样一个问题，我们喂给机器什么样的数据？</p><p><a href="https://imgchr.com/i/Dw1jfO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/Dw1jfO.png" srcset="/img/loading.gif" alt="Dw1jfO.png"></a></p><p>我们可以从以下方法来入手：</p><p><a href="https://imgchr.com/i/Dw38hT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/Dw38hT.png" srcset="/img/loading.gif" alt="Dw38hT.png"></a></p><p>比如 x=(对称性，多样性)  这样的数据，或者是是16*16像素点的256维向量。</p><p>第二种方法看起来很好，但是对于机器来说，对于这么多维的数据，对于机器是很难训练的，同时需要大量数据来学习。</p><p>自己抽取特征，也可以是机器自己发现的：</p><p><a href="https://imgchr.com/i/Dw8kr9" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/26/Dw8kr9.png" srcset="/img/loading.gif" alt="Dw8kr9.png"></a></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>[<img src="https://s3.ax1x.com/2020/11/26/Dw8RRU.png" srcset="/img/loading.gif" alt="Dw8RRU.png">](</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石CH2：Learning to Answer Yes/No</title>
    <link href="/2020/11/24/CH2%EF%BC%9ALearning%20to%20Answer%20Yes%20or%20No/"/>
    <url>/2020/11/24/CH2%EF%BC%9ALearning%20to%20Answer%20Yes%20or%20No/</url>
    
    <content type="html"><![CDATA[<h1 id="CH2：Learning-to-Answer-Yes-No"><a href="#CH2：Learning-to-Answer-Yes-No" class="headerlink" title="CH2：Learning to Answer Yes/No"></a>CH2：Learning to Answer Yes/No</h1><h2 id="Perceptron-Hypothesis-Set"><a href="#Perceptron-Hypothesis-Set" class="headerlink" title="Perceptron Hypothesis Set"></a>Perceptron Hypothesis Set</h2><p><a href="https://imgchr.com/i/BwNSPJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwNSPJ.png" srcset="/img/loading.gif" alt="BwNSPJ.png"></a></p><p>$x$为 顾客的特征向量， $y$为是否发卡。</p><p>$y$取值为${+1,-1}$。 最后我们得到一个假说Hypothesis  $h(x)$, $sign$函数是一个符号函数，在<0,>0，=0分别取-1，1，0。$threshold$为是否发卡的阈值。</p><p><a href="https://imgchr.com/i/BwU3lR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwU3lR.png" srcset="/img/loading.gif" alt="BwU3lR.png"></a></p><p>我们为了书写简单，把$threshold$收入$w_ix_i$，下标改为从0开始。</p><p><a href="https://imgchr.com/i/BwaA4e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwaA4e.png" srcset="/img/loading.gif" alt="BwaA4e.png"></a></p><p>那么怎么直观的理解h(x)究竟是什么东西呢？</p><p>我们把x看作一个只有两维的向量，那么它可以代表平面上的一个点，此时还有一个$w_1,w_2$来影响x向量，每个点 有一个label即圆圈还是叉叉。那么h就代表平面上的一条线。</p><p>hypothesis可以看作一堆直线，我们选出一个可以很好划分不同label的直线作为最后的划分函数h(x)即可。h(x)感知机实际上就是一个线性的分类器，即回答yes or no。</p><h2 id="Perceptron-Learning-Algorithm-PLA"><a href="#Perceptron-Learning-Algorithm-PLA" class="headerlink" title="Perceptron Learning Algorithm (PLA)"></a>Perceptron Learning Algorithm (PLA)</h2><p><a href="https://imgchr.com/i/BwwnTf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwwnTf.png" srcset="/img/loading.gif" alt="BwwnTf.png"></a></p><p>H是一个无限大的集合，因此我们的想法是找一个不是那么优秀的直线，然后对直线进行旋转移动等方法对他进行修正。</p><p><a href="https://imgchr.com/i/Bw0Sjs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bw0Sjs.png" srcset="/img/loading.gif" alt="Bw0Sjs.png"></a></p><p>我们找到一个错误的$w<em>t^T$ 使得 $sign(w_t^Tx</em>{n(t)})$被错误的分类(其中n(t)代表第n个样本在第t轮)。因此我们想要对他改进纠错，当$y=+1$时，代表我们想要正的却识别出了负的，因此我们要进行改错，我们把$w<em>t^Tx</em>{n(t)}$可以看作向量$w$和向量$x$的夹角，夹角太大就要减小，即$w$更新为$w+yx$。当$y=-1$时同理。</p><p>不断改错直到没有错误或者错误最少。</p><p><a href="https://imgchr.com/i/Bwr1U0" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bwr1U0.png" srcset="/img/loading.gif" alt="Bwr1U0.png"></a></p><p><a href="https://imgchr.com/i/Bwry8O" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bwry8O.png" srcset="/img/loading.gif" alt="Bwry8O.png"></a></p><p><a href="https://imgchr.com/i/BwrOqs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwrOqs.png" srcset="/img/loading.gif" alt="BwrOqs.png"></a></p><p><a href="https://imgchr.com/i/Bw6xII" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bw6xII.png" srcset="/img/loading.gif" alt="Bw6xII.png"></a></p><p><a href="https://imgchr.com/i/BwcEZj" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/BwcEZj.png" srcset="/img/loading.gif" alt="BwcEZj.png"></a></p><p>一定会找到全部符合的h吗？  即使找出来g一定就是h吗？</p><h2 id="Guarantee-of-PLA"><a href="#Guarantee-of-PLA" class="headerlink" title="Guarantee of PLA"></a>Guarantee of PLA</h2><p><a href="https://imgchr.com/i/Bw2hZQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bw2hZQ.png" srcset="/img/loading.gif" alt="Bw2hZQ.png"></a></p><p>后面两种并不能找出一条直线完美切分。</p><p><strong>迭代保证的证明：</strong></p><p><a href="https://imgchr.com/i/DY5lmq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/23/DY5lmq.png" srcset="/img/loading.gif" alt="DY5lmq.png"></a></p><p>这里有意思的证明方法是，他对 $w_f$和$w_t$进行了内积，这里采用的度量方式是内积越大，说明和perfect直线越接近。</p><p>但是我们仔细想想会发现，内积不仅取决于角度（角度变小可以使得内积变大），同时向量的模也有作用，在你不断迭代，可能由于$w_t$长度影响了内积的大小。</p><p>那怎么证明这个问题呢？</p><p><a href="https://imgchr.com/i/DYIw8g" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/23/DYIw8g.png" srcset="/img/loading.gif" alt="DYIw8g.png"></a></p><p>但是仔细思考一下 我们是只在错误的时候才做更新，如上图黄色部分。</p><p>因此我们再次考虑长度变化问题，看到蓝色的一项是小于0的，因此我们加上不等式关系后我们可以看作0</p><p>我们再观察红色项，这个是用来调节的向量，因此无论左右怎么调节，我们直接选一个极值 也就是 $yx$的最大偏移。取完以后我们是可以把$y_n$忽略掉的，因为$y_n$是{-1，+1}是不会影响长度这个标量的。</p><p>最后我们可以推到得出下式：</p><p><a href="https://imgchr.com/i/DYoIfS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/23/DYoIfS.png" srcset="/img/loading.gif" alt="DYoIfS.png"></a></p><p>这个式子的<strong>常数constant是多少</strong>呢？我们做以下推导：</p><p><a href="https://imgchr.com/i/DtwqHA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/DtwqHA.png" srcset="/img/loading.gif" alt="DtwqHA.png"></a></p><p><a href="https://imgchr.com/i/Dtwz38" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/Dtwz38.png" srcset="/img/loading.gif" alt="Dtwz38.png"></a></p><p>最后这个有关于T的不等式 可以用来估计 调整次数 </p><p><a href="https://imgchr.com/i/DtBJds" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/DtBJds.png" srcset="/img/loading.gif" alt="DtBJds.png"></a></p><h2 id="Non-Separable-Data"><a href="#Non-Separable-Data" class="headerlink" title="Non-Separable Data"></a>Non-Separable Data</h2><p><a href="https://imgchr.com/i/DtBqYt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/DtBqYt.png" srcset="/img/loading.gif" alt="DtBqYt.png"></a></p><p>PLA可以拓展到n维。</p><p>PLA的一些问题：我们假设这是线性可分的，我们不知道到底需要多少次迭代，因为$w_f$我们是不知道的，同时真正的样本会存在一些噪音杂质。</p><p>对于下列这样一个问题，我们想找到一个w来线性分割使得 犯的错误最少，但这个是一个NP-hard问题。</p><p><a href="https://imgchr.com/i/DtDElT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/DtDElT.png" srcset="/img/loading.gif" alt="DtDElT.png"></a></p><p>虽然我们找到完美的一条线是np-hard问题，但是在一个优秀的复杂度内找到近似最优的一条线还是有解决方法的，如下：<strong>Pocket Algorithm</strong></p><p>这其实就是一个简单的贪心算法，迭代时我们多考虑一下这条线是否比现在的更优。</p><p><a href="https://imgchr.com/i/DtDz36" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/DtDz36.png" srcset="/img/loading.gif" alt="DtDz36.png"></a></p><p><a href="https://imgchr.com/i/Dtre8P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/Dtre8P.png" srcset="/img/loading.gif" alt="Dtre8P.png"></a></p><p>答案：A</p><p>pocket算法可能和 PLA得到的结果是一样的，因此34都不对，pocket是一定比PLA慢的，因为Pocket需要对比迭代的直线是不是比当前更好，因此要对比所有的数据才可以知道，这会大大浪费时间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基石Ch1：The Learning Problem</title>
    <link href="/2020/11/24/CH1%EF%BC%9AThe%20Learning%20Problem/"/>
    <url>/2020/11/24/CH1%EF%BC%9AThe%20Learning%20Problem/</url>
    
    <content type="html"><![CDATA[<h1 id="Ch1：The-Learning-Problem"><a href="#Ch1：The-Learning-Problem" class="headerlink" title="Ch1：The Learning Problem"></a>Ch1：The Learning Problem</h1><h2 id="1-1-What-is-Machine-Learning？"><a href="#1-1-What-is-Machine-Learning？" class="headerlink" title="1.1 What is Machine Learning？"></a>1.1 What is Machine Learning？</h2><p><a href="https://imgchr.com/i/BYxop4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/30/BYxop4.png" srcset="/img/loading.gif" alt="BYxop4.png"></a></p><p><strong>skill</strong>可以定义为 某一种表现的提升，例如 你通过<strong>股票的数据</strong> 进行机器学习使得你获得了<strong>更多的收益</strong></p><p><a href="https://imgchr.com/i/BYxL0x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/30/BYxL0x.png" srcset="/img/loading.gif" alt="BYxL0x.png"></a></p><p>对于辨别一棵树，我们是通过见过无数棵树后总结出来的判断规律。这和机器学习是相似的，通过数据进行学习。</p><p><strong>是否适合使用机器学习的一些基本判别关键点？</strong></p><p>1.能够有某些效能指标或者目标希望机器可以达到</p><p>2.不知道怎么有效的定义</p><p>3.有data</p><p><a href="https://imgchr.com/i/BYzb8g" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/30/BYzb8g.png" srcset="/img/loading.gif" alt="BYzb8g.png"></a></p><p>正确答案：3</p><p>第一个小女孩哭没有规则可以预测，第二个图里的环可以有效的定义，不需要机器学习。最后一个地球被核能毁灭没有相关的数据。</p><h2 id="1-2-Applications-of-Machine-Learning"><a href="#1-2-Applications-of-Machine-Learning" class="headerlink" title="1.2 Applications of Machine Learning"></a>1.2 Applications of Machine Learning</h2><h2 id="1-3Components-of-Machine-Learning"><a href="#1-3Components-of-Machine-Learning" class="headerlink" title="1.3Components of Machine Learning"></a>1.3Components of Machine Learning</h2><p>信用卡是否发卡的预测问题：</p><p>下面是一个申请表：</p><p><a href="https://imgchr.com/i/BtCFxg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/30/BtCFxg.png" srcset="/img/loading.gif" alt="BtCFxg.png"></a></p><ul><li>input：$x\in X$   顾客的申请信息</li><li>output: $y\in Y$  同意发卡后的顾客表现的好坏</li><li>目标方程（target function）: $f:X→ Y$</li><li>data: 训练样本$D={(x_1,y_1),(x_2,y_2)…(x_N,y_N)}$  代表以前同样的顾客x给他发信用卡后的表现y</li><li>hypothesis：训练出一个函数$g：X→Y$来衡量要不要给顾客信用卡。</li></ul><p><a href="https://imgchr.com/i/BtPCwR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/30/BtPCwR.png" srcset="/img/loading.gif" alt="BtPCwR.png"></a></p><p>我们希望训练出来的$g$和$f$越像越好。</p><h2 id="1-4-Machine-Learning-and-Other-Fields"><a href="#1-4-Machine-Learning-and-Other-Fields" class="headerlink" title="1.4 Machine Learning and Other Fields"></a>1.4 Machine Learning and Other Fields</h2><p><strong>资料勘探和机器学习：</strong> 我们用机器学习来寻找相关的资料，这些资料可以用于其它领域的机器学习训练的数据</p><h2 id="1-5-Homework-0"><a href="#1-5-Homework-0" class="headerlink" title="1.5 Homework  #0"></a>1.5 Homework  #0</h2><p><a href="https://imgchr.com/i/BUsa4S" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/31/BUsa4S.png" srcset="/img/loading.gif" alt="BUsa4S.png"></a></p><p><a href="https://imgchr.com/i/BUO6N8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/31/BUO6N8.png" srcset="/img/loading.gif" alt="BUO6N8.png"></a></p><p><a href="https://imgchr.com/i/BUXkgH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/31/BUXkgH.png" srcset="/img/loading.gif" alt="BUXkgH.png"></a></p><p><a href="https://imgchr.com/i/Bw3XQK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/11/01/Bw3XQK.png" srcset="/img/loading.gif" alt="Bw3XQK.png"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AHU汇编语言</title>
    <link href="/2020/07/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2020/07/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="AHU汇编语言"><a href="#AHU汇编语言" class="headerlink" title="AHU汇编语言"></a>AHU汇编语言</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>对AHU汇编课的一些笔记总结,我自认为总结的还算全面，但受限于个人水平，有些地方可能会出现错误，如果有什么遗漏或者错误之处，可以发邮件到：howiewang.cs@gmail.com </p><h2 id="Ch1-汇编语言基础知识"><a href="#Ch1-汇编语言基础知识" class="headerlink" title="Ch1-汇编语言基础知识"></a>Ch1-汇编语言基础知识</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><strong>二进制/十六进制数→十进制数：</strong></p><p>$N=101101.1B=1<em>2^5+1</em>2^3+1<em>2^2+1</em>2^0+1*2^{-1}=45.5D$</p><p>$N=5F H=5<em>16^1+15</em>16^0=95D$</p><p><strong>十进制数 → 二进制数：</strong></p><p>13/2=6 …….1</p><p>6/2=3……….0</p><p>3/2=1……….1</p><p>1/2=0……….1</p><p>$N=13D=1101B$</p><p><strong>十进制数→十六进制数：</strong></p><p>先转二进制，然后四个一组，整数部分高位补0凑4位，小数部分低位补0凑4位。</p><h3 id="进制计算"><a href="#进制计算" class="headerlink" title="进制计算"></a>进制计算</h3><p>43A5+5A34=9DD9</p><p>2A34*0025=61984(H)   列竖式自己算一下即可</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>负数取反加1，正数不变即可。</p><p>例如用8位二进制表示-3的补码：</p><p>$[-3]_补$:0000 0011取反加1，即1111 1101</p><p>如果此时要用16位二进制表示-3的补码，我们只需要在前面加上8个1即可，这叫做符号扩展，对于负数来说，符号扩展是在前面补1，正数是在前面补0。</p><p><strong>补码的运算：</strong></p><p>$[X+Y]<em>补=[X]</em>补+[Y]_补$</p><p>$[X-Y]<em>补=[X]</em>补+[-Y]_补$</p><p>如果是在机器中限制了二进制位数且加完后超过了二进制位数则会舍弃高位。</p><p>例如8位加法运算：0001 1001+1110 0000=（1，这个1舍弃） 0000 0111</p><h3 id="字符表示和逻辑运算"><a href="#字符表示和逻辑运算" class="headerlink" title="字符表示和逻辑运算"></a>字符表示和逻辑运算</h3><p>ASCII:   <strong>30-39：’0’ - ‘9’        41-5A：’A’ - ‘Z’     61-7A:  ‘a’ - ‘z’</strong></p><p>回车:0dh</p><p>换行:0ah</p><p>空格:20h</p><p>逻辑运算:  与，或，非，异或</p><h2 id="Ch2-计算机基本原理"><a href="#Ch2-计算机基本原理" class="headerlink" title="Ch2-计算机基本原理"></a>Ch2-计算机基本原理</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p><strong>16位结构的CPU：</strong></p><p>8086是十六位结构的CPU，16位结构的CPU具有以下四个方面的结构特征：</p><p>1.数据总线为16位</p><p>2.运算器一次最多可以处理16位的数据</p><p>3.寄存器最大宽度16位</p><p>4.寄存器与运算器之间的通路16位</p><p><strong>8086中</strong>，8个bit（二进制位）一个byte（字节），2个byte（字节）一个word（字）。</p><p><strong>高位字节/低位字节：</strong></p><p><img src="https://s1.ax1x.com/2020/07/22/UHNtGF.png" srcset="/img/loading.gif" alt="UHNtGF.png"></p><p><strong>上图中的字和字节在内存中表示一定要明白：</strong></p><p>（31200H）处的字包含两个字节A28FH，分别在31201H,31200H,因为字的前半部分是高位字节在高位，但是字的位置是由低位字节表示的。</p><p><strong>8086CPU有20位地址总线，可以传送20位地址，也就是说物理地址20位。20位地址可以标定的内存单元有1M，即寻址能力可达1MB。</strong></p><p><strong>存储器分段：</strong></p><p><img src="https://s1.ax1x.com/2020/07/22/UHRFqf.png" srcset="/img/loading.gif" alt="UHRFqf.png"></p><p>物理地址=段地址*16+偏移地址​     </p><p>每个段大小位64KB（偏移地址从0000-FFFF）。</p><p><strong>段的类型：</strong></p><p>代码段—用于存放指令，代码段段基址存放在段寄存器CS</p><p>数据段—用于存放数据，数据段段基址段地址存放在段寄存器DS</p><p>附加段—用于辅助存放数据，附加段段基址存放在段寄存器ES</p><p>堆栈段—是重要的数据结构，可用来保存数据、地址和系统参数，堆栈段段基址存放在段寄存器SS</p><p><strong>写程序时，代码段必须要有。</strong></p><p><strong>逻辑地址：</strong></p><p>逻辑地址是用户编程时使用的地址，分为<strong>段地址</strong>和<strong>偏移地址</strong>两个部分。</p><p><img src="https://s1.ax1x.com/2020/07/24/UjzrVI.png" srcset="/img/loading.gif" alt="UjzrVI.png"></p><p>逻辑地址：如上如中存储单元C8的逻辑地址为： 1123H：0013H 或者  1124H:0003H</p><p><strong>公式：</strong>段地址*16+偏移地址=物理地址  （ 相当于短地址在十六进制下左移一位再加上偏移地址即为物理地址）</p><p><strong>例题</strong>  段基址为1896H，偏移地址为1655H。其物理地址为多少？</p><p>18960H+1655H=19FB5H</p><p><img src="https://s1.ax1x.com/2020/07/24/UvpVpT.png" srcset="/img/loading.gif" alt="UvpVpT.png"></p><p><strong>通用寄存器：</strong></p><p>8086 CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，有时候也可以存放地址，被称为<strong>通用数据寄存器</strong>。</p><p>①AX：累加器，运算时较多使用这个寄存器，有些指令规定必须使用它。</p><p>②BX：基址寄存器，除了存放数据，它经常用来存放一段内存的起始偏移地址。</p><p>③CX：计数寄存器，除了存放数据，它经常用来存放重复操作的次数。</p><p>④DX：数据寄存器，除了存放数据，它有时存放32位数据的高16位。</p><p>一个字存放在16位的寄存器中，这个字分为高位字节和低位字节，高位字节存储在寄存器的高8位(AH)，第八位(AL)同理。</p><p><strong>地址寄存器:</strong></p><p>16位的8086处理器有4个16位的通用地址寄存器。它们的主要作用是存放数据的所在偏移地址，也可以存放数据。这4个寄存器不能再拆分使用。</p><p>①SP：堆栈指针，这是一个专用的寄存器，存放堆栈栈顶的偏移地址。</p><p>②BP：基址指针，可以用来存放内存中数据的偏移地址。</p><p>③SI：源变址寄存器，它经常用来存放内存中源数据区的偏移地址，所谓变址寄存器，是指在某些指令作用下它可以自动地递增或递减其中的值。</p><p>④DI：目的变址寄存器，它经常用来存放内存中目的数据区的偏移地址，并在某些指令作用下可以自动地递增或递减其中的值。</p><p><strong>段寄存器：</strong></p><p>16位80x86处理器有4个16位的段寄存器，分别命名为CS，SS，DS，ES。它们用来存放4个段的段基址。 </p><p>①CS：代码段寄存器，用来存放当前正在执行的程序段的段基址。</p><p>②SS：堆栈段寄存器，用来存放堆栈段的段基址。</p><p>③DS：数据段寄存器，用来存放数据段段基址。</p><p>④ES：附加段寄存器，用来存放另一个数据段的段基址。  </p><p><strong>指令指针寄存器：</strong></p><p> IP：指令指针寄存器，存放即将执行指令的偏移地址。</p><p><strong>指令指针寄存器：</strong></p><p>FLAGS：存放CPU的两类标志。</p><p>状态标志：反映处理器当前的状态，如有无溢出，有无进位等。</p><p>状态标志有6个：CF、PF、AF、ZF、SF和OF</p><p>控制标志：用来控制处理器的工作方式，如是否响应可屏蔽中断等</p><p>控制标志有3个：TF、IF和DF</p><p><strong>堆栈区：</strong></p><p>当堆栈区为空时，栈顶和栈底是重合的。数据在堆栈区存放时，必须以字存入，每次存入一个字，后存入的数据依次放入栈的低地址单元中。栈指针<strong>SP每次减2</strong>，由栈指针SP指出当前栈顶的位置，数据存取时采用后进先出的方式</p><h2 id="Ch3-汇编程序实例-上机操作"><a href="#Ch3-汇编程序实例-上机操作" class="headerlink" title="Ch3-汇编程序实例/上机操作"></a>Ch3-汇编程序实例/上机操作</h2><h3 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h3><p><strong>1.盘</strong></p><p>E:        回车即可进入E盘</p><p><strong>2.CD 选择目录</strong></p><p>E:\&gt;CD MASM                  进到MASM的子目录</p><p>E:\&gt;MASM&gt;CD MY         进到MY的子目录</p><p>E:\&gt;MASM&gt;MY&gt;CD..      退到上一级目录MASM</p><p>E:\&gt;MASM&gt;CD\                退回到根目录</p><p><strong>3.DIR        显示目录和文件</strong></p><p>E:\&gt;MASM&gt;DIR</p><p>E:\&gt;MASM&gt;DIR <em>.ASM            列出扩展名为ASM的文件，\</em>为通配符</p><p>E:\&gt;MASM&gt;DIR HELLOW.<em>    列出名为ASM的文件，\</em>为通配符</p><p>E:\&gt;MASM&gt;DIR HE*.???          列出名为HE开头，扩展名有三个字符的文件</p><p><strong>4.REN  改变文件名</strong></p><p>E:\&gt;REN H1.TXT H2.ASM      把 H1.TXT 改为 H2.ASM  </p><p><strong>5.CLS 清屏</strong></p><p><strong>6.DEL  删除文件</strong></p><p>E:\&gt;DEL C.TXT</p><p><strong>7.MD  建立目录</strong></p><p>E:\&gt;MD MASM</p><p><strong>8.RD 删除目录</strong></p><p>E:\&gt;RD MASM</p><p><strong>9.COPY 复制文件</strong></p><p>E:\&gt;COPY H1.TXT H2.TXT  复制文件H1.TXT到文件H2.TXT</p><p><strong>10.TYPE 显示文本文件内容</strong></p><p>E:\&gt;TYPE C.TXT</p><p><strong>11.HELP 显示命令格式的用法</strong></p><p> E:\&gt;HELP  显示所用命令的格式</p><p>E:\&gt;HELP DIR 显示DIR命令的用法</p><h3 id="汇编程序实例"><a href="#汇编程序实例" class="headerlink" title="汇编程序实例"></a>汇编程序实例</h3><p>输出输入字符的下一个字符：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">code segment <br>assume cs:code<br>start:<br>mov ah,1  ;输入<br>int 21h<br>mov dl,al ;al传到dl<br>add dl,1  ;dl+1<br>mov ah,2  ;显示<br>int 21h<br>mov ah,4ch<br>int 21h<br>code ends<br>end start<br></code></pre></div></td></tr></table></figure><p>显示字符串：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">data segment <br>string db &#39;hello,world!$&#39;<br>data ends<br><br>code segment<br>assume cs:code,ds:data<br>start:<br>mov ax,data<br>mov ds,ax<br>mov dx,offset string<br>mov ah,9<br>int 21h<br>mov ah,4ch<br>int 21h<br>code ends<br>end start<br></code></pre></div></td></tr></table></figure><p>1.编辑   EDIT HELLO.ASM</p><p>2.汇编  MASM HELLO.ASM</p><p>3.连接  LINK HELLO.OBJ</p><p>4.运行 HELLO.EXE</p><h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><p>(1) debug的R命令查看，改变寄存器的内容。<br>查看：<br>改变寄存器的内容：将AX=0000改为AX=1234</p><p>(2) 用debug的D命令查看内存中的内容<br>命令： -d 短地址:偏移地址<br>-d 短地址：偏移地址x 偏移地址y 可以查询短地址：偏移地址x 到 短地址：偏移地址y 的内存中内容</p><p>(3) 用debug的E命令改写内存中的内容<br>命令： -e 起始地址 数据 数据 数据…..<br>命令：-e 起始地址<br>对从起始地址开始的内存进行改写，按空格改写下一个，回车改写结束。<br>向内存中写入字符串：</p><p>(4) 反汇编命令U</p><p>(5) 运行程序命令G</p><p>(6) 跟踪程序命令T</p><p>(7) 单步执行程序命令P</p><p>(8) 退出命令Q</p><h3 id="DOS系统功能调用-INT-21H"><a href="#DOS系统功能调用-INT-21H" class="headerlink" title="DOS系统功能调用(INT 21H)"></a>DOS系统功能调用(INT 21H)</h3><p><strong>1.键盘输入并回显（1号功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AH,1<br>INT 21H<br></code></pre></div></td></tr></table></figure><p>等待从键盘输入一个字符，将该字符的ASCII码送入AL中，并送屏幕显示。</p><p><strong>2.显示单个字符（2号功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AH,2<br>MOV DL,&#39;A&#39;<br>INT 21H<br></code></pre></div></td></tr></table></figure><p>显示DL的字符，执行后AL寄存器的值被修改为DL的值</p><p><strong>3.显示字符串（9号功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AH,9<br>LEA DX,STR<br>INT 21H<br></code></pre></div></td></tr></table></figure><p><strong>DS:DX</strong>指向以$结束的字符串STR，执行后AL寄存器的值被修改为$</p><p><strong>4.键盘输入到缓冲区（0AH/10号功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AH,0AH<br>LEA DX,BUF<br>INT 21H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">   data segment<br>   bufferdb 81    ；定义缓冲区大小为9个字节<br>db ？        ；大小未定         <br>db 81 dup(？)     ；dup代表保存空间不被占用<br>...<br>data ends<br><br>mov dx, seg buffer；伪指令seg取得buffer的段地址<br>mov ds, dx；设置数据段DS<br>mov dx, offset buffer<br>mov ah, 0ah<br>int 21h<br></code></pre></div></td></tr></table></figure><p><strong>5.结束程序返回DOS（4CH号功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AH,4CH<br>INT 21H<br></code></pre></div></td></tr></table></figure><h2 id="Ch4-操作数的寻址方式"><a href="#Ch4-操作数的寻址方式" class="headerlink" title="Ch4-操作数的寻址方式"></a>Ch4-操作数的寻址方式</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1.立即寻址方式"></a><strong>1.立即寻址方式</strong></h3><p>操作数就在指令中，紧跟在操作码之后，<strong>操作数作为指令的一部分存放在代码段</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AL,6H<br><br>MOV AX,12AFH<br></code></pre></div></td></tr></table></figure><p>TIPS:</p><p><strong>①执行时无需去内存取数，因此称为立即数。</strong></p><p><strong>②主要用于寄存器赋初值。</strong></p><p><strong>③立即数只能作为源操作数，并且长度与目的操作数一致。</strong> 不可出现MOV AL,12AFH</p><h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2.寄存器寻址方式"></a><strong>2.寄存器寻址方式</strong></h3><p>操作数就是寄存器中的值。指令中给出寄存器的名字</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX,BX  (√)<br>MOV AL,BL  (√)<br>MOV AL,BX  (x)<br>MOV AX,BL  (x)<br></code></pre></div></td></tr></table></figure><h3 id="3-直接寻址方式"><a href="#3-直接寻址方式" class="headerlink" title="3.直接寻址方式"></a><strong>3.直接寻址方式</strong></h3><p>操作数的有效地址EA就在指令中，机器默认段地址在DS中。</p><p><img src="https://s1.ax1x.com/2020/07/26/aCfgvn.png" srcset="/img/loading.gif" alt="aCfgvn.png"></p><p>EA和段寄存器中的段地址组成操作数。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;存储器读操作<br>MOV AX,DS:[2000H]<br><br>;存储器写操作<br>MOV DS:[2000H],AX<br><br>;符号地址:直接寻址方式除了用数值作为有效地址之外，还可以用符号地址的形式。为存储单元定义一个名字，该名字就是符号地址。<br>VALUE DW 5678H<br>MOV AX,VALUE<br>MOV AX,[VALUE]<br><br>;段前缀：在与内存有关的寻址方式中，操作数的段地址默认为数据段，80X86规定除了数据段之外，数据还可以存放在其他三种段中。如果操作数在其他段中存放，称为段超越，需要在指令中用段超越前缀指出，即用操作数前加上段寄存器名和冒号表示。<br>VALUE EQU 1000H<br>MOV AX,DS:[VALUE]<br>MOV AX,ES:[VALUE]<br></code></pre></div></td></tr></table></figure><h3 id="4-寄存器间接寻址方式"><a href="#4-寄存器间接寻址方式" class="headerlink" title="4.寄存器间接寻址方式"></a><strong>4.寄存器间接寻址方式</strong></h3><p><strong>特点：</strong>操作数的有效地址在寄存器中，<strong>只允许使用BX、BP、SI和DI寄存器</strong>。</p><p>​        物理地址=10H × (DS) + (BX)</p><p>​        物理地址=10H × (DS) + (SI )</p><p>​        物理地址=10H × (DS) + (DI )</p><p>​        物理地址=10H × (SS) + (BP)</p><p><img src="https://s1.ax1x.com/2020/07/26/aC5H2Q.png" srcset="/img/loading.gif" alt="aC5H2Q.png"></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX,[BX]<br>MOV DX,[BP]<br>MOV ES:[DI],AX<br></code></pre></div></td></tr></table></figure><h3 id="5-寄存器相对寻址方式"><a href="#5-寄存器相对寻址方式" class="headerlink" title="5.寄存器相对寻址方式"></a><strong>5.寄存器相对寻址方式</strong></h3><p><strong>特点：操作数的有效地址是一个寄存器和位移量之和。</strong></p><p>​        物理地址=10H × (DS) + (BX) + 8(16)位位移量</p><p>​        物理地址=10H × (DS) + (SI ) + 8(16)位位移量</p><p>​        物理地址=10H × (DS) + (DI ) + 8(16)位位移量</p><p>​        物理地址=10H × (SS) + (BP) + 8(16)位位移量</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX,TOP[SI]<br>;TOP为符号地址，即位移量。<br>;已知(DS)&#x3D;1500H ,(SI)&#x3D;7310H, TOP&#x3D;25H<br>;有效地址EA&#x3D;TOP+SI&#x3D;7310H+25H&#x3D;7335H<br>;物理地址&#x3D;DS*10H+EA&#x3D;1C335H<br>;若（1C335H）&#x3D;2428H ,(AX)&#x3D;2428H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV [BX+2623H],AX<br>;此时的位移量为2623H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  AX,ARRY[BX]       <br>MOV  AX,[ARRY][BX]<br>MOV  AX,[ARRY+BX]<br>MOV  AL,BUF[BX]<br>MOV  AL,[BX+8H]<br>MOV  AL,[BX].8H<br></code></pre></div></td></tr></table></figure><h3 id="6-基址变址寻址方式"><a href="#6-基址变址寻址方式" class="headerlink" title="6.基址变址寻址方式"></a><strong>6.基址变址寻址方式</strong></h3><p>操作数的<strong>有效地址是一个基址寄存器和一个变址寄存器的内容之和</strong>。</p><p><strong>基址寄存器BX和BP，变址寄存器SI和DI</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX, [BX+DI]<br>;执行前：已知（DS）&#x3D;2100H，（BX）&#x3D;0158H，（DI）&#x3D;10A5H，（221FD）&#x3D;34H，（221FE）&#x3D;95H，（AX）&#x3D;0FFFFH。则<br>;有效地址EA&#x3D;（BX）+（DI）&#x3D;0158H+10A5H&#x3D;11FDH<br>;物理地址&#x3D;（DS）*10H+EA&#x3D;21000H+11FDH&#x3D;221FDH<br>;执行后，（AX）&#x3D;9534H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  AX，[BX][SI]         ；默认DS寄存器作段地址<br>MOV  AX，[BP][DI]         ；默认SS寄存器作段地址<br>MOV  AX，ES:[BX][DI]      ；指定ES寄存器作段地址<br>MOV  DX，[BP][SI]；默认SS寄存器作段地址<br>MOV  [BX+DI], CX ；默认DS寄存器作段地址<br>MOV  [BP+SI], AL ；默认SS寄存器作段地址<br></code></pre></div></td></tr></table></figure><h3 id="7-相对基址变址寻址方式"><a href="#7-相对基址变址寻址方式" class="headerlink" title="7.相对基址变址寻址方式"></a><strong>7.相对基址变址寻址方式</strong></h3><p>操作数的有效地址是一个基址寄存器和一个变址寄存器以及一个位移量之和。<br>基址寄存器BX和BP，变址寄存器SI和DI。<br>默认段寄存器搭配和寄存器间接寻址方式一样</p><p><img src="https://s1.ax1x.com/2020/07/27/aCoQYT.png" srcset="/img/loading.gif" alt="aCoQYT.png"></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  AX,MASK[BX][SI]      ；默认DS寄存器作段地址<br>MOV  AX,[MASK+BX+SI]；默认DS寄存器作段地址<br>MOV  AX,[BX+SI].MASK；默认DS寄存器作段地址<br>;以上三种表示形式实现的功能是一样的。其有效地址EA&#x3D;MASK+(BX)+(SI)；物理地址&#x3D;(DS)*10H+EA。<br></code></pre></div></td></tr></table></figure><h2 id="Ch5-常用指令系统"><a href="#Ch5-常用指令系统" class="headerlink" title="Ch5-常用指令系统"></a>Ch5-常用指令系统</h2><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><strong>①MOV:</strong></p><p>最基本的指令，注意<strong>源操作数和目的操作数的长度要一致</strong></p><p><strong>目的操作数不能是CS和IP</strong>，因为CS:IP是程序当前的地址</p><p><strong>目的操作数不可是立即数</strong>，如：MOV 9H,AL</p><p><strong>源操作数不能超过8位二进制</strong>，例如：MOV AH,258  (错误)</p><p><strong>MOV [BX],0 是错误的</strong>，应该写为MOV BYTE PTR[BX],0 或者 MOV WORD PTR[BX],0</p><p><strong>段地址寄存器须通过寄存器得到段地址，不能直接由符号地址、段寄存器、立即数得到。</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  DS, DATA_SEG     ;段寄存器不接受符号地址<br>MOV  DS, ES           ;段寄存器之间不能直接传送<br>MOV  DS, 1234         ;段寄存器不接受立即数<br>MOV  CS, AX           ;指令合法，但代码段寄存器不能赋值<br></code></pre></div></td></tr></table></figure><p><strong>两个操作数不能同为内存单元</strong>，例如MOV [BX],BUFF   MOV [AX],[BX]</p><p><strong>MOV AX,OFFSET TABLE(正确)  MOV AX,OFFSET TABLE(错误)</strong>， OFFSET出来的有效地址总是16位</p><p><strong>②PUSH 进栈指令</strong></p><p>格式: PUSH   SRC<br>操作: (SP)←(SP)-2<br>            (( SP)+1,(SP))←(SRC)<br>堆栈：后进先出内存区，以字为单位传送，SS:SP总是指向栈顶。</p><p><strong>③POP 出栈指令</strong></p><p>格式: POP   DST<br>操作: (DST)←((SP)+1,(SP))<br>             (SP)←(SP)+2 </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV BX,1234H<br>PUSH BX  ;将BX的值压入栈<br>POP AX   ;将栈弹出并赋值给AX<br></code></pre></div></td></tr></table></figure><p><strong>④XCHG 交换指令</strong></p><p>格式: XCHG   OPR1,  OPR2<br>操作: (OPR1)&lt;==&gt;(OPR2)<br>功能：把两个操作数互换位置。<br>遵循双操作数指令的规定，但操作数不能为立即数。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">XCHG  AX，  BX      ;两个寄存器长度相等<br>XCHG  AX，  [BX]    ;AX要求[BX]也取字单元<br>XCHG  AX，  VAR     ;VAR 必须是字变量<br>以下指令是错误的:<br>XCHG  AX，  5       ;显然操作数不能为立即数  <br>XCHG  [BX], VAR     ;操作数不能同为内存单元 <br>XCHG  AX，  BH      ;操作数长度要一致<br></code></pre></div></td></tr></table></figure><h3 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h3><p><strong>① IN 输入指令</strong></p><p>长格式：IN  AL,PORT（字节） ;00~FFH<br>                IN  AX,PORT（字）</p><p>操作：AL←(PORT)<br>            AX←(PORT)</p><p>功能：把端口PORT的数据输入到累加器。</p><p>短格式：IN  AL,DX（字节） ; PORT放入DX<br>                IN  AX,DX（字）</p><p>操作：AL←((DX))<br>            AX← ((DX))</p><p>功能：把DX指向的端口的数据输入到累加器。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV DX,2F8H<br>IN AL,DX<br>;把端口2F8H的8为数据输入到累加器AL中<br>IN AX,[DX] 错误 端口号不可以用[]<br></code></pre></div></td></tr></table></figure><p><strong>②OUT 输出指令</strong></p><p>长格式：OUT  PORT,AL （字节） ;00-FFH<br>                OUT  PORT,AX （字）</p><p>操作：PORT ← AL<br>            PORT ← AX</p><p>功能：把累加器的数据输出到端口PORT。</p><p>短格式：OUT  DX,AL （字节） ;0000-FFFFH<br>                OUT  DX,AX （字） </p><p>操作： (DX) ← AL<br>             (DX) ← AX</p><p>功能：把累加器的数据输出到DX指向的端口。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">OUT 61H,AL<br>OUT DX,AL<br></code></pre></div></td></tr></table></figure><p><strong>③XLAT换码指令</strong></p><p>格式：XLAT<br>操作：AL←（BX+AL）<br>功能：把BX+AL的值作为有效地址，取出其中的一个字节送AL。</p><h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p><strong>①LEA 有效地址送寄存器指令</strong></p><p>格式：LEA  REG,SRC<br>操作：REG←SRC<br>功能：把源操作数的有效地址EA送到指定的寄存器。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">LEA   BX,TABLE<br>MOV   BX,OFFSET TABLE<br>;上面2条指令等效。TABLE无论是何类型的变量，其有效地址总是16位。<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">LEA   BX， [2016H]<br>MOV  BX,  OFFSET  [2016H]<br>指令执行后，BX&#x3D;2016H。<br></code></pre></div></td></tr></table></figure><p><strong>②LDS 指针送寄存器和DS指令</strong></p><p>格式： LDS   REG, SRC<br>操作：REG←（SRC）<br>               DS←（SRC+2）<br>功能：把源操作数SRC所指向的内存单元中的两个字送到指定的寄存器REG和DS。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">LDS  SI,[BX]<br>;指令执行前，如DS&#x3D;2000H，BX&#x3D;0400H，(2000:0400)&#x3D;1234H, (2000:0402)&#x3D;5678H,<br>;指令执行后，SI&#x3D;1234H，DS&#x3D;5678H。<br></code></pre></div></td></tr></table></figure><p><strong>③LES 指针送寄存器和ES指令</strong></p><p>格式： LES   REG, SRC<br>操作：REG←（SRC）<br>               ES←（SRC+2）<br>功能：把源操作数SRC所指向的内存单元中的两个字送到指定的寄存器REG和ES。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">LES   DI,  [10H] <br>;DS&#x3D;C000H,  (C0010H)&#x3D;0180H,    (C0012H)&#x3D;2000H<br>;结果 DI&#x3D;0180H,  ES&#x3D;2000H<br></code></pre></div></td></tr></table></figure><h3 id="标志寄存器传送指令"><a href="#标志寄存器传送指令" class="headerlink" title="标志寄存器传送指令"></a>标志寄存器传送指令</h3><p>LAHF       标志寄存器FLAGS的低字节送AH<br>SAHF       AH送FLAGS的低字节<br>PUSHF    标志进栈<br>POPF       标志出栈<br>以上传送类指令均不影响标志位,除SAHF, POPF 外.</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">LAHF          ；标志寄存器低字节送AH寄存器<br>SAHF          ；AH送标志寄存器<br>PUSHF         ；标志入栈<br>POPF          ；标志出栈<br></code></pre></div></td></tr></table></figure><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p><strong>①CBW  扩展指令</strong></p><p>AL扩展为AX ,字节扩展为字</p><p><strong>扩展为符号扩展</strong></p><p><strong>②CWD 扩展指令</strong></p><p>AX扩展为DX,AX    字扩展为双字</p><p><strong>扩展为符号扩展</strong></p><p><strong>负数补1，正数补0</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV  AL，52H  ;AL中的52H是正数<br>CBW           ;指令执行后，AX&#x3D;0052H<br>CWD           ;指令执行后，DX&#x3D;0000H,AX&#x3D;0052H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;负数的扩展<br>MOV AL,88H      ;AL中的88H是负数<br>CBW             ;执行后，AX&#x3D;FF88H<br>CWD    ;执行后，DX&#x3D;FFFFH  AX&#x3D;FF88H<br></code></pre></div></td></tr></table></figure><p><strong>③ADD  加法</strong></p><p>格式：ADD   DST，SRC<br>操作：（DST）← （DST） + （SRC）</p><p>加法指令执行后会影响标志寄存器中的CF和OF标志位</p><p><strong>无符号数的溢出标志位CF(Carry Flag)</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AL,72H<br>ADD AL,93H<br>;执行后 AL&#x3D;105H,但是AL只可以存放一个字节，因此CF&#x3D;1<br></code></pre></div></td></tr></table></figure><p><strong>有符号数的溢出标志位OF(overflow flag)</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AL,92H<br>ADD AL,93H<br>;-110+(-109)&#x3D;-219 超过了八位，所以会溢出，OF&#x3D;1<br></code></pre></div></td></tr></table></figure><p><strong>④ADC 带进位加法指令</strong></p><p>格式：ADC   DST，SRC<br>操作：（DST）←（DST）+（SRC）+ <strong>CF</strong> </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DX&#x3D;2000H,AX&#x3D;8000H<br>BX&#x3D;4000H,CX&#x3D;9000H<br><br>ADD AX,CX<br>ADC DX,BX<br>;第一次执行ADD AX,CX时，因为无符号溢出导致CF&#x3D;1<br>;第二次执行ADC DX,BX时，因为 DX+BX&#x3D;6000H,同时由于上次计算的影响CF&#x3D;1,因此 DX最终等于6001H<br></code></pre></div></td></tr></table></figure><p><strong>⑤INC 自增加一</strong></p><p>格式：INC   OPR<br>操作：（OPR）←（OPR）+1 </p><p><strong>条件标志位(条件码) 最主要有:</strong><br><strong>进位CF,  零ZF,   符号SF,  溢出OF</strong></p><p><strong>⑥SUB 减法指令</strong></p><p>格式：SUB   DST，SRC<br>操作：（DST）← （DST） -（SRC）</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AL,72H<br>SUB AL,93H<br><br>;72H-93H 在看作无符号情况下，出现溢出，即CF&#x3D;1<br>;再看做有符号情况下，相当于0111 0010B&#x3D;+72H  1001 0011B&#x3D;-13H 相减后不出现溢出，因此OF&#x3D;0<br></code></pre></div></td></tr></table></figure><p><strong>⑦SBB 带借位减法指令</strong></p><p>格式：SBB   DST，SRC<br>操作：（DST）← （DST） -（SRC）- <strong>CF</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DX&#x3D;2001H， AX&#x3D;8000H<br>BX&#x3D;2000H， CX&#x3D;9000H<br><br>SUB AX,CX  ;低位字减法<br>SBB DX,BX  ;高位字减法<br><br>;第一条指令执行后，AX&#x3D;F000H，CF&#x3D;1，而对OF&#x3D;0，ZF&#x3D;0,SF&#x3D;1，不必在意。<br>;第二条指令执行后，DX&#x3D;0000H，CF&#x3D;0，OF&#x3D;0，表示结果正确。ZF&#x3D;1,SF&#x3D;0。<br></code></pre></div></td></tr></table></figure><p><strong>⑧DEC 自减1指令</strong></p><p>格式：DEC   OPR<br>操作：（OPR）←（OPR）- 1</p><p><strong>⑨NEG 求补指令</strong></p><p>格式：NEG   OPR<br>操作：（OPR）←  -（OPR）<br>功能：对OPR求补,求- OPR, 即反码+1.<br>只有OPR为0时，CF=0。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV   AX,3<br>NEG   AX<br>;3的补码 AX&#x3D;FFFD H<br>MOV   DX,0<br>NEG   DX<br>0的补码 DX&#x3D;0<br></code></pre></div></td></tr></table></figure><p><strong>⑩CMP比较指令</strong></p><p>格式：CMP   OPR1, OPR2<br>操作：（OPR1）-（OPR2）<br>不回送结果,只产生标志位。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV   AX,5<br>DEC   AX<br>CMP   AX,5 <br><br>;指令序列执行后，AX&#x3D;4，ZF&#x3D;0，SF&#x3D;1，CF&#x3D;1，OF&#x3D;0。<br>;CMP指令虽作减法，但不回送结果，只是产生标志位，为程序员比较两个数的大小提供判断依据。<br></code></pre></div></td></tr></table></figure><h3 id="乘法-除法指令"><a href="#乘法-除法指令" class="headerlink" title="乘法/除法指令"></a>乘法/除法指令</h3><p><strong>①MUL 无符号数乘法</strong> </p><p>格式:  MUL   SRC<br>操作：</p><p>要提前设置好AX</p><p>操作数为字节时: (AX)← (AL) × (SRC) </p><p>操作数为字时: (DX,AX)← (AX) × (SRC) </p><p><strong>②IMUL 有符号数乘法</strong></p><p>格式:  IMUL   SRC<br>操作：<br>    操作数为字节时: (AX)← (AL) X (SRC)<br>    操作数为字时: (DX,AX)← (AX) X (SRC)</p><p>两个相乘的数必须长度相同。<br><strong>SRC不能是立即数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV   AL,0F1H<br>MOV   BL,AL<br>MUL   BL<br>指令序列执行后，AX&#x3D;E2E1H。<br>如果看成是两个带符号相乘，则应选择如下指令：<br>MOV   AL,0F1H<br>MOV   BL,AL<br>IMUL  BL<br>指令序列执行后，AX&#x3D;00E1H。说明了两个负数相乘，结果为正数。<br></code></pre></div></td></tr></table></figure><p><strong>③DIV 无符号数触发</strong></p><p>格式：DIV SRC</p><p>操作取决于SRC的大小</p><p><strong>字节操作：</strong> AL&lt;= AX / SRC 的商</p><p>​                    AH&lt;=AX / SRC  的余数</p><p><strong>字操作：</strong>   AX&lt;= (DX,AX) / SRC</p><p>​                    DX&lt;=(DX,AX) / SRC 的余数</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX,300H<br>MOV BL,2<br>DIV BL<br>;300H &#x2F; 2 &#x3D; 3*2^8 &#x2F; 2&#x3D; 768 &#x2F;2 &#x3D; 384  产生了溢出 AL放不下<br><br>;AX扩展成双字即可<br>MOV  AX,300H<br>CWD<br>MOV  BX,2<br>DIV  BX<br></code></pre></div></td></tr></table></figure><p><strong>④IDIV 带符号数除法指令</strong></p><p>格式:  IDIV   SRC<br>操作与DIV 相同</p><p>余数和被除数同符号。<br>被除数长度应为除数长度的两倍。<br><strong>SRC不能是立即数</strong>,因为要根据SRC的类型来确定操作类型。</p><p><strong>算术运算综合题：</strong></p><p><strong>重点，重点，重点，重点，重点，重点，重点，重点，重点，重点，重点，重点，重点，重点，重点</strong></p><p>算术运算综合举例，计算:(V－(X×Y＋Z－16))／X，其中X、Y、Z、V均为16位带符号数，在数据段定义，要求上式计算结果的商存入AX，余数存入DX寄存器。 </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>    x dw 4<br>    y dw 2<br>    z dw 14h<br>    v dw 18h  <br>DATAS ENDS<br><br>STACKS SEGMENT<br>    ;此处输入堆栈段代码<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    <br>   mov ax,x<br>   imul y<br>   mov cx,ax<br>   mov bx,dx<br>   mov ax,z<br>   cwd<br>   add cx,ax<br>   adc bx,dx<br>   sub cx,16<br>   sbb bx,0<br>    mov ax,v<br>    cwd<br>    sub ax,cx<br>    sbb dx,bx<br>    mov ax,x<br>    idiv x<br>    <br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="BCD码十进制调整指令"><a href="#BCD码十进制调整指令" class="headerlink" title="BCD码十进制调整指令"></a>BCD码十进制调整指令</h3><p>BCD码 (Binary  Coded  Decimal)：用二进制编码表示十进制数.<br>四位二进制数表示一位十进制数，由于四位二进制数的权分别为8，4，2，1，所以又称为8421码. </p><p> <strong>①DAA  加法十进制调整指令</strong></p><p>格式：DAA<br>操作：<br>   IF  CF=1  or  AL高4位是[A～F]   THEN     AL+60H.<br>   IF  AF=1  or  AL低4位是[A～F]   THEN    AL+6</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;如AL&#x3D;28H&#x3D;28(BCD),BL&#x3D;65H&#x3D;65(BCD)<br>ADD AL,BL        ;AL&#x3D;28H+65H&#x3D;8DH<br>DAA      ;AL&#x3D;AL+6H&#x3D;8DH+6H&#x3D;93H&#x3D;93(BCD)      <br>;AL和BL中都是用BCD码表示的十进制数，含义分别是28和65，ADD指令作二进制加法后得到8DH，不是BCD码，DAA指令作用后，把和调整为93H，但它表示的是十进制数93的BCD码。<br></code></pre></div></td></tr></table></figure><p> <strong>②DAS   减法十进制调整指令</strong></p><p>格式：DAS<br>操作：<br>   IF  AF=1  OR  AL低4位是[A～F]  THEN   AL-6<br>   IF  CF=1  OR AL高4位是[A～F]   THEN AL-60H.   </p><p>道理和DAA 一样，计算完后加一个DAS进行调整即可 </p><h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><p><strong>①AND与指令</strong></p><p>格式: AND   DST，SRC<br>操作: (DST)←(DST)&amp;(SRC)</p><p><strong>②OR 或指令</strong></p><p>格式: OR   DST，SRC<br>操作: (DST)←(DST) | (SRC)</p><p><strong>③ NOT 非指令</strong></p><p>格式: NOT   OPR   </p><p><strong>④ XOR 异或指令</strong></p><p>格式: XOR   DST，SRC<br>操作: (DST)←(DST) xor (SRC)</p><p><strong>⑤TEST 测试指令</strong></p><p>格式: TEST   OPR1，OPR2<br>操作: (OPR1) ∧ (OPR2)<br>TEST执行AND操作, <strong>但不保存结果</strong>,只根据其特征<strong>置标志位</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;屏蔽AL寄存器的高四位，如AL&#x3D;36H<br>AND  AL,0FH  ;指令执行的结果使AL&#x3D;06H<br><br>;对AL寄存器的最低两位置1，如AL&#x3D;36H。<br>OR AL,03H   <br><br>;对AL寄存器的最低两位取反，如AL&#x3D;36H。<br>XOR  AL,03H  <br><br>;测试AL寄存器中的数，如果是负数则转到标号NEXT去执行。如AL&#x3D;86H。<br>TEST  AL,80H  <br>JS NEXT<br></code></pre></div></td></tr></table></figure><h3 id="位移指令"><a href="#位移指令" class="headerlink" title="位移指令"></a>位移指令</h3><p><strong>①SHL 逻辑左移</strong></p><p>格式：SHL    OPR, CNT<br>CNT可以是1或CL寄存器，如需移位的次数大于1，则可以在该移位指令前把移位次数先送到CL寄存器。</p><p><img src="https://s1.ax1x.com/2020/07/27/aFwg5n.png" srcset="/img/loading.gif" alt="aFwg5n.png"></p><p><strong>②SAL 算数左移</strong></p><p><img src="https://s1.ax1x.com/2020/07/27/aFwg5n.png" srcset="/img/loading.gif" alt="aFwg5n.png"></p><p><strong>③SHR 逻辑右移</strong></p><p><a href="https://imgchr.com/i/aFwhvT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/27/aFwhvT.md.png" srcset="/img/loading.gif" alt="aFwhvT.md.png"></a></p><p><strong>④SAR 算术右移</strong></p><p><img src="https://s1.ax1x.com/2020/07/27/aFwLP1.png" srcset="/img/loading.gif" alt="aFwLP1.png"></p><p><strong>⑤ROL循环左移</strong></p><p><a href="https://imgchr.com/i/aFwjxK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/27/aFwjxK.md.png" srcset="/img/loading.gif" alt="aFwjxK.md.png"></a></p><p><strong>⑥ROR 循环右移</strong></p><p><a href="https://imgchr.com/i/aF0kGt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/27/aF0kGt.md.png" srcset="/img/loading.gif" alt="aF0kGt.md.png"></a></p><p><strong>TIPS：以上所说的移动一位，指的是二进制的一位，并非十六进制的一位</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;对AX中内容实现半字交换，即交换AH和AL中的内容。<br>MOV   CL，8<br>ROL   AX，CL <br>;如指令执行前，AX&#x3D;1234H，指令执行后，AX&#x3D;3412H。<br></code></pre></div></td></tr></table></figure><h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><p><strong>①MOVS 串传送</strong></p><p>MOVS   DST,  SRC  ;将源串SRC传送到目的串DST中<br>MOVSB                    ;以字节为单位传送<br>MOVSW                   ;以字为单位传送</p><p>字节操作:<br>    <strong>(ES:DI)←(DS:SI)</strong>, SI=SI±1, DI=DI±1<br>字操作:<br>    <strong>(ES:DI)←(DS:SI),</strong> SI=SI±2, DI=DI±2</p><p>CLD 设置正向</p><p>STD 设置反向</p><p><strong>实现整个串传送的准备工作：</strong></p><p>SI=源串首地址（如反向传送则是末地址）.<br>DI=目的串首地址（如反向传送则是末地址）.<br>CX=串长度.<br>设置方向标志DF.  </p><p><strong>例题：</strong></p><p>在数据段中有一个字符串MESS，其长度为19，要求把它们转送到附加段中名为BUFF的一个缓冲区中，并显示出BUFF字符串，编制程序如下所示</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>    mess db &#39;yu bao zui shuai$&#39;<br>DATAS ENDS<br><br>ext segment<br>buff db 19 dup(?)<br>ext ends<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    mov ax,ext<br>    mov es,ax<br>    lea si,mess<br>    lea di,buff<br>    mov cx, 17<br>    cld<br>    rep movsb<br>    mov bx,es<br>    mov ds,bx<br>    lea dx,buff<br>    mov ah,9<br>    int 21h<br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><p><strong>②CMPS 串比较</strong></p><p>CMPS  SRC，DST ;操作数寻址方式固定<br>CMPSB                   ;字节<br>CMPSW                   ;字 </p><p>字节操作:<br>    (ES:DI)-(DS:SI), SI=SI±1, DI=DI±1<br>字操作:<br>    (ES:DI)-(DS:SI), SI=SI±2, DI=DI±2<br>指令不保存结果，只是根据结果设置标志位。</p><p><strong>例题：</strong></p><p>在数据段中有一个长度为19的字符串MESS1，还有一个长度为19的字符串MESS2，比较它们是否相等。若相等显示‘Y’，否则显示‘N’。编制程序如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>    mess1 db &#39;yu bao zui shuai$&#39;<br>    mess2 db &#39;yu bao zui shuai$&#39;<br>DATAS ENDS<br><br>STACKS SEGMENT<br>    ;此处输入堆栈段代码<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    mov es,ax<br>    lea si,mess1<br>    lea di,mess2<br>    mov cx,17<br>    cld<br>    repe cmpsb<br>    jz yes<br>    mov dx,&#39;N&#39;<br>    jmp disp<br>yes:<br>mov dx,&#39;Y&#39;<br>disp:<br>mov ah,2<br>int 21h<br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><p><strong>③SCAS 串扫描</strong></p><p>SCAS  DST   ;操作数寻址方式固定<br>SCASB          ;字节<br>SCASW         ;字 </p><p>字节操作:<br>    AL-(ES:DI), DI=DI±1<br>字操作:<br>    AX-(ES:DI), DI=DI±2</p><p>指令不保存结果，只是根据结果设置标志位。</p><p><strong>例题：</strong></p><p>在附加段中有一个字符串MESS，其长度为19，要求查找其中有无空格符，若有空格符，把首次发现的空格符改为‘#’，存回该单元，并显示‘Y’，否则显示‘N’。编制程序如下所示</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>    mess1 db &#39;yu bao zui shuai  $&#39;<br>DATAS ENDS<br><br>STACKS SEGMENT<br>    ;此处输入堆栈段代码<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    mov es,ax<br>    mov cx,19<br>    lea di,mess1<br>    mov al,&#39; &#39;<br>    cld<br>    repne scasb<br>    jz yes<br>    mov dl,&#39;N&#39;<br>    jmp disp<br>yes:<br>mov dl,&#39;Y&#39;<br>dec di<br>mov byte ptr es:[di],&#39;#&#39;<br>disp:<br>mov ah,2<br>int 21h<br>lea dx,mess1<br>mov ah,9<br>int 21h<br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><p><strong>④STOS 存入串</strong></p><p>STOS  DST   ;操作数寻址方式固定<br>STOSB          ;字节<br>STOSW         ;字 </p><p>字节操作:<br>    (ES:DI)←AL, DI=DI±1<br>字操作:<br>    (ES:DI)←AX, DI=DI±2</p><p><strong>例题：</strong></p><p>写出把附加段EXT中的首地址为MESS，长度为9个字的缓冲区置为0值的程序片段。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV AX,MESS<br>MOV ES,AX<br>LEA DI,MESS<br>MOV CX,9<br>MOV AX,&#39;0&#39;<br>CLD<br>REP STOSW<br></code></pre></div></td></tr></table></figure><p><strong>⑤LODS 从串取</strong></p><p>LODS  SRC   ;操作数寻址方式固定<br>LODSB          ;字节<br>LODSW         ;字 </p><p>字节操作:<br>    AL←(DS:SI), SI=SI±1<br>字操作:<br>    AX←(DS:SI), SI=SI±2<br>指令一般不和REP连用。</p><p><strong>⑥REP/REPE/REPZ/REPNE/REPNZ 重复</strong></p><p><strong>REP                             重复</strong><br><strong>REPE / REPZ              相等或为零则重复</strong><br><strong>REPNE / REPNZ         不相等或不为零则重复</strong></p><p><strong>REP的作用</strong><br>重复执行串操作指令，直到CX=0为止.，串操作指令每执行一次，使CX自动减1. </p><p><strong>REPE/REPZ的作用</strong></p><p>当CX ≠ 0  并且  ZF=1时，重复执行串操作指令，直到CX=0 或者 ZF=0为止。串操作指令每执行一次，使CX自动减1. </p><p><strong>REPNE/REPNZ的作用</strong><br>当CX ≠ 0  并且  ZF=0时，重复执行串操作指令，直到CX=0 或者 ZF=1为止。串操作指令每执行一次，使CX自动减1.</p><h3 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h3><p><strong>①JMP 无条件转移指令</strong></p><p>转移的目标地址和本跳跳转指令在同一个代码段，则为<strong>段内转移</strong>；否则是<strong>段间转移</strong>。</p><p>转移的目标地址在跳转指令中直接给出，则为<strong>直接转移</strong>；否则是<strong>间接转移</strong>。</p><p><strong>1.段内直接转移</strong></p><p>格式: JMP  NEAR  PTR   OPR<br>操作: IP←IP+16位位移量<br>NEAR  PTR为目标地址OPR的属性说明，表明是一个近（段内）跳转，通常可以省略。<br>位移量是带符号数，IP的值可能减小（程序向后跳），也可能增加（程序向前跳）</p><p>就是平时最经常写的那一种，例如 JMP DISP</p><p><strong>2.段内间接转移</strong></p><p>格式: JMP  WORD PTR   OPR<br>操作: IP←（EA）<br>可以使用除立即数以外的任何一种寻址方式。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;如果BX&#x3D;2000H，DS&#x3D;4000H，(42000H)&#x3D;6050H，(44000H)&#x3D;8090H，TABLE的偏移地址为2000H，分析下面四条指令单独执行后IP的值。<br>JMP   BX                ;寄存器寻址，IP&#x3D;BX<br>JMP  WORD PTR [BX]      ;寄存器间接寻址，IP&#x3D;[DS:BX]<br>JMP  WORD PTR TABLE     ;直接寻址，IP&#x3D;[DS:TABLE]<br>JMP  TABLE[BX]          ;寄存器相对寻址，IP&#x3D;[DS:(TABLE+BX)]<br>;第一条指令执行后，IP&#x3D;BX&#x3D;2000H。<br>;第二条指令执行后，IP&#x3D;(DS:2000H)&#x3D;(40000H+2000H)&#x3D;(42000H)&#x3D;6050H。<br>;第三条指令执行后，IP&#x3D;(DS:2000H)&#x3D;(40000H+2000H)&#x3D;(42000H)&#x3D;6050H。<br>;第四条指令执行后，IP&#x3D;(DS:4000H)&#x3D;(40000H+4000H)&#x3D;(44000H)&#x3D;8090H。<br></code></pre></div></td></tr></table></figure><p><strong>3.段间直接转移</strong></p><p>格式: JMP  FAR  PTR  OPR<br>操作: IP←OPR的偏移地址<br>         CS←OPR所在段的段地址</p><p><strong>4.段间间接转移</strong></p><p>格式: JMP  DWORD PTR   OPR<br>操作: IP←（EA）<br>          CS←（EA+2）<br>可以使用除立即数和寄存器方式以外的任何一种寻址方式。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">如果BX&#x3D;2000H，DS&#x3D;4000H，(42000H)&#x3D;6050H，(42002H)&#x3D;1234H，指出下面指令执行后IP和CS的值。<br>JMP DWORD PTR [BX]<br>指令执行后，IP&#x3D;(DS:2000H)&#x3D;(40000H+2000H)&#x3D;(42000H)&#x3D;6050H；CS&#x3D;(42002H)&#x3D;1234H。<br></code></pre></div></td></tr></table></figure><p><strong>②条件转移指令</strong></p><p>条件转移指令根据上一条指令所设置的标志位来判别测试条件，从而决定程序转向。<br>通常在使用条件转移指令之前，应有一条能产生标志位的前导指令，如CMP指令。<br>汇编指令格式中，转向地址由标号表示。<br>所有的条件转移指令都不影响标志位。 </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">JZ  (JE)    <br>结果为零转移<br>格式: JZ   OPR<br>测试条件:ZF&#x3D;1<br>    <br>JNZ  (JNE)    <br>结果不为零转移<br>格式: JNZ   OPR<br>测试条件:ZF&#x3D;0<br><br>JS      <br>结果为负转移<br>格式: JS   OPR<br>测试条件:SF&#x3D;1<br><br>JNS OPR    <br>结果不为负（为正）转移<br>测试条件:SF&#x3D;0<br><br>JO  OPR    <br>结果溢出转移<br>测试条件:OF&#x3D;1<br><br>JNO  OPR    <br>结果不溢出转移<br>测试条件:OF&#x3D;0<br><br>JP (JPE)     <br>奇偶位为1转移<br>格式: JP   OPR<br>测试条件:PF&#x3D;1<br><br>JNP (JPO)     <br>奇偶位为0转移<br>格式: JNP   OPR<br>测试条件:PF&#x3D;0<br><br>JB (JNAE,JC)  <br>低于,(不高于等于,进位位为1),则转移.<br>格式: JB   OPR<br>测试条件:CF&#x3D;1<br><br>JNB (JAE,JNC)  <br>不低于,(高于等于,进位位为0),则转移.<br>格式: JNB   OPR<br>测试条件:CF&#x3D;0<br><br>JCXZ <br>测试CX寄存器的值为0则转移<br>格式: JCXZ   OPR <br>测试条件:CX&#x3D;0<br><br><br>;比较两个无符号数,根据结果转移<br>JB (JNAE,JC)  <br>低于,(不高于或等于,进位位为1),则转移.<br>格式: JB   OPR<br>测试条件:CF&#x3D;1<br><br>JNB (JAE,JNC)  <br>不低于,(高于等于,进位位为0),则转移.<br>格式: JNB   OPR<br>测试条件:CF&#x3D;0<br><br>JBE (JNA)  <br>低于或等于,(不高于),则转移.<br>格式: JBE   OPR<br>测试条件:CF OR  ZF&#x3D;1<br><br>JNBE (JA)  <br>不低于或等于,（高于),则转移.<br>格式: JNBE   OPR<br>测试条件:CF  OR  ZF&#x3D;0<br>     <br>     <br>;比较两个带符号数,根据结果转移<br>JL   (JNGE) <br>小于,(不大于等于),则转移.    &lt;<br>格式: JL   OPR<br>测试条件:SF XOR OF&#x3D;1<br>     <br>JNL   (JGE)  <br>不小于,(大于等于),则转移.    &gt;&#x3D;<br>格式: JNL   OPR<br>测试条件:SF XOR OF&#x3D;0<br>     <br>JLE   (JNG)  <br>小于等于,(不大于),则转移.    &lt;&#x3D;<br>格式: JLE   OPR<br>测试条件:(SF XOR OF) OR ZF&#x3D;1<br><br>JNLE   (JG)  <br>不小于等于,(大于),则转移.    &gt;<br>格式: JNLE   OPR<br>测试条件:(SF XOR OF) OR ZF&#x3D;0<br></code></pre></div></td></tr></table></figure><p><strong>例题：</strong></p><p>有一个长为19字节的字符串，首地址为MESS。查找其中的‘空格’(20H) 字符,如找到则继续执行，否则转标号NO。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MOV CX,19<br>MOV AL,20H<br>MOV DI,-1<br>LK:<br>INC DI<br>CMP AL,MESS[DI]<br>JCXZ NO<br>JNE LK<br></code></pre></div></td></tr></table></figure><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>LOOP                          循环<br>LOOPZ / LOOPE        为零或相等时循患<br>LOOPNZ / LOOPNE   不为零或不相等时循环</p><p>指令：LOOP    OPR<br>测试条件:CX ≠ 0，则循环</p><p>指令：LOOPZ / LOOPE    OPR<br>测试条件:ZF=1  AND  CX≠0 ，则循环</p><p>指令：LOOPNZ / LOOPNE    OPR<br>测试条件:ZF=0  AND  CX≠0 ，则循环</p><p>操作: <strong>首先CX寄存器减1</strong>，然后根据测试条件决定是否转移。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;在首地址为MESS长为19字节的字符串中查找 ‘空格’(20H) 字符,如找到则继续执行，否则转标号NO。用循环指令实现程序的循环。<br>MOV     AL，20H<br>MOV     CX，19<br>MOV     DI，-1<br>LK: INC     DI<br>CMP     AL, MESS[DI] <br>LOOPNE  LK<br>JNZ     NO<br></code></pre></div></td></tr></table></figure><h2 id="Ch6-伪指令和源程序格式"><a href="#Ch6-伪指令和源程序格式" class="headerlink" title="Ch6-伪指令和源程序格式"></a>Ch6-伪指令和源程序格式</h2><h3 id="伪指令概述"><a href="#伪指令概述" class="headerlink" title="伪指令概述"></a>伪指令概述</h3><p><strong>指令</strong>是在程序运行期间由计算机的CPU来执行的。</p><p><strong>伪指令</strong>是在汇编程序对源程序进行<strong>汇编期间由汇编程序处理的操作</strong>。</p><p><strong>段定义伪指令格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">segment_name    SEGMENT<br> ……<br>segment_name    ENDS<br></code></pre></div></td></tr></table></figure><p><strong>ASSUME伪指令格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ASSUME register_name:segment_name,register_name:segment_name<br></code></pre></div></td></tr></table></figure><p><strong>数据定义与存储器单元分配伪指令</strong></p><p>定义数据类型的伪指令：</p><p><strong>DB：用来定义字节，其后的每个操作数都占用1个字节。</strong><br><strong>DW：用来定义字，其后的每个操作数都占用1个字。</strong><br><strong>DD：用来定义双字，其后的每个操作数都占用2个字。</strong><br>DF：用来定义六个字节的字，其后的每个操作数都占用48位。<br>DQ：用来定义4个字，其后的每个操作数都占用4个字。<br>DT：用来定义10个字节，其后的每个操作数都占用10个字节。</p><p><strong>DUP</strong> <strong>复制伪指令</strong><br><strong>格式：</strong>count  DUP (operand, …, operand)<br><strong>操作：</strong>将括号中的操作数重复count次，count可以是一个表达式，其值应该是一个正数。</p><p>DUP操作可嵌套。 </p><p><strong>例子1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">D_BYTE    DB  10, 10H<br>D_WORD    DW  14,100H,-5，0ABCDH<br>D_DWORD   DD  4×8<br></code></pre></div></td></tr></table></figure><p>数据在内存中的存放如下:</p><p><strong>0A  10  0E  00  00  01  FB  FF  CD AB 20 00 00 00</strong></p><p><strong>解释：</strong></p><p><strong>0A:</strong> 10     10: 10H    </p><p><strong>0E 00(因为是字所以16位):</strong>即00 0E，即14,内存中反着装 </p><p><strong>00 01：</strong>即01 00，即100H，内存中是反着的</p><p><strong>FB FF：</strong>即-5的补码</p><p><strong>CD AB:</strong>即0ABCDH</p><p><strong>20 00 00 00:</strong>即 00 00 00 20H=32</p><p><strong>例子2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">MESSAGE DB ‘HELLO?’,?     ;问号?通常被系统置0<br>    DB ‘AB’，?<br>        DW ‘AB’           ;注意这里‘AB’作为串常量按字类型存放<br></code></pre></div></td></tr></table></figure><p>数据在内存中的存放如下:</p><p>48  45 4C 4C 4F — 41 42 — 42 41</p><p>48  45 4C 4C 4F 3F: ‘HELLO?’</p><p>— : ？ 预留的空间</p><p>41 42 — :’AB’ 和 ？预留的空间</p><p>42 41：‘AB’</p><p><strong>这里需要解释为什么 ‘AB’ 在DB和DW没有什么区别呢？</strong></p><p>因为’AB’在DW时依然是按照一个字符一个字符存入的，对于 DW ‘A’,’B’才是一个字符占用16位。</p><p>我们做个实验可以发现  DW ‘ba’,’c’,’e’ 中ba和c，e的存放是有区别的。</p><p><img src="https://s1.ax1x.com/2020/07/28/aA6xpQ.png" srcset="/img/loading.gif" alt="aA6xpQ.png"></p><p><strong>例子3：</strong></p><p>用操作符复制操作数。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ARRAY   DB 2 DUP(1,3,2 DUP(4,5))<br></code></pre></div></td></tr></table></figure><p>ARRAY:即为 1 3 4 5 4 5    1 3 4 5 4 5</p><p>在内存中存放即为： 01 03 04 05 04 05   01 03 04 05 04 05</p><p><strong>TIPS:</strong></p><p>1.数据在内存中负数以补码形式存储。</p><p>2.允许数据表达式，例如 D_DWORD   DD  4×8。</p><p>3.搞清楚 DW ‘ba’,’c’,’e’ 中ba和c，e的存放是有区别，DW ‘AB’ 和 DB ‘AB’存放无区别</p><p>4.DUP 格式和代表的意义需要清楚</p><h3 id="类型属性操作符"><a href="#类型属性操作符" class="headerlink" title="类型属性操作符"></a>类型属性操作符</h3><p><strong>WORD PTR    ；字类型</strong>      </p><p><strong>BYTE PTR     ；字节类型</strong> </p><p>类型属性操作符仅是指定变量的“访问类型”，并不改变变量本身的类型。</p><p>在指令中用类型属性操作符指定对内存变量的访问类型，以匹配两个操作数。<br>    OPER1    DB  3, 4<br>    OPER2    DW  5678H, 9<br>    ┇<br>    MOV   AX，OPER1     ；操作数类型不匹配<br>    MOV   BL, OPER2       ；操作数类型不匹配<br>    MOV   [DI], 0                ；操作数类型不明确<br>这三条指令可改为：<br>    MOV   AX，WORD PTR OPER1     ；从OPER1处取一个字使AX=0403H<br>    MOV   BL, BYTE PTR OPER2     ；从OPER2处取一个字节使BL=78H<br>    MOV   BYTE PTR[DI], 0               ；常数0送到内存字节单元</p><h3 id="THIS操作符和LABEL伪操作"><a href="#THIS操作符和LABEL伪操作" class="headerlink" title="THIS操作符和LABEL伪操作"></a>THIS操作符和LABEL伪操作</h3><p>一个变量可以定义成不同的访问类型，THIS操作符或LABEL伪操作都可以实现。<br>格式：name = THIS  type<br>格式：name   LABEL  type<br>操作：指定一个类型为type的操作数，使该操作数的地址与下一个存储单元地址相同。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">BUF&#x3D;THIS WORD           <br>DAT  DB  8,9 <br>OPR_B   LABEL  BYTE<br>OPR_W   DW  4 DUP(2)<br>┇<br>MOV   AX,  1234H<br>MOV   OPR_B, AL<br>MOV   OPR_W+2, AX<br>MOV   DAT+1, AL<br>MOV   BUF, AX<br>;表达式BUF&#x3D;THIS  WORD使BUF和DAT指向同一个内存单元。<br>;LABE伪操作使得OPR_B和OPR_W指向同一个内存单元。<br></code></pre></div></td></tr></table></figure><p>BUF=THIS WORD<br>DAT  DB  8,9<br>OPR_B   LABEL  BYTE<br>OPR_W   DW  4 DUP(2) </p><p>这四句话定义完后，内存中数据如下：</p><p>08 09 02 00 02 00 02 00 02 00</p><p>BUF和DAT都指向08，   OPR_B和OPR_W都指向第一个02 </p><p>执行MOV   OPR_B, AL 后   =&gt;        08 09 <strong>34</strong> 00 02 00 02 00 02 00</p><p>执行MOV   OPR_W+2, AX 后   =&gt;  08 09 34 00 <strong>34 12</strong> 02 00 02 00</p><p>执行MOV   DAT+1, AL后     =&gt;       08 <strong>12</strong> 34 00 34 12 02 00 02 00</p><p>执行MOV   BUF, AX后     =&gt;           <strong>34</strong> <strong>12</strong> 34 00 34 12 02 00 02 00</p><h3 id="表达式赋值伪指令“EQU”-和"><a href="#表达式赋值伪指令“EQU”-和" class="headerlink" title="表达式赋值伪指令“EQU” 和="></a>表达式赋值伪指令“EQU” 和=</h3><p>可以用赋值伪操作给表达式赋予一个常量或名字。格式如下：<br>    Expression_name  <strong>EQU</strong>  Expression<br>    Expression_name  =  Expression</p><p><strong>TIPS：</strong></p><p>1.表达式中的变量或标号，必须<strong>先定义后引用</strong>。</p><p>2.<strong>EQU伪操作中的表达式名是不允许重复定义的，而“＝”伪操作则允许重复定义。</strong> </p><p>例如：VALUE =53    </p><p>​            VALUE = VALUE + 89 </p><p>这是正确的，但是=换成EQU就是错误的，因为EQU不允许重复定义。</p><h3 id="汇编地址计数器-与定位伪指令"><a href="#汇编地址计数器-与定位伪指令" class="headerlink" title="汇编地址计数器$与定位伪指令"></a>汇编地址计数器$与定位伪指令</h3><p><strong>①地址计数器$</strong></p><p>1.地址计数器是一个16位的变量，<strong>用$表示</strong><br>2.开始汇编或在每一段开始时，将<strong>地址计数器初始化为零</strong>。<br>3.当在指令中用到$时，它只代表此指令的首地址，而与$本身无关。</p><p>例如：jmp $+6 表示转向地址是JMP指令的首地址加上6 </p><p>4.当$用在伪操作的参数字段时，它所表示的是地址计数器的当前值。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">array dw 1,2,$+4,3,4,$+4， ;array分配的偏移地址 为0074。<br>[0074]  01,00 ,  02,00,  7C,00, 03,00,  04,00, 82,00<br></code></pre></div></td></tr></table></figure><p>7C=$(0078)+4=007C   后面同理，由于$的值在不断变换，因此两个$+4的值是不同的。</p><p><strong>TIPS：</strong></p><p>这里$每次+1的1代表一个字节，如果定义的数据类型是DW(字)，$每次则要＋2</p><p><strong>②ORG 伪操作</strong> </p><p>ORG伪操作用来<strong>设置当前地址计数器的值</strong>。</p><p>格式：ORG  constant expression<br>操作：如常数表达式的值为n，则该操作指示下一个字节的存放地址为n。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ORG  0<br>DB   3<br>ORG  4<br>BUFF DB 6<br>ORG  $+6<br>VAL  DB  9<br></code></pre></div></td></tr></table></figure><p>内存中数据存放： 03 — — — 06 — — — — — — 09</p><p><strong>③EVEN 伪操作</strong><br>EVEN伪操作使下一个变量或指令开始于偶数地址。</p><p><strong>④ALIGN 伪操作</strong><br>ALIGN伪操作使下一个变量的地址从4的倍数开始。</p><h3 id="过程定义伪指令"><a href="#过程定义伪指令" class="headerlink" title="过程定义伪指令"></a>过程定义伪指令</h3><p>过程定义包含两条伪指令：PROC和ENDP。</p><p>PROC表示过程的开始，ENDP表示过程的结束。</p><p>过程定义语句的格式：<br>          过程名  PROC  [属性]         ；过程开始<br>                                                        ；过程体<br>          过程名  ENDP                     ；过程结束<br>功能：定义一个过程(子程序)。</p><p>属性可以是FAR或NEAR类型。NEAR为近，是段内调用。FAR类型为远，是跨段调用，缺省时为NEAR。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">data    segment                 ;定义数据段data<br>    string   db ‘hello,world!$’<br>data    ends<br>code    segment                 ;定义代码段code<br>assume  cs:code,ds:data         <br>main   proc  far                ;定义过程main<br>mov  ax,data             <br>mov  ds,ax<br>mov  dx,offset string<br>mov  ah,9<br>int  21h<br>mov  ah,4ch<br>int  21h<br>main    endp<br>code    ends<br>end   main                 ;汇编结束, 程序起始点main<br></code></pre></div></td></tr></table></figure><h3 id="表达式和操作符"><a href="#表达式和操作符" class="headerlink" title="表达式和操作符"></a>表达式和操作符</h3><p><strong>①算术操作符</strong></p><p>算术运算符主要有+、－、*、/、MOD。</p><p>MOD也称为取模，它得到除法之后的余数。</p><p>减法运算可用于段内两个操作数地址（以变量名表示）的运算，其结果是一个常数，表示这两个变量之间相距的字节数。</p><p>TIPS：算术操作符的使用中，<strong>常量</strong>间可以用各种操作符，<strong>变量和常量</strong>间<strong>有物理意义</strong>才能用</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ORG 0<br>VAL&#x3D;4<br>DA1  DW  6，2，9，3<br>DA2  DW  15，17，24<br>COU&#x3D;$-DA2<br><br>MOV   AX,DA1*4           ;错，地址乘或除，没有意义<br>MOV   AX,DA1*DA2         ;错，地址乘或除，没有意义<br>MOV   AX，DA1+DA2        ;错，地址相加，没有意义<br>MOV   AX，BX+VAL         ;错，BX+VAL须用指令实现<br>MOV   AX，[BX+VAL]       ;地址表达式，汇编成MOV  AX，[BX+4]<br>MOV   AX，DA1+VAL        ;地址表达式，汇编成MOV  AX，[4]<br>MOV   AX，[DA1+VAL]      ;地址表达式，汇编成MOV  AX，[4]<br>MOV   AX，VAL*4&#x2F;2        ;数字表达式，汇编成MOV  AX，8<br>MOV   AX，[VAL*4&#x2F;2]      ;数字表达式，汇编成MOV  AX，8 <br>MOV   CX，(DA2-DA1)&#x2F;2    ;得到DA1区数据个数,汇编成MOV  CX，4 <br>MOV   BX，COU            ;得到DA2区的字节数,汇编成MOV  BX，6<br></code></pre></div></td></tr></table></figure><h3 id="逻辑与移位操作符"><a href="#逻辑与移位操作符" class="headerlink" title="逻辑与移位操作符"></a>逻辑与移位操作符</h3><p>逻辑操作符：AND,  OR,  NOT, XOR。<br>移位操作符：SHL和SHR。</p><p>格式：expression  操作符 number<br>逻辑与移位操作符都是按位进行的。<br>逻辑与移位操作符都<strong>只能</strong>用于<strong>数字表达式</strong>中。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ARY  DW  8<br>VAL&#x3D;4<br>MOV   AX，BX AND 0FFH    ;错，BX AND VAL须用指令实现<br>MOV   AX，ARY AND 0FFH   ;错，ARY AND VAL须用指令实现<br>MOV   AX，VAL AND 0F0H   ;汇编成MOV  AX,0<br>AND   AX，VAL OR 0F0H    ;汇编成AND  AX,0F4H<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ARY  DW   8<br>VAL&#x3D;4<br>MOV   AX,BX SHL 2      ;错，BX 左移须用指令实现<br>MOV   AX,ARY SHL 2     ;错，ARY 左移须用指令实现<br>MOV   AX,VAL SHL 2     ;汇编成MOV  AX，10H<br>MOV   AX,8  SHL 2      ;汇编成MOV  AX，20H<br>MOV   AX,VAL SHL 15    ;汇编成MOV  AX，00H<br></code></pre></div></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符用来对两个操作数的大小关系作出判断。<br>        EQ（相等）<br>        NE（不相等）<br>        LT（小于）<br>        LE（小于等于）<br>        GT（大于）<br>        GE（大于等于）</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">VAL&#x3D;4<br>MOV   AX,BX GT 2     ;错，BX 是否大于2须用指令实现判断<br>MOV   AX,VAL GE 2    ;汇编成MOV  AX，FFFFH<br>MOV   AX,8 LE VAL    ;汇编成MOV  AX，0<br></code></pre></div></td></tr></table></figure><h3 id="数值回送操作符"><a href="#数值回送操作符" class="headerlink" title="数值回送操作符"></a>数值回送操作符</h3><p><strong>①TYPE</strong></p><p>格式：TYPE  expression<br>表达式为变量，则汇编程序回送该变量的以字节数表示的类型。<br>     DB        回送1           DW       回送2<br>     DD        回送4           DF         回送6<br>     DQ        回送8           DT         回送10<br>表达式为标号，则汇编程序回送代表该标号类型的数值。<br>     NEAR    回送-1<br>     FAR       回送-2<br>表达式为常数则回送0。 </p><p><strong>②LEN</strong></p><p>格式： LENGTH  variable </p><p>若变量用DUP定义，则返回总变量数，否则为1。</p><p><strong>嵌套的DUP不计</strong>。所以，对于使用嵌套的DUP复制的数据不能据此得到正确的总变量数。</p><p>例如：</p><p>BUFF DW 4DUP(4DUP(3))</p><p>LEN BUFF 的值是4</p><p><strong>③SIZE</strong> </p><p>格式：SIZE  variable </p><p>若变量用DUP定义，则返回总字节数，否则为单个变量的字节数。</p><p><strong>嵌套的DUP不计</strong>，所以，对于使用嵌套的DUP复制的数据不能据此得到正确的总字节数。</p><p> <strong>④OFFSET</strong> </p><p>格式：OFFSET    variable或label<br>操作：回送变量或标号的偏移地址。</p><p><strong>⑤SEG</strong> </p><p>格式：SEG    variable或label<br>操作：回送变量或标号的段地址。 </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">ORG  0<br>VAL&#x3D;4<br>ARR  DW  4  DUP(3)<br>BUF  DW  4  DUP( 4 DUP(3))<br>DAT  DW  15，17，24<br>STR  DB  ‘ABCDEF’<br>;汇编程序对下面的指令汇编结果为：<br>MOV   AX，TYPE ARR             ;汇编成MOV  AX，2<br>MOV   AX，LENGTH  ARR          ;汇编成MOV  AX，4<br>MOV   AX，LENGTH  BUF          ;汇编成MOV  AX，4<br>MOV   AX，LENGTH  DAT          ;汇编成MOV  AX，1<br>MOV   AX，SIZE  ARR            ;汇编成MOV  AX，8<br>MOV   AX，SIZE  BUF            ;汇编成MOV  AX，8（不是32）<br>MOV   AX，SIZE  DAT            ;汇编成MOV  AX，2<br>MOV   AL，SIZE  STR            ;汇编成MOV  AX，1<br>MOV   AX，OFFSET  ARR          ;不完整的机器指令<br>MOV   BX，SEG  ARR             ;不完整的机器指令<br></code></pre></div></td></tr></table></figure><h2 id="Ch7-分支与循环程序设计"><a href="#Ch7-分支与循环程序设计" class="headerlink" title="Ch7-分支与循环程序设计"></a>Ch7-分支与循环程序设计</h2><h3 id="单分支结构程序"><a href="#单分支结构程序" class="headerlink" title="单分支结构程序"></a>单分支结构程序</h3><p><img src="https://s1.ax1x.com/2020/07/28/aEYwOe.png" srcset="/img/loading.gif" alt="aEYwOe.png"></p><p><strong>例题：</strong></p><p>双字长数存放在DX和AX寄存器中(高位在DX)，求该数的绝对值(用16位指令)。 </p><p>算法分析：</p><ol><li>双字长数高字在DX中，低字在AX中；</li><li>判该数的正负，为正数（最高位为0），该数不处理；为负数，就对该数求补（即反码加1）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    <br>    mov dx,9000h<br>    mov ax,1234h<br>    <br>    cmp dx,8000h<br>    jb exit<br>    not ax<br>    not dx<br>    add ax,1<br>    adc dx,0<br>exit:<br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="复合分支程序"><a href="#复合分支程序" class="headerlink" title="复合分支程序"></a>复合分支程序</h3><p><strong>例题：</strong></p><p>从键盘输入一位十六进制数，并将其转换为十进制数输出显示。</p><p>算法分析：<br>     从键盘输入一个十六进制数，有以下四种情况：</p><div class="hljs code-wrapper"><pre><code>    1. 为数字0～9（ASCII码30～39H），无需处理，直接输出；    2. 为大写字母A～F（ASCII码41～46H），先输出31H，再输出该数ASCII码-11H；    3. 为小写字母a～f（ASCII码61～66H），先输出31H，再输出该数ASCII码-31H；    4. 该数不为0～9、A～F、a～f，是非法字符，应退出程序或输出错误信息。</code></pre></div><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>    mess1 db &#39;yu bao zui shuai  $&#39;<br>DATAS ENDS<br><br>STACKS SEGMENT<br>    ;此处输入堆栈段代码<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    <br>    mov ah,1<br>    int 21h<br>    cmp al,30h<br>    jl error<br>    cmp al,39h<br>    jle num<br>    cmp al,41h<br>    jl error<br>    cmp al,46h<br>    jle bigletter<br>    cmp al,61h<br>    jl error<br>    cmp al,66h<br>    jle smallletter<br>    jmp error<br>num:<br>mov ah,2<br>mov dl,al<br>int 21h<br>jmp exit<br>bigletter:<br>mov ah,2<br>mov dl,&#39;1&#39;<br>push ax<br>int 21h ;int指令会改写ax<br>pop ax<br>mov ah,2<br>sub al,11h<br>mov dl,al<br>int 21h<br>jmp exit<br>smallletter:<br>mov ah,2<br>mov dl,&#39;1&#39;<br>push ax<br>int 21h<br>pop ax<br>mov ah,2<br>sub al,31h<br>mov dl,al<br>int 21h<br>jmp exit<br>error:<br>mov ah,2<br>mov dl,&#39;N&#39;<br>int 21h<br>exit:<br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="多分支程序"><a href="#多分支程序" class="headerlink" title="多分支程序"></a>多分支程序</h3><p><strong>分支向量表：</strong></p><p>如果在分支结构中有超过两个以上的多个可供选择的分支，这就是多分支结构。</p><p>如果对多分支的条件逐个查询以确定是哪一个分支，只会增加代码和时间，为了尽快进入某个分支，可以采用分支向量表法。 </p><p><strong>例题：</strong></p><p>根据键盘输入的一位数字(1～4)，使程序转移到4个不同的分支中去，以显示键盘输入的数字。</p><p>算法分析：从键盘输入一个数1～4，</p><div class="hljs code-wrapper"><pre><code>   1. 建立一个分支向量表branch ，集中存放四个分支的偏移地址；   2. 每个偏移地址位16位，占用2个单元；   3. 四个分支的偏移地址在转移地址表的地址是：转移地址表首址+输入数字（0～3）×2；   4. 用间接寻址方式转向对应分支。</code></pre></div><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>DATAS ENDS<br><br>STACKS SEGMENT<br>    ;此处输入堆栈段代码<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    <br>    mov ah,1<br>    int 21h<br>    mov dl,al<br>    cmp al,31h<br>    jl exit<br>cmp al,34h<br>jnle exit<br>sub al,30h<br>dec al<br>shl bl,1<br>mov bh,0<br>jmp branch[bx]<br>r1:<br>mov ah,2<br>int 21h<br>jmp exit<br>r2:<br>mov ah,2<br>int 21h<br>jmp exit<br>r3:<br>mov ah,2<br>int 21h<br>jmp exit<br>r4:<br>mov ah,2<br>int 21h<br>exit:<br>    MOV AH,4CH<br>    INT 21H<br>    <br>branch dw r1  ;向量分支表<br>   dw r2<br>   dw r3<br>   dw r4<br><br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="循环计数程序"><a href="#循环计数程序" class="headerlink" title="循环计数程序"></a>循环计数程序</h3><p><strong>例题：</strong></p><p>把BX中的二进制数用十六进制显示.（设BX=123AH）</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br>    <br>    mov bx,123AH<br>    mov cx,4<br>shift:<br>rol bx,1<br>rol bx,1<br>rol bx,1<br>rol bx,1<br>mov al,bl<br>and al,0fh<br>add al,30h<br>cmp al,39h<br>jle disp1<br>jmp disp2<br>disp1:<br>mov dl,al<br>mov ah,2<br>int 21h<br>loop shift<br>disp2:<br>sub al,10<br>add al,&#39;A&#39;-&#39;0&#39;<br>mov dl,al<br>mov ah,2<br>int 21h<br>loop shift<br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="条件循环程序"><a href="#条件循环程序" class="headerlink" title="条件循环程序"></a>条件循环程序</h3><p>在循环程序中，有时候每次循环所做的操作可能不同，即循环体中有分支的情况，需要依据某一个标志来决定做何操作。标志位为1表示要做操作A，标志位为0表示要做操作B，我们可把这种标志字称为逻辑尺。 </p><p><strong>例题：</strong></p><p>从键盘输入8位二进制数作为逻辑尺。再输入一个英文字母，根据逻辑尺当前的最高位标志显示输出该字母的相邻字符，标志位为0则显示其前趋字符，标志位为1则显示其后继字符。显示相邻字符后，逻辑尺循环左移一位，再接收下一个字母的输入，并依据逻辑尺显示相邻字符，直到回车键结束程序。</p><p><strong>新转跳符：JNC</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br><br>mov bx,0<br>mov cx,8<br>inlog:<br>    mov ah,1<br>    int 21h<br>    cmp al,30h<br>    jb exit<br>    cmp al,31h<br>    ja exit<br>    sub al,30h<br>    shl bl,1<br>    add bl,al<br>    loop inlog<br>    mov ah,2     ;输出一个回车，换到下一行<br>    mov dl,10<br>    int 21h<br>inchar:<br>mov ah,1<br>int 21h<br>cmp al,13  ;检查是否为回车键，如果是则退出<br>je exit    ;<br>mov dl,al<br>rol bl,1<br>jnc k30  ;jnc的意思是如果没进位则转跳，这里由于做了rol bl，1。即bl首位如果是0则转跳k30<br>inc dl   ;否则找后继字符<br>jmp putc<br>k30:<br>dec dl<br>putc:<br>mov ah,2<br>int 21h<br>jmp inchar<br>exit: <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h3 id="条件计数循环程序"><a href="#条件计数循环程序" class="headerlink" title="条件计数循环程序"></a>条件计数循环程序</h3><p><strong>例题：</strong></p><p>设置键盘缓冲区为16个字节，从键盘输入一串字符，然后再从键盘输入一个单个字符，查找这个字符是否在字符串中出现，如果找到，显示该字符串，否则显示‘NOT FOUND’。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>buffer db 16,?,16 dup(?),13,10,&#39;$&#39;<br>input  db &#39;intput string:$&#39;<br>notfound db &#39;notfound$&#39;<br>inchar db &#39;input char:$&#39;<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>START:<br>    MOV AX,DATAS<br>    MOV DS,AX<br><br>mov ah,9<br>lea dx,input<br>int 21h<br>lea dx,buffer<br>mov ah,10<br>int 21h<br>mov dl,10<br>mov ah,2<br>int 21h<br>mov ah,9<br>lea dx,inchar<br>int 21h<br>mov ah,1<br>int 21h<br>mov bl,al<br>mov dl,10<br>mov ah,2<br>int 21h<br>lea di,buffer+1<br>mov cl,buffer+1 <br>seek:<br><br>inc di<br>cmp bl,[di]<br>jz disp<br>loop seek<br>jmp nofind<br>disp:<br>mov ah,9<br>lea dx,buffer+2<br>int 21h<br>jmp exit<br>nofind:<br>mov ah,9<br>lea dx,notfound<br>int 21h<br>exit:<br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></div></td></tr></table></figure><h2 id="Ch8-子程序设计"><a href="#Ch8-子程序设计" class="headerlink" title="Ch8-子程序设计"></a>Ch8-子程序设计</h2><h3 id="子程序结构"><a href="#子程序结构" class="headerlink" title="子程序结构"></a>子程序结构</h3><p><strong>①子程序调用指令</strong></p><p><strong>子程序定义：</strong>在模块化程序设计中，经常把程序中某些具有独立功能的部分编写成独立的程序模块，称为子程序。<br>主程序通过<strong>CALL指令调用子程序</strong>。<br>子程序执行完毕后通过<strong>RET指令回到主程序</strong>。</p><p><strong>CALL调用指令：</strong></p><p>格式: CALL  DST<br>操作：首先把下一条指令的地址（返回地址）压入堆栈保存，再把子程序的入口地址置入IP（CS）寄存器，以便实现转移。<br>   对于<strong>段内调用</strong>，只是向堆栈<strong>保存IP寄存器</strong>的值。（段内CS相同不需要记录）<br>   对于<strong>段间调用</strong>，是先向堆栈<strong>保存CS寄存器</strong>的值，再向堆栈<strong>保存IP寄存器</strong>的值。</p><p><strong>RET返回指令：</strong></p><p>格式1: RET<br>格式2: RET  EXP<br>操作：把堆栈里保存的返回地址送回IP（CS）寄存器，实现程序的返回。<br>   对于<strong>段内调用</strong>，弹出一个字到<strong>IP寄存器</strong>。<br>   对于<strong>段间调用</strong>，先弹出一个字到<strong>IP寄存器</strong>，再  弹出一个字到<strong>CS寄存器</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/29/ae58mT.png" srcset="/img/loading.gif" alt="ae58mT.png"></p><p><strong>解析：</strong>这个程序就是A调用B，然后B在调用C，需要注意的是,A调用B是段间调用，所以要CALL FAR PTR B,而B调用C是段内调用，要CALL NEAR PTR C。段间调用要压栈保护CS和IP，而段内调用只需要压栈保护IP即可。</p><p><img src="https://s1.ax1x.com/2020/07/29/aeImDK.png" srcset="/img/loading.gif" alt="aeImDK.png"></p><p><strong>②过程定义与过程结构</strong></p><p>过程定义伪指令<br>    Procedure_Name  PROC   Attribute<br>    ┇<br>   Procedure_Name  ENDP</p><p>如：<br>   main  proc   far /near<br>   ┇<br>   main  endp</p><p>NEAR为近，是段内调用。FAR类型为远，是跨段调用。<br>如调用程序和子程序在同一代码段，则使用NEAR属性；如调用程序和子程序不在同一代码段，则使用FAR属性。<br><strong>主程序的过程定义属性应为FAR。</strong>，因为dos首先会调用主程序main，因此第一次一定是远调</p><p>基本定义结构如下:</p><p>1.子程序和调用程序在一个代码段</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">main proc far<br>    …<br>call    subr<br>    …<br>ret<br>main endp<br><br>subr proc near ;子程序和调用程序在一个代码段,所以near<br>    …<br>ret<br>subr    endp<br></code></pre></div></td></tr></table></figure><p>2.子程序和调用程序不在一个代码段</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">code1 segment <br> …   <br>main proc far<br> …<br>call subr<br> …<br>ret<br>main endp<br>code1 ends<br><br>…<br><br>code2 segment <br>     …   <br>call subr<br>…<br>subr proc far<br>     …<br> ret<br>subr endp<br>code2 ends<br></code></pre></div></td></tr></table></figure><p><strong>③ 保存和恢复现场寄存器</strong></p><p>子程序调用 CALL：首先将返回地址压栈，然后把子程序的入口地址送入IP/CS寄存器。<br>子程序返回 RET：将堆栈里保存的返回地址送回IP/CS寄存器。<br>在子程序中对主程序的现场实施保护和恢复<br>在进入子程序后，对将<strong>要使用的寄存器，先保存这些寄存器的值</strong>，在子程序<strong>退出前恢复这些寄存器的值</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/29/amJUIJ.png" srcset="/img/loading.gif" alt="amJUIJ.png"></p><p>这里要注意 你压入的顺序和弹出的顺序是相反的。</p><h3 id="子程序的参数传递"><a href="#子程序的参数传递" class="headerlink" title="子程序的参数传递"></a>子程序的参数传递</h3><p>入口参数(调用参数)：主程序传递给子程序。<br>出口参数(返回参数)：子程序返回给主程序。<br>传递的参数：值传递和地址传递。</p><p><strong>①用寄存器传递参数</strong></p><p>用寄存器传递参数就是约定某些寄存器存放将要传递的参数。该方法简单，执行的速度也很快。但由于寄存器数量有限，不能用于传递很多的参数。</p><p>main中的三句话很重要，为的是可以正常返回，结束程序</p><p>main proc far<br>    push  ds<br>    xor   ax,ax<br>    push  ax  </p><p><strong>例题：</strong></p><p>从键盘输入一个十进制数（小于65536的正数），显示输出该数的十六进制形式。通过寄存器传送变量。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">dtohex segment<br>assume cs:dtohex<br>main proc far<br>push  ds   ;push ds<br>xor   ax,ax  <br>push  ax   ;push 0,使得栈中压入ds:0弹出后程序即可结束，这三句话很重要，经常考填空<br>call  dtob  ;十进制数键盘输入整合为二进制<br>call  crlf  ;输出回车换行<br>call  btoh  ;二进制转为十六进制显示<br>    ret   <br>main endp<br>;-------------------------------------------<br>dtob proc near<br>mov bx,0<br>intput:<br>mov ah,1<br>int 21h<br>sub al,30h<br>jl exit<br>cmp al,9<br>jg exit<br>cbw<br>xchg ax,bx<br>mov cx,10<br>mul cx<br>xchg ax,bx<br>add bx,ax<br>jmp input<br>exit:<br>ret<br>dtob endp<br>;----------------------------------------------<br>btoh proc near<br>mov ch,4<br>shift:<br>mov cl,4<br>rol bx,cl<br>mov al,bl<br>and al,0fh<br>add al,30h<br>cmp al,39h<br>jle dig<br>add al,7<br>dig:<br>mov dl,al<br>mov ah,2<br>int 21h<br>dec ch<br>jnz shift<br>ret<br>btoh endp<br></code></pre></div></td></tr></table></figure><p><strong>②用变量传递参数</strong></p><p>参数较多时可以用约定的变量在过程间传递参数。</p><p><strong>例题：</strong> </p><p>键盘输入字符串到缓冲区后，对缓冲区内容降序排序并输出。</p><p><strong>请仔细观察双循环的写法，十分重要十分重要十分重要十分重要十分重要</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>buff db 16<br>numb db ?<br>arry db 16 dup(?)<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>main proc far<br>push ds<br>sub ax,ax<br>push ax<br><br>mov ax,datas<br>mov ds,ax<br>call order<br>ret<br>main endp<br><br>order proc near<br>lea dx,buff<br>mov ah,10<br>int 21h<br>mov cl,numb<br>mov ch,0<br>mov di,cx<br>lp1:      <br>mov cx,di<br>mov bx,0<br>lp2:<br>mov al,arry[bx]<br>cmp al,arry[bx+1]<br>jnb nxt<br>xchg al,arry[bx+1]<br>mov arry[bx],al<br>nxt:<br>inc bx<br>loop lp2<br>dec di<br>jnz lp1<br>call output<br>ret<br>order endp<br><br>output proc near<br>mov bl,numb<br>mov bh,0<br>mov byte ptr[arry+bx],&#39;$&#39;<br>lea dx,arry<br>mov ah,9<br>int 21h<br>ret<br>output endp<br><br>CODES ENDS<br>    END main<br></code></pre></div></td></tr></table></figure><p><strong>③用地址表传递参数</strong></p><p>在主程序中建立一个地址表，把要传递的参数地址放在地址表中，然后把地址表的首地址放入寄存器，子程序通过寄存器间接寻址方式从地址表中取得所需参数，可以设计通用子程序处理其他类似字符串排序问题。</p><p><strong>例题：</strong></p><p>采用通过地址表传递参数地址的方法，键盘输入缓冲区并对其内容排序和输出。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">DATAS SEGMENT<br>buff db 16<br>numb db ?<br>arry db 16 dup(?)<br>table dw 3 dup(?);地址表<br>DATAS ENDS<br><br>STACKS SEGMENT<br>STACKS ENDS<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,DS:DATAS,SS:STACKS<br>main proc far<br>push ds<br>sub ax,ax<br>push ax<br><br>mov ax,datas<br>mov ds,ax<br>mov table,offset buff ;这里要注意，不可以用LEA table,buff ,因为lea后面要接寄存器，不是寄存器不能用，只可以lea bx，buff这样用。<br>mov table+2,offset numb<br>mov table+4,offset arry<br>mov bx,offset table<br>mov si,bx<br>call order<br>ret<br>main endp<br><br>order proc near<br>mov dx,[bx]<br>mov ah,10<br>int 21h<br>mov di,[bx+2]<br>mov cl,[di]<br>mov ch,0<br>mov di,cx<br>lp1:<br>mov cx,di<br>mov bx,[si]<br>add bx,2<br>lp2:<br>mov al,[bx]<br>cmp al,[bx+1]<br>jbe nxt<br>xchg al,[bx+1]<br>mov [bx],al<br>nxt:<br>inc bx<br>loop lp2<br>dec di<br>jnz lp1<br><br>call output<br>ret<br>order endp<br><br>output proc near<br>mov bl,numb<br>mov bh,0<br>mov byte ptr[arry+bx],&#39;$&#39;<br>lea dx,arry<br>mov ah,9<br>int 21h<br>ret<br>output endp<br><br>CODES ENDS<br>    END main<br></code></pre></div></td></tr></table></figure><p><strong>④用堆栈传递参数</strong></p><p><strong>例题：</strong></p><p>键盘输入缓冲区内容排序并输出，用堆栈传递参数地址。</p><p>提示：会考这三句设置ss和sp</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;设置ss和sp,很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要<br>mov ax,data<br>mov ss,ax<br>lea sp,tos<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">data segment <br>dw 50 dup(?)         ;堆栈50个字<br>tos label  word      ;栈顶地址tos<br>buff db 16<br>numb db ?<br>arry db 16 dup(?)<br>data ends<br>code segment<br>assume  cs:code，ds:data，ss:data<br>main proc far<br>;设置ss和sp,很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要很重要<br>mov ax,data<br>mov ss,ax<br>lea sp,tos<br>;ds和0压入堆栈，以便返回dos<br>push ds<br>xor ax,ax<br>push ax<br>mov ax,data<br>mov ds,ax <br>;参数地址压入堆栈<br>lea bx, buff            <br>push bx                 ;buff的地址压入堆栈<br>lea bx, numb            <br>push bx                 ;numb的地址压入堆栈<br>lea bx, arry           <br>push bx                 ;arry的地址压入堆栈<br>call order<br>ret<br>main endp<br><br>order proc near<br>mov bp,sp<br>mov dx,[bp+6]          ;buff地址送dx<br>mov ah,10<br>int 21h         <br>mov di, [bp+4]         ;取numb的地址<br>mov cl,[di]<br>mov ch,0               ;numb送cx  <br>mov di,cx<br>lp1:  <br>mov cx,di<br>mov bx，[bp+2]        ;arry的地址送bx<br>lp2:       <br>    mov al,[bx]<br>cmp al,[bx+1]<br>jge cont<br>xchg al,[bx+1]<br>mov [bx],al<br>cont:     <br>    inc  bx<br>    loop lp2<br>    dec di<br>    jnz lp1<br>    call output<br>   ret 6                  ;修改sp指针并返回<br>order  endp<br><br>；------------------<br>output proc  near<br>mov   di,[bp+4]          ;后面插入$以便显示<br>mov   bl,[di]<br>mov   bh,0     <br>mov   di,[bp+2]<br>mov   byte ptr[di+bx],&#39;$&#39;<br>mov   dx, di<br>mov   ah,9<br>int   21h<br>    ret<br>output endp<br>code ends<br> end main<br></code></pre></div></td></tr></table></figure><p><strong>⑤用结构变量传递参数</strong></p><p>结构就是把逻辑上互相关联的一组数据以某种形式组合在一起。在程序中，若要多次使用相同的一组数据格式，那么我们就可以把这一组数据格式定义为一个结构数据。</p><p>结构类型的定义：结构名   STRUC<br>                                         ……<br>                                结构名    ENDS<br>STRUC伪指令只是定义了一种结构模式，还没有生成结构变量。<br>用结构预置语句生成结构变量并赋值。<br>    结构预置语句格式：<br>    变量   结构名 &lt;各字段赋值&gt;</p><p>对结构字段初值的修改，并非所有字段的初值都可以修改，<strong>只有简单结构字段和字符串字段初值才可以修改</strong>。简单结构字段是指由伪指令DB、DW或DD定义的单项变量。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;定义一个名为STUDENT的结构类型。<br>    STUDENT STRUC<br>         ID DB ‘AAAAAAAA’    ;可修改 <br>         NAME DB 3 DUP(0) ;不可修改<br>         JF1 DW 22H          ;可修改 <br>         JF2 DW ?;可修改 <br>         JF3 DW ?;可修改 <br>         JF4 DW ?;可修改 <br>    STUDENT   ENDS<br>    <br>;声明结构体变量    <br>    STD1     STUDENT   &lt;’A2031456’,,,33H&gt;  ;定义一个结构体student并赋初值<br>    STD2     STUDENT   &lt;  &gt;      ;定义一个结构体student<br>    STDSS   STUDENT  100  DUP(&lt;  &gt;)     ;定义100个student结构体<br><br><br>;结构变量的访问<br>     MOV  SI,1<br>     LEA   BX,STD1<br>     MOV  AL, STD1.NAME[SI]<br>     ; 变量STD1的字段NAME的第2项送AL<br>     MOV  AL, [BX].NAME[SI]<br>     ; 变量STD1的字段NAME的第2项送AL<br>     MOV  DL, STDSS+3*19.NAME[SI]<br>     ;变量STDSS第4条记录的字段NAME的第2项送AL<br></code></pre></div></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">data  segment <br>dw  50 dup(?)                ；堆栈50个字<br>tos label  word           ；栈顶地址tos<br>buff db 16         <br>numb db ?        <br>arry dw 16 dup(?)  <br>data ends<br>code segment<br>    assume cs:code,ds:data,ss:data<br>    <br>main proc far<br>;设置ss和sp,设置栈和栈顶指针<br>mov ax,data<br>mov ss,ax<br>lea sp,tos<br>;ds和0压入堆栈，以便返回dos<br>push ds<br>xor ax,ax<br>    push ax<br>mov ax,data<br>    mov ds,ax            <br>;参数地址压入堆栈<br>lea bx, buff            <br>     push bx                   ;buff的地址压入堆栈<br>lea bx, numb            <br>push bx                   ;numb的地址压入堆栈<br>lea bx, arry           <br>    push bx                   ;arry的地址压入堆栈<br>    call order           <br>ret<br>main endp<br><br>order proc near<br>par struc   ;定义结构体<br>pip dw  ?               <br>     p3 dw  ?<br>     p2 dw  ?<br>     p1 dw  ?         <br>par ends;完成结构体定义<br>mov bp,sp<br>    mov dx,[bp].p1     ;buff的地址送dx<br>mov ah, 10<br>int 21h<br>    mov di, [bp].p2     ;取numb的地址<br>    mov cl,[di          ;numb送cx<br>mov ch,0    <br>mov di,cx<br>lp1:     <br>mov   cx,di<br> mov   bx,[bp].p3    ;arry地址送bx<br>lp2:      <br>mov   al,[bx]<br>cmp   al,[bx+1]<br>jge   cont<br>xchg  al,[bx+1]<br>mov  [bx],al<br>cont:     <br>inc bx<br>loop lp2<br>dec  di<br>jnz   lp1<br>call output<br>     ret 6              ;修改sp指针并返回<br>order endp<br>code ends<br>     end main<br><br>;------------------<br>output    proc  near<br>mov   di,[bp].p2<br>mov   bl,[di]<br>mov   bh,0<br>mov   di,[bp].p3<br>mov   byte ptr[di+bx],&#39;$&#39;<br>mov   dx, di<br>mov   ah,9<br>int   21h            <br>ret<br>output endp<br>code ends<br>   end  main<br></code></pre></div></td></tr></table></figure><h3 id="多模块程序设计"><a href="#多模块程序设计" class="headerlink" title="多模块程序设计"></a>多模块程序设计</h3><p>汇编程序是可以由两个asm文件构成的。</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment">;812main.asm</span><br>public  <span class="hljs-keyword">buff,numb,arry </span><span class="hljs-comment">;如果你的程序想把这些变量给其他程序用。一定要public生命这些变量</span><br><span class="hljs-keyword">extrn </span>  <span class="hljs-keyword">order:far </span> ；如果你用了别人的程序里的变量 要<span class="hljs-keyword">extern声明</span><br></code></pre></div></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">；<span class="hljs-number">812</span>sub.asm<br><span class="hljs-keyword">public</span>  order  <br>extrn   <span class="hljs-string">buff:</span><span class="hljs-keyword">byte</span>,<span class="hljs-string">numb:</span><span class="hljs-keyword">byte</span>,<span class="hljs-string">arry:</span><span class="hljs-keyword">byte</span><br></code></pre></div></td></tr></table></figure><p><strong>各模块先分别汇编，然后再连接:</strong><br>    Link  812main+812sub</p><p><strong>Link 的次序影响结果</strong>，主模块在前面。</p><h2 id="Ch9-宏汇编"><a href="#Ch9-宏汇编" class="headerlink" title="Ch9-宏汇编"></a>Ch9-宏汇编</h2><h3 id="宏定义，宏调用，宏展开"><a href="#宏定义，宏调用，宏展开" class="headerlink" title="宏定义，宏调用，宏展开"></a>宏定义，宏调用，宏展开</h3><p>宏是源程序中一段有独立功能的程序代码。它只需要在源程序中定义一次，就可以多次调用，调用时只需要用一个宏指令语句就可以了。</p><p>宏功能既可以<strong>实现程序复用</strong>，又能<strong>方便的传递多个参数</strong>。</p><p>宏定义: </p><p> 宏指令名  MACRO  [形参1,形参2,…]<br>                     &lt;宏定义体&gt;<br>                     ENDM </p><p><strong>TIPS:</strong></p><p>1.宏定义体是一组有独立功能的程序代码。</p><p>2.<strong>宏指令名</strong>给出宏定义的名称，调用时就<strong>使用宏指令名来调用宏定义</strong>。<strong>第一个符号必须是字符</strong>。</p><p>3.哑元表给出了宏定义中所用到的形式参数，每个哑元之间用逗号隔开。</p><p><strong>例题：</strong>用宏指令实现两数的相加。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;宏定义：<br>sumn MACRO x, y, result<br> mov ax, x                 <br> add ax, y               <br> mov result, ax<br> ENDM<br>;宏调用<br>sumn 34,25,bx<br><br>;宏展开<br>mov ax,34<br>add ax,25<br>mov bx,ax<br></code></pre></div></td></tr></table></figure><p><strong>例题：</strong>用宏指令实现两个八位有符号数的乘法</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;宏定义<br>imultiply MACRO x,y,result<br> push ax  ;这个是为了保护进来的时ax的值，退出宏后ax值依旧，如果没这个需求不加也可以。<br> mov al,x<br> imul y<br> mov result,ax<br> pop ax<br> ENDM<br> <br>;宏调用<br>imultiply cl,dl,[bx]<br>imultiply ary,var,save<br><br>;宏展开<br>push ax<br>mov  al,cl<br>imul  dl<br>mov  [bx], ax<br>pop  ax<br>┇<br>push ax<br>mov al,ary<br>imul var<br>mov save,ax<br>pop  ax<br></code></pre></div></td></tr></table></figure><p><strong>例题：</strong></p><p>某工厂工人的周工资由计时工资和计件工资组成，计时工资按每小时工资率RATE乘以工作小时数计算；计件工资按超定额部分乘以SUP计算（超定额=实际完成的工件数MADE-定额工件数PART），工资总额放在WAGE中。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;宏定义<br>wages  macro  rate, hout, made, part, sup  <br>       wage&#x3D;rate*hout+(made-part)*sup<br>       endm<br>rate&#x3D;5<br>part&#x3D;100<br>sup&#x3D;4<br><br>;宏调用:<br>wages  rate,40,120,part,sup<br><br>;宏展开为:<br>wage&#x3D;rate*40+(120-part)*sup<br></code></pre></div></td></tr></table></figure><h3 id="宏定义的嵌套"><a href="#宏定义的嵌套" class="headerlink" title="宏定义的嵌套"></a>宏定义的嵌套</h3><p>这种嵌套结构的特点是外层宏定义的宏体中又有宏定义，<strong>只有调用外层宏定义一次后，才能调用内层宏指令</strong>。</p><p><strong>例题：</strong></p><p>用嵌套的宏定义实现两个八位数的算术运算。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;宏定义：<br>math   MACRO  mathname, action, num<br>       mathname   MACRO  x, y, result<br>                  push ax<br>                  mov num,x<br>             action y<br>             mov result ax<br>             pop ax<br>             ENDM<br>       ENDM<br>;宏调用<br>math divide, div, ax<br><br>;宏展开<br>divide MACRO x, y, result<br>       push ax<br>       mov  ax, x<br>       div  y<br>   mov result, ax<br>   pop ax<br>   ENDM <br>;接下来可使用宏调用:<br>divide ary, var, save<br><br>;则宏展开如下：<br>push ax<br>mov  ax, ary<br>div    var<br>mov  save, ax<br>pop   ax<br></code></pre></div></td></tr></table></figure><h3 id="宏定义中使用宏调用"><a href="#宏定义中使用宏调用" class="headerlink" title="宏定义中使用宏调用"></a>宏定义中使用宏调用</h3><p>宏定义中使用的宏调用必须已经定义。</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;用宏指令实现显示字符。<br>;宏定义：<br>INT21 MACRO FUNCTN<br>MOV AH,FUNCTN<br>INT 21H<br>ENDM<br>DISPC MACRO CHAR<br>MOV DL,CHAR<br>INT21 2<br>ENDM<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>What is submodular function(次模函数)</title>
    <link href="/2020/07/20/What%20is%20submodular%20function(%E6%AC%A1%E6%A8%A1%E5%87%BD%E6%95%B0)/"/>
    <url>/2020/07/20/What%20is%20submodular%20function(%E6%AC%A1%E6%A8%A1%E5%87%BD%E6%95%B0)/</url>
    
    <content type="html"><![CDATA[<h1 id="次模函数-submodular-function"><a href="#次模函数-submodular-function" class="headerlink" title="次模函数 submodular function"></a>次模函数 submodular function</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​    最近在读2003KDD《Maximizing the spread of influence through a social network》这篇文章中遇到了<strong>次模函数 submodular function</strong>这个东西，整理一下搜集到的东西。</p><p>​    submodular实际上就对“边际效用递减”这个说法的形式化。</p><p>​    </p><h2 id="submodular-function-次模函数-定义"><a href="#submodular-function-次模函数-定义" class="headerlink" title="submodular function(次模函数)定义"></a>submodular function(次模函数)定义</h2><p>子模态是几何函数的一种性质。一个几何函数$f(x)$的定义要满足下面这个性质。</p><p>$f:2^{Ω} → \R$</p><p>也就是说：即f(x)的定义域为集合Ω的任何一个子集，值域为实数集。而这个集合函数如果要满足子模态性质的话，还需要满足下面三个等价条件中的任何一个：</p><p><strong>(1)对于任何一个$X,Y\subset Ω$且$X\subset Y$,以及对任何一个$x\in Ω$，以下式子成立</strong></p><p>$f(X∪x)−f(X)≥f(Y∪x)−f(Y)$</p><p>这个就是次模函数的本身定义。</p><p><strong>(2)对于任何一个$X,Y\subset Ω$，以下式子成立：</strong></p><p>$f(X)+f(Y)≥f(X∪Y)+f(X∩Y)$</p><p>证明:</p><p>$f(X)-f(X∩Y)≥f(Y∪X)-f(Y)$</p><p>$f((X∩Y)∪X)-f(X∩Y)≥f(Y∪X)-f(Y)$</p><p>且$(X∩Y)\subset Y$</p><p>故等价于(1)定义</p><p><strong>(3)对于任何一个$X⊂Ω$及$x1,x2∈Ω$下面的式子一定成立</strong></p><p>$f(X∪x1)+f(X∪x2)≥f(X∪x_1,x_2)+f(X)$</p><p>证明：</p><p>$f(X∪x_1)-f(X)≥f(X∪x_2∪x_1)-f(X∪x_2)$</p><p>$(X∪x1)\subset (X∪x_2∪x_1)$</p><p>故等价于(1)</p><p><strong>推论：</strong></p><div class="hljs code-wrapper"><pre><code> 设$f1(x),f2(x),⋯,fk(x)$都是有子模态性质的函数，$c1,c2,⋯,ck $是非负实数，则下面这个函数:</code></pre></div><p><a href="https://imgchr.com/i/BAeyvD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAeyvD.png" srcset="/img/loading.gif" alt="BAeyvD.png"></a></p><p>仍然是次模函数。即多个次模函数的非负线性组合仍然是次模函数。</p><h2 id="次模函数与贪心方法"><a href="#次模函数与贪心方法" class="headerlink" title="次模函数与贪心方法"></a>次模函数与贪心方法</h2><p>​    次模函数的性质我们称之为子模态，这个子模态的性质主要的作用就是保证我们在贪心求解问题时所得到的近似解不会太差，提供了一个近似保证。即贪心的解$f(x)$的值不会小于$(1-\frac{1}{e})*OPT$,其中$OPT$为最优解。</p><p>​    我们的贪心规则是，每一次将一个新的元素加入到所想要构建的目标集合$x$,迭代k步。我们用$X_i$来表示迭代$i$次之后的$x$集合,初始时$x=\varnothing$。故可以用以下式子表示贪心规则：</p><p>现在我们要<strong>证明</strong>：$\begin{equation}f(x)\geq (1-\frac{1}{e})*OPT\end{equation}$</p><p>首先引入一个引理：$\begin{equation} f(A\cup B)-f(A)\leq \sum_{j=1}^{k}{[f(A\cup {b_j})-f(A)]}\end{equation}$</p><p>其中$B={b<em>1,b_2,b_3…,b_k}$，此时我们定义$B_i={b_1,b_2,b_3…,b_i}$ ,则：$\begin{equation}\begin{split}f(A\cup B)-f(A)&amp;=\sum</em>{i=1}^{k}{[f(A\cup B<em>i)-f(A\cup B</em>{i-1})]}\&amp;=\sum<em>{i=1}^{k}{[f(A\cup B</em>{i-1}\cup {b<em>i})-f(A\cup B</em>{i-1})]}\&amp;\leq\sum_{j=1}^{k}{[f(A\cup {b_j})-f(A)]}\end{split}\end{equation}$</p><p>设最优解为$T={t<em>1,\cdots,t_k}$,  $\delta_i=f(X_i)-f(X</em>{i-1})$，由引理中的不等式可以推出：</p><p>$\begin{equation}\begin{split}f(T)&amp;\leq f(X<em>i\cup T)\&amp;=f(X_i\cup T)-f(X_i)+f(X_i)\&amp;\leq\sum</em>{j=1}^{k}{[f(X<em>i\cup {t_j})-f(X_i)]}+f(X_i)\&amp;\leq\sum</em>{j=1}^{k}{[\delta<em>{i+1}]}+f(X_i)\&amp;=f(X_i)+k\delta</em>{i+1}\end{split}\end{equation}$</p><p>即可得：$\begin{equation}\delta_{i+1}\geq \frac{1}{k}[f(T)-f(X_i)]\end{equation}$</p><p>所以：</p><p>$\begin{equation}\begin{split}f(X<em>{i+1})&amp;=f(X_i)+\delta</em>{i+1}\&amp;\geq f(X_i)+\frac{1}{k}[f(T)-f(X_i)]\&amp;=(1-\frac{1}{k})f(X_i)+\frac{1}{k}f(T)\end{split}\end{equation}$</p><p>故递推式为：$\begin{equation}f(X_i)\geq [1-{(1-\frac{1}{k})}^i]f(T)\end{equation}$</p><p>数列求和即可证明：$\begin{equation}f(X_k)\geq [1-{(1-\frac{1}{k})}^k]f(T)\geq [1-\frac{1}{e}]f(T)\end{equation}$</p><h2 id="Application：次模函数在影响力最大化问题上的应用"><a href="#Application：次模函数在影响力最大化问题上的应用" class="headerlink" title="Application：次模函数在影响力最大化问题上的应用"></a>Application：次模函数在影响力最大化问题上的应用</h2><p>​    主要在影响力最大化问题中用于证明：贪心法在此问题中是可行的。</p><p>​    $f(X)$，就是初始集合$X$该过程$S$下所返回的集合$P$的大小的平均值。</p><p>​    影响最大化问题就是在固定集合$X$大小$k$的情况下，最大化$f(X)$。我们可以证明这个优化问题是NP-Hard 的。该问题的简化形式为$p<em>{vw}$ 都是1，此时该问题不再是一个随机过程。每个初始点$v$的可达集是固定的，我们可以表示为$Rv$ 。因此，原问题等价于在集合$R_1,⋯,R</em>{|v|} $中找到$k$个集合，使得</p><p>$arg\max<em>u{f(S</em>{i-1}\cup{u})}$</p><p>​    但是，如何证明这个贪心是有效的一个难题，因为这是一个随机过程，每个点的增益在每一个时刻都是一个不同的随机变量，函数表达式也不是一个解析式。</p><p>​    我们现在先从简化问题出发，然后再去求解原问题。而简化问题就是我们之前提到的集合覆盖问题$f(S)$，这个问题其实是子模态的。在$t$时刻节点$v$引发$w$的概率为$p_{vw}$ ，这是一个01分布。事实上这个结果是0还是1与时刻t是无关的，所以我们可以预先生成好这个随机变量。对所有的边进行提前生成随机变量之后，我们就得到了一个图N.</p><p><img src="http://spiritsaway.info/image/Submodual/NewGraph1.png" srcset="/img/loading.gif" alt="新图1"></p><p><img src="http://spiritsaway.info/image/Submodual/NewGraph2.png" srcset="/img/loading.gif" alt="新图2"></p><p><img src="http://spiritsaway.info/image/Submodual/NewGraph3.png" srcset="/img/loading.gif" alt="新图3"></p><p>而当$v$引发$w$时,$p_{vw}=1$，否则就等于0.在$N$中的影响最大等价于之前讨论的集合覆盖问题。设生成图$Ni$ 的概率为$pi$ ，设$f_i(X)$为在图$N_i$ 上寻找影响最大的解，则</p><p>可以看出这是多个子模态函数的非负线性组合，因此$f(X)$是子模态的。又根据我们在之前证明贪心法在子模态函数上是可行的，所以贪心法对影响最大问题是可行的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.怎么理解次模函数 submodular function？ - 彭鹏的回答 - 知乎<br><a href="https://www.zhihu.com/question/34720027/answer/79260358" target="_blank" rel="noopener">https://www.zhihu.com/question/34720027/answer/79260358</a></p><p>2.Submodual <a href="http://spiritsaway.info/submodual.html" target="_blank" rel="noopener">http://spiritsaway.info/submodual.html</a></p><p>3.<a href="http://en.wikipedia.org/wiki/Submodular" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Submodular</a> 维基百科</p><p>4.<a href="http://www.cs.cornell.edu/home/kleinber/kdd03-inf.pdf" target="_blank" rel="noopener">http://www.cs.cornell.edu/home/kleinber/kdd03-inf.pdf</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>影响力最大化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AHU计算机图形学笔记</title>
    <link href="/2020/07/17/AHU%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <url>/2020/07/17/AHU%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="AHU计算机图形学"><a href="#AHU计算机图形学" class="headerlink" title="AHU计算机图形学"></a>AHU计算机图形学</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>对AHU计算机图形学课的一些笔记总结,我自认为总结的还算全面，期末靠着这个复习也拿到了相对不错的分数，但受限于个人水平，有些地方可能会出现错误，如果有什么遗漏或者错误之处，可以发邮件到：howiewang.cs@gmail.com </p><p>像素：绘图的最小单位。</p><p>分辨率与像素的关系：若分辨率1024*768（每行有1024个像素，总共有768行）。</p><h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h2><p><strong>计算机图形学（Computer Graphics）</strong>是研究怎样利用计算机来显示、生成和处理图形的原理、方法和技术的一门学科。国际标准化组织（ISO）定义它为：计算机图形学是研究通过计算机将数据转换成图形，并在专门显示设备上显示的原理、方法和技术。</p><p><img src="https://s1.ax1x.com/2020/04/14/Gxe7xP.png" srcset="/img/loading.gif" alt="Gxe7xP.png"></p><p>​        计算机中表示带有颜色及形状信息的图和形常用两种方法：<strong>点阵法和参数法</strong>。点阵法是用具有灰度或颜色信息的点阵来表示图形的一种方法，它强调图形由哪些点组成，并且具有什么灰度或色彩。参数法是以计算机中所记录图形的形状参数与属性参数来表示图形的一种方法。形状参数可以是形状的方程系数、线段的起点和终点对等几何属性的描述；属性参数则描述灰度、色彩、线型等非几何属性。这样，可以进一步细分：把参数法描述的图形叫做图形（Graphics），而把点阵法描述的图形叫做图像（Image）。</p><p><strong>图形学的发展：</strong></p><ol><li><strong>酝酿期（20世纪50年代）</strong><br>1950年，美国麻省理工学院（MIT）的旋风1号（Whirlwind I）计算机配备了阴极射线管（CRT）来显示一些简单的图形。<br>1958年，美国CALCOMP公司将联机的数字记录仪发展成滚筒式绘图仪，GERBER公司则把数控机床发展成平板式绘图仪。<br>整个50年代，计算机图形学处于准备和酝酿时期，称之为“被动”的图形学。</li><li><strong>萌芽期（20世纪60年代）</strong><br>60年代初，美国麻省理工学院林肯实验室中基于旋风计算机开发的北美空中防御系统SAGE具有了指挥和控制图形对象的功能。<br>1962年，<strong>美国麻省理工学院林肯实验室的Ivan.E.Sutherland</strong>发表了一篇题为”Sketchpad：一个人——机通信的图形系统”的博士论文，其中<strong>首次使用了“Computer Graphics”这个术语</strong>，从而<strong>确立了计算机图形学的学科地位</strong>。 </li><li><strong>发展期（20世纪70年代）</strong><br>70年代，美国洛克希德飞机公司完成了一个用于飞机设计的交互式图形处理系统，即CADAM。<br>计算机图形处理技术进入实用化阶段，但由于图形设备昂贵、功能简单、基于图形的应用软件缺乏等原因，计算机图形学还是一个较小的学科领域。</li><li><strong>普及期（20世纪80年代）</strong><br>由于出现了带有光栅图形显示器的个人计算机和工作站，以及大量简单易用、价格便宜的基于图形的应用软件，计算机图形学进入了社会生活的各个领域。 </li><li><strong>提高增强期（20世纪90年代）</strong><br>计算机图形学向着标准化、集成化和智能化方向发展。</li></ol><h2 id="第二章：计算机图形系统及硬件"><a href="#第二章：计算机图形系统及硬件" class="headerlink" title="第二章：计算机图形系统及硬件"></a>第二章：计算机图形系统及硬件</h2><h3 id="计算机图形系统概述"><a href="#计算机图形系统概述" class="headerlink" title="计算机图形系统概述"></a>计算机图形系统概述</h3><p>  一个<strong>交互式计算机图形系统</strong>应具有<strong>计算、存储、交互（对话）、输入和输出</strong>等<strong>五个方面的功能</strong></p><p><img src="https://s1.ax1x.com/2020/04/14/GxN4II.png" srcset="/img/loading.gif" alt="GxN4II.png"></p><p><strong>计算机图形系统结构：</strong></p><p><strong>图形应用数据结构</strong>：对应一组图形数据文件，保存着图形对象的全部描述信息。<br><strong>图形应用软件</strong>：是图形系统的核心部分，包括了各种图形生成和处理技术，是图形技术在各种不同应用中的抽象。</p><p><strong>图形支撑软件</strong>：由一组公用的图形子程序所组成，它扩展了系统中原有高级语言和操作系统的图形处理功能。</p><p><img src="https://s1.ax1x.com/2020/04/14/GxNrPx.png" srcset="/img/loading.gif" alt="GxNrPx.png"></p><p><strong>图形应用数据结构对应一组图形数据文件，存放将要生成的图形对象的全部描述信息（位置、大小、属性、…….)</strong></p><p><strong>图形应用软件是解决某种应用问题的图形软件.它从图形应用数据结构中取得物体的几何模型和属性等,按照应用要求进行各种处理(裁剪、消隐、变换、填充等），然后使用图形支撑软件所提供的各种功能，生成该对象的图形并在图形输出设备上输出。</strong></p><p><strong>图形支撑软件一般由一组公用的图形子程序组成。</strong></p><h3 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h3><p><strong>1.键盘</strong></p><p><strong>2.鼠标</strong></p><p><strong>3.光笔</strong></p><p><strong>4.操纵杆</strong></p><p><strong>5.触摸屏</strong></p><p><strong>6.跟踪球/空间球：</strong></p><p>跟踪球是一个球，可用手指或掌心旋转以使屏幕光标移动，常用作二维定位设备。空间球与跟踪球不同的是它可以提供6个自由度，常用作三维定位和选择设备。</p><p><strong>7.数字化仪：</strong></p><p> 数字化仪用来输入一组坐标位置，相互以直线段连接，以逼近曲线或表面形状。</p><p><strong>8.扫描仪</strong></p><h3 id="什么是-阴极射线管-CRT-？"><a href="#什么是-阴极射线管-CRT-？" class="headerlink" title="什么是  阴极射线管(CRT)？"></a>什么是  阴极射线管(CRT)？</h3><p>阴极射线管（CRT，Cathode Ray Tube）利用电磁场产生高速的、经过聚焦的电子束，偏转到屏幕的不同位置轰击屏幕表面的荧光材料而产生可见图形。</p><p><img src="https://s1.ax1x.com/2020/04/14/GxBbQ0.png" srcset="/img/loading.gif" alt="GxBbQ0.png"></p><p>（1）电子枪：</p><p><strong>控制栅</strong>：控制电子的数量</p><p><strong>加速极</strong>：控制电子的速度</p><p><strong>聚焦极</strong>：把电子聚集成一束电子</p><p><img src="https://s1.ax1x.com/2020/04/14/Gxf9Et.png" srcset="/img/loading.gif" alt="Gxf9Et.png"></p><p>（2）偏转系统：</p><p>分为<strong>电偏转</strong>和<strong>磁偏转</strong>两种，电偏转有两组电极板，水平偏转板和垂直偏转板。</p><p><strong>电偏转：</strong><img src="https://s1.ax1x.com/2020/04/14/GxfUV1.png" srcset="/img/loading.gif" alt="GxfUV1.png"></p><p><strong>磁偏转：</strong><img src="https://s1.ax1x.com/2020/04/14/Gxf18U.png" srcset="/img/loading.gif" alt="Gxf18U.png"></p><p>（3）荧光屏：</p><p>主要结构：<strong>三色荧光屏、三支电子枪、荫罩板。</strong><br><strong>三色荧光屏</strong>：在整个荧光屏上密密麻麻交错布满了能发R、G、B光的荧光小点，这些荧光点按次序整齐的排列，并相互错开，如下图所示。</p><p><strong>三支电子枪</strong>：荫罩管的尾部装有三支电子枪，它们安装成“品”字形，互成120度角，并略向管轴倾斜，以保证三支电子枪能同时击中一组荧光小点。</p><p>每只电子枪只能控制开或者关(2种强度)：2<em>2\</em>2=8种颜色</p><p>每只电子枪可控制8种强度：8<em>8\</em>8=256种颜色</p><p>每只电子枪能控制256种强度：256*256*256种颜色</p><p><strong>荫罩板</strong>：在离开荧光屏1cm处安装了一块薄钢板制成的网板，像一个罩子将屏幕罩起来，故称荫罩板。荫罩板上有许多小孔，每个小孔准确地和一组三色荧光小点对应。这样，三支电子枪正好交汇在荫罩的小孔上，然后再各自打在相应的荧光小点。</p><h3 id="CRT图形显示器"><a href="#CRT图形显示器" class="headerlink" title="CRT图形显示器"></a>CRT图形显示器</h3><p><strong>1.随机扫描的图形显示器</strong></p><p>​       随机扫描的图形显示器又称向量显示器或笔划显示器，电子束的定位和偏转具有随机性，即电子束的扫描轨迹随显示内容而变化，<strong>只在需要的地方扫描，而不必全屏扫描（可局部扫描）</strong>。</p><p>​       荧光粉余晖时间短，荧光粉发光后马上消失，然后再重复这样的过程，刷新频率低画面会一闪一闪，刷新频率过高会高频度打击屏幕，可能会击穿或者烧毁。</p><p> <strong>随机扫描显示器的特点</strong><br>(1)无冗余扫描、速度快、图像清晰、比光栅系统具有更高的分辨率，生成光滑线条。<br>(2)不能显示逼真场景，和电视标准不一致，驱动系统也较复杂。</p><p><strong>2.直视存储管图形显示器</strong></p><p>直视存储管（DVST，direct-view storage tube） 从表面上看直视存储管的特性极象一个有长余辉的荧光屏，一条线一旦画在屏幕上，在一小时之内都将是可见的。</p><p><strong>不能局部修改，不能显示彩色。</strong></p><p><strong>3.光栅扫描的图形显示器</strong></p><p><strong>扫描过程</strong>：如下图所示，在光栅扫描系统中，电子束横向扫描屏幕，<strong>一次一行</strong>，<strong>从顶到底顺次进行</strong>，当电子束横向沿每一行移动时，由电子束的强度不断变化来建立亮点的图案。</p><p><img src="https://s1.ax1x.com/2020/04/14/Gx7FdH.png" srcset="/img/loading.gif" alt="Gx7FdH.png"></p><p><strong>刷新速率</strong>：每秒扫描的帧数。<br><strong>水平回扫</strong>：每条扫描线扫过后，电子束返回到屏幕左端，称为电子束的水平回扫。<br><strong>垂直回扫</strong>：在每一帧的终了，电子束返回的屏幕左上角，称为电子束的垂直回扫。<br><strong>逐行扫描和隔行扫描</strong>：逐行扫描是扫描线从屏幕顶端开始，从0行光栅开始，逐行下扫，直到屏幕底部；隔行扫描将每帧显示分为两趟，采用隔行刷新方式。第一趟，电子束从顶到底，一行隔一行扫描偶数扫描线，垂直回扫后，电子束则进行第二趟扫描奇数扫描线。隔行扫描使在逐行扫描所需时间的一半时就能看到整个屏幕显示。</p><p>在光栅扫描的图形显示器中，被显示的线段、字符、图形及其背景色都存储在<strong>刷新缓冲存储器</strong>（Refresh Buffer）<strong>或称 帧缓冲存储器</strong>（Frame Buffer，FB）中，刷新缓冲存储器保存的每一组信息对应屏幕上的一个点。</p><p><strong>像素（pixel或pel，是picture element的简写）</strong>：每个屏幕点称为一个像素。像素信息从应用程序转换并放入帧缓冲区的过程称之为扫描转换过程。<br><strong>走样</strong>：光栅扫描的图形显示器是画点设备，绘制图形时只能用尽可能靠近图形的像素点集来近似表示图形，因而会产生失真。这种失真称为走样。</p><p>如下图就是<strong>走样现象</strong>：原因就是像素点是离散的，只能近似表示图形。</p><p><img src="https://s1.ax1x.com/2020/04/14/GxXSSA.png" srcset="/img/loading.gif" alt="GxXSSA.png"></p><h3 id="平板显示器"><a href="#平板显示器" class="headerlink" title="平板显示器"></a>平板显示器</h3><p><strong>平板显示器（flat-panel display）</strong> 是一种<strong>低电压、轻小型、数字化</strong>显示器件，它可以<strong>分为发射显示器和非发射显示器两类</strong>。<br>    <strong>发射显示器（emissive display）</strong>：将电能转换为光能，如等离子体显示器。<br>    <strong>非发射显示器（none-emissive display）</strong>：利用光学效应，将太阳光或来自其他光源的光转换为图形图案，典型设备是液晶显示器。</p><p>1.<strong>液晶显示器(LCD)：</strong>液晶是一类有机化合物，在一定的温度范围内不但有像液体那样的流动性，而且具有像晶体那样的各项异性。<br>    <strong>液晶的电光效应</strong>：由于<strong>液晶具有各项异性</strong>以及在外来电场、磁场、应力、温度等作用下容易改变其分子排列的特性，等液晶分子的某种排列状态在电场作用下变为另一种排列状态时，液晶的光学性质随之改变，这种产生光被电场调制的现象称为液晶的电光效应。</p><p>​    <strong>液晶显示的机理</strong>：液晶显示器就是利用液晶的电光效应，通过施加电压改变液晶的光学特性，从而造成对入射光的调制，使通过液晶的透射光或反射光受所加电压的控制，达到显示的目的。</p><p><strong>2.等离子体显示板</strong></p><p><strong>等离子体显示器也称气体放电显示器(gas-discharge display)</strong>，其结构如下图所示。通常用包括氖气在内的混合气体充入两块玻璃板之间的区域，两块玻璃板上分别放置垂直、水平导电带，在成对的水平和垂直导电带上施以点火电压，导致两导电带交叉点处的气体进入辉光放电的电子和离子等离子区，从而显示图形。</p><p><strong>3.发光二极管(LED)</strong></p><h3 id="图形显示子系统"><a href="#图形显示子系统" class="headerlink" title="图形显示子系统"></a>图形显示子系统</h3><p>现在常用的PC图形显示子系统包括哪儿三个结构？  <strong>帧缓冲存储器 ，显示控制器 ，ROM BIOS</strong></p><p><strong>帧缓冲存储器：</strong>存储屏幕上像素的颜色值，简称<strong>帧缓冲器</strong>，俗称<strong>显存</strong>。</p><p><strong>显示控制器：</strong> 主要功能是不断地读取帧缓存中的图像点阵，并转换成RGB三色信号并配备同步信号送至显示器，即可刷新屏幕。</p><p><strong>显示处理器：</strong> 把CPU从图形显示处理的事务中解脱出来。</p><p><strong>1.早期的光栅图形显示子系统</strong><br>早期的光栅图形显示子系统如下图所示，帧缓冲存储器可以位于系统主存的任意位置，显示控制器<strong>通过系统总线访问</strong>帧缓冲存储器，以刷新屏幕。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3UI1g.png" srcset="/img/loading.gif" alt="J3UI1g.png"></p><p> <strong>2.目前常用的光栅图形显示子系统</strong><br>在目前常用的光栅图形显示子系统中，<strong>帧缓冲存储器由显示控制器直接访问</strong>，它<strong>既可以使用系统内存的固定区域，又可以是专用的显示内存</strong>。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3UTXj.png" srcset="/img/loading.gif" alt="J3UTXj.png"></p><p> 在如上图所示的显示子系统中，<strong>显示图形时所需的扫描转换工作直接由CPU来完成</strong>，即由<strong>CPU计算出表示图形的每个像素的坐标并将其属性值写入相应的帧缓存单元</strong>。</p><p><strong>3.发展的光栅图形显示子系统</strong><br>发展的光栅图形显示子系统的结构如下图所示，除了帧缓存和显示控制器外，还包含<strong>显示处理器</strong>和独立的显示处理器存储区域。显示处理器，又叫图形控制器或显示协处理器，它的主要任务是扫描转换待显示的图形。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3UOA0.png" srcset="/img/loading.gif" alt="J3UOA0.png"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>1.分辨率</strong><br><strong>光点</strong>是指电子束打在显示器的荧光屏上，<strong>显示器能够显示的最小的发光点</strong>，一般用其<strong>直径</strong>来标明光点的大小。<br>像素点是指图形显示在屏幕上时候，按当前的图形显示分辨率所能提供的最小元素点。像素点可以看作是光点的集合。 </p><p>图形显示技术中有<strong>三种分辨率</strong>：<br>     <strong>(1)屏幕分辨率(光点数×光点数)</strong>：也称光栅分辨率或物理分辨率，它决定了显示系统最大可能的分辨率，通常<strong>用水平方向上的光点数与垂直方向上的光点数的乘积来表示</strong>。<br>     <strong>(2)显示分辨率（字符数×字符数）</strong>：是计算机显示控制器所能够提供的显示模式分辨率，实际应用中简称为显示模式。对于文本显示方式，<strong>显示分辨率用水平和垂直方向上所能显示的字符总数的乘积表示</strong>；对于图形显示方式，则用水平和垂直方向上所能显示的像素点总数的乘积表示。<br>     <strong>(3)图形的存储分辨率（帧缓冲区大小）：</strong>是<strong>指帧缓冲区的大小</strong>，一般用缓冲区的字节数表示。由于帧缓冲存储器的大小不仅与显示分辨率有关，还与像素点的颜色数有关。</p><p><strong>帧缓存大小的计算为：</strong></p><p><a href="https://imgchr.com/i/J3ae3D" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3ae3D.png" srcset="/img/loading.gif" alt="J3ae3D.png"></a></p><p>​        其中：x、y分别为表示当前显示分辨率下x、y方向上的像素点总数，n为颜色数或灰度等级数。 </p><p> <strong>2.像素与帧缓存</strong><br>    屏幕上一个像素点就对应帧缓存中的一组信息。对应的方式有以下两种：<br>    <strong>(1) 组合像素法（Packed Pixel Method）</strong><br>    在组合像素法中，一个图形像素点的全部信息被编码成一个数据字节，按照一定方式存储到帧缓存中，<strong>编码字节的长度</strong>与<strong>点的属性</strong>（如颜色、灰度）<strong>有关</strong>。</p><p>​    <a href="https://imgchr.com/i/J3aMDA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3aMDA.png" srcset="/img/loading.gif" alt="J3aMDA.png"></a></p><p>​    <strong>(2)颜色位面法（Color Plane Method）</strong><br>​    在颜色位面法中，帧缓存被分成若干独立的存储区域，每一个区域称为一个位面（BitPlane），如下图所示，<strong>每个位面控制一种颜色或者灰度</strong>，每一个图形像素点在每个位面中占一位，通过几个位面中的同一位组合成一个像素。</p><p><strong>帧缓存大小的计算为：</strong><a href="https://imgchr.com/i/J3ae3D" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3ae3D.png" srcset="/img/loading.gif" alt="J3ae3D.png"></a></p><p><strong>3位面帧缓存的容量计算：8种颜色</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/J3awbn.png" srcset="/img/loading.gif" alt="J3awbn.png"></p><p><strong>24位面帧缓存：</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/J30NvD.png" srcset="/img/loading.gif" alt="J30NvD.png"></p><p> <strong>3.颜色查找表(Color Lookup Data)</strong><br>    颜色查找表也称调色板，是由高速的随机存储器组成，用来储存表达像素色彩的代码。此时帧缓冲存储器中每一像素对应单元的代码不再代表该像素的色彩值，而是作为查色表的地址索引，如下图所示的具有<strong>24位面彩色帧缓存和10位颜色查找表</strong>的光栅显示器。<br>    <strong>采用颜色查找表后可以提高总的光强等级，即总的颜色数</strong>，但每屏可显示的颜色数还是受帧缓存中单个像素点所占用的位数决定。</p><p><img src="https://s1.ax1x.com/2020/04/21/J30r5t.png" srcset="/img/loading.gif" alt="J30r5t.png"></p><p>比如原来有2^24种颜色，加上颜色查找表后，可以达到 2^30种颜色</p><p> <strong>4.显示长宽比</strong><br>    显示长宽比，即水平点数与垂直点数之比。当屏幕显像管的长宽比等于4:3，为了使屏幕两个方向上相同像素点数产生同样长度的线段，以使图形不至发生畸变，水平方向上的像素点数与垂直方向上的像素点数之比大约也是4:3。</p><p><strong>5.屏幕坐标系</strong><br>    常用的<strong>屏幕坐标系</strong>有如下图所示的两种。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3D3p6.png" srcset="/img/loading.gif" alt="J3D3p6.png"></p><h2 id="第四章：图形的表示与数据结构"><a href="#第四章：图形的表示与数据结构" class="headerlink" title="第四章：图形的表示与数据结构"></a>第四章：图形的表示与数据结构</h2><p> <strong>1.图素和体素</strong><br>    在二维图形系统中将基本图形元素称为<strong>图素</strong>或图元，而在三维图形系统中称为<strong>体素</strong>。<br>    <strong>图素是指可以用一定的几何参数和属性参数描述的最基本的图形输出元素</strong>，包括点、线、圆、圆弧、椭圆、二次曲线等。<strong>体素的定义相对复杂一些，是三维空间中可以用有限个尺寸参数定位和定形的体</strong>。</p><p><strong>2.刚体运动和拓扑运动</strong></p><p><strong>刚体运动：</strong>不该百年图形上任意两点间的距离，也不改变图形的几何性质的运动。</p><p><strong>拓扑运动：</strong>允许形体做弹性运动，即在拓扑关系中，对图形可随意地伸张扭曲。但<strong>不允许把不同的点合并成一个点。</strong></p><p><strong>3.坐标系</strong></p><p>建模坐标系，用户坐标系，观察坐标系，规格化设备坐标系，设备坐标系</p><p><strong>4.欧拉公式</strong></p><p>对于简单多面体来说：V-E+F=2   顶点数-边数+面数=2</p><p>若不满足欧拉公式肯定不是有效形体，若满足欧拉公式也不一定是有效形体。</p><p><strong>5.数据结构</strong></p><p>三维形体的信息：几何信息，拓扑信息，属性信息</p><p>几何信息的数据结构： 比如定点表，面表，边表</p><p>拓扑信息的数据结构：比如 边表扩充成包括指向面表和顶点表的指针。</p><p>属性信息：物体透明度，反射度，纹理 等。</p><h3 id="三维形体的表示"><a href="#三维形体的表示" class="headerlink" title="三维形体的表示"></a>三维形体的表示</h3><p>分为线框模型和实体模型。</p><h3 id="线框模型"><a href="#线框模型" class="headerlink" title="线框模型"></a>线框模型</h3><p>线框模型存在着几个缺陷。<br>    (1)用三维线框模型表示三维形体常具有二义性，如下图所示的图形可以有多种理解方式。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3TiqA.png" srcset="/img/loading.gif" alt="J3TiqA.png"></p><p>​                                                    图4-12 线框模型的二义性</p><p> (2)由于不存在面的信息，三维线框容易构造出无效形体，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3TmRS.png" srcset="/img/loading.gif" alt="J3TmRS.png"></p><p>(3)由于不能表示出曲面的轮廓线，所以不能正确表示曲面信息。</p><p>(4)无法进行图形的线面消隐。<br>(5)生成复杂形体时，线框模型要求输入大量的数据，加重用户的输入负担。<br>(6)难以保证数据的统一性和有效性。</p><h3 id="实体模型：多边形表面模型"><a href="#实体模型：多边形表面模型" class="headerlink" title="实体模型：多边形表面模型"></a>实体模型：多边形表面模型</h3><p><strong>1.多边形表</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/J3Wmn0.png" srcset="/img/loading.gif" alt="J3Wmn0.png"></p><p>数据结构： 几何信息：定点表，边表，面表这一类的表。</p><p>​                    拓扑信息：如将边表扩充成包括指向面表和顶点表的指针，由此可构造出如下图所示的翼边结构                    表示（Winged Edges Structure）。 </p><p>​                        <img src="https://s1.ax1x.com/2020/04/21/J3fib6.png" srcset="/img/loading.gif" alt="J3fib6.png"></p><p>​                    属性信息：颜色，纹理，质感</p><p><strong>2.平面方程：</strong></p><p>可以利用平面方程：<br>    (1)求得平面的法向量。<br>    (2)鉴别空间上的点与物体平面的位置关系。<br>    (3)判别点在面的内部或外部。</p><ol><li><strong>多边形网格（polygon mesh）</strong> </li></ol><p>三维形体的曲面边界通常用多边形网格（polygon mesh）的拼接来模拟。常用的是如下图所示的三角形带和四边形网格。</p><p><img src="https://s1.ax1x.com/2020/06/20/NlQk36.png" srcset="/img/loading.gif" alt="NlQk36.png"></p><h3 id="实体模型：扫描表示法"><a href="#实体模型：扫描表示法" class="headerlink" title="实体模型：扫描表示法"></a>实体模型：扫描表示法</h3><p><strong>扫描表示法（sweep representation）</strong>可以<strong>利用简单的运动规则生成有效实体</strong>。扫描表示包含两个要素：作扫描运动的基本图形以及扫描运动的方式。<br>    常见扫描运动的方式有：<br>    (1)旋转扫描：沿图形路径从0到360度的角度范围内移动。<br>    (2)非圆形路径扫描：给定描述路径的曲线函数和沿路径移动的距离。<br>    (3)广义扫描法：沿扫描路径变化剖面的形状和大小，或者当移动该形状通过某空间区间时，可以变化剖面相对于扫描路径的方向。</p><h3 id="实体模型：构造实体几何法"><a href="#实体模型：构造实体几何法" class="headerlink" title="实体模型：构造实体几何法"></a>实体模型：构造实体几何法</h3><p><strong>构造实体几何法（CSG，Constructive Solid Geometry）</strong>由两个实体间的并、交或差操作生成新的实体。 </p><p><a href="https://imgchr.com/i/J3oSns" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3oSns.png" srcset="/img/loading.gif" alt="J3oSns.png"></a></p><p><strong>GSG树：</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/J3hYTK.png" srcset="/img/loading.gif" alt="J3hYTK.png"></p><h3 id="实体模型：空间位置枚举表示法"><a href="#实体模型：空间位置枚举表示法" class="headerlink" title="实体模型：空间位置枚举表示法"></a>实体模型：空间位置枚举表示法</h3><p><strong>八叉树（octrees）</strong>又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。</p><p>1.四叉树：  看准象限的位置，这个和一般坐标系不太一样，总左上开始第一象限，顺时针旋转。</p><p><a href="https://imgchr.com/i/J35pvj" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J35pvj.png" srcset="/img/loading.gif" alt="J35pvj.png"></a></p><p>2.八叉树<br>    八叉树方法与四叉树类似，用一个空间的长方体来包围一个三维实体，每次把它分为8个卦限来进行判断。</p><p><a href="https://imgchr.com/i/J3IpFK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3IpFK.png" srcset="/img/loading.gif" alt="J3IpFK.png"></a></p><p><strong>二叉空间分割树（binary space partitioning，BSP）</strong>方法每次将一实体用任一位置和任一方向的平面分为二部分。这种方法可将分割平面的位置和方向按适合于实体的空间属性来确定，更为有效。</p><p><strong>如何绘制BSP树？</strong>      <a href="https://blog.csdn.net/pleasecallmewhy/article/details/8426183" target="_blank" rel="noopener">https://blog.csdn.net/pleasecallmewhy/article/details/8426183</a></p><p>下图为面的俯视图，A面两边为B,C.    B的两面为D和E。  C的两面为F和G</p><p><a href="https://imgchr.com/i/J3IuY8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3IuY8.png" srcset="/img/loading.gif" alt="J3IuY8.png"></a></p><h3 id="非规则对象的表示"><a href="#非规则对象的表示" class="headerlink" title="非规则对象的表示"></a>非规则对象的表示</h3><p>基于分数维理论的随机模型：由A.Fournier等人基于分数维理论提出来的一种过程式模拟，它能够有效地模拟海岸线和山脉等自然景物。<br><strong>基于文法的模型：</strong> 由A.R.Smith用正规文法来构造植物等结构性较强的自然景物，是一个并行重写系统，由一组产生式规则组成。<br><strong>粒子系统模型：</strong>由随着时间变化的一组粒子组成的，此模型可以用来模拟火、烟、雾等，也可以用来模拟被风吹动的草和灌木等。</p><h2 id="第五章：基本图形生成算法"><a href="#第五章：基本图形生成算法" class="headerlink" title="第五章：基本图形生成算法"></a>第五章：基本图形生成算法</h2><h3 id="直线的扫描转换"><a href="#直线的扫描转换" class="headerlink" title="直线的扫描转换"></a>直线的扫描转换</h3><p><strong>直线的绘制要求</strong>：<br>    (1)直线要直；<br>    (2)直线的端点要准确；<br>    (3)亮度、色泽均匀；<br>    (4)画线速度快；<br>    (5)具有不同的色泽、亮度、线型等。</p><p><strong>1.数值微分法（DDA）</strong></p><p>数值微分法(DDA法，Digital Differential Analyzer)是一种直接从直线的微分方程生成直线的方法。给定直线的两端点P0(x0, y0)和P1(x1, y1)，得到直线的微分方程如下：</p><p><img src="https://s1.ax1x.com/2020/04/21/J3q01K.png" srcset="/img/loading.gif" alt="J3q01K.png"></p><p><img src="https://s1.ax1x.com/2020/04/21/J3q5jS.png" srcset="/img/loading.gif" alt="J3q5jS.png"></p><p><a href="https://imgchr.com/i/J3LI8x" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3LI8x.png" srcset="/img/loading.gif" alt="J3LI8x.png"></a></p><p><img src="https://s1.ax1x.com/2020/04/21/J3Lr80.png" srcset="/img/loading.gif" alt="J3Lr80.png"></p><p>求出来可能是小数，然后要四舍五入取整。</p><p><img src="https://s1.ax1x.com/2020/04/21/J3Orod.png" srcset="/img/loading.gif" alt="J3Orod.png"></p><p><strong>（上图黄色框中漏了一个（2，1）！！！）</strong></p><p><strong>2.中点Bresenham算法</strong></p><p>在增量大的方向变化一个步长，从当前点（红色）考虑变化大方向的下两个点（蓝色，绿色点），然后看蓝色和绿色哪个点和直线距离最近下一个点就选谁（图中选择蓝色点）。</p><p>然后把蓝色点看成p~i~接着去找p~u~, p~d~    .</p><p><img src="https://s1.ax1x.com/2020/04/21/J3X674.png" srcset="/img/loading.gif" alt="J3X674.png"></p><p><img src="https://s1.ax1x.com/2020/04/21/J3jbrT.png" srcset="/img/loading.gif" alt="J3jbrT.png"></p><p><a href="https://imgchr.com/i/J3jxi9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/21/J3vCM6.png" srcset="/img/loading.gif" alt="J3vCM6.png"></a></p><p>计算递推式（加快运行效率）</p><p><img src="https://s1.ax1x.com/2020/04/28/J49oEF.png" srcset="/img/loading.gif" alt="J49oEF.png"></p><p>进一步增加运行效率(去掉k中的除法) </p><p><a href="https://imgchr.com/i/J49bC9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/28/J49bC9.png" srcset="/img/loading.gif" alt="J49bC9.png"></a></p><p><img src="https://s1.ax1x.com/2020/04/28/J4CEKP.png" srcset="/img/loading.gif" alt="J4CEKP.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4CVDf.png" srcset="/img/loading.gif" alt="J4CVDf.png"></p><p><strong>3.改进的Bresenham算法</strong></p><p><img src="https://s1.ax1x.com/2020/04/28/J4C1vq.png" srcset="/img/loading.gif" alt="J4C1vq.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4C4xI.png" srcset="/img/loading.gif" alt="J4C4xI.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4CTqf.png" srcset="/img/loading.gif" alt="J4CTqf.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4PJSA.png" srcset="/img/loading.gif" alt="J4PJSA.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4Pdw8.png" srcset="/img/loading.gif" alt="J4Pdw8.png"></p><h3 id="圆的扫描转换"><a href="#圆的扫描转换" class="headerlink" title="圆的扫描转换"></a>圆的扫描转换</h3><p><strong>1.中点bresenham画圆算法</strong></p><p><img src="https://s1.ax1x.com/2020/04/28/J4ACc9.png" srcset="/img/loading.gif" alt="J4ACc9.png"></p><p><a href="https://imgchr.com/i/J4ENa6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/28/J4ENa6.png" srcset="/img/loading.gif" alt="J4ENa6.png"></a></p><p><img src="https://s1.ax1x.com/2020/04/28/J4VSy9.png" srcset="/img/loading.gif" alt="J4VSy9.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4VTpD.png" srcset="/img/loading.gif" alt="J4VTpD.png"></p><h3 id="椭圆的扫描转换"><a href="#椭圆的扫描转换" class="headerlink" title="椭圆的扫描转换"></a>椭圆的扫描转换</h3><p><strong>中点bresenham算法</strong></p><p><img src="https://s1.ax1x.com/2020/04/28/J4efJK.png" srcset="/img/loading.gif" alt="J4efJK.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4mTpT.png" srcset="/img/loading.gif" alt="J4mTpT.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4mvA1.png" srcset="/img/loading.gif" alt="J4mvA1.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4nOxS.png" srcset="/img/loading.gif" alt="J4nOxS.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4uF2T.png" srcset="/img/loading.gif" alt="J4uF2T.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4uuI1.png" srcset="/img/loading.gif" alt="J4uuI1.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4QgdH.png" srcset="/img/loading.gif" alt="J4QgdH.png"></p><h3 id="多边形的扫描转换与区域填充"><a href="#多边形的扫描转换与区域填充" class="headerlink" title="多边形的扫描转换与区域填充"></a>多边形的扫描转换与区域填充</h3><p><img src="https://s1.ax1x.com/2020/04/28/J48JpR.png" srcset="/img/loading.gif" alt="J48JpR.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4GCg1.png" srcset="/img/loading.gif" alt="J4GCg1.png"></p><h4 id="1-X-扫描线算法"><a href="#1-X-扫描线算法" class="headerlink" title="1.X-扫描线算法"></a><strong>1.X-扫描线算法</strong></h4><p><img src="https://s1.ax1x.com/2020/04/28/J4JteK.png" srcset="/img/loading.gif" alt="J4JteK.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4YKnP.png" srcset="/img/loading.gif" alt="J4YKnP.png"></p><p><strong>基本思想：</strong>如下图所示，按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的所有像素。 </p><p><strong>算法步骤：</strong><br>    (1)确定多边形所占有的最大扫描线数，得到多边形顶点的最小和最大y值（ymin和ymax）。</p><p>​                         <img src="https://s1.ax1x.com/2020/04/28/J40Pv4.png" srcset="/img/loading.gif" alt="J40Pv4.png">          </p><p>​    (2)从y=ymin到y=ymax，每次用一条扫描线进行填充。填充过程可分为四个步骤：<br>​      a.求交：计算扫描线与多边形各边的交点；<br>​      b.排序：把所有交点按照递增顺序进行排序；<br>​      c.交点配对：交点两两配对，表示扫描线与多边形的一个相交区间；<br>​      d.区间填色：将相交区间内的像素置成不同于背景色的填充色。<br>​    存在问题：当扫描线与多边形顶点相交时，交点的取舍问题。如下图所示，在扫描线y=1，y=5和y=7时，扫描线过多边形的顶点，若不加以处理，交点配对时会发生错误。</p><p><img src="https://s1.ax1x.com/2020/04/28/J4wNjJ.png" srcset="/img/loading.gif" alt="J4wNjJ.png"></p><p>​    解决方法：当扫描线与多边形的顶点相交时，<strong>若共享顶点的两条边分别落在扫描线的两边，交点只算一个</strong>；若<strong>共享顶点的两条边在扫描线的同一边，这时交点作为零个或两个</strong>。实际处理时，只要检查顶点的两条边的另外两个端点的Y值，两个Y值中大于交点Y值的个数是0，1，2，来决定取0，1，2个交点</p><h4 id="2-改进的有效边算法-y的连贯性算法"><a href="#2-改进的有效边算法-y的连贯性算法" class="headerlink" title="2.改进的有效边算法(y的连贯性算法)"></a><strong>2.改进的有效边算法(y的连贯性算法)</strong></h4><p>由于x-扫描线算法在处理每条扫描线时，需要与多边形所有的边求交，效率很低，因此需要加以改进，形成改进的有效边表算法。</p><p><img src="https://s1.ax1x.com/2020/04/28/J4Bnwn.png" srcset="/img/loading.gif" alt="J4Bnwn.png"></p><p><img src="https://s1.ax1x.com/2020/04/28/J4DpX4.png" srcset="/img/loading.gif" alt="J4DpX4.png"></p><p> 边表：为了方便有效边表的建立与更新，需要构造一个边表（Edge Table）。<br>     (1)首先构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个结点，称为一个桶，则对应多边形覆盖的每一条扫描线。<br>     (2)将每条边的信息链入与该边最小y坐标（ymin）相对应的桶处。也就是说，若某边的较低端点为ymin，则该边就放在相应的扫描线桶中。<br>     (3)每条边的数据形成一个结点，内容包括：该扫描线与该边的初始交点x（即较低端点的x值），1/k，以及该边的最大y值ymax。 </p><p>x|ymin   ymax  1/k   NEXT</p><p>​    (4)同一桶中若干条边按X|ymin由小到大排序，若x|ymin 相等，则按照1/k由小到大排序。</p><p>​    为了解决顶点交点计为1时的情形，可将多边形的某些边缩短以分离那些应计为1个交点的顶点，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/04/28/J4rAbj.png" srcset="/img/loading.gif" alt="J4rAbj.png"></p><p>根据建立的边表，改进有效边表（活化边表）的算法步骤如下：<br>    (1)初始化：构造边表，AET表置空；<br>    (2)将第一个不空的ET表中的边与AET表合并；<br>    (3)由AET表中取出交点对进行填充。填充之后删除y=ymax的边；<br>    (4)yi+1=yi+1,根据xi+1=xi+1/k计算并修改AET表，同时合并ET表中y=yi+1桶中的边，按次序插入到AET表中，形成新的AET表；<br>    (5)AET表不为空则转(3)，否则结束。</p><p><img src="https://s1.ax1x.com/2020/04/28/J4sz1f.png" srcset="/img/loading.gif" alt="J4sz1f.png"></p><h4 id="3-边缘填充算法"><a href="#3-边缘填充算法" class="headerlink" title="3.边缘填充算法"></a><strong>3.边缘填充算法</strong></h4><p>基本思想：按任意顺序处理多边形的每条边。处理时，先求出该边与扫描线的交点，再对扫描线上交点右方的所有像素取反。<br>特点：算法简单，但对于复杂图型，每一像素可能被访问多次。</p><h4 id="4-栅栏填充算法"><a href="#4-栅栏填充算法" class="headerlink" title="4.栅栏填充算法"></a><strong>4.栅栏填充算法</strong></h4><p>​    栅栏指的是一条过多边形顶点且与扫描线垂直的直线。它把多边形分为两半。<br>​    基本思想：按任意顺序处理多边形的每一条边，但处理每条边与扫描线的交点时，将交点与栅栏之间的像素取反。<br>​    特点：这种算法尽管减少了被重复访问像素的数目，但仍有一些像素被重复访问。</p><p><img src="https://s1.ax1x.com/2020/04/28/J4gI5d.png" srcset="/img/loading.gif" alt="J4gI5d.png"></p><h4 id="5-边标志算法"><a href="#5-边标志算法" class="headerlink" title="5.边标志算法"></a>5.边标志算法</h4><p>​     基本思想：先用特殊的颜色在帧缓存中将多边形的边界勾画出来，然后将着色的像素点依x坐标递增的顺序配对，再把每一对像素构成的区间置为填充色。<br>​     操作分为两个步骤：<br>​     (1)打标记：对多边形的每条边进行直线扫描转换。<br>​     (2)填充：对每条与多边形相交的扫描线，依从左到右的顺序，按“左闭右开”的原则对扫描线上的像素点进行填色。<br>​     特点：当用软件实现本算法时，速度与改进的有效边表算法相当，但本算法用硬件实现后速度会有很大提高。</p><h4 id="6-区域填充算法"><a href="#6-区域填充算法" class="headerlink" title="6.区域填充算法"></a><strong>6.区域填充算法</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMaNlV.png" srcset="/img/loading.gif" alt="YMaNlV.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMacSx.png" srcset="/img/loading.gif" alt="YMacSx.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMdFXT.png" srcset="/img/loading.gif" alt="YMdFXT.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMdEBF.png" srcset="/img/loading.gif" alt="YMdEBF.png"></p><h4 id="7-简单的种子填充算法"><a href="#7-简单的种子填充算法" class="headerlink" title="7.简单的种子填充算法"></a><strong>7.简单的种子填充算法</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMdK91.png" srcset="/img/loading.gif" alt="YMdK91.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMdN4A.png" srcset="/img/loading.gif" alt="YMdN4A.png"></p><p>这其实就是个BFS，但是他是不带标记的（出栈的会标记上），所以很多像素会重复入栈。</p><h4 id="8-扫描线种子填充算法"><a href="#8-扫描线种子填充算法" class="headerlink" title="8.扫描线种子填充算法"></a><strong>8.扫描线种子填充算法</strong></h4><p>详细解释：<a href="https://blog.csdn.net/orbit/article/details/7343236" target="_blank" rel="noopener">https://blog.csdn.net/orbit/article/details/7343236</a></p><p><img src="https://s1.ax1x.com/2020/05/09/YMwWIH.png" srcset="/img/loading.gif" alt="YMwWIH.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMwOoQ.png" srcset="/img/loading.gif" alt="YMwOoQ.png"></p><h4 id="9-泛填充算法"><a href="#9-泛填充算法" class="headerlink" title="9.泛填充算法"></a><strong>9.泛填充算法</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMwxWn.png" srcset="/img/loading.gif" alt="YMwxWn.png"></p><h3 id="其他相关概念："><a href="#其他相关概念：" class="headerlink" title="其他相关概念："></a>其他相关概念：</h3><p><img src="https://s1.ax1x.com/2020/05/09/YMDCaF.png" srcset="/img/loading.gif" alt="YMDCaF.png"></p><p><strong>非零环绕数规则：</strong><a href="https://www.jianshu.com/p/f1590d4fb5c5" target="_blank" rel="noopener">https://www.jianshu.com/p/f1590d4fb5c5</a></p><p><img src="https://s1.ax1x.com/2020/05/09/YMD5W9.png" srcset="/img/loading.gif" alt="YMD5W9.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMDIzR.png" srcset="/img/loading.gif" alt="YMDIzR.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMsN4g.png" srcset="/img/loading.gif" alt="YMsN4g.png"></p><h3 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h3><p><img src="https://s1.ax1x.com/2020/05/09/YMsd3j.png" srcset="/img/loading.gif" alt="YMsd3j.png"></p><h3 id="属性处理"><a href="#属性处理" class="headerlink" title="属性处理"></a>属性处理</h3><p>刷子 改变 线条的颜色，线宽。</p><p><img src="https://s1.ax1x.com/2020/05/09/YMcmNT.png" srcset="/img/loading.gif" alt="YMcmNT.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMcwgH.png" srcset="/img/loading.gif" alt="YMcwgH.png"></p><p>上下各扩展一个，宽度为1就变为宽度为3了。</p><p><img src="C:\Users\49815\AppData\Roaming\Typora\typora-user-images\1588988297063.png" srcset="/img/loading.gif" alt="1588988297063"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMWPI0.png" srcset="/img/loading.gif" alt="YMWPI0.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMW3RO.png" srcset="/img/loading.gif" alt="YMW3RO.png"></p><p><strong>利用 像素模板 改变线形</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YMhIr4.png" srcset="/img/loading.gif" alt="YMhIr4.png"></p><p><strong>填充属性：</strong></p><p><strong>走样现象：</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YM4xf0.png" srcset="/img/loading.gif" alt="YM4xf0.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YM5Jht.png" srcset="/img/loading.gif" alt="YM5Jht.png"></p><p><strong>反走样技术：</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YMHEzq.png" srcset="/img/loading.gif" alt="YMHEzq.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMb2g1.png" srcset="/img/loading.gif" alt="YMb2g1.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMqLi4.png" srcset="/img/loading.gif" alt="YMqLi4.png"></p><h2 id="第六章：二维变换"><a href="#第六章：二维变换" class="headerlink" title="第六章：二维变换"></a>第六章：二维变换</h2><p><img src="https://s1.ax1x.com/2020/05/09/YMLtO0.png" srcset="/img/loading.gif" alt="YMLtO0.png"></p><h3 id="基本几何变换"><a href="#基本几何变换" class="headerlink" title="基本几何变换"></a>基本几何变换</h3><h4 id="1-平移变换"><a href="#1-平移变换" class="headerlink" title="1.平移变换"></a><strong>1.平移变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMLqnP.png" srcset="/img/loading.gif" alt="YMLqnP.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMOFBV.png" srcset="/img/loading.gif" alt="YMOFBV.png"></p><h4 id="2-比例变换"><a href="#2-比例变换" class="headerlink" title="2.比例变换"></a><strong>2.比例变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMO1HK.png" srcset="/img/loading.gif" alt="YMO1HK.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMORvn.png" srcset="/img/loading.gif" alt="YMORvn.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMX8rq.png" srcset="/img/loading.gif" alt="YMX8rq.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMXNIU.png" srcset="/img/loading.gif" alt="YMXNIU.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMXwRJ.png" srcset="/img/loading.gif" alt="YMXwRJ.png"></p><p>Sx=Sy=2，x和y都扩大2倍</p><p>Sx=2，Sy=1，x扩大两倍，y不变。</p><h4 id="3-旋转变换"><a href="#3-旋转变换" class="headerlink" title="3.旋转变换"></a><strong>3.旋转变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMj0k8.png" srcset="/img/loading.gif" alt="YMj0k8.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMjxhD.png" srcset="/img/loading.gif" alt="YMjxhD.png"></p><h4 id="4-对称变换"><a href="#4-对称变换" class="headerlink" title="4.对称变换"></a><strong>4.对称变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMvZ4S.png" srcset="/img/loading.gif" alt="YMvZ4S.png"></p><p>其他的关于什么对称可以先写出坐标,然后对应着找矩阵，就不一一列举了。</p><h4 id="5-错切变换"><a href="#5-错切变换" class="headerlink" title="5.错切变换"></a><strong>5.错切变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/09/YMvav9.png" srcset="/img/loading.gif" alt="YMvav9.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YMvrE6.png" srcset="/img/loading.gif" alt="YMvrE6.png"></p><p><img src="https://s1.ax1x.com/2020/05/09/YQpboq.png" srcset="/img/loading.gif" alt="YQpboq.png"></p><h4 id="6-复合变换"><a href="#6-复合变换" class="headerlink" title="6.复合变换"></a><strong>6.复合变换</strong></h4><p>上面的变换矩阵多个乘在一起就是多个变换的叠加。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQiHjU.png" srcset="/img/loading.gif" alt="YQiHjU.png"></p><p>先平移到原点，然后缩放，再平移回去。</p><p>如何实现任意参照点的旋转变换？  先平移到原点，然后旋转，再平移回去。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQFfKO.png" srcset="/img/loading.gif" alt="YQFfKO.png"></p><p>先向右平移，然后旋转theta角，关于y对称过去成p’，然后反转回来theta角，最后左平移回去。</p><h3 id="二维观察变换"><a href="#二维观察变换" class="headerlink" title="二维观察变换"></a>二维观察变换</h3><p>有关 <strong>窗口</strong> 的几个定义：<strong>用户域</strong>和<strong>窗口区</strong></p><p><strong>窗口用来定义下显示什么</strong>。比如框住一棵树，那么窗口就要显示树。</p><p><img src="https://s1.ax1x.com/2020/05/12/YYHvuQ.png" srcset="/img/loading.gif" alt="YYHvuQ.png"></p><p>有关 <strong>视区</strong> 的几个定义：<strong>屏幕域</strong>和<strong>视图区</strong></p><p><strong>视区定义图象显示在何处</strong>，比如上面说到的那棵树在屏幕的哪儿就是视区定义的。</p><p><img src="https://s1.ax1x.com/2020/05/12/YYbAvF.png" srcset="/img/loading.gif" alt="YYbAvF.png"></p><h4 id="窗口和视图区"><a href="#窗口和视图区" class="headerlink" title="窗口和视图区"></a><strong>窗口和视图区</strong></h4><p><img src="https://s1.ax1x.com/2020/05/12/YYbeb9.png" srcset="/img/loading.gif" alt="YYbeb9.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YYLkm4.png" srcset="/img/loading.gif" alt="YYLkm4.png"></p><p>解得(<strong>这个解没必要背，理解上面两个公式，直接分别把$X_s,Y_s$移动到一边即可</strong>)：</p><p><img src="https://s1.ax1x.com/2020/05/18/YhrKMR.png" srcset="/img/loading.gif" alt="YhrKMR.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YYLwjS.png" srcset="/img/loading.gif" alt="YYLwjS.png"></p><h4 id="观察变换"><a href="#观察变换" class="headerlink" title="观察变换"></a><strong>观察变换</strong></h4><p><img src="https://s1.ax1x.com/2020/05/12/YYLIHJ.png" srcset="/img/loading.gif" alt="YYLIHJ.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YYOC4I.png" srcset="/img/loading.gif" alt="YYOC4I.png"></p><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><img src="https://s1.ax1x.com/2020/05/12/YYOfPI.png" srcset="/img/loading.gif" alt="YYOfPI.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YYO5xf.png" srcset="/img/loading.gif" alt="YYO5xf.png"></p><p><strong><img src="https://s1.ax1x.com/2020/05/12/YYObZQ.png" srcset="/img/loading.gif" alt="YYObZQ.png"></strong></p><p><img src="https://s1.ax1x.com/2020/05/12/YYXuLD.png" srcset="/img/loading.gif" alt="YYXuLD.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YYX3FA.png" srcset="/img/loading.gif" alt="YYX3FA.png"></p><h4 id="Cihen-Sutherland裁剪算法"><a href="#Cihen-Sutherland裁剪算法" class="headerlink" title="Cihen-Sutherland裁剪算法"></a><strong>Cihen-Sutherland裁剪算法</strong></h4><p><img src="https://s1.ax1x.com/2020/05/12/YYXrYn.png" srcset="/img/loading.gif" alt="YYXrYn.png"></p><p><strong>落在窗口内就是0000.</strong></p><p><img src="https://s1.ax1x.com/2020/05/12/YYjc4A.png" srcset="/img/loading.gif" alt="YYjc4A.png"></p><p><strong>如果是立方体：那么需要6位编码（立方体六个面）</strong></p><p>具体算法：<a href="https://blog.csdn.net/soulmeetliang/article/details/79179350" target="_blank" rel="noopener">https://blog.csdn.net/soulmeetliang/article/details/79179350</a></p><p><img src="https://s1.ax1x.com/2020/05/12/YYjH4s.png" srcset="/img/loading.gif" alt="YYjH4s.png"></p><p>用Cohen-Sutherland编码最多求4次交点。</p><h4 id="中点分割算法-对分法"><a href="#中点分割算法-对分法" class="headerlink" title="中点分割算法(对分法)"></a><strong>中点分割算法(对分法)</strong></h4><p><img src="https://s1.ax1x.com/2020/05/12/YYzTED.png" srcset="/img/loading.gif" alt="YYzTED.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/Yt9vK1.png" srcset="/img/loading.gif" alt="Yt9vK1.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtPiwV.png" srcset="/img/loading.gif" alt="YtPiwV.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtiK3Q.png" srcset="/img/loading.gif" alt="YtiK3Q.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtiMcj.png" srcset="/img/loading.gif" alt="YtiMcj.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/Ytia34.png" srcset="/img/loading.gif" alt="Ytia34.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtiDD1.png" srcset="/img/loading.gif" alt="YtiDD1.png"></p><h4 id="参数裁剪算法-Cyrus-Beck"><a href="#参数裁剪算法-Cyrus-Beck" class="headerlink" title="参数裁剪算法(Cyrus-Beck)"></a><strong>参数裁剪算法(Cyrus-Beck)</strong></h4><p><img src="https://s1.ax1x.com/2020/05/12/YtFpV0.png" srcset="/img/loading.gif" alt="YtFpV0.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtkOns.png" srcset="/img/loading.gif" alt="YtkOns.png"></p><p>下面的两个交点和P1一共3个点 要<strong>求最大值</strong>，上面的 三个点和P2一共四个点 <strong>求最小值</strong>，即可求出相交线段。可是如何知道哪个点算作上部分，哪个点算作下部分呢？我们先看边的法向量和向量P1P2的夹角，如果夹角小于90，算下部分；大于90算上部分。</p><p><img src="https://s1.ax1x.com/2020/05/12/YtVeSO.png" srcset="/img/loading.gif" alt="YtVeSO.png"></p><h4 id="Liang-Barsky算法"><a href="#Liang-Barsky算法" class="headerlink" title="Liang-Barsky算法"></a><strong>Liang-Barsky算法</strong></h4><p>详细介绍：<a href="https://blog.csdn.net/keneyr/article/details/83871170" target="_blank" rel="noopener">https://blog.csdn.net/keneyr/article/details/83871170</a></p><p>​                    <a href="https://blog.csdn.net/soulmeetliang/article/details/79185603" target="_blank" rel="noopener">https://blog.csdn.net/soulmeetliang/article/details/79185603</a></p><p><img src="https://s1.ax1x.com/2020/05/12/YtVoh6.png" srcset="/img/loading.gif" alt="YtVoh6.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtVbcD.png" srcset="/img/loading.gif" alt="YtVbcD.png"></p><p><a href="https://imgchr.com/i/Y497Sf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/19/Y497Sf.png" srcset="/img/loading.gif" alt="Y497Sf.png"></a></p><p><img src="https://s1.ax1x.com/2020/05/12/YtZrbd.png" srcset="/img/loading.gif" alt="YtZrbd.png"></p><p><img src="https://s1.ax1x.com/2020/05/12/YtZ2PP.png" srcset="/img/loading.gif" alt="YtZ2PP.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4P9UA.png" srcset="/img/loading.gif" alt="Y4P9UA.png"></p><h4 id="Weiler-Atherton多边形裁剪算法："><a href="#Weiler-Atherton多边形裁剪算法：" class="headerlink" title="Weiler-Atherton多边形裁剪算法："></a><strong>Weiler-Atherton多边形裁剪算法：</strong></h4><p><a href="https://blog.csdn.net/yangxi_pekin/article/details/37738219" target="_blank" rel="noopener">https://blog.csdn.net/yangxi_pekin/article/details/37738219</a></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4uUCF.png" srcset="/img/loading.gif" alt="Y4uUCF.png"></p><p><a href="https://imgchr.com/i/Y4u6UK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/19/Y4u6UK.png" srcset="/img/loading.gif" alt="Y4u6UK.png"></a></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4u7Uf.png" srcset="/img/loading.gif" alt="Y4u7Uf.png"></p><p><strong>$I_1,I_3,I_5,I_7$是进点</strong></p><p><strong>内裁剪：</strong></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4KFGF.png" srcset="/img/loading.gif" alt="Y4KFGF.png"></p><p><strong>外裁剪：</strong></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4Miwt.png" srcset="/img/loading.gif" alt="Y4Miwt.png"></p><h4 id="Sutherland-Hodgeman多边形裁剪"><a href="#Sutherland-Hodgeman多边形裁剪" class="headerlink" title="Sutherland-Hodgeman多边形裁剪"></a><strong>Sutherland-Hodgeman多边形裁剪</strong></h4><h4 id="字符裁剪"><a href="#字符裁剪" class="headerlink" title="字符裁剪"></a>字符裁剪</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y43S4P.png" srcset="/img/loading.gif" alt="Y43S4P.png"></p><h2 id="第七章：三维变换及三维观察"><a href="#第七章：三维变换及三维观察" class="headerlink" title="第七章：三维变换及三维观察"></a>第七章：三维变换及三维观察</h2><h3 id="三维上-的裁剪"><a href="#三维上-的裁剪" class="headerlink" title="三维上 的裁剪"></a>三维上 的裁剪</h3><h3 id="三维上的几何变换"><a href="#三维上的几何变换" class="headerlink" title="三维上的几何变换"></a>三维上的几何变换</h3><h4 id="比例变换"><a href="#比例变换" class="headerlink" title="比例变换"></a>比例变换</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y48RoR.png" srcset="/img/loading.gif" alt="Y48RoR.png"></p><p><strong>逆变换</strong>：a，e，j变为原来的倒数</p><p><img src="https://s1.ax1x.com/2020/05/19/Y4G9Og.png" srcset="/img/loading.gif" alt="Y4G9Og.png"></p><p>解:</p><p><img src="https://s1.ax1x.com/2020/05/19/Y4GUXD.png" srcset="/img/loading.gif" alt="Y4GUXD.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4GfBQ.png" srcset="/img/loading.gif" alt="Y4GfBQ.png"></p><h4 id="旋转变换："><a href="#旋转变换：" class="headerlink" title="旋转变换："></a>旋转变换：</h4><p>规定用<strong>右手坐标系</strong></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4JwvT.png" srcset="/img/loading.gif" alt="Y4JwvT.png"></p><p>按照X’ Y’ Z’的顺序对应着找，就可以写出下面的旋转矩阵，不用死记。</p><p>$[X’，Y’，Z’，1]  ·T_{RX}=[x，y<em>cosθ-z</em>sinθ，y<em>sinθ+z</em>cosθ]$</p><p><img src="https://s1.ax1x.com/2020/05/19/Y4J6a9.png" srcset="/img/loading.gif" alt="Y4J6a9.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4J5rD.png" srcset="/img/loading.gif" alt="Y4J5rD.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4YpZQ.png" srcset="/img/loading.gif" alt="Y4YpZQ.png"></p><h4 id="对称变换："><a href="#对称变换：" class="headerlink" title="对称变换："></a>对称变换：</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y4YnZ4.png" srcset="/img/loading.gif" alt="Y4YnZ4.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4YQiR.png" srcset="/img/loading.gif" alt="Y4YQiR.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4Y1Rx.png" srcset="/img/loading.gif" alt="Y4Y1Rx.png"></p><p><strong>关于平面的变换和比例变换一个道理，相当于变成原来的-1倍</strong></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4Yaod.png" srcset="/img/loading.gif" alt="Y4Yaod.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4YrSP.png" srcset="/img/loading.gif" alt="Y4YrSP.png"></p><h4 id="错切变换："><a href="#错切变换：" class="headerlink" title="错切变换："></a>错切变换：</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y4Ygeg.png" srcset="/img/loading.gif" alt="Y4Ygeg.png"></p><p>c=f=0时，不难看出z’=z 。b=0，h=0则y’=y  。x’=x+dy+gz。</p><p>后面两个同理。</p><h4 id="平移变换："><a href="#平移变换：" class="headerlink" title="平移变换："></a>平移变换：</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y4YbmF.png" srcset="/img/loading.gif" alt="Y4YbmF.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4NS4s.png" srcset="/img/loading.gif" alt="Y4NS4s.png"></p><p><strong>绕空间轴三维旋转变换：</strong></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4N7a4.png" srcset="/img/loading.gif" alt="Y4N7a4.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4U9de.png" srcset="/img/loading.gif" alt="Y4U9de.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YILcDA.png" srcset="/img/loading.gif" alt="YILcDA.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y405E8.png" srcset="/img/loading.gif" alt="Y405E8.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIOCr9.png" srcset="/img/loading.gif" alt="YIOCr9.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIOPbR.png" srcset="/img/loading.gif" alt="YIOPbR.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIOarj.png" srcset="/img/loading.gif" alt="YIOarj.png"></p><h3 id="三维上的投影"><a href="#三维上的投影" class="headerlink" title="三维上的投影"></a>三维上的投影</h3><p><img src="https://s1.ax1x.com/2020/05/19/Y4Dbmq.png" srcset="/img/loading.gif" alt="Y4Dbmq.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4rMnI.png" srcset="/img/loading.gif" alt="Y4rMnI.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4r5E6.png" srcset="/img/loading.gif" alt="Y4r5E6.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4rbgH.png" srcset="/img/loading.gif" alt="Y4rbgH.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4sDsA.png" srcset="/img/loading.gif" alt="Y4sDsA.png"></p><h4 id="正投影"><a href="#正投影" class="headerlink" title="正投影"></a>正投影</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y4s4Mj.png" srcset="/img/loading.gif" alt="Y4s4Mj.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y46ujJ.png" srcset="/img/loading.gif" alt="Y46ujJ.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4gpes.png" srcset="/img/loading.gif" alt="Y4gpes.png"></p><p>为了在一个面上，可以做如下处理：</p><p>俯视图即： 先投影到XOY面上，然后绕着x轴旋转-90°。</p><p>侧视图：先投影到YOZ面上，然后绕着Z轴转90°。</p><p><img src="https://s1.ax1x.com/2020/05/19/Y4fhb4.png" srcset="/img/loading.gif" alt="Y4fhb4.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIXtFx.png" srcset="/img/loading.gif" alt="YIXtFx.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIXs0A.png" srcset="/img/loading.gif" alt="YIXs0A.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4hAsS.png" srcset="/img/loading.gif" alt="Y4hAsS.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4hKGq.png" srcset="/img/loading.gif" alt="Y4hKGq.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/YIvuMF.png" srcset="/img/loading.gif" alt="YIvuMF.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y44z9I.png" srcset="/img/loading.gif" alt="Y44z9I.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y45pgP.png" srcset="/img/loading.gif" alt="Y45pgP.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y45AEQ.png" srcset="/img/loading.gif" alt="Y45AEQ.png"></p><h4 id="斜投影"><a href="#斜投影" class="headerlink" title="斜投影"></a>斜投影</h4><p><img src="https://s1.ax1x.com/2020/05/19/Y4IkM6.png" srcset="/img/loading.gif" alt="Y4IkM6.png"></p><p><img src="https://s1.ax1x.com/2020/05/19/Y4I5y6.png" srcset="/img/loading.gif" alt="Y4I5y6.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxbRld.png" srcset="/img/loading.gif" alt="YxbRld.png"></p><p>斜等测的投影和原来物体长度相等，而斜二测不相等，斜二测是op=2op’，变为原来的1/2。</p><h4 id="透视投影："><a href="#透视投影：" class="headerlink" title="透视投影："></a><strong>透视投影：</strong></h4><p><img src="https://s1.ax1x.com/2020/05/24/YxqChF.png" srcset="/img/loading.gif" alt="YxqChF.png"></p><p>投影平面上的是投影，后面的是物体。当后面的物体往后移，投影变小。透视投影可以产生近大远小的特点。</p><p><img src="https://s1.ax1x.com/2020/05/24/Yxqa4S.png" srcset="/img/loading.gif" alt="Yxqa4S.png"></p><p>由相似关系可得变换矩阵：</p><p><img src="https://s1.ax1x.com/2020/05/24/YxqBcj.png" srcset="/img/loading.gif" alt="YxqBcj.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxL9bt.png" srcset="/img/loading.gif" alt="YxL9bt.png"></p><p>在上图中，投影平面为XOY，正方体中和投影面不平行的只有侧着的四个边，他们相交于一点，即为灭点，又因为这四个侧边是作汴州方向的平行线，所以这个灭点还是个主灭点。</p><p><img src="https://s1.ax1x.com/2020/05/24/YxqvgH.png" srcset="/img/loading.gif" alt="YxqvgH.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxL5i8.png" srcset="/img/loading.gif" alt="YxL5i8.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxOrT0.png" srcset="/img/loading.gif" alt="YxOrT0.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxO7tK.png" srcset="/img/loading.gif" alt="YxO7tK.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YxzzJx.png" srcset="/img/loading.gif" alt="YxzzJx.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzSeYt.png" srcset="/img/loading.gif" alt="YzSeYt.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzSQOg.png" srcset="/img/loading.gif" alt="YzSQOg.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzPAjf.png" srcset="/img/loading.gif" alt="YzPAjf.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzPGuT.png" srcset="/img/loading.gif" alt="YzPGuT.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzPh8I.png" srcset="/img/loading.gif" alt="YzPh8I.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YziSMV.png" srcset="/img/loading.gif" alt="YziSMV.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/Yziia4.png" srcset="/img/loading.gif" alt="Yziia4.png"></p><h2 id="第八章：曲线和曲面"><a href="#第八章：曲线和曲面" class="headerlink" title="第八章：曲线和曲面"></a>第八章：曲线和曲面</h2><p><img src="https://s1.ax1x.com/2020/06/09/tIk74I.png" srcset="/img/loading.gif" alt="tIk74I.png"></p><p>我们称：将连接有一定次序的控制点的直线序列称之为<strong>控制多边形</strong> 或者 <strong>特征多边形</strong></p><p>曲线可以用单个参数来表示，例如：</p><p><img src="https://s1.ax1x.com/2020/06/09/tIAjRx.png" srcset="/img/loading.gif" alt="tIAjRx.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzFClt.png" srcset="/img/loading.gif" alt="YzFClt.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzFeYj.png" srcset="/img/loading.gif" alt="YzFeYj.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzFupn.png" srcset="/img/loading.gif" alt="YzFupn.png"></p><p>比如线性插值： 是指两个不同点x1，x2，用一个线性函数y=ax+b近似代替，称为线性插值函数</p><p>抛物线插值：三个不同的点x1，x2，x3的函数值分别为y1,y2,y3，要求构造一个函数 $f(x)=ax^2+bx+c$,使得抛物线f(x)在x=x1,x2,x3时与y1,y2,y3的值相等。(其实就是要求抛物线经过这三个点)</p><p><img src="https://s1.ax1x.com/2020/05/24/YzFr7D.png" srcset="/img/loading.gif" alt="YzFr7D.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzkgVU.png" srcset="/img/loading.gif" alt="YzkgVU.png"></p><p><img src="https://s1.ax1x.com/2020/05/24/YzkGKP.png" srcset="/img/loading.gif" alt="YzkGKP.png"></p><p><strong>参数连续性：</strong>一阶参数连续性中的α为1时，即交点处一阶导数相等，此时即为一阶参数连续性，α为n，代表n阶导数相等（0阶参数连续性就是指连接点处的函数数值相同）。记为$C^n$</p><p><strong>n阶几何连续性：</strong> 1.2.3…n阶交点处导数都成比例,且比例相等。 (0阶几何连续就是交点处函数值相同)</p><p><img src="https://s1.ax1x.com/2020/05/26/tPuxkd.png" srcset="/img/loading.gif" alt="tPuxkd.png"></p><p><img src="https://s1.ax1x.com/2020/05/26/tPKiX8.png" srcset="/img/loading.gif" alt="tPKiX8.png"></p><p><img src="https://s1.ax1x.com/2020/05/26/tPMpE4.png" srcset="/img/loading.gif" alt="tPMpE4.png"></p><p><strong>记住下图的矩阵：</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tPMebD.png" srcset="/img/loading.gif" alt="tPMebD.png"></p><p><img src="https://s1.ax1x.com/2020/05/26/tPMgZF.png" srcset="/img/loading.gif" alt="tPMgZF.png"></p><p><strong>n+1</strong>个控制点可以构造<strong>n</strong>次的贝塞尔曲线</p><p><img src="https://s1.ax1x.com/2020/05/26/tPQ8Y9.png" srcset="/img/loading.gif" alt="tPQ8Y9.png"></p><p>首尾相连的曲线，p0和pn重合</p><p><img src="https://s1.ax1x.com/2020/05/26/tPlQjP.png" srcset="/img/loading.gif" alt="tPlQjP.png"></p><p><strong>一次贝塞尔曲线是一条直线段  $p(t)=(1-t)p_0+tp_1$</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tPlfjx.png" srcset="/img/loading.gif" alt="tPlfjx.png"></p><p><strong>是一条抛物线，记住上述矩阵</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tP1fiQ.png" srcset="/img/loading.gif" alt="tP1fiQ.png"></p><p><img src="https://s1.ax1x.com/2020/06/09/tIMuIU.png" srcset="/img/loading.gif" alt="tIMuIU.png"></p><p><strong>是一条三次曲线，记住上述矩阵</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tPtDzQ.png" srcset="/img/loading.gif" alt="tPtDzQ.png"></p><p><img src="https://s1.ax1x.com/2020/05/26/tPNEY8.png" srcset="/img/loading.gif" alt="tPNEY8.png"></p><p><img src="https://s1.ax1x.com/2020/05/26/tPUW2F.png" srcset="/img/loading.gif" alt="tPUW2F.png"></p><p>虚线的变化幅度明显大于实现，所以<strong>缩减性变差</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tPaKI0.png" srcset="/img/loading.gif" alt="tPaKI0.png"></p><p>bezier的缺点就是一个整体逼近的方案，<strong>很难实现局部的修改</strong></p><p><img src="https://s1.ax1x.com/2020/05/26/tP0sQU.png" srcset="/img/loading.gif" alt="tP0sQU.png"></p><p><a href="https://imgchr.com/i/tPBN6O" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/26/tPBN6O.png" srcset="/img/loading.gif" alt="tPBN6O.png"></a></p><p><img src="https://s1.ax1x.com/2020/05/26/tPgTZ8.png" srcset="/img/loading.gif" alt="tPgTZ8.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tllDBV.png" srcset="/img/loading.gif" alt="tllDBV.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tllyAU.png" srcset="/img/loading.gif" alt="tllyAU.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tl1C4g.png" srcset="/img/loading.gif" alt="tl1C4g.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tl1nET.png" srcset="/img/loading.gif" alt="tl1nET.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tl8YtO.png" srcset="/img/loading.gif" alt="tl8YtO.png"></p><h2 id="第九章：消隐"><a href="#第九章：消隐" class="headerlink" title="第九章：消隐"></a>第九章：消隐</h2><p><img src="https://s1.ax1x.com/2020/05/31/tlJdeI.png" srcset="/img/loading.gif" alt="tlJdeI.png"></p><p>消隐的对象是三维物体</p><p><img src="https://s1.ax1x.com/2020/05/31/tlYSfO.png" srcset="/img/loading.gif" alt="tlYSfO.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlYC1e.png" srcset="/img/loading.gif" alt="tlYC1e.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlYP6H.png" srcset="/img/loading.gif" alt="tlYP6H.png"></p><h3 id="深度排序算法-画家算法"><a href="#深度排序算法-画家算法" class="headerlink" title="深度排序算法(画家算法)"></a>深度排序算法(画家算法)</h3><p><img src="https://s1.ax1x.com/2020/05/31/tlYZAP.png" srcset="/img/loading.gif" alt="tlYZAP.png"></p><p><strong>先远后进</strong></p><p><img src="https://s1.ax1x.com/2020/05/31/tlY6N6.png" srcset="/img/loading.gif" alt="tlY6N6.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlt3xe.png" srcset="/img/loading.gif" alt="tlt3xe.png"></p><h3 id="深度缓存算法-z-buffer"><a href="#深度缓存算法-z-buffer" class="headerlink" title="深度缓存算法(z-buffer)"></a>深度缓存算法(z-buffer)</h3><p><img src="https://s1.ax1x.com/2020/05/31/tlt6qs.png" srcset="/img/loading.gif" alt="tlt6qs.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlNSQe.png" srcset="/img/loading.gif" alt="tlNSQe.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlN8YV.png" srcset="/img/loading.gif" alt="tlN8YV.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlNYSU.png" srcset="/img/loading.gif" alt="tlNYSU.png"></p><p><img src="https://s1.ax1x.com/2020/05/31/tlyABT.png" srcset="/img/loading.gif" alt="tlyABT.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NRX4ns.png" srcset="/img/loading.gif" alt="NRX4ns.png"></p><p>z(x,y) z(x+1,y) z(x,y+1)互相差一个常数，因此可以已知一个点后去递推其他的点。这样就减少了z值得计算量。</p><p>z-buffer算法缺点还有：在实现反走样，透明和半透明等效果方面有困难。</p><p><strong>总结一下z-buffer method：</strong></p><p>他用了两个数组，FB颜色数组和ZB深度数组，对于每一个图形的像素点，首先看这个像素点的深度Z(X,Y)是否大于当前点的ZB(X,Y)，如果大于则更新该点的颜色数组和深度数组：FB(x,y)=该图形上这个像素的颜色，ZB(X,Y)=Z(X,Y)</p><h3 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h3><p><img src="https://s1.ax1x.com/2020/05/31/tl6VMt.png" srcset="/img/loading.gif" alt="tl6VMt.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NRjTrd.png" srcset="/img/loading.gif" alt="NRjTrd.png"></p><p>这个算法主要是为了加速Z-buffer算法的，因为z-buffer本来要一个一个像素来计算的，现在它通过边表找到一段区间都是同一个颜色，且深度都一样，因此大大加速了相似点的计算。</p><h3 id="区域细分算法"><a href="#区域细分算法" class="headerlink" title="区域细分算法"></a>区域细分算法</h3><p>这算法也是为了加速，分成多种情况分别处理。</p><p><img src="https://s1.ax1x.com/2020/06/29/NWSZz8.png" srcset="/img/loading.gif" alt="NWSZz8.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWSuLQ.png" srcset="/img/loading.gif" alt="NWSuLQ.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWStQU.png" srcset="/img/loading.gif" alt="NWStQU.png"></p><h3 id="光线投射算法-了解"><a href="#光线投射算法-了解" class="headerlink" title="光线投射算法(了解)"></a>光线投射算法(了解)</h3><p><img src="https://s1.ax1x.com/2020/06/29/NWSxkn.png" srcset="/img/loading.gif" alt="NWSxkn.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWSzYq.png" srcset="/img/loading.gif" alt="NWSzYq.png"></p><p>感觉和上面z-buffer没什么区别，就是变成了三维的了。</p><p><img src="https://s1.ax1x.com/2020/06/29/NWpP6U.png" srcset="/img/loading.gif" alt="NWpP6U.png"></p><h3 id="BSP树算法-不考，懒得写了。。"><a href="#BSP树算法-不考，懒得写了。。" class="headerlink" title="BSP树算法(不考，懒得写了。。)"></a>BSP树算法(不考，懒得写了。。)</h3><h2 id="第十章：真实感图形绘制"><a href="#第十章：真实感图形绘制" class="headerlink" title="第十章：真实感图形绘制"></a>第十章：真实感图形绘制</h2><h3 id="简单的光照模型"><a href="#简单的光照模型" class="headerlink" title="简单的光照模型"></a>简单的光照模型</h3><p><strong>简单的光照模型</strong>中<strong>只考虑反射光</strong>的作用。</p><p>反射光由<strong>环境光</strong>，<strong>漫反射光</strong>和<strong>镜面反射光</strong>三部分组成。</p><p><img src="https://s1.ax1x.com/2020/06/29/NWpzHH.png" srcset="/img/loading.gif" alt="NWpzHH.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NW9F8P.png" srcset="/img/loading.gif" alt="NW9F8P.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NW9kgf.png" srcset="/img/loading.gif" alt="NW9kgf.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NW9Av8.png" srcset="/img/loading.gif" alt="NW9Av8.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NW9uUs.png" srcset="/img/loading.gif" alt="NW9uUs.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWC8JI.png" srcset="/img/loading.gif" alt="NWC8JI.png"></p><p>以上都是理想情况，实际中：光在传播中能量会衰减，因此我们要考虑模型中光强的衰减。</p><p><img src="https://s1.ax1x.com/2020/06/29/NWbpmq.png" srcset="/img/loading.gif" alt="NWbpmq.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWbs3Q.png" srcset="/img/loading.gif" alt="NWbs3Q.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NWbo34.png" srcset="/img/loading.gif" alt="NWbo34.png"></p><p>RGB颜色模型就是在原来的计算公式中，将rgb三色拆开来算。</p><p><img src="https://s1.ax1x.com/2020/06/29/NWbzCD.png" srcset="/img/loading.gif" alt="NWbzCD.png"></p><h3 id="基于简单光照模型的多边形绘制"><a href="#基于简单光照模型的多边形绘制" class="headerlink" title="基于简单光照模型的多边形绘制"></a>基于简单光照模型的多边形绘制</h3><h4 id="恒定光强："><a href="#恒定光强：" class="headerlink" title="恒定光强："></a><strong>恒定光强：</strong></h4><p><img src="https://s1.ax1x.com/2020/06/29/NWqN24.png" srcset="/img/loading.gif" alt="NWqN24.png"></p><h4 id="Gouraud敏感处理："><a href="#Gouraud敏感处理：" class="headerlink" title="Gouraud敏感处理："></a>Gouraud敏感处理：</h4><p><img src="https://s1.ax1x.com/2020/06/29/NWLkQJ.png" srcset="/img/loading.gif" alt="NWLkQJ.png"></p><p><strong>缺点：</strong>双线性光强插值<strong>解决了相邻多边形之间的颜色突变问题</strong>，<strong>镜面反射效果不太理想</strong>，<strong>相邻多边形的边界处的马赫带效应不能完全消除</strong></p><p><img src="https://s1.ax1x.com/2020/06/29/NWvwEn.png" srcset="/img/loading.gif" alt="NWvwEn.png"></p><h4 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h4><p><img src="https://s1.ax1x.com/2020/06/29/NWx0qH.png" srcset="/img/loading.gif" alt="NWx0qH.png"></p><p>和gouraud的区别是，phong先对多边形内部通过双线性插值确定矢量，然后再用光照模型确定内部光强。</p><h3 id="透明处理："><a href="#透明处理：" class="headerlink" title="透明处理："></a>透明处理：</h3><p>简单的透明处理是不考虑折射的。</p><p>但实际上透明表面的光强包括反射光和折射光。</p><h3 id="产生阴影："><a href="#产生阴影：" class="headerlink" title="产生阴影："></a>产生阴影：</h3><p><img src="https://s1.ax1x.com/2020/06/29/NfpYin.png" srcset="/img/loading.gif" alt="NfpYin.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/NfptGq.png" srcset="/img/loading.gif" alt="NfptGq.png"></p><h3 id="模拟景物表面细节"><a href="#模拟景物表面细节" class="headerlink" title="模拟景物表面细节"></a>模拟景物表面细节</h3><p><img src="https://s1.ax1x.com/2020/06/29/Nf9ZmF.png" srcset="/img/loading.gif" alt="Nf9ZmF.png"></p><h3 id="整体光照模型和光线追踪"><a href="#整体光照模型和光线追踪" class="headerlink" title="整体光照模型和光线追踪"></a>整体光照模型和光线追踪</h3><p><img src="https://s1.ax1x.com/2020/06/29/Nf960g.png" srcset="/img/loading.gif" alt="Nf960g.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/Nf92kj.png" srcset="/img/loading.gif" alt="Nf92kj.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/Nf9Whn.png" srcset="/img/loading.gif" alt="Nf9Whn.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/Nf95cV.png" srcset="/img/loading.gif" alt="Nf95cV.png"></p><p><img src="https://s1.ax1x.com/2020/06/29/Nf9IXT.png" srcset="/img/loading.gif" alt="Nf9IXT.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AHU_SQL_Consise_Tutorial</title>
    <link href="/2020/07/17/SQL_tutorial/"/>
    <url>/2020/07/17/SQL_tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-Consise-Tutorial"><a href="#SQL-Consise-Tutorial" class="headerlink" title="SQL(Consise Tutorial)"></a>SQL(Consise Tutorial)</h1><h1 id="SQL-Consise-Tutorial-1"><a href="#SQL-Consise-Tutorial-1" class="headerlink" title="SQL_Consise_Tutorial"></a>SQL_Consise_Tutorial</h1><p><strong>写在前面：</strong></p><p>由于书上的SQL讲解太过于分散，因此我写了一个文档来总结这些知识点，以例子代替讲解，方便大家查漏补缺，由于开始时写这个文档是为了实验考试，但后来为了准备期末考试又添加了一些实验课上没有讲到的东西，如果有什么缺失的知识点，可以发邮件给我：howiewang.cs@gmail.com ，我会尽量补上缺失的内容。</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>创建STUDENT表</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> STUDENT<br>(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">IDENTITY</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br> SNo <span class="hljs-built_in">CHAR</span> (<span class="hljs-number">5</span>) PRIMARY <span class="hljs-keyword">KEY</span>,<br> CLno <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>),<br> SName <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>，<br> SSex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">'男'</span>,<span class="hljs-string">'女'</span>))，   //用<span class="hljs-keyword">CHECK</span>短语指定列值该满足的条件<br> SBir DATETIME<br> SAge <span class="hljs-built_in">INT</span><br>)<br></code></pre></div></td></tr></table></figure><p>创建表时，用CHECK短语指定列值该满足的条件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> STUDENT<br>(<br>Sno <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">9</span>) PRIMARY <span class="hljs-keyword">KEY</span>,<br>SName <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>Ssex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>),<br><span class="hljs-keyword">CHECK</span>(SSex=<span class="hljs-string">'女'</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'Ms.%'</span>)   //对元组进行<span class="hljs-keyword">CHECK</span>检查<br>)<br></code></pre></div></td></tr></table></figure><h2 id="修改表的属性"><a href="#修改表的属性" class="headerlink" title="修改表的属性"></a>修改表的属性</h2><p><strong>修改表Course的列属性,将CName的长度改为40,且不允许为空</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> COURSE<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> CNAME <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">49</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><br></code></pre></div></td></tr></table></figure><h2 id="增加表的属性"><a href="#增加表的属性" class="headerlink" title="增加表的属性"></a>增加表的属性</h2><p><strong>向表Student中增加E-mail列,且要求输入的电子邮件地址必须包括”@”字符</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">ADD</span> Email <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><br><span class="hljs-keyword">CONSTRAINT</span> CHECK_EA <span class="hljs-keyword">CHECK</span>(Email <span class="hljs-keyword">like</span> <span class="hljs-string">'%@%'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="删除表的属性"><a href="#删除表的属性" class="headerlink" title="删除表的属性"></a>删除表的属性</h2><p><strong>删除表Student中的SAge列</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> Sage<br></code></pre></div></td></tr></table></figure><h2 id="修改数据的类型"><a href="#修改数据的类型" class="headerlink" title="修改数据的类型"></a>修改数据的类型</h2><p>修改STUDENT表中的Sage为INT类型</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> SAge <span class="hljs-built_in">INT</span><br></code></pre></div></td></tr></table></figure><h2 id="增加-删除属性的完整性约束"><a href="#增加-删除属性的完整性约束" class="headerlink" title="增加/删除属性的完整性约束"></a>增加/删除属性的完整性约束</h2><p>给属性CName添加唯一值的约束性条件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> COURSE<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span>(CName)<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">增加约束<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span>(Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">9999999</span>)<br>删除约束<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C1<br></code></pre></div></td></tr></table></figure><h2 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> Pk_name PRIMARY <span class="hljs-keyword">KEY</span>(SName)<br></code></pre></div></td></tr></table></figure><h2 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> Pk_name<br></code></pre></div></td></tr></table></figure><h2 id="WITH-NOCHECK字句对表的属性添加约束"><a href="#WITH-NOCHECK字句对表的属性添加约束" class="headerlink" title="WITH NOCHECK字句对表的属性添加约束"></a>WITH NOCHECK字句对表的属性添加约束</h2><p>如果已存在的数据与要创建的约束冲突，则需要加上 with nocheck</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> STUDENT <br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">NOCHECK</span> <br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> ck_age <span class="hljs-keyword">CHECK</span>(SAge&gt;=<span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> SAge&lt;=<span class="hljs-number">25</span>)<br></code></pre></div></td></tr></table></figure><h2 id="使约束无效-重新有效"><a href="#使约束无效-重新有效" class="headerlink" title="使约束无效/重新有效"></a>使约束无效/重新有效</h2><p>使约束无效</p><p>NOCHECK CONSTRAINT字句</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">NOCHECK</span> <span class="hljs-keyword">CONSTRAINT</span> ck_ea<br></code></pre></div></td></tr></table></figure><p>使约束重新有效</p><p>CHECK CONSTRAINT字句</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">CONSTRAINT</span> ck_ea<br></code></pre></div></td></tr></table></figure><h2 id="普通插入数据"><a href="#普通插入数据" class="headerlink" title="普通插入数据"></a>普通插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> STUDENT<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'06002'</span>,<span class="hljs-string">'06001'</span>,<span class="hljs-string">'要强'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-string">'1999-1-1'</span>,<span class="hljs-string">'4992131@qq.com'</span>,<span class="hljs-literal">null</span>)<br></code></pre></div></td></tr></table></figure><h2 id="选择性的插入数据"><a href="#选择性的插入数据" class="headerlink" title="选择性的插入数据"></a>选择性的插入数据</h2><p>把表Student中学号为”06001”的记录插入到表ss中</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SS<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> SNo=<span class="hljs-string">'06001'</span><br></code></pre></div></td></tr></table></figure><p>把表Student中所有男生且SNo不为06001的记录插入到表ss中</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SS<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> SSex =<span class="hljs-string">'男'</span> <span class="hljs-keyword">AND</span> SNO&lt;&gt;<span class="hljs-string">'06001'</span><br></code></pre></div></td></tr></table></figure><h2 id="更新修改表中数据"><a href="#更新修改表中数据" class="headerlink" title="更新修改表中数据"></a>更新修改表中数据</h2><p>①学号为”06002”的学生的年龄改为20岁。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> STUDENT <br><span class="hljs-keyword">SET</span> SAge=<span class="hljs-number">20</span><br><span class="hljs-keyword">WHERE</span> SNo=<span class="hljs-string">'06002'</span>;<br></code></pre></div></td></tr></table></figure><p>②所有男生的年龄增加1岁。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> STUDENT<br><span class="hljs-keyword">SET</span> SAge=SAge+<span class="hljs-number">1</span><br><span class="hljs-keyword">WHERE</span> SSex=<span class="hljs-string">'男'</span><br></code></pre></div></td></tr></table></figure><p>③所有选修了数字逻辑课程的学生的成绩加5分。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> STUDENT<br><span class="hljs-keyword">SET</span> GRADE=GRADE+<span class="hljs-number">5</span><br><span class="hljs-keyword">WHERE</span> CNo=(<span class="hljs-keyword">SELECT</span> CNo <span class="hljs-keyword">FROM</span> COURSE <span class="hljs-keyword">WHERE</span> CName=<span class="hljs-string">'数字逻辑'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="删除表中数据"><a href="#删除表中数据" class="headerlink" title="删除表中数据"></a>删除表中数据</h2><p>删除学生学号为”06001”的记录</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> STUDENT <br><span class="hljs-keyword">WHERE</span> SNO=<span class="hljs-string">'06001'</span><br></code></pre></div></td></tr></table></figure><p>删除所有学生选课记录</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> SC<br></code></pre></div></td></tr></table></figure><h2 id="查看查询数据"><a href="#查看查询数据" class="headerlink" title="查看查询数据"></a>查看查询数据</h2><p>查看所有教职工的信息</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">xSELECT * FROM TEACHER<br></code></pre></div></td></tr></table></figure><p>查看所有教职工号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TName,TNo <span class="hljs-keyword">FROM</span> TEACHER<br></code></pre></div></td></tr></table></figure><p>查看所有职工的职工号、姓名,并且将输出结果中的列名显示为“教职工号”、“姓名”。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TName 姓名,TNo 教职工号 <span class="hljs-keyword">FROM</span> TEACHER<br></code></pre></div></td></tr></table></figure><p>查询所有职工的姓名和年薪,并且将输出结果中的列名显示为“姓名”、“年薪”</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TName 姓名,Sal*<span class="hljs-number">12</span> 年薪 <span class="hljs-keyword">FROM</span> Teacher<br></code></pre></div></td></tr></table></figure><p>查询所有职工的姓名和年薪,并且将输出结果中的列名显示为“姓名”、“年薪”、“币种单位”,其中币种单位的值为“元”。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TName 姓名,sal*<span class="hljs-number">12</span> 年薪,<span class="hljs-string">'元'</span> 币种单位<br></code></pre></div></td></tr></table></figure><p><strong>DISTINCT关键字：</strong></p><p>输出的数据中不包含相同的</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> ............<br></code></pre></div></td></tr></table></figure><p>查询所有0004部门职员的信息</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Teacher<br><span class="hljs-keyword">WHERE</span> DNo=<span class="hljs-string">'0004'</span><br></code></pre></div></td></tr></table></figure><p>查询1984年和1985年出生的男生的信息。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SName,SBir <br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> SSex=<span class="hljs-string">'男'</span> <span class="hljs-keyword">AND</span> SBir <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'1984-01-01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'1985-12-31'</span><br></code></pre></div></td></tr></table></figure><p>查询0004部门、0005部门和0006部门的职工的信息。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Teacher<br><span class="hljs-keyword">WHERE</span> DNo <span class="hljs-keyword">IN</span>(<span class="hljs-string">'0004'</span>,<span class="hljs-string">'0005'</span>,<span class="hljs-string">'0006'</span>)<br></code></pre></div></td></tr></table></figure><p>查询学号为03004的同学正在学习的课程。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CNo <br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> SNo=<span class="hljs-string">'0304'</span><br></code></pre></div></td></tr></table></figure><p>查询姓“要”的同学的信息。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> Student_X01814031<br><span class="hljs-keyword">WHERE</span> SName <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'要%'</span><br></code></pre></div></td></tr></table></figure><p><strong>ORDER BY关键字</strong></p><p>查询所有职工的工号，年龄，并按照年龄<strong>从小到大</strong>的顺序进行排列</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TNo,TAge<br><span class="hljs-keyword">FROM</span> TEACHER<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> AGE<br></code></pre></div></td></tr></table></figure><p>查询学生某门课(如00005)的成绩，并按成绩<strong>由高到低</strong>的顺序输出</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Score<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> CName=<span class="hljs-string">'00005'</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Score <span class="hljs-keyword">DESC</span><br></code></pre></div></td></tr></table></figure><p>查询职工的年薪，并按<strong>年薪</strong>的升序排列</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TName,sal*<span class="hljs-number">12</span><br><span class="hljs-keyword">FROM</span> TEACHER<br>OREDER <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>查询所有职工信息，被部门号的降序排列，再部门相同的情况下，按照年龄的升序排列</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> TEACHER<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> DNo <span class="hljs-keyword">DESC</span>,Age<br></code></pre></div></td></tr></table></figure><h2 id="查询中聚合函数应用"><a href="#查询中聚合函数应用" class="headerlink" title="查询中聚合函数应用"></a>查询中聚合函数应用</h2><p>统计职工的工资总额</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(sal)<br><span class="hljs-keyword">FROM</span> TEACHER<br></code></pre></div></td></tr></table></figure><p>统计职工的工资总额，并显示每个职工的工资情况。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">显示每个职工的工资情况。<br><span class="hljs-keyword">SELECT</span> TNo,sal  <br><span class="hljs-keyword">FROM</span> TEACHER<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> TNo <br>统计职工的工资总额<br><span class="hljs-keyword">COMPUTE</span> <span class="hljs-keyword">SUM</span>(sal)<br></code></pre></div></td></tr></table></figure><p>统计职工的工资总额，并显示每个职工的工资情况及各部门的工资总额。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> TNo,sal<br><span class="hljs-keyword">FROM</span> TEACHER <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> DNo,TNo<br><span class="hljs-keyword">COMPUTE</span> <span class="hljs-keyword">SUM</span>(sal) <span class="hljs-keyword">BY</span> DNo<br></code></pre></div></td></tr></table></figure><p>求职工的最高工资，最低工资和平均工资</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(sal),<span class="hljs-keyword">MIN</span>(sal),<span class="hljs-keyword">AVG</span>(sal)<br><span class="hljs-keyword">FROM</span> TEACHER<br></code></pre></div></td></tr></table></figure><p>求男学生的学生总数</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> COUNT(*)<br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> Ssex=<span class="hljs-string">'男'</span><br></code></pre></div></td></tr></table></figure><p>查询有多少学生的数学课成绩小于99</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(SNo)<br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> COURSE.SNo=STUDENT.SNo <span class="hljs-keyword">AND</span> COURSE.CName=<span class="hljs-string">'数学'</span> <span class="hljs-keyword">AND</span> COURSE.Score&lt;<span class="hljs-number">09</span><br></code></pre></div></td></tr></table></figure><h2 id="查询中分组统计GROUP-BY"><a href="#查询中分组统计GROUP-BY" class="headerlink" title="查询中分组统计GROUP BY"></a>查询中分组统计GROUP BY</h2><p>求每个班学生的人数</p><p>CLno：班级</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CLno,<span class="hljs-keyword">COUNT</span>(*)<span class="hljs-string">'COUNT(*)'</span><br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CLno<br></code></pre></div></td></tr></table></figure><p>查询每个学生已获得的学分</p><p>CCredits:学分</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNo,<span class="hljs-keyword">SUM</span>(CCredits)<br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> SCORE&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> SC.CNo=COURSE.CNo<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNO<br></code></pre></div></td></tr></table></figure><h2 id="HAVING字句"><a href="#HAVING字句" class="headerlink" title="HAVING字句"></a>HAVING字句</h2><p>使用<strong>HAVING字句</strong>查询学分大于8的学生，并输出学生的学号和学分</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNo,<span class="hljs-keyword">SUM</span>(CCredit)<br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> SC.SCORE&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> SC.CNo=COURSE.CNo<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNO<br><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">SUM</span>(CCredits)&gt;<span class="hljs-number">8</span>   //大于<span class="hljs-number">8</span>的留下<br></code></pre></div></td></tr></table></figure><h2 id="基本连接操作"><a href="#基本连接操作" class="headerlink" title="基本连接操作"></a>基本连接操作</h2><p>查询选修了语文课程的学生</p><p>原来的方法：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNO <br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> SC.CNo=COURSE.CNO <span class="hljs-keyword">AND</span> COURSE.CName=<span class="hljs-string">'语文'</span><br></code></pre></div></td></tr></table></figure><p>也可以用连接操作：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.SNo<br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">AS</span> A,COURSE <span class="hljs-keyword">AS</span> B<br>WHRER A.CNo=B.CNo <span class="hljs-keyword">AND</span> CName=<span class="hljs-string">'语文'</span><br></code></pre></div></td></tr></table></figure><p>查询电路基础成绩不及格的学生名单(输出学生的学号、姓名及成绩)</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> STUDENT.SNo,STUDENT.SName,SC.Score<br><span class="hljs-keyword">FROM</span> SC,STUDENT<br><span class="hljs-keyword">WHERE</span> STUDENT.CNo=SC.Cno <span class="hljs-keyword">AND</span> SC.SCore&lt;<span class="hljs-number">60</span>  <span class="hljs-keyword">AND</span> SC.SName=<span class="hljs-string">'基础电路'</span><br></code></pre></div></td></tr></table></figure><h2 id="内连接操作"><a href="#内连接操作" class="headerlink" title="内连接操作"></a>内连接操作</h2><p>查询每个学生及其选修课程的情况,并且输出其学号、姓名、所选课程号及分数</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.SNo,A.SName,B.CNo,B.Score<br><span class="hljs-keyword">FROM</span> STUDENT A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC B<br><span class="hljs-keyword">ON</span> A.SNo=B.SNo<br></code></pre></div></td></tr></table></figure><p>查询每个学生及其选修课程的情况,输出其学号、姓名、所选课程号及分数,并且按“学号”的降序排列</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.SNo,A.SName,B.CNo,B.Score<br><span class="hljs-keyword">FROM</span> STUDENT A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC B<br><span class="hljs-keyword">ON</span> A.SNo=B.SNo<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> A.SNo <span class="hljs-keyword">DESC</span><br></code></pre></div></td></tr></table></figure><p>查询在数字逻辑课之后,还有哪些课被选修(按课程编号排序)</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> B.CNo<br><span class="hljs-keyword">FROM</span> COURSE A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC B<br><span class="hljs-keyword">ON</span> B.CNo&gt;A.CNo <span class="hljs-keyword">AND</span> A.CName=<span class="hljs-string">'数字逻辑'</span><br></code></pre></div></td></tr></table></figure><h2 id="外连接操作"><a href="#外连接操作" class="headerlink" title="外连接操作"></a>外连接操作</h2><p>显示目前还没学生报道的班级</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CLname <br><span class="hljs-keyword">FROM</span> STUDENT A <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">CLASS</span> B<br><span class="hljs-keyword">ON</span> A.CLno=B.CLno<br><span class="hljs-keyword">WHERE</span> SNo <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span><br></code></pre></div></td></tr></table></figure><p>查询每个学生及选修课程的情况，并比较如下两条命令的执行结果</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.*,B.* <br><span class="hljs-keyword">FROM</span> STUDENT A <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC B<br><span class="hljs-keyword">ON</span> A.SNo=B.SNo<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.*,SC.* <br><span class="hljs-keyword">FROM</span> Student,SC <br><span class="hljs-keyword">WHERE</span> Student.SNo=SC.SNo<br></code></pre></div></td></tr></table></figure><p>联合查询</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNo <span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> CName=<span class="hljs-string">'英语'</span><br></code></pre></div></td></tr></table></figure><h2 id="联合查询UNION"><a href="#联合查询UNION" class="headerlink" title="联合查询UNION"></a>联合查询UNION</h2><p>两种不同的用法是UNION和UNION ALL，区别在于UNION从结果集中删除重复的行。如果使用UNION ALL 将包含所有行并且将不删除重复的行。</p><p>UNION和UNION ALL的区别：</p><p>union 检查重复</p><p>union all 不做检查</p><p>比如select ‘a’ union select ‘a’ 输出就是一行 a</p><p>比如select ‘a’ union all select ‘a’ 输出就是两行 a</p><p>查询当前至少上着数学和英语其中一门课的学生</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">(<br><span class="hljs-keyword">SELECT</span> SNo <br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> CName=<span class="hljs-string">'英语'</span> <span class="hljs-keyword">AND</span> SC.CNo=COURSE.CNo<br>)<br><span class="hljs-keyword">UNION</span><br>(<br><span class="hljs-keyword">SELECT</span> SNo <br><span class="hljs-keyword">FROM</span> SC,COURSE<br><span class="hljs-keyword">WHERE</span> CName=<span class="hljs-string">'数学'</span> <span class="hljs-keyword">AND</span> SC.CNo=COURSE.CNo<br>)<br></code></pre></div></td></tr></table></figure><h2 id="集合操作-交，叉，并"><a href="#集合操作-交，叉，并" class="headerlink" title="集合操作(交，叉，并)"></a>集合操作(交，叉，并)</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><br>1.并操作UNION<br>(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> A) <span class="hljs-keyword">UNION</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> B) <br><span class="hljs-number">2.</span>交操作<span class="hljs-keyword">INTERSECT</span><br>(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> A) <span class="hljs-keyword">INTERSECT</span>(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> B) <br><span class="hljs-number">3.</span>差操作<span class="hljs-keyword">EXCEPT</span>（<span class="hljs-keyword">MINUS</span>）<br>(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> A) <span class="hljs-keyword">EXCEPT</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">TABLE</span> B)<br></code></pre></div></td></tr></table></figure><h2 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h2><p>交叉连接就是两个表的乘积。</p><p>查询每个学生选修课程的情况，并输出其学号，姓名，所选课程号及分数。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.SNo,SName,SC.CNo,Score  <br><span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> SC<br><span class="hljs-keyword">WHERE</span> Student.SNo=SC.SNo<br></code></pre></div></td></tr></table></figure><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>在表Teacher中查询职工的上级领导信息</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> B.TNo,B.TName<br><span class="hljs-keyword">FROM</span> TEACHER A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> TEACHER B<br><span class="hljs-keyword">ON</span> A.Manager=B.TNo<br></code></pre></div></td></tr></table></figure><p>查询混双选手名单。每行输出一对选手,男在前,女在后</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.Name,B.Name<br><span class="hljs-keyword">FROM</span> ATHLETE A <span class="hljs-keyword">AND</span> ATHLETE B<br><span class="hljs-keyword">ON</span> A.GROUP=B.GROUP<br><span class="hljs-keyword">WHERE</span> A.Sex=<span class="hljs-string">'男'</span><br></code></pre></div></td></tr></table></figure><h2 id="IN关键字"><a href="#IN关键字" class="headerlink" title="IN关键字"></a>IN关键字</h2><p>查询语文班的学生名单</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Name</span><br><span class="hljs-keyword">FROM</span> STUDENT,<span class="hljs-keyword">CLASS</span><br><span class="hljs-keyword">WHERE</span> STUDENT.CLno=CLASS.CLno <span class="hljs-keyword">AND</span> CLASS.CLName=<span class="hljs-string">'语文'</span><br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SName   <br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> CLno <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> CLno <br>               <span class="hljs-keyword">FROM</span> Class_X01814031 <br>               <span class="hljs-keyword">WHERE</span> CLname=<span class="hljs-string">'语文'</span>)<br></code></pre></div></td></tr></table></figure><p>数学高于90分的男生</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SName<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sex=<span class="hljs-string">'男'</span> <span class="hljs-keyword">AND</span> SNo <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> SNo <br>                         <span class="hljs-keyword">FROM</span> SC<br>                         <span class="hljs-keyword">WHERE</span> Score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> SC.CNo <span class="hljs-keyword">IN</span> （<span class="hljs-keyword">SELECT</span> CNo <br>                               <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Class</span><br>                               <span class="hljs-keyword">WHERE</span> Class.CLname=<span class="hljs-string">'数学'</span>））<br></code></pre></div></td></tr></table></figure><h2 id="EXIST关键字"><a href="#EXIST关键字" class="headerlink" title="EXIST关键字"></a>EXIST关键字</h2><p>   英语解释就是存在，不过他的意思也差不多，相当于存在量词’З’。他不返回数据的，当后带带的查询为空值是，返回“FALSE”，非空则返回“TRUE”。就因为 EXISTS 返回的是真值或假值，所以他所带的子查询一般直接用’select *’ 因为给出列名也没多少意义。  </p><p>查询所有选修了1号课程的学生的名字</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SName<br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> EXIST (<span class="hljs-keyword">SELECT</span> * <br>             <span class="hljs-keyword">FROM</span> SC <br>             <span class="hljs-keyword">WHERE</span> SNo=STUDENT.SNo <span class="hljs-keyword">AND</span> CNo=<span class="hljs-string">'1'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="NOT-EXIEST关键字"><a href="#NOT-EXIEST关键字" class="headerlink" title="NOT EXIEST关键字"></a>NOT EXIEST关键字</h2><p>和EXIST同理，长和谓词推到结合使用。</p><h2 id="谓词推导-利用EXIST查询"><a href="#谓词推导-利用EXIST查询" class="headerlink" title="谓词推导+利用EXIST查询"></a>谓词推导+利用EXIST查询</h2><p>查询至少选修了学生200215122选修的全部课程的学生号码。</p><p>我们首先转换一下语句：<strong>不存在任何课程该学生没选修</strong></p><p>即：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *<br>                 <span class="hljs-keyword">FROM</span> Course<br>                 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *<br>                                  <span class="hljs-keyword">FROM</span> SC<br>                                  <span class="hljs-keyword">WHERE</span> Sno= Student.Sno <span class="hljs-keyword">AND</span> Cno= Course.Cno<br>                                  )<br>                 )<br></code></pre></div></td></tr></table></figure><p>查询至少选修了学生200215122选修的全部课程的学生号码。</p><p><img src="https://s1.ax1x.com/2020/06/23/NYjMUU.png" srcset="/img/loading.gif" alt="NYjMUU.png"></p><p><img src="https://s1.ax1x.com/2020/06/23/NYjGvR.png" srcset="/img/loading.gif" alt="NYjGvR.png"></p><p><img src="https://s1.ax1x.com/2020/06/23/NYjtDx.png" srcset="/img/loading.gif" alt="NYjtDx.png"></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Sno<br>       <span class="hljs-keyword">FROM</span> SC SCX<br>       <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *<br>                        <span class="hljs-keyword">FROM</span> SC SCY<br>                        <span class="hljs-keyword">WHERE</span> SCY.Sno = <span class="hljs-string">' 200215122 '</span>  <br>                        <span class="hljs-keyword">AND</span><br>                        <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> *<br>                                   <span class="hljs-keyword">FROM</span> SC SCZ<br>                                   <span class="hljs-keyword">WHERE</span> SCZ.Sno=SCX.Sno <span class="hljs-keyword">AND</span> SCZ.Cno=SCY.Cno)<br>                       )；<br></code></pre></div></td></tr></table></figure><h2 id="查询中的比较运算符"><a href="#查询中的比较运算符" class="headerlink" title="查询中的比较运算符"></a>查询中的比较运算符</h2><p>查询其他班中比1班所有学生年龄都小的学生，并按照年龄降序输出</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SName,SAge<br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> SAge&lt;<span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> SAge<br>               <span class="hljs-keyword">FROM</span> STUDENT<br>               <span class="hljs-keyword">WHERE</span> CLno=<span class="hljs-string">'1'</span> )  <span class="hljs-keyword">AND</span> CLno&lt;&gt;<span class="hljs-string">'1'</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SAge <span class="hljs-keyword">DESC</span><br></code></pre></div></td></tr></table></figure><h2 id="子查询修改数据"><a href="#子查询修改数据" class="headerlink" title="子查询修改数据"></a>子查询修改数据</h2><p>对每一个班学生求平均年龄，并存输入数据库</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ClassAge(CLno <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">6</span>),avgage <span class="hljs-built_in">INT</span>)  <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> ClassAge(CLno,avgage)  <span class="hljs-keyword">SELECT</span> CLno,<span class="hljs-keyword">AVG</span>(SAge)  <br><span class="hljs-keyword">FROM</span> Student_X01814031  <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CLno<br></code></pre></div></td></tr></table></figure><p>将1班所有学生成绩置为95</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> SC_X01814031 <span class="hljs-keyword">SET</span> Score=<span class="hljs-number">95</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'1'</span>=  (<span class="hljs-keyword">SELECT</span> CLno   <br>  <span class="hljs-keyword">FROM</span> Student_X01814031   <br>  <span class="hljs-keyword">WHERE</span> Student_X01814031.SNo=SC_X01814031.SNo)<br></code></pre></div></td></tr></table></figure><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>创建1班学生的视图</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> C1_STUDENT<br><span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> CLno=<span class="hljs-string">'1'</span><br></code></pre></div></td></tr></table></figure><p><strong>with  check option</strong> :</p><p>约束条件是对视图里面所有的name 首字符必须是以 ‘张’字打头。不管是修改前还是修改后都必须遵从此规则。否则出错</p><p>创建姓”要”的学生的视图</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> W1_Student  <br><span class="hljs-keyword">AS</span>  <br><span class="hljs-keyword">SELECT</span> SNo,SName   <br><span class="hljs-keyword">FROM</span> Student_X01814031  <br><span class="hljs-keyword">WHERE</span> SName <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'要%'</span><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">OPTION</span><br></code></pre></div></td></tr></table></figure><p>创建1班选修了语文课程的学生的视图</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> C1(SCno,SName,Score)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> STUDENT.SNo, SName, <span class="hljs-keyword">Class</span><br><span class="hljs-keyword">FROM</span> STUDENT,SC,<span class="hljs-keyword">CLASS</span><br><span class="hljs-keyword">WHERE</span> STUDENT.CLname=<span class="hljs-string">'1'</span> <br><span class="hljs-keyword">AND</span> STUDENT.SNo=SC.SNo <br><span class="hljs-keyword">AND</span> SC.SName=<span class="hljs-string">'语文'</span> <br><span class="hljs-keyword">AND</span> STUDENT.CLno=CLASS.CLno<br></code></pre></div></td></tr></table></figure><p>创建一个反应学生出生年份的视图：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> STUDENT_Birthyear(SNo,SName,SBirth)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> SNo,SName,<span class="hljs-number">2020</span>-SAge<br><span class="hljs-keyword">FROM</span> STUDENT<br></code></pre></div></td></tr></table></figure><p>将学生的学号和平均成绩创建一个视图</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> SNO_AVG_VIEW(SNo,GRADE_avg)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> SNo,<span class="hljs-keyword">AVG</span>(Score)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SNo<br></code></pre></div></td></tr></table></figure><h2 id="更新视图定义"><a href="#更新视图定义" class="headerlink" title="更新视图定义"></a>更新视图定义</h2><p>将S_G1表中的年龄限定改为20</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> S_G1(SNo,S age)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> SNo,Sage<br><span class="hljs-keyword">FROM</span> STUDENT<br><span class="hljs-keyword">WHERE</span> SAge&gt;<span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> S_G1<br></code></pre></div></td></tr></table></figure><h2 id="向视图插入新数据"><a href="#向视图插入新数据" class="headerlink" title="向视图插入新数据"></a>向视图插入新数据</h2><p>向1班学生的视图插入一条记录</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> C1_STUDENT(SNo,CLno,SName,Email)<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'7'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'张三'</span>，<span class="hljs-string">'12345@qq.com'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="更新视图数据"><a href="#更新视图数据" class="headerlink" title="更新视图数据"></a>更新视图数据</h2><p>将1班学生的视图中的学号为1的学生年龄改为23</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> C1_STUDENT<br><span class="hljs-keyword">SET</span> SAge=<span class="hljs-number">23</span> <br><span class="hljs-keyword">WHERE</span> SNo=<span class="hljs-string">'1'</span><br></code></pre></div></td></tr></table></figure><h2 id="删除视图数据"><a href="#删除视图数据" class="headerlink" title="删除视图数据"></a>删除视图数据</h2><p>将1班学生的视图中学号为1的学生删除</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> C1_STUDENT<br><span class="hljs-keyword">WHERE</span> SNo=<span class="hljs-string">'1'</span><br></code></pre></div></td></tr></table></figure><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p><strong>索引的目的</strong>：加快查询速度</p><p> 索引有唯一索引(例如身份证号等)，非唯一索引(例如年龄等)，聚簇索引(数据库的物理结构上的概念，他使得索引顺序和物理顺序相同，提高效率)。</p><p>在STUDENT表中SNo属性创建<strong>唯一索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> StuSNo <span class="hljs-keyword">ON</span> STUDENT(SNo)<br></code></pre></div></td></tr></table></figure><p>在表Course上创建一个<strong>唯一性</strong>的<strong>聚簇索引</strong>，索引排列顺序为<strong>降序</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> CLUSTERED <span class="hljs-keyword">INDEX</span> IX_CNo <span class="hljs-keyword">ON</span> COURSE(CNo <span class="hljs-keyword">DESC</span>)<br></code></pre></div></td></tr></table></figure><p>在表Course上创建一个<strong>非唯一性</strong>的<strong>非聚簇索引</strong></p><p>—drop_existing：表示如果这个索引还在表上就 drop 掉然后在 create 一个新的。 默认为 OFF。<br>—drop_existing=on:指定要删除并重新生成现有索引，其必须具有相同名称作为参数 index_name。<br>—drop_existing=off:指定不删除和重新生成现有的索引。 如果指定的索引名称已经存在，SQL Server 将显示一个错误。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">CREATE</span> NONCLUSTERED <span class="hljs-keyword">INDEX</span> INX_CName <span class="hljs-keyword">ON</span> COURSE(CName)<br><span class="hljs-keyword">WITH</span> DROP_EXISTING<br></code></pre></div></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p>查看Course上的所有索引</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br>EXEC SP_HELPINDEX COURSE<br></code></pre></div></td></tr></table></figure><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>删除表Course上的IX_CNo索引</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> SM_X01814031<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> COURSE.IX_CNo<br></code></pre></div></td></tr></table></figure><h2 id="授权：授予"><a href="#授权：授予" class="headerlink" title="授权：授予"></a>授权：授予</h2><p>把查询student表的权限授给用户U1</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">TO</span> U1<br></code></pre></div></td></tr></table></figure><p>把对Student表和Course表的全部从操作权限赋予用户U2,U3</p><p><strong>ALL PRIVILEGES</strong>:所有权限</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT,COURSE<br><span class="hljs-keyword">TO</span> U2,U3<br></code></pre></div></td></tr></table></figure><p>把对标SC的查询全授予所有用户</p><p><strong>PUBLIC</strong> : 所有用户</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">TO</span> <span class="hljs-keyword">PUBLIC</span><br></code></pre></div></td></tr></table></figure><p>把查询STUDENT表和修改学生学号的权限授予用户U4</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">UPDATE</span>(SNo),<span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">TO</span> U5<br></code></pre></div></td></tr></table></figure><p>把对表SC的INSERT权限授予用户U5,并允许将权限授予用户</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">TO</span> US<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span><br></code></pre></div></td></tr></table></figure><h2 id="授权：收回"><a href="#授权：收回" class="headerlink" title="授权：收回"></a>授权：收回</h2><p>REVOKE 权限,…</p><p>ON 对象类型 对象名,…..</p><p>FROM 用户1，用户2, ……[CASCADE/RESTRICT]</p><p>把用户U4修改学生学号的权限收回。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">FROM</span> U4<br></code></pre></div></td></tr></table></figure><p>把用户U5对SC表的INSERT权限收回</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">FROM</span> U5 <span class="hljs-keyword">CASCADE</span><br></code></pre></div></td></tr></table></figure><p>CASCADE:级联，比如U5把权力给了U6，U6又给了U7，则CASCADE会将U5,U6,U7权限一起收回，这样保证了自主存取控制的权利。如果收回权限语句中不写，也是默认CASCADE的。</p><h2 id="授权：创建数据库模式的权限"><a href="#授权：创建数据库模式的权限" class="headerlink" title="授权：创建数据库模式的权限"></a>授权：创建数据库模式的权限</h2><p>上面两种讲述到了对用户授权和收回对数据的操作权限，对创建数据库模式一类的数据库对象的授权则应该由数据库管理员在创建用户时实现。</p><p>格式： </p><p>CREATE USER 用户名 [WITH DBA/RESOURCE/CONNECT]</p><p>DBA:可以CREATE USER  /SCHEMA /TABLE /登录数据库执行数据查询</p><p>RESOURCE:  可以CREATE TABLE/登录数据库执行数据查询</p><p>CONNECT： 可以登录数据库执行查询操作</p><p><strong>1.角色的创建：</strong></p><p>创建一个角色R1</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">ROLE</span> R1<br></code></pre></div></td></tr></table></figure><p><strong>2.授予用户角色权限：</strong></p><p>使角色R1拥有student表的SELECT UPDATE INSERT权限 </p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">UPDATE</span>,<span class="hljs-keyword">INSERT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">TO</span> R1<br></code></pre></div></td></tr></table></figure><p>将这个角色授予王平，张明，赵玲</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> R1<br><span class="hljs-keyword">TO</span> 王平，张明，赵玲<br></code></pre></div></td></tr></table></figure><p><strong>3.收回用户的角色权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> R1<br><span class="hljs-keyword">FROM</span> 王平，张明，赵玲<br></code></pre></div></td></tr></table></figure><p><strong>4.增加角色权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">TO</span> R1<br></code></pre></div></td></tr></table></figure><p><strong>5.减少角色权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> STUDENT<br><span class="hljs-keyword">FROM</span> R1<br></code></pre></div></td></tr></table></figure><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>由于任何系统的安全保护措施都不是完美无缺的，当数据库的安全等级达到C2以上，就会拥有审计功能。</p><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志。审计员可以利用审计日志监控找出非法操作的人。</p><p>对修改SC表结构或修改SC表数据的操作进行审计</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">AUDIT <span class="hljs-keyword">ALTER</span>,<span class="hljs-keyword">UPDATE</span><br><span class="hljs-keyword">ON</span> SC<br></code></pre></div></td></tr></table></figure><p>取消对SC表的一切审计</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">NOAUDIT <span class="hljs-keyword">ALTER</span>,<span class="hljs-keyword">UPDATE</span><br><span class="hljs-keyword">ON</span> SC<br></code></pre></div></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言是指通过声明性质的断言来指定更具一般性的约束。涉及断言中提到的操作时会对操作检查，如果使得断言不为真值会被拒绝执行。</p><p>创建断言的语句格式 ：</p><p>CREATE ASSERTION &lt;断言名&gt; <CHECK字句></p><p>例如：</p><p>限制数据库课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">ASSERTION</span>  ASSE_SC_DB_NUM<br><span class="hljs-keyword">CHECK</span>(<span class="hljs-number">60</span>&gt;=(<br>           <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <br>               <span class="hljs-keyword">FROM</span> COURSE,SC<br>             <span class="hljs-keyword">WHERE</span> SC.CNO=COURSE.CNO <span class="hljs-keyword">AND</span> COURSE.CNAME=<span class="hljs-string">'数据库'</span><br>            )<br></code></pre></div></td></tr></table></figure><p>删除断言</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">ASSERTION</span> ASSE_SC_DB_NUM<br></code></pre></div></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是指用户定义在关系表上的一类由事件驱动的特殊过程。</p><p>注：触发器在SQL99之后才被写入SQL标准。</p><p>CREATE TRIGGER &lt;触发器名&gt;</p><p>{BEFORE/AFTER}&lt;触发时间&gt; ON &lt;表名&gt;</p><p>REFERENCING NEW|OLD ROW AS &lt;变量&gt;</p><p>FOR EACH {ROW|STATEMENT}</p><p>[WHEN &lt;触发条件&gt; ] &lt;触发动作体&gt;</p><p>例：</p><p>当对表SC的Grade属性进行修改时，若分数增加10%，则将此次操作记录到另一个表SC_U( Sno,Cno,Oldgrade,NewGrade)中，其中OLDgrade是修改前的分数，Newgrade是修改后的分数。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> SC_T<br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> Grade <span class="hljs-keyword">ON</span> SC<br><span class="hljs-keyword">REFERENCING</span><br>OLDROW <span class="hljs-keyword">AS</span> Oldtuple,<br>NEWROW <span class="hljs-keyword">AS</span> Newtuple<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><br><span class="hljs-keyword">WHEN</span>(Newtuple.Grade&gt;=<span class="hljs-number">1.1</span>*Oldtuple.Grade)<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SC_U(Sno,Cno,Oldgrade,Newgrade)<br><span class="hljs-keyword">VALUES</span>(Oldtuple.Sno,Oldtuple.Cno,Oldtuple.Grade,Newtuple.Grade)<br></code></pre></div></td></tr></table></figure><p>将每次对表STUDENT的插入操作所增加的学生个数记录到表Student-InsertLog中</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> Student_Count<br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> STUDENT<br><span class="hljs-keyword">REFERENCING</span><br>NEWTABLE <span class="hljs-keyword">AS</span> Delta<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Student_InsertLog(Numbers)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> DELTA<br></code></pre></div></td></tr></table></figure><p>定义一个BEFORE行级触发器，为教师表TEACHER定义完整性规则“教授的工资不低于4000元，如果低于4000元，自动改为4000元”</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> Insert_Or_Update_Sal<br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> TEACHER<br><span class="hljs-keyword">REFERENCING</span><br>NEWROW <span class="hljs-keyword">AS</span> Newtuple<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><br><span class="hljs-keyword">WHEN</span>(Newtuple.Sal&lt;<span class="hljs-number">4000</span> <span class="hljs-keyword">AND</span> Newtuple.Job=<span class="hljs-string">'教授'</span>)<br>Newtuple.Sal=<span class="hljs-number">4000</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第二场）</title>
    <link href="/2020/07/17/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89/"/>
    <url>/2020/07/17/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2020牛客暑期多校训练营（第二场）"><a href="#2020牛客暑期多校训练营（第二场）" class="headerlink" title="2020牛客暑期多校训练营（第二场）"></a>2020牛客暑期多校训练营（第二场）</h1><p>Chillstep个人补题记录：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th><th>I</th><th>J</th><th>K</th></tr></thead><tbody><tr><td></td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td><td>√</td><td>√</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h2 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h2><h2 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个点(不包括原点)，问经过原点的圆最多可以和多少个点相交？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>枚举两个点，与原点三点确定一个圆。<br>求得每个点的圆心位置，计算圆心位置设圆方程，然后带入两个点列方程即可，然后解出来带分式的圆心的横纵坐标即可，用分数类维护，维护分数类的时候千万不要gcd约分，直接__int128类型乘就好，gcd约分会超时，这道题应该是有点卡常的。</p><p>用数据结构或排序维护每个圆心的出现次数。</p><h3 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e3</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">frac</span></span><br><span class="hljs-class">&#123;</span><br>    ll x,y;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> frac&amp; b) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> __int128(x)*(b.y)&lt;__int128(y)*(b.x);<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> frac&amp; b) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> __int128(x)*(b.y)==__int128(y)*(b.x);<br>    &#125;<br> <br> <br>    frac(ll a=<span class="hljs-number">0</span>,ll b=<span class="hljs-number">0</span>): x(a),y(b) &#123;&#125;<br>&#125;;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><br><span class="hljs-class">&#123;</span><br>    frac x,y;<br> <br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x==b.x?y&lt;b.y:x&lt;b.x;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x==b.x &amp;&amp; y==b.y;<br>    &#125;<br> <br>    <span class="hljs-built_in">point</span>(ll a=<span class="hljs-number">1</span>,ll b=<span class="hljs-number">2</span>,ll c=<span class="hljs-number">3</span>,ll d=<span class="hljs-number">4</span>): x(b*(c*c+d*d)-d*(a*a+b*b),<span class="hljs-number">2l</span>l*(b*c-a*d)),y(-a*(c*c+d*d)+c*(a*a+b*b),<span class="hljs-number">2l</span>l*(b*c-a*d))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x.y&lt;<span class="hljs-number">0</span>) x.x=-x.x,x.y=-x.y;<br>        <span class="hljs-keyword">if</span>(y.y&lt;<span class="hljs-number">0</span>) y.x=-y.x,y.y=-y.y;<br>    &#125;<br>&#125;;<br> <br>ll a[MAXN],b[MAXN];<br><span class="hljs-keyword">int</span> q[<span class="hljs-number">4002001</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2000</span>;i++)<br>    &#123;<br>        q[i*(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]=i;<br>    &#125;<br> <br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">point</span>&gt;qp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*b[j]==a[j]*b[i]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//3 points in a line,throw it</span><br>            qp.push_back(<span class="hljs-built_in">point</span>(a[i],b[i],a[j],b[j]));<br>        &#125;<br>    &#125;<br>    sort(qp.<span class="hljs-built_in">begin</span>(),qp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> maxx=<span class="hljs-number">0</span>,tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-keyword">int</span>)qp.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(qp[i]==qp[i<span class="hljs-number">-1</span>])<br>        &#123;<br>            tep++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            maxx=<span class="hljs-built_in">max</span>(maxx,tep);<br>            tep=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    maxx=<span class="hljs-built_in">max</span>(maxx,tep);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;q[maxx]&lt;&lt;<span class="hljs-built_in">endl</span>;<br> <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p>给一棵无向树，然后让你在树中找出一些路径来覆盖这课树的所有边，问最少需要多少条路径。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>画几个图很容易看出来，我们首先为叶子节点表上号(1,2,3,4…x),然后，然后连接1→1+x/2，2→2+x/2，3→3+x/2,…..  以此类推，共需要n/2（上取整）条路径。</p><p>举个例子：</p><p><img src="https://s1.ax1x.com/2020/07/14/Ua8he1.png" srcset="/img/loading.gif" alt="Ua8he1.png"></p><h3 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">3</span>;<br> <br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[N];<br> <br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; p;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (g[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) p.push_back(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[x]) &#123;<br>        <span class="hljs-keyword">if</span> (v == f) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        dfs(v, x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::sync_with_stdio(<span class="hljs-literal">false</span>), <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>), <span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>        g[a].push_back(b);<br>        g[b].push_back(a);<br>    &#125;<br> <br>    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> l = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; (l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l / <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; p[i + l / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &amp; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; p.back() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h2><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><p>给两个时间，求时间差</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>换成秒，相减取绝对值即可</p><h3 id="code：-2"><a href="#code：-2" class="headerlink" title="code："></a>code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-built_in">string</span> s1,s2;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;<br>    <span class="hljs-keyword">int</span> a=(s1[<span class="hljs-number">6</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s1[<span class="hljs-number">7</span>]-<span class="hljs-string">'0'</span>+((s1[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s1[<span class="hljs-number">4</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">60</span>+((s1[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s1[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">3600</span>;<br>    <span class="hljs-keyword">int</span> b=(s2[<span class="hljs-number">6</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s2[<span class="hljs-number">7</span>]-<span class="hljs-string">'0'</span>+((s2[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s2[<span class="hljs-number">4</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">60</span>+((s2[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+s2[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">3600</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">abs</span>(a-b)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h2><h2 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h2><h3 id="题意：-3"><a href="#题意：-3" class="headerlink" title="题意："></a>题意：</h3><p>给一个n<em>m矩阵，其中A(i,j)=LCM(i,j)，然后给一个k，求n\</em>m中所有k*k的方块中最大值的和。</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>首先要对lcm做一下预处理，可以利用线性筛记忆化的思想来做预处理，这样复杂度就是O(nm)的，再做单调队列二维窗口。</p><p>被恶心到了，这题不卡O(nmlog)的做法，非卡一下空间，感觉有点本末倒置了，对着空气debug，我还以为wa了呢，搞半天最多开两个5000*5000的数组，三个数组空间就给卡掉了。没意思没意思。</p><h3 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e3</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">int</span> n,m,k;<br><br><span class="hljs-keyword">int</span> LCM[<span class="hljs-number">5002</span>][<span class="hljs-number">5002</span>],x[<span class="hljs-number">5002</span>][<span class="hljs-number">5002</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-keyword">if</span> (!LCM[i][j])<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k * i &lt;= n &amp;&amp; k * j &lt;= m; k ++)<br>                    LCM[k * i][k * j] = k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++) &#123;<br>            LCM[i][j] = i*j/LCM[i][j];<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">int</span> q[MAXN];<br><span class="hljs-keyword">int</span> h,t;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dd_queue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span></span><br><span class="hljs-function"></span>&#123;<br>    h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;LCM[row][i]&gt;=LCM[row][q[t]]) t--;<br>        q[++t]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;q[h]&lt;i-k+<span class="hljs-number">1</span>) h++;<br>            x[row][i]=LCM[row][q[h]];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    init();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) dd_queue(i);<br>    ll sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=k; j&lt;=m; j++)<br>    &#123;<br>        h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;x[i][j]&gt;=x[q[t]][j]) t--;<br>            q[++t]=i;<br>            <span class="hljs-keyword">if</span>(i&gt;=k)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(h&lt;=t&amp;&amp;q[h]&lt;i-k+<span class="hljs-number">1</span>) h++;<br>                sum+=x[q[h]][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Problem-G"><a href="#Problem-G" class="headerlink" title="Problem G"></a>Problem G</h2><h2 id="Problem-H"><a href="#Problem-H" class="headerlink" title="Problem H"></a>Problem H</h2><h2 id="Problem-I"><a href="#Problem-I" class="headerlink" title="Problem I"></a>Problem I</h2><h2 id="Problem-J"><a href="#Problem-J" class="headerlink" title="Problem J"></a>Problem J</h2><h3 id="题意：-4"><a href="#题意：-4" class="headerlink" title="题意："></a>题意：</h3><p>给一个质数$k$，一个排列$A$，求一个置换$P$，使得{1,2,3,4….}经过k次置换$P$后得到排列A。</p><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>我们考虑一个环若大小为m，置换k次的效果是和置换k mod m一样的。</p><p>进行一次置换，相当于把一个数字移动到了下一个位置，建立一个数组$t$,他代表$t[i]$位置的数经过一次置换会转换到$t[i+1]$位置处。</p><p>那么对于$A_i=x$，可以理解为一个本来在{1,2,3,4…}排列中第$[x]$个的数，经过置换k次后，最后挪动到了排列A的第i个。我们把这种情况带入，考虑$t[j]=x$   (在x处),则经过一次置换到达的地方的值是$t[j+1]$，经过k次置换后到达的地方的值变成了$t[(j+k)\%m]=i$  (变换到了i处)。也就是说在x处的数k次置换后，会变到i处。</p><p>再次观察 $t[(i+k)\%m]=i$，它代表现在i处的数经过k次置换后会到达 $t[(i+k+k)\%m]=g$ 处。</p><p>再次观察$t[(i+k+k)\%m]=g$ ，以此类推。</p><p>如果冲突就说明不存在这样的置换。</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code:"></a>code:</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><br></code></pre></div></td></tr></table></figure><h2 id="Problem-K"><a href="#Problem-K" class="headerlink" title="Problem K"></a>Problem K</h2><h3 id="题意：-5"><a href="#题意：-5" class="headerlink" title="题意："></a>题意：</h3><p>给出三个同心圆，三个点分别在三个同心圆上，求这三个点组成的三角形的期望面积。</p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>大概有两个方法.</p><p><strong>第一种方法：</strong></p><p>第一个方法是标称中里写到的那种，因为有三个点，可以假设一个点不动即可，我们枚举第二个点( 复杂度O(T) )，算第三个点到过第一个点和第二个点直线的距离的期望(可以通过积分来做复杂度$O(\frac{1}{eps})$)，那么最后复杂度是O($\frac{T}{eps}$)</p><p><strong>第二种方法：</strong></p><p>第二种方法就是场上想到的，可惜感觉精度不太对，没敢写。但是由于题目精度要求比较低，只要求保留最后一位小数，所以是没问题的。</p><p>方法就是老老实实的用向量表示出三角形面积。然后对两个角度做积分。</p><p><img src="https://s1.ax1x.com/2020/07/16/UrYDSI.png" srcset="/img/loading.gif" alt="UrYDSI.png"></p><p>$S=\frac{1}{2}  \vec{AB} \vec{AC}=\frac{1}{2}  (R_2cosα-R_1 cos θ，R_2sinα-R_1 sin θ) (R_3cosβ-R_1 cos θ，R_3sinβ-R_1 sin θ)$</p><p>这里的A点的坐标可以随便选一个点，即A(R_1,0)</p><p>$E(S)=\int<em>{0}^{2\pi}\int</em>{0}^{2\pi}|S|dθdα$ </p><p>记得预处理一下cos sin，不然会超时。</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code:"></a>code:</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e3</span>+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">double f(double x)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    return ; //辛普森积分的函数</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">double simpson(double a, double b)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    double c = a + (b - a) / 2;</span><br><span class="hljs-comment">    return (f(a) + 4 * f(c) + f(b)) * (b - a) / 6;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">double integral(double L, double R, double Eps)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    double mid = L + (R - L) / 2;</span><br><span class="hljs-comment">    double ST = simpson(L, R), SL = simpson(L, mid), SR = simpson(mid, R);</span><br><span class="hljs-comment">    if(fabs(SL + SR - ST) &lt;= 15 * Eps)  return SL + SR + (SL + SR - ST) / 15;</span><br><span class="hljs-comment">    return integral(L, mid, Eps/2) + integral(mid, R, Eps/2);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-keyword">int</span> T=<span class="hljs-number">500</span>;<br><span class="hljs-keyword">double</span> si[<span class="hljs-number">1002</span>],co[<span class="hljs-number">1002</span>];<br><span class="hljs-keyword">double</span> r[<span class="hljs-number">5</span>];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">//cin.tie(0);</span><br><br>    <span class="hljs-keyword">double</span> a=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> d=<span class="hljs-number">2.0</span>*pi/(<span class="hljs-keyword">double</span>)T;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=T;i++)<br>    &#123;<br>        si[i]=<span class="hljs-built_in">sin</span>(a);<br>        co[i]=<span class="hljs-built_in">cos</span>(a);<br>        a+=d;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> TT;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;TT;<br>    <span class="hljs-keyword">while</span>(TT--)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;r[<span class="hljs-number">1</span>]&gt;&gt;r[<span class="hljs-number">2</span>]&gt;&gt;r[<span class="hljs-number">3</span>];<br>        sort(r+<span class="hljs-number">1</span>,r+<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=T;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=T;j++)<br>            &#123;<br>                ans+=<span class="hljs-built_in">abs</span>((r[<span class="hljs-number">3</span>]*co[j]-r[<span class="hljs-number">1</span>])*r[<span class="hljs-number">2</span>]*si[i]-(r[<span class="hljs-number">2</span>]*co[i]-r[<span class="hljs-number">1</span>])*r[<span class="hljs-number">3</span>]*si[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.1f\n"</span>,ans/<span class="hljs-number">2.0</span>/(<span class="hljs-keyword">double</span>)T/(<span class="hljs-keyword">double</span>)T);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-牛客多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后缀数组(SA)+拓展应用</title>
    <link href="/2020/04/10/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    <url>/2020/04/10/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀数组（SA）-拓展应用"><a href="#后缀数组（SA）-拓展应用" class="headerlink" title="后缀数组（SA）+拓展应用"></a>后缀数组（SA）+拓展应用</h1><h2 id="什么是后缀数组？"><a href="#什么是后缀数组？" class="headerlink" title="什么是后缀数组？"></a>什么是后缀数组？</h2><h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>后缀就是从字符串的某个位置i到字符串末尾的子串，我们定义<strong>以s的第i个字符为第一个元素的后缀为suff(i)</strong></p><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>把s的每个后缀按照字典序排序</p><p>后缀数组$sa[i]$就表示<strong>排名为i的后缀</strong>的起始位置的下标</p><p>而它的映射数组$rk[i]$就表示<strong>起始位置的下标为i的后缀</strong>的排名</p><p>简单来说，$sa$表示排名为i的是啥，$rk$表示第$i$个的排名是啥</p><h2 id="怎么求后缀数组？"><a href="#怎么求后缀数组？" class="headerlink" title="怎么求后缀数组？"></a>怎么求后缀数组？</h2><p>先说最暴力的情况，快排$O(n log n)$每个后缀，但是这是字符串，所以比较任意两个后缀的复杂度其实是$O(n)，$这样一来就是接近$O(n^2 log n)$的复杂度，复杂度太高，所以要优化，</p><p>所以我们这里有<strong>两个优化</strong>。</p><h2 id="复杂度过高能不能优化呢？"><a href="#复杂度过高能不能优化呢？" class="headerlink" title="复杂度过高能不能优化呢？"></a>复杂度过高能不能优化呢？</h2><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p>首先读入字符串之后我们现<strong>根据单个字符排序</strong>，当然也可以理解为先<strong>按照每个后缀的第一个字符排序</strong>。对于每个字符，我们按照字典序给一个排名(当然<strong>可以并列</strong>)，这里称作<strong>关键字</strong>。</p><p>(注：图片来自<strong>havana1</strong>)</p><p><img src="https://github.com/xMinh/xMinh.github.io/blob/master/pic/havana1.png?raw=true" srcset="/img/loading.gif" alt="havana1"></p><p>接下来我们再把相邻的两个关键字合并到一起，就相当于根据每一个后缀的前两个字符进行排序。想想看，这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。没有第二关键字的补零。</p><p><img src="https://github.com/xMinh/xMinh.github.io/blob/master/pic/havana2.png?raw=true" srcset="/img/loading.gif" alt="havana2"></p><p>接下来我们对于一个在第i位（第i位指的是下标，是排名会说排名为i）上的关键字，它的<strong>第二关键字就是第(i+2)位置上的</strong>，联想一下，因为现在<strong>第i位上的关键字是suff(i)的前两个字符（i和i+1）的排名</strong>，<strong>第i+2位置上的关键字是suff(i+2)的前两个字符（i+2和i+3）的排名</strong>，这两个一合并，不就是<strong>suff(i)的前四个字符的排名</strong>吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第i位和第i+4位，以此类推即可…… 这不就是倍增的思想吗？</p><p>那么我们什么时候结束呢？很简单，当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。</p><p>显然<strong>这样排序的速度稳定在$O(nlog^2 n)$(每次$nlogn$排序，排了$log n$次)</strong></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>如果我们用快排的话，复杂度就是$O(n log^2 n)$ 还是太大。</p><p>这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到$O(n)$级别，总复杂度就是$ O(n log n)$。</p><p>介绍一下什么是基数排序，这里就拿两位数举例</p><p>我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的，很好理解。</p><p><strong>具体举个例子基数排序的例子：</strong></p><p>73, 22, 93, 43, 55, 14, 28, 65, 39, 81</p><p><strong>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：</strong></p><p>0</p><p>1 81</p><p>2 22</p><p>3 73 93 43</p><p>4 14</p><p>5 55 65</p><p>6</p><p>7</p><p>8 28</p><p>9 39</p><p><strong>第二步</strong></p><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p><p>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p><p>接着再进行一次分配，这次是根据十位数来分配：</p><p>0</p><p>1 14</p><p>2 22 28</p><p>3 39</p><p>4 43</p><p>5 55</p><p>6 65</p><p>7 73</p><p>8 81</p><p>9 93</p><p><strong>第三步</strong></p><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p><p>14, 22, 28, 39, 43, 55, 65, 73, 81, 93</p><p>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们现在已经可以$O(nlog n)$来求后缀数组了。</p><h2 id="后缀数组的辅助工具-最长公共前缀（LCP）"><a href="#后缀数组的辅助工具-最长公共前缀（LCP）" class="headerlink" title="后缀数组的辅助工具-最长公共前缀（LCP）"></a>后缀数组的辅助工具-最长公共前缀（LCP）</h2><h3 id="什么是LCP"><a href="#什么是LCP" class="headerlink" title="什么是LCP"></a>什么是LCP</h3><p><strong>我们定义$LCP(i,j)$为$suff(sa[i])$与$suff(sa[j])$的最长公共前缀</strong>（请仔细看，是$sa[i]$的后缀，而不是$i$的后缀,这很重要！！！）</p><h3 id="LCP的显而易见的性质"><a href="#LCP的显而易见的性质" class="headerlink" title="LCP的显而易见的性质"></a>LCP的显而易见的性质</h3><p>显而易见的：</p><ol><li>$LCP(i,j)=LCP(j,i);$</li><li>$LCP(i,i)=len(sa[i])=n-sa[i]+1;$</li></ol><p>这俩性质有什么用？</p><p>对于$i&gt;j$的情况，我们可以把它转化成$i&lt;j$，对于$i=j$的情况，我们可以直接算长度，所以我们直接讨论$i&lt;j$的情况就可以了。</p><p><strong>我们怎么求LCP？</strong></p><p>每次比较要$O(n)$比较，这太慢了，多次询问复杂度就太高了，肯定要做一些预处理</p><h3 id="用于快速求LCP的推论"><a href="#用于快速求LCP的推论" class="headerlink" title="用于快速求LCP的推论"></a>用于快速求LCP的推论</h3><h4 id="LCP推论1-LCP-i-k-min-LCP-i-j-LCP-j-k"><a href="#LCP推论1-LCP-i-k-min-LCP-i-j-LCP-j-k" class="headerlink" title="LCP推论1:$LCP(i,k)=min(LCP(i,j),LCP(j,k))$"></a>LCP推论1:$LCP(i,k)=min(LCP(i,j),LCP(j,k))$</h4><p><strong>推论1</strong>：$LCP(i,k)=min(LCP(i,j),LCP(j,k))$ <strong>对于任意$1&lt;=i&lt;=j&lt;=k&lt;=n$</strong></p><p><strong>证明：</strong></p><p>设$p=min{LCP(i,j),LCP(j,k)}$，则有$LCP(i,j)≥p,LCP(j,k)≥p$。</p><p>设$suff(sa[i])=u,suff(sa[j])=v,suff(sa[k])=w$;</p><p>所以$u$和$v$的前p个字符相等，$v$和$w$的前$p$个字符相等</p><p>所以$u$和$w$的前$p$的字符相等，$LCP(i,k)&gt;=p$</p><p>设$LCP(i,k)=q&gt;p$ 那么$q&gt;=p+1$</p><p>因为$p=min{LCP(i,j),LCP(j,k)}$，所以$u[p+1]!=v[p+1] $或者$v[p+1]!=w[p+1]$ </p><p>但是$u[p+1]=w[p+1]$  ，即$u[p+1]!=v[p+1] $且$v[p+1]!=w[p+1]$ </p><p>这明显是错误的：因为$u[p+1]&gt;=v[p+1]&gt;=w[p+1]$(字符串是升序排列的)，而$u[p+1]=w[p+1]$ 。故：$u[p+1]=v[p+1]=w[p+1]$.这和上面推出的$u[p+1]!=v[p+1] $且$v[p+1]!=w[p+1]$ 相矛盾。</p><p>所以$LCP(i,k)&lt;=p$</p><p>综上所述$LCP(i,k)=p=min{LCP(i,j),LCP(j,k)}$</p><h4 id="LCP推论2-LCP-i-k-min-LCP-j-j-1"><a href="#LCP推论2-LCP-i-k-min-LCP-j-j-1" class="headerlink" title="LCP推论2:$LCP(i,k)=min(LCP(j,j-1))$"></a>LCP推论2:$LCP(i,k)=min(LCP(j,j-1))$</h4><p><strong>推论2：</strong>$LCP(i,k)=min(LCP(j,j-1)) $   <strong>对于任意$1&lt;i+1&lt;=j&lt;=k&lt;=n$</strong></p><p>利用<strong>推论1</strong></p><p>我们可以把$i~k$拆成两部分$i-(i+1)$以及$(i+1)-k$</p><p>那么$LCP(i,k)=min(LCP(i,i+1),LCP(i+1,k))$</p><p>我们可以把$(i+1)- k$再拆，这样就像一个DP，正确性是显然的。</p><h3 id="怎么求LCP？"><a href="#怎么求LCP？" class="headerlink" title="怎么求LCP？"></a>怎么求LCP？</h3><h4 id="证明关键推论：-h-i-gt-h-i-1-1"><a href="#证明关键推论：-h-i-gt-h-i-1-1" class="headerlink" title="证明关键推论：$h[i]&gt;=h[i-1]-1;$"></a>证明关键推论：$h[i]&gt;=h[i-1]-1;$</h4><p>我们设$height[i]$为$LCP(i,i-1)$，$1&lt;i&lt;=n$，显然$height[1]=0$;</p><p>由<strong>推论2</strong>可得，$LCP(i,k)=min(height[j])$,$ i+1&lt;=j&lt;=k$</p><p>我们要利用这些后缀之间的联系求$height[]$数组：</p><p>设$h[i]=height[rk[i]]$，同样的，我们若求出$h$数组，只需$height[i]=h[sa[i]]$即可求出$height$数组;</p><p>那么现在来证明最关键的一条定理：$h[i]&gt;=h[i-1]-1;$</p><p><strong>证明</strong>：设$suffix(k)$是排在$suffix(i-1)$前一名的后缀，它们的最长公共前缀是$h[i-1]$。</p><p>那么$suffix(k+1)$将排在$suffix(i)$的前面（这里要求$h[i-1]&gt;1$，如果$h[i-1]≤1$，原式显然成立）并且$suffix(k+1)$和$suffix(i)$的最长公共前缀是$h[i-1]-1$，</p><p>所以$suffix(i)$和在它前一名的后缀的最长公共前缀至少是$h[i-1]-1$。</p><p>按照$h[1],h[2],……,h[n]$的顺序计算,并利用$h$ 数组的性质，时间复杂度可以降为$O(n)$。</p><p>即：</p><p>　　　<strong>rank[i-1] = q-1　suffix(k):        rabaa</strong></p><p>　　　<strong>rank[i-1] = q　   suffix(i-1):  　 racadabrabaa         h[i-1] = 2;</strong></p><p>　　　<strong>……</strong></p><p>　　　<strong>rank[k-1] = p-1   suffix(k-1):     abaa</strong></p><p>　　　<strong>rank[i] = p          suffix(i):  　    acadabrabaa         h[i] = 1 (h[i] &gt;= h[i-1]-1 = 1;)</strong></p><h4 id="求h数组"><a href="#求h数组" class="headerlink" title="求h数组"></a>求h数组</h4><p>可以令$i$从$1$循环到$n$（此循环中i的意义为$suffix(i)$）按照如下方法依次算出$h[i]$：</p><p>（1）若 $Rank[i]=1$，则$h[i]=0$。字符比较次数为$0$。</p><p>（2）若$i=1$或者$h[i-1]≤1$，则直接暴力算，将$Suffix(i)$和$Suffix(Rank[i]-1)$从第一个字符开始依次比较直到有字符不相同，由此计算出$h[i]$。因为$h[i-1]&lt;=1$且$h[i-1]&lt;=1$的个数最多也就是$n$个，$i=1$的情况也只有一次，所以这一步复杂度也是不超过$O(n)$的</p><p>（3）否则，说明$i&gt;1$，$Rank[i]&gt;1$，$h[i-1]&gt;1$，根据性质2，$Suffix(i)$和$Suffix(Rank[i]-1)$至少有前$h[i-1]-1$ 个字符是相同的，于是字符比较可以从$h[i-1]$开始，直到某个字符不相同，由此计算出$h[i]$。字符比较次数为$h[i]-(h[i-1]-1)+1=h[i]-h[i-1]+2$。</p><p>　　可求得最后算法复杂度为$O(n)$。</p><h4 id="从h反推出height数组"><a href="#从h反推出height数组" class="headerlink" title="从h反推出height数组"></a>从h反推出height数组</h4><p>$h[i]=height[rk[i]]$，可以推出$height[i]=h[sa[i]]$</p><h4 id="通过RMQ来做LCP"><a href="#通过RMQ来做LCP" class="headerlink" title="通过RMQ来做LCP"></a>通过RMQ来做LCP</h4><p>由推论2可知：$LCP(i,k)=min(LCP(j,j-1))$ ，$1&lt;i+1&lt;=j&lt;= k &lt;=n$</p><p>$height[i]$=$LCP(i,i-1)$</p><p>故$LCP(i,k)=min(height[ j ])$ ,$1&lt;i+1&lt;=j&lt;= k &lt;=n$</p><h3 id="后缀数组-LCP用来解决什么问题？"><a href="#后缀数组-LCP用来解决什么问题？" class="headerlink" title="后缀数组+LCP用来解决什么问题？"></a>后缀数组+LCP用来解决什么问题？</h3><p><strong>1.利用LCP的性质将平凡LCP问题转化为height数组上的RMQ问题</strong></p><p><strong>solution：</strong>比如我们多次查询字符串的第$x$位的后缀和第$y$位的后缀的最长公共前缀的长度：</p><p>因为LCP(i,k)里的i和k是指排名,所以我们可以通过先求$i=rank[x],k=rank[y]$</p><p>然后查询区间$1&lt;i+1&lt;=j&lt;=k&lt;=n$中$min(height[j])$，这转换成了一个<strong>RMQ</strong>问题了</p><p>然后<strong>log</strong>查询，效率十分高。</p><p><strong>2.有一个字符串s，求它的子串中至少出现过两次的最长的子串。</strong></p><p><strong>Solution：</strong>考虑$height$的定义：两个rank值相近的字符串的最长公共前缀，那么很显然答案就是<br>$max(height[i])(i∈(1,n))$</p><p><strong>3.有一个字符串s，求它的子串中至少出现过两次的最长的子串（不可重叠）。</strong></p><p><strong>Solution：</strong></p><p><strong>4.给定一个字符串s，求它不同的子串的个数</strong></p><p><strong>Solution：</strong>考虑有$height[i ]$的重复，</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-后缀数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCv with Python for Image and Video Analysis(3/20)</title>
    <link href="/2020/03/24/OpenCV/"/>
    <url>/2020/03/24/OpenCV/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenCv-with-Python-for-Image-and-Video-Analysis"><a href="#OpenCv-with-Python-for-Image-and-Video-Analysis" class="headerlink" title="OpenCv with Python for Image and Video Analysis"></a>OpenCv with Python for Image and Video Analysis</h1><h2 id="P1-intro-and-loading-Images"><a href="#P1-intro-and-loading-Images" class="headerlink" title="P1 intro and loading Images"></a>P1 intro and loading Images</h2><h3 id="1-利用cv2显示图像"><a href="#1-利用cv2显示图像" class="headerlink" title="1.利用cv2显示图像"></a><strong>1.利用cv2显示图像</strong></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'cat.jpg'</span>,cv2.IMREAD_GRAYSCALE) <span class="hljs-comment">#灰度图读入</span><br> <span class="hljs-comment">#读图片</span><br> <span class="hljs-comment">#IMREAD_GRAYSCALE = 0  灰度</span><br> <span class="hljs-comment">#IMREAD_COLOR =  1   颜色</span><br> <span class="hljs-comment">#IMREAD_UNCHANGE= -1  不变</span><br>cv2.imshow(<span class="hljs-string">'image'</span>, img)  <span class="hljs-comment">#以窗口打开img，窗口名字叫做img</span><br>cv2.waitKey(<span class="hljs-number">0</span>)  <span class="hljs-comment">#等待键入</span><br>cv2.destroyAllWindows() <span class="hljs-comment">#关闭所有窗口</span><br></code></pre></div></td></tr></table></figure><h3 id="2-使用matplotlib显示图像"><a href="#2-使用matplotlib显示图像" class="headerlink" title="2.使用matplotlib显示图像"></a><strong>2.使用matplotlib显示图像</strong></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'cat.jpg'</span>, cv2.IMREAD_GRAYSCALE)<br>plt.imshow(img,cmap=<span class="hljs-string">'gray'</span>,interpolation=<span class="hljs-string">'bicubic'</span>)<br>plt.plot([<span class="hljs-number">50</span>,<span class="hljs-number">100</span>],[<span class="hljs-number">80</span>,<span class="hljs-number">100</span>],<span class="hljs-string">'c'</span>,linewidth=<span class="hljs-number">5</span>)<span class="hljs-comment">#linewidth=划线的宽度  'c'指线的颜色为青色</span><br>plt.show()<br>cv2.imwrite(<span class="hljs-string">'gray.png'</span>, img)<span class="hljs-comment">#保存img</span><br></code></pre></div></td></tr></table></figure><p><strong>Colormap是MATLAB里面用来设定和获取当前色图的函数，可以设置如下色图：</strong>   </p><p> <strong>hot 从黑平滑过度到红、橙色和黄色的背景色，然后到白色。</strong>    </p><p><strong>cool 包含青绿色和品红色的阴影色。从青绿色平滑变化到品红色。</strong>    </p><p><strong>gray 返回线性灰度色图。</strong>    </p><p><strong>bone 具有较高的蓝色成分的灰度色图。该色图用于对灰度图添加电子的视图。</strong>    </p><p><strong>white 全白的单色色图。</strong>     </p><p><strong>spring 包含品红和黄的阴影颜色。</strong>     </p><p><strong>summer 包含绿和黄的阴影颜色。</strong>    </p><p><strong>autumn 从红色平滑变化到橙色，然后到黄色。</strong>     </p><p><strong>winter 包含蓝和绿的阴影色。</strong></p><h3 id="3-matplotlib中图片时rgb顺序，cv2中时bgr"><a href="#3-matplotlib中图片时rgb顺序，cv2中时bgr" class="headerlink" title="3.matplotlib中图片时rgb顺序，cv2中时bgr"></a><strong>3.matplotlib中图片时rgb顺序，cv2中时bgr</strong></h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'cat.jpg'</span>)<br>b, g, r = cv2.split(img)<br>img2 = cv2.merge([r, g, b])<br><span class="hljs-comment"># img2 = img[:,:,::-1]    this can be faster</span><br>plt.subplot(<span class="hljs-number">121</span>) <span class="hljs-comment">#subplot(xyz)的意思时分成x行y列个图 这是第z个图</span><br>plt.imshow(img)  <span class="hljs-comment"># expects distorted color</span><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.imshow(img2)  <span class="hljs-comment"># expects true color</span><br>plt.show()<br><br>cv2.imshow(<span class="hljs-string">'bgr image'</span>, img)  <span class="hljs-comment"># expects true color</span><br>cv2.imshow(<span class="hljs-string">'rgb image'</span>, img2)  <span class="hljs-comment"># expects distrorted color</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></div></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/03/22/8o902t.png" srcset="/img/loading.gif" alt="8o902t.png"></p><p><a href="https://imgchr.com/i/8oPxHO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/22/8oPxHO.th.png" srcset="/img/loading.gif" alt="8oPxHO.th.png"></a><a href="https://imgchr.com/i/8oiPCd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/22/8oiPCd.th.png" srcset="/img/loading.gif" alt="8oiPCd.th.png"></a></p><p>​           bgr  image                        rgb image</p><h2 id="P2-loading-video-source"><a href="#P2-loading-video-source" class="headerlink" title="P2 loading video source"></a>P2 loading video source</h2><h3 id="1-加载摄像头"><a href="#1-加载摄像头" class="headerlink" title="1.加载摄像头"></a>1.加载摄像头</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cv2<br><br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ret, frame = cap.read()<br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    <span class="hljs-comment">#gray = cv2.cvtColor(frame,cv2.COLOR_RGB2GRAY) 灰度图展示</span><br>    <span class="hljs-comment">#cv2.imshow('gray', gray)</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></div></td></tr></table></figure><p><strong>1、cap = cv2.VideoCapture(0)</strong></p><p>VideoCapture()中参数是0，表示打开笔记本的内置摄像头</p><p>参数是视频文件路径则打开视频，如cap = cv2.VideoCapture(“../test.avi”)</p><p><strong>2、ret,frame = cap.read()</strong></p><p> cap.read()按帧读取视频，ret,frame是获cap.read()方法的两个返回值。其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就为False。frame就是每一帧的图像，是个三维矩阵。</p><p><strong>3、cv2.waitKey(1)，waitKey（）方法本身表示等待键盘输入</strong></p><p><strong>参数是1</strong>，表示延时1ms切换到下一帧图像，对于视频而言；</p><p><strong>参数为0</strong>，如cv2.waitKey(0)只显示当前帧图像，相当于视频暂停,；</p><p><strong>参数过大</strong>，如cv2.waitKey(1000)，会因为延时过久而卡顿感觉到卡顿。</p><p>得到的是键盘输入的ASCII码，<strong>ord(‘q’)</strong>表示q的ascii码</p><p><strong>4、调用release()释放摄像头，调用destroyAllWindows()关闭所有图像窗口。</strong><br><strong>5.cv2.cvtColor(frame,cv2.COLOR_RGB2GRAY)</strong> 用于转换颜色</p><h3 id="2-录制视频"><a href="#2-录制视频" class="headerlink" title="2.录制视频"></a>2.录制视频</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cv2<br><br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">'XVID'</span>)<br>out = cv2.VideoWriter(<span class="hljs-string">'output.avi'</span>, fourcc, <span class="hljs-number">20.0</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ret, frame = cap.read()<br>    out.write(frame)<br>    cv2.imshow(<span class="hljs-string">"frame"</span>, frame)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br>cap.release()<br>out.release()<br>cv2.destroyAllWindows()<br></code></pre></div></td></tr></table></figure><p><strong>1.详解cv2.VideoWriter_fourcc对象(摘自Learning OpenCV3 Computer Vision with Python)</strong></p><p>定义编码器：</p><h1 id="fourcc意为四字符代码（Four-Character-Codes），顾名思义，该编码由四个字符组成-下面是VideoWriter-fourcc对象一些常用的参数，注意：字符顺序不能弄混"><a href="#fourcc意为四字符代码（Four-Character-Codes），顾名思义，该编码由四个字符组成-下面是VideoWriter-fourcc对象一些常用的参数，注意：字符顺序不能弄混" class="headerlink" title="fourcc意为四字符代码（Four-Character Codes），顾名思义，该编码由四个字符组成,下面是VideoWriter_fourcc对象一些常用的参数，注意：字符顺序不能弄混"></a>fourcc意为四字符代码（Four-Character Codes），顾名思义，该编码由四个字符组成,下面是VideoWriter_fourcc对象一些常用的参数，注意：字符顺序不能弄混</h1><h1 id="cv2-VideoWriter-fourcc-‘I’-‘4’-‘2’-‘0’-该参数是YUV编码类型，文件名后缀为-avi"><a href="#cv2-VideoWriter-fourcc-‘I’-‘4’-‘2’-‘0’-该参数是YUV编码类型，文件名后缀为-avi" class="headerlink" title="cv2.VideoWriter_fourcc(‘I’, ‘4’, ‘2’, ‘0’),该参数是YUV编码类型，文件名后缀为.avi"></a>cv2.VideoWriter_fourcc(‘I’, ‘4’, ‘2’, ‘0’),该参数是YUV编码类型，文件名后缀为.avi</h1><h1 id="cv2-VideoWriter-fourcc-‘P’-‘I’-‘M’-‘I’-该参数是MPEG-1编码类型，文件名后缀为-avi"><a href="#cv2-VideoWriter-fourcc-‘P’-‘I’-‘M’-‘I’-该参数是MPEG-1编码类型，文件名后缀为-avi" class="headerlink" title="cv2.VideoWriter_fourcc(‘P’, ‘I’, ‘M’, ‘I’),该参数是MPEG-1编码类型，文件名后缀为.avi"></a>cv2.VideoWriter_fourcc(‘P’, ‘I’, ‘M’, ‘I’),该参数是MPEG-1编码类型，文件名后缀为.avi</h1><h1 id="cv2-VideoWriter-fourcc-‘X’-‘V’-‘I’-‘D’-该参数是MPEG-4编码类型，文件名后缀为-avi"><a href="#cv2-VideoWriter-fourcc-‘X’-‘V’-‘I’-‘D’-该参数是MPEG-4编码类型，文件名后缀为-avi" class="headerlink" title="cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’),该参数是MPEG-4编码类型，文件名后缀为.avi"></a>cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’),该参数是MPEG-4编码类型，文件名后缀为.avi</h1><h1 id="cv2-VideoWriter-fourcc-‘T’-‘H’-‘E’-‘O’-该参数是Ogg-Vorbis-文件名后缀为-ogv"><a href="#cv2-VideoWriter-fourcc-‘T’-‘H’-‘E’-‘O’-该参数是Ogg-Vorbis-文件名后缀为-ogv" class="headerlink" title="cv2.VideoWriter_fourcc(‘T’, ‘H’, ‘E’, ‘O’),该参数是Ogg Vorbis,文件名后缀为.ogv"></a>cv2.VideoWriter_fourcc(‘T’, ‘H’, ‘E’, ‘O’),该参数是Ogg Vorbis,文件名后缀为.ogv</h1><h1 id="cv2-VideoWriter-fourcc-‘F’-‘L’-‘V’-‘1’-该参数是Flash视频，文件名后缀为-flv"><a href="#cv2-VideoWriter-fourcc-‘F’-‘L’-‘V’-‘1’-该参数是Flash视频，文件名后缀为-flv" class="headerlink" title="cv2.VideoWriter_fourcc(‘F’, ‘L’, ‘V’, ‘1’),该参数是Flash视频，文件名后缀为.flv"></a>cv2.VideoWriter_fourcc(‘F’, ‘L’, ‘V’, ‘1’),该参数是Flash视频，文件名后缀为.flv</h1><p><strong>2.out = cv2.VideoWriter(‘output.avi’, fourcc, 20.0, (640, 480))</strong></p><p>向视频文件写入一帧，输出成为output.avi文件，fourcc 指定编码器，fps=20.0 代表20帧，frameSize 要保存的文件的画面尺寸。</p><h2 id="P3-drawing-and-writing-on-image"><a href="#P3-drawing-and-writing-on-image" class="headerlink" title="P3 drawing and writing on image"></a>P3 drawing and writing on image</h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy数据分析基础</title>
    <link href="/2020/02/28/Numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/02/28/Numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Numpy模块学习"><a href="#Numpy模块学习" class="headerlink" title="Numpy模块学习"></a>Numpy模块学习</h1><h2 id="numpy的基本属性"><a href="#numpy的基本属性" class="headerlink" title="numpy的基本属性"></a>numpy的基本属性</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>array = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>                  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br>print(array)  <span class="hljs-comment"># [[1 2 3]</span><br>              <span class="hljs-comment">#  [2 3 4]]</span><br><br>print(<span class="hljs-string">'number of dim:'</span>,array.ndim)  <span class="hljs-comment">#维数  number of dim: 2</span><br>print(<span class="hljs-string">'shape:'</span>,array.shape)  <span class="hljs-comment">#shape: (2, 3)</span><br>print(<span class="hljs-string">'size:'</span>,array.size)    <span class="hljs-comment">#size: 6</span><br></code></pre></div></td></tr></table></figure><h2 id="numpy创建的array"><a href="#numpy创建的array" class="headerlink" title="numpy创建的array"></a>numpy创建的array</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-number">2</span>,<span class="hljs-number">23</span>,<span class="hljs-number">4</span>],dtype=np.int)  <span class="hljs-comment">#定义数据的类型</span><br>print(a)  <span class="hljs-comment">#[ 2 23  4]</span><br>print(a.dtype)  <span class="hljs-comment">#int32</span><br><br>a = np.zeros((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>))  <span class="hljs-comment">#生成一个4行2列的全0矩阵</span><br>print(a)<br><br>a = np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>))   <span class="hljs-comment">#生成一个4行2列的全1矩阵</span><br>print(a)<br><span class="hljs-comment">#[[1. 1.]</span><br><span class="hljs-comment"># [1. 1.]</span><br><span class="hljs-comment"># [1. 1.]</span><br><span class="hljs-comment"># [1. 1.]]</span><br><br><span class="hljs-comment">#我们可以对它的数据类型进行规定</span><br>a = np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),dtype=int)<br>print(a)<br><span class="hljs-comment">#[[1 1]</span><br><span class="hljs-comment"># [1 1]</span><br><span class="hljs-comment"># [1 1]</span><br><span class="hljs-comment"># [1 1]]</span><br><br>a = np.empty((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))  <span class="hljs-comment">#空矩阵 矩阵中的数十分接近零</span><br>print(a)<br><br>a = np.arange(<span class="hljs-number">10</span>)   <span class="hljs-comment">#0-9</span><br>a = np.arange(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">#有序从10到20 步长为2</span><br>print(a)  <span class="hljs-comment">#[10 12 14 16 18]</span><br><br>a = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))  <span class="hljs-comment">#首先构造一个0-11的序列 然后reshape使他变为3*4的矩阵</span><br>print(a)<br><span class="hljs-comment">#[[ 0  1  2  3]</span><br><span class="hljs-comment"># [ 4  5  6  7]</span><br><span class="hljs-comment"># [ 8  9 10 11]]</span><br><br>a = np.linspace(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>) <span class="hljs-comment">#构造10-20 有20个数在里面</span><br>print(a)<br><br>a = a.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)) <span class="hljs-comment">#把上述的linspace reshape为4*5的矩阵</span><br>print(a)<br><span class="hljs-comment">#[[10.         10.52631579 11.05263158 11.57894737 12.10526316]</span><br><span class="hljs-comment"># [12.63157895 13.15789474 13.68421053 14.21052632 14.73684211]</span><br><span class="hljs-comment"># [15.26315789 15.78947368 16.31578947 16.84210526 17.36842105]</span><br><span class="hljs-comment"># [17.89473684 18.42105263 18.94736842 19.47368421 20.        ]]</span><br></code></pre></div></td></tr></table></figure><h2 id="numpy的基础运算1"><a href="#numpy的基础运算1" class="headerlink" title="numpy的基础运算1"></a>numpy的基础运算1</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>])<br>b = np.arange(<span class="hljs-number">4</span>)<br>print(a,b)    <span class="hljs-comment">#[10 20 30 40] [0 1 2 3]</span><br>c = a + b<br>print(c)    <span class="hljs-comment">#[10 21 32 43]</span><br><br>c = c**<span class="hljs-number">2</span><br>print(c)   <span class="hljs-comment">#[ 100  441 1024 1849]</span><br><br>c = <span class="hljs-number">10</span>*np.sin(a)   <span class="hljs-comment">#把a都放到sin函数种</span><br>print(c)    <span class="hljs-comment">#[-5.44021111  9.12945251 -9.88031624  7.4511316 ]</span><br><br>print(a&gt;<span class="hljs-number">10</span>)    <span class="hljs-comment"># a种大于10的有哪些？ [False  True  True  True]</span><br>print(a==<span class="hljs-number">10</span>)   <span class="hljs-comment">#a=10有哪些？        [ True False False False]</span><br><br>a = np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],<br>              [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]])<br>c=a*a   <span class="hljs-comment">#对应位置乘</span><br>c_dot=np.dot(a,a)   <span class="hljs-comment">#矩阵乘法</span><br>c_dot_2=a.dot(a)    <span class="hljs-comment">#矩阵乘法 a*a</span><br>print(c)<br><span class="hljs-comment">#[[4 1]</span><br><span class="hljs-comment"># [0 9]]</span><br>print(c_dot)<br><span class="hljs-comment">#[[4 5]</span><br><span class="hljs-comment"># [0 9]]</span><br><br>a = np.random.random((<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))  <span class="hljs-comment">#2行4列 0-1随机数</span><br>print(a)<br><span class="hljs-comment">#[[0.93790893 0.46084244 0.1663417  0.21452909]</span><br><span class="hljs-comment"># [0.45389007 0.3981491  0.06045777 0.41783302]]</span><br><br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<br>              [<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>]])<br>print(np.sum(a))  <span class="hljs-comment">#70</span><br>print(np.sum(a,axis=<span class="hljs-number">1</span>)) <span class="hljs-comment">#每一行的和   #[15 55]</span><br>print(np.sum(a,axis=<span class="hljs-number">0</span>)) <span class="hljs-comment">#每一列的和   #[10 12 14 16 18]</span><br>print(np.min(a))  <span class="hljs-comment">#1</span><br>print(np.max(a))  <span class="hljs-comment">#13</span><br>print(np.min(a,axis=<span class="hljs-number">1</span>))  <span class="hljs-comment">#每一行最小值 [1 9]</span><br></code></pre></div></td></tr></table></figure><h2 id="numpy基础运算2"><a href="#numpy基础运算2" class="headerlink" title="numpy基础运算2"></a>numpy基础运算2</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.arange(<span class="hljs-number">2</span>,<span class="hljs-number">14</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>print(a)<br><span class="hljs-comment">#[[ 2  3  4  5]</span><br><span class="hljs-comment"># [ 6  7  8  9]</span><br><span class="hljs-comment"># [10 11 12 13]]</span><br>print(np.argmin(a))  <span class="hljs-comment"># .argmin()索引最小的数的index  #0</span><br>print(np.argmax(a))  <span class="hljs-comment"># .argmax()索引最大的数的index  #11</span><br>print(np.mean(a))    <span class="hljs-comment">#把矩阵中的数据的平均值7.5</span><br>print(np.mean(a,axis=<span class="hljs-number">0</span>))  <span class="hljs-comment">#列平均</span><br>print(np.mean(a,axis=<span class="hljs-number">1</span>))   <span class="hljs-comment">#行平均</span><br>print(np.median(a))  <span class="hljs-comment">#中位数 7.5</span><br>print(np.cumsum(a))  <span class="hljs-comment">#每个数据的前缀和[ 2  5  9 14 20 27 35 44 54 65 77 90] 如果想要矩阵形式，只需要reshape一下</span><br>print(np.diff(a))    <span class="hljs-comment">#每个数据与前面一个数据的差</span><br><span class="hljs-comment">#[[1 1 1]</span><br><span class="hljs-comment"># [1 1 1]</span><br><span class="hljs-comment"># [1 1 1]]</span><br>print(np.nonzero(a))<br><span class="hljs-comment">#会输出非零元素的行列</span><br><span class="hljs-comment">#(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2], dtype=int64), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3], dtype=int64))</span><br><br>print(np.sort(a))  <span class="hljs-comment">#这里的sort不对所有元素排序 而是逐行排序</span><br>print(np.transpose(a)) <span class="hljs-comment">#矩阵的转置</span><br><span class="hljs-comment">#[[ 2  6 10]</span><br><span class="hljs-comment"># [ 3  7 11]</span><br><span class="hljs-comment"># [ 4  8 12]</span><br><span class="hljs-comment"># [ 5  9 13]]</span><br>print(a.T)  <span class="hljs-comment">#矩阵的转置</span><br><br>print(np.clip(a,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>))   <span class="hljs-comment">#.clip(a,min,max)大于9的变为9，小于5的变为5，使数据在5-9之间</span><br></code></pre></div></td></tr></table></figure><h2 id="numpy的索引"><a href="#numpy的索引" class="headerlink" title="numpy的索引"></a>numpy的索引</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.arange(<span class="hljs-number">3</span>,<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br>print(a)<br><span class="hljs-comment">#[[ 3  4  5  6]</span><br><span class="hljs-comment"># [ 7  8  9 10]</span><br><span class="hljs-comment"># [11 12 13 14]]</span><br>print(a[<span class="hljs-number">2</span>])  <span class="hljs-comment">#[11 12 13 14]</span><br>print(a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])  <span class="hljs-comment">#11</span><br>print(a[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>])   <span class="hljs-comment">#同上，11</span><br>print(a[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>:]) <span class="hljs-comment">#第1行，从第1列开始到最后   [ 8  9 10]</span><br>print(a[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment">#第1行，从第1列开始到第2列（左闭右开）  [8 9]</span><br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> a:<br>    print(row)<br><span class="hljs-comment">#[3 4 5 6]</span><br><span class="hljs-comment">#[7  8  9 10]</span><br><span class="hljs-comment">#[11 12 13 14]</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> a.T:<br>    print(column)<br><span class="hljs-comment">#[ 3  7 11]</span><br><span class="hljs-comment">#[ 4  8 12]</span><br><span class="hljs-comment">#[ 5  9 13]</span><br><span class="hljs-comment">#[ 6 10 14]</span><br><br>print(a.flatten())  <span class="hljs-comment"># 将矩阵变成一行列表 [ 3  4  5  6  7  8  9 10 11 12 13 14]</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> a.flat:    <span class="hljs-comment">#  a.flat是迭代器</span><br>    print(item)<br><span class="hljs-comment">#也可以这样</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> a.flatten():    <span class="hljs-comment">#  这里a.flatten()不是迭代器，只是一个简单的列表</span><br>    print(item)<br></code></pre></div></td></tr></table></figure><h2 id="numpy的array合并"><a href="#numpy的array合并" class="headerlink" title="numpy的array合并"></a>numpy的array合并</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])<br>b = np.array([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br>c = np.vstack((a,b))  <span class="hljs-comment">#vertical stack ,可以是3或者多个个合并，上下合并</span><br>print(c)<br><span class="hljs-comment">#[[1 1 1]</span><br><span class="hljs-comment"># [2 2 2]]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])<br>b = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]])<br>c = np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<br><br>d = np.concatenate((a,b,c),axis=<span class="hljs-number">0</span>) <span class="hljs-comment">#纵向合并</span><br>print(d)<br><span class="hljs-comment">#[[1 1 1]</span><br><span class="hljs-comment"># [2 2 2]</span><br><span class="hljs-comment"># [3 3 3]]</span><br>d = np.concatenate((a,b,c),axis=<span class="hljs-number">1</span>) <span class="hljs-comment">#横向合并</span><br>print(d)  <span class="hljs-comment">#[[1 1 1 2 2 2 3 3 3]]</span><br></code></pre></div></td></tr></table></figure><p>下面单独拿出来说一下关于array的维度的问题和newaxis这个函数的理解</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">print(np.transpose(a))  <span class="hljs-comment">#[1 1 1] </span><br>print(a.T)  <span class="hljs-comment">#同上[1 1 1]</span><br></code></pre></div></td></tr></table></figure><p>一个二维的数组才有转置，一个一维的数组把他转置后，再放回一维数组那还是原来的一维数组，如果我们想让它输出一列那样，那就是一个二维的数组了，所以此时我们就需要增加维数。</p><p>这里引入一个函数$numpy.axis$ 可以用来增加数组的维数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#我们给列增加维数 相当于 a[3]-&gt;a[3][1]</span><br>print(a[:,np.newaxis]) <span class="hljs-comment">#列增加一个维度</span><br><span class="hljs-comment">#[[1]</span><br><span class="hljs-comment"># [1]</span><br><span class="hljs-comment"># [1]]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#给行增加维数 相当于  a[3]-&gt;a[1][3] </span><br>print(a[np.newaxis, :])  <span class="hljs-comment">#[[1 1 1]]</span><br></code></pre></div></td></tr></table></figure><h2 id="array的分割"><a href="#array的分割" class="headerlink" title="array的分割"></a>array的分割</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br>print(a)<br><span class="hljs-comment">#[[ 0  1  2  3]</span><br><span class="hljs-comment"># [ 4  5  6  7]</span><br><span class="hljs-comment"># [ 8  9 10 11]]</span><br>print(np.split(a,<span class="hljs-number">4</span>,axis=<span class="hljs-number">1</span>))  <span class="hljs-comment">#等量分割  spilt(分割的数组,分成相等的几分[不能分成不相等的份数]，横向还是纵向1是纵向，0是横向)</span><br><span class="hljs-comment">#[array([[0],</span><br><span class="hljs-comment">#       [4],</span><br><span class="hljs-comment">#       [8]]), array([[1],</span><br><span class="hljs-comment">#       [5],</span><br><span class="hljs-comment">#       [9]]), array([[ 2],</span><br><span class="hljs-comment">#       [ 6],</span><br><span class="hljs-comment">#       [10]]), array([[ 3],</span><br><span class="hljs-comment">#       [ 7],</span><br><span class="hljs-comment">#       [11]])]</span><br><br>print(np.array_split(a,<span class="hljs-number">3</span>,axis=<span class="hljs-number">1</span>))  <span class="hljs-comment">#不等量分割</span><br><span class="hljs-comment">#[array([[0, 1],</span><br><span class="hljs-comment">#       [4, 5],</span><br><span class="hljs-comment">#       [8, 9]]), array([[ 2],</span><br><span class="hljs-comment">#       [ 6],</span><br><span class="hljs-comment">#       [10]]), array([[ 3],</span><br><span class="hljs-comment">#       [ 7],</span><br><span class="hljs-comment">#       [11]])]</span><br>print(<span class="hljs-string">'111'</span>)<br>print(np.vsplit(a, <span class="hljs-number">3</span>))  <span class="hljs-comment">#纵向等量分割</span><br><br>print(np.hsplit(a, <span class="hljs-number">2</span>))  <span class="hljs-comment">#横向等量分割</span><br></code></pre></div></td></tr></table></figure><h2 id="numpy的copy-amp-deepcopy"><a href="#numpy的copy-amp-deepcopy" class="headerlink" title="numpy的copy&amp;deepcopy"></a>numpy的copy&amp;deepcopy</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">b=a.copy()  <span class="hljs-comment">#deep copy</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python-基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas数据分析基础</title>
    <link href="/2020/02/28/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/02/28/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Pandas模块学习"><a href="#Pandas模块学习" class="headerlink" title="Pandas模块学习"></a>Pandas模块学习</h1><h2 id="Pandas基本介绍"><a href="#Pandas基本介绍" class="headerlink" title="Pandas基本介绍"></a>Pandas基本介绍</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>s = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,np.nan,<span class="hljs-number">44</span>,<span class="hljs-number">1</span>])<br>print(s)<br><span class="hljs-comment">#0     1.0</span><br><span class="hljs-comment">#1     3.0</span><br><span class="hljs-comment">#2     4.0</span><br><span class="hljs-comment">#3     6.0</span><br><span class="hljs-comment">#4     NaN</span><br><span class="hljs-comment">#5    44.0</span><br><span class="hljs-comment">#6     1.0</span><br><br>dates = pd.date_range(<span class="hljs-string">'20200202'</span>,periods=<span class="hljs-number">6</span>)<br>print(dates)  <span class="hljs-comment">#DatetimeIndex(['2020-02-02', '2020-02-03', '2020-02-04', '2020-02-05',</span><br>              <span class="hljs-comment">#  '2020-02-06', '2020-02-07'],</span><br><br>df = pd.DataFrame(np.random.rand(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>),index=dates,columns=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>])  <span class="hljs-comment">#index指每行的坐标，也就是纵坐标，column是横坐标</span><br>print(df)<br><br><span class="hljs-comment">#                    a         b         c         d</span><br><span class="hljs-comment"># 2020-02-02  0.640585  0.969161  0.367313  0.680238</span><br><span class="hljs-comment"># 2020-02-03  0.619822  0.430586  0.451134  0.365451</span><br><span class="hljs-comment"># 2020-02-04  0.460065  0.730973  0.540782  0.844242</span><br><span class="hljs-comment"># 2020-02-05  0.154691  0.324446  0.945344  0.221274</span><br><span class="hljs-comment"># 2020-02-06  0.584177  0.865024  0.226741  0.834784</span><br><span class="hljs-comment"># 2020-02-07  0.501330  0.016878  0.927609  0.128724</span><br><br>df_2 = pd.DataFrame(np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))) <span class="hljs-comment">#不加index和columns默认是0，1，2，3，4作为坐标</span><br>print(df_2)<br><span class="hljs-comment">#    0  1   2   3</span><br><span class="hljs-comment"># 0  0  1   2   3</span><br><span class="hljs-comment"># 1  4  5   6   7</span><br><span class="hljs-comment"># 2  8  9  10  11</span><br><br>df_3 = pd.DataFrame(&#123;<span class="hljs-string">'A'</span>:<span class="hljs-number">1.0</span>,<span class="hljs-string">'B'</span>:pd.Timestamp(<span class="hljs-string">'20130102'</span>),<span class="hljs-string">'C'</span>:pd.Series(<span class="hljs-number">1</span>,list(range(<span class="hljs-number">4</span>)),dtype=<span class="hljs-string">'float32'</span>)&#125;)<br>print(df_3)<br><span class="hljs-comment">#      A          B    C</span><br><span class="hljs-comment"># 0  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 1  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 2  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 3  1.0 2013-01-02  1.0</span><br>print(df_3.dtypes)<br><span class="hljs-comment"># A           float64</span><br><span class="hljs-comment"># B    datetime64[ns]</span><br><span class="hljs-comment"># C           float32</span><br><span class="hljs-comment"># dtype: object</span><br>print(df_3.index)  <span class="hljs-comment">#Int64Index([0, 1, 2, 3], dtype='int64')</span><br>print(df_3.columns)  <span class="hljs-comment">#Index(['A', 'B', 'C'], dtype='object')</span><br>print(df_3.describe())<br><span class="hljs-comment">#          A    C</span><br><span class="hljs-comment"># count  4.0  4.0</span><br><span class="hljs-comment"># mean   1.0  1.0</span><br><span class="hljs-comment"># std    0.0  0.0</span><br><span class="hljs-comment"># min    1.0  1.0</span><br><span class="hljs-comment"># 25%    1.0  1.0</span><br><span class="hljs-comment"># 50%    1.0  1.0</span><br><span class="hljs-comment"># 75%    1.0  1.0</span><br><span class="hljs-comment"># max    1.0  1.0</span><br>print(df_3.T)  <span class="hljs-comment">#转置</span><br><span class="hljs-comment">#                      0  ...                    3</span><br><span class="hljs-comment"># A                    1  ...                    1</span><br><span class="hljs-comment"># B  2013-01-02 00:00:00  ...  2013-01-02 00:00:00</span><br><span class="hljs-comment"># C                    1  ...                    1</span><br>print(df_3.sort_index(axis=<span class="hljs-number">1</span>,ascending=<span class="hljs-literal">False</span>))  <span class="hljs-comment">#对行列进行排序  .sort_index(axis=行还是列,ascending=是否排序成增序列)</span><br><span class="hljs-comment">#      C          B    A</span><br><span class="hljs-comment"># 0  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 1  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 2  1.0 2013-01-02  1.0</span><br><span class="hljs-comment"># 3  1.0 2013-01-02  1.0</span><br><br>print(df_3.sort_values(by=<span class="hljs-string">'E'</span>)) <span class="hljs-comment">#按照某一列对行进行排序</span><br></code></pre></div></td></tr></table></figure><h2 id="Pandas-选择数据"><a href="#Pandas-选择数据" class="headerlink" title="Pandas 选择数据"></a>Pandas 选择数据</h2><p>请注意：在pandas版本0.20.0及其以后版本中，ix已经不被推荐使用，建议采用iloc和loc实现ix。这是为什么呢？这是由于ix的复杂特点可能使ix使用起来有些棘手：</p><p>如果索引是整数类型，则ix将仅使用基于标签的索引，而不会回退到基于位置的索引。如果标签不在索引中，则会引发错误。<br>如果索引不仅包含整数，则给定一个整数，ix将立即使用基于位置的索引而不是基于标签的索引。但是，如果ix被赋予另一种类型（例如字符串），则它可以使用基于标签的索引。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>dates = pd.date_range(<span class="hljs-string">'20130101'</span>, periods=<span class="hljs-number">6</span>)<br>df = pd.DataFrame(np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">4</span>)), index=dates, columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])<br>print(df)<br><span class="hljs-comment">#              A   B   C   D</span><br><span class="hljs-comment"># 2013-01-01   0   1   2   3</span><br><span class="hljs-comment"># 2013-01-02   4   5   6   7</span><br><span class="hljs-comment"># 2013-01-03   8   9  10  11</span><br><span class="hljs-comment"># 2013-01-04  12  13  14  15</span><br><span class="hljs-comment"># 2013-01-05  16  17  18  19</span><br><span class="hljs-comment"># 2013-01-06  20  21  22  23</span><br><br><br>print(df[<span class="hljs-string">'A'</span>]) <span class="hljs-comment">#df.A</span><br><span class="hljs-comment"># 2013-01-01     0</span><br><span class="hljs-comment"># 2013-01-02     4</span><br><span class="hljs-comment"># 2013-01-03     8</span><br><span class="hljs-comment"># 2013-01-04    12</span><br><span class="hljs-comment"># 2013-01-05    16</span><br><span class="hljs-comment"># 2013-01-06    20</span><br>print(df[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])  <span class="hljs-comment">#0-3行  也可以用df['20130101':'20130103']</span><br><span class="hljs-comment">#             A  B   C   D</span><br><span class="hljs-comment"># 2013-01-01  0  1   2   3</span><br><span class="hljs-comment"># 2013-01-02  4  5   6   7</span><br><span class="hljs-comment"># 2013-01-03  8  9  10  11</span><br><br>print(df.loc[<span class="hljs-string">'20130103'</span>]) <span class="hljs-comment">#选出特定的一行  .loc()是根据数字标签label来筛选</span><br><span class="hljs-comment"># A     8</span><br><span class="hljs-comment"># B     9</span><br><span class="hljs-comment"># C    10</span><br><span class="hljs-comment"># D    11</span><br><span class="hljs-comment"># Name: 2013-01-03 00:00:00, dtype: int32</span><br>print(df.loc[:, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>]])   <span class="hljs-comment">#选出特定的一列</span><br><span class="hljs-comment">#              A   B</span><br><span class="hljs-comment"># 2013-01-01   0   1</span><br><span class="hljs-comment"># 2013-01-02   4   5</span><br><span class="hljs-comment"># 2013-01-03   8   9</span><br><span class="hljs-comment"># 2013-01-04  12  13</span><br><span class="hljs-comment"># 2013-01-05  16  17</span><br><span class="hljs-comment"># 2013-01-06  20  21</span><br><br>print(df.loc[<span class="hljs-string">'20130103'</span>:<span class="hljs-string">'20130105'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>]])  <span class="hljs-comment">#特定的行和列</span><br><span class="hljs-comment">#              A   B</span><br><span class="hljs-comment"># 2013-01-03   8   9</span><br><span class="hljs-comment"># 2013-01-04  12  13</span><br><span class="hljs-comment"># 2013-01-05  16  17</span><br><br>print(df.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">0</span>:<span class="hljs-number">1</span>])  <span class="hljs-comment">#不按照行列的名字，而是按照行数和列数的index来筛选  (注意：左闭右开)</span><br><span class="hljs-comment">#             A</span><br><span class="hljs-comment"># 2013-01-02  4</span><br><span class="hljs-comment"># 2013-01-03  8</span><br>print(df.iloc[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], <span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><span class="hljs-comment">#              B   C</span><br><span class="hljs-comment"># 2013-01-02   5   6</span><br><span class="hljs-comment"># 2013-01-04  13  14</span><br><span class="hljs-comment"># 2013-01-06  21  22</span><br>print(df.iloc[range(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><br><br><span class="hljs-comment">#请注意：在pandas版本0.20.0及其以后版本中，ix已经不被推荐使用，建议采用iloc和loc实现ix。这是为什么呢？这是由于ix的复杂特点可能使ix使用起来有些棘手：</span><br><span class="hljs-comment">#如果索引是整数类型，则ix将仅使用基于标签的索引，而不会回退到基于位置的索引。如果标签不在索引中，则会引发错误。</span><br><span class="hljs-comment">#如果索引不仅包含整数，则给定一个整数，ix将立即使用基于位置的索引而不是基于标签的索引。但是，如果ix被赋予另一种类型（例如字符串），则它可以使用基于标签的索引。</span><br><span class="hljs-comment">#print(df._ix[:3, ['A', 'B']])</span><br><br>print(df[df.A&gt;<span class="hljs-number">8</span>])<br><span class="hljs-comment">#              A   B   C   D</span><br><span class="hljs-comment"># 2013-01-04  12  13  14  15</span><br><span class="hljs-comment"># 2013-01-05  16  17  18  19</span><br><span class="hljs-comment"># 2013-01-06  20  21  22  23</span><br></code></pre></div></td></tr></table></figure><h2 id="Pandas设置值"><a href="#Pandas设置值" class="headerlink" title="Pandas设置值"></a>Pandas设置值</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>dates = pd.date_range(<span class="hljs-string">'20130101'</span>, periods=<span class="hljs-number">6</span>)<br>df = pd.DataFrame(np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">4</span>)), index=dates, columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])<br>print(df)<br><span class="hljs-comment">#              A   B   C   D</span><br><span class="hljs-comment"># 2013-01-01   0   1   2   3</span><br><span class="hljs-comment"># 2013-01-02   4   5   6   7</span><br><span class="hljs-comment"># 2013-01-03   8   9  10  11</span><br><span class="hljs-comment"># 2013-01-04  12  13  14  15</span><br><span class="hljs-comment"># 2013-01-05  16  17  18  19</span><br><span class="hljs-comment"># 2013-01-06  20  21  22  23</span><br><br><span class="hljs-comment">#更改DataFrame中的值</span><br>df.iloc[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] = <span class="hljs-number">111</span><br>df.loc[<span class="hljs-string">'20130101'</span>,<span class="hljs-string">'B'</span>] = <span class="hljs-number">222</span><br><span class="hljs-comment">#df[df.A&gt;4] = 0  #df.A&gt;4的那行为赋值为0</span><br>df.B[df.A&gt;<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">#只对一列操作</span><br><span class="hljs-comment">#              A    B    C   D</span><br><span class="hljs-comment"># 2013-01-01   0  222    2   3</span><br><span class="hljs-comment"># 2013-01-02   4    5    6   7</span><br><span class="hljs-comment"># 2013-01-03   8    0  111  11</span><br><span class="hljs-comment"># 2013-01-04  12    0   14  15</span><br><span class="hljs-comment"># 2013-01-05  16    0   18  19</span><br><span class="hljs-comment"># 2013-01-06  20    0   22  23</span><br><br><span class="hljs-comment">#增加series</span><br>df[<span class="hljs-string">'E'</span>] = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],index=pd.date_range(<span class="hljs-string">'20130101'</span>,periods=<span class="hljs-number">6</span>))<br>print(df)<br><span class="hljs-comment">#              A    B    C   D  E</span><br><span class="hljs-comment"># 2013-01-01   0  222    2   3  1</span><br><span class="hljs-comment"># 2013-01-02   4    5    6   7  2</span><br><span class="hljs-comment"># 2013-01-03   8    0  111  11  3</span><br><span class="hljs-comment"># 2013-01-04  12    0   14  15  4</span><br><span class="hljs-comment"># 2013-01-05  16    0   18  19  5</span><br><span class="hljs-comment"># 2013-01-06  20    0   22  23  6</span><br></code></pre></div></td></tr></table></figure><h2 id="Pandas处理丢失数据"><a href="#Pandas处理丢失数据" class="headerlink" title="Pandas处理丢失数据"></a>Pandas处理丢失数据</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>dates = pd.date_range(<span class="hljs-string">'20130101'</span>, periods=<span class="hljs-number">6</span>)<br>df = pd.DataFrame(np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">6</span>, <span class="hljs-number">4</span>)), index=dates, columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])<br>df.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] = np.nan<br>df.iloc[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] = np.nan<br>print(df)<br><span class="hljs-comment">#              A     B     C   D</span><br><span class="hljs-comment"># 2013-01-01   0   NaN   2.0   3</span><br><span class="hljs-comment"># 2013-01-02   4   5.0   NaN   7</span><br><span class="hljs-comment"># 2013-01-03   8   9.0  10.0  11</span><br><span class="hljs-comment"># 2013-01-04  12  13.0  14.0  15</span><br><span class="hljs-comment"># 2013-01-05  16  17.0  18.0  19</span><br><span class="hljs-comment"># 2013-01-06  20  21.0  22.0  23</span><br><br><span class="hljs-comment">#drop none value data</span><br>print(df.dropna(axis = <span class="hljs-number">0</span>,how = <span class="hljs-string">'any'</span>))<br><span class="hljs-comment">#axis=0丢掉行，axis=1丢掉列  #how='any'代表只要某一行（列）有NaN就删除该行(列) how='all'代表全是NaN才删除</span><br><br><span class="hljs-comment">#              A     B     C   D</span><br><span class="hljs-comment"># 2013-01-03   8   9.0  10.0  11</span><br><span class="hljs-comment"># 2013-01-04  12  13.0  14.0  15</span><br><span class="hljs-comment"># 2013-01-05  16  17.0  18.0  19</span><br><span class="hljs-comment"># 2013-01-06  20  21.0  22.0  23</span><br><br><br><span class="hljs-comment">#fill none value data 填入数据</span><br>print(df.fillna(value=<span class="hljs-number">123</span>))<br><span class="hljs-comment">#              A      B      C   D</span><br><span class="hljs-comment"># 2013-01-01   0  123.0    2.0   3</span><br><span class="hljs-comment"># 2013-01-02   4    5.0  123.0   7</span><br><span class="hljs-comment"># 2013-01-03   8    9.0   10.0  11</span><br><span class="hljs-comment"># 2013-01-04  12   13.0   14.0  15</span><br><span class="hljs-comment"># 2013-01-05  16   17.0   18.0  19</span><br><span class="hljs-comment"># 2013-01-06  20   21.0   22.0  23</span><br>print(df.isnull())<br><span class="hljs-comment">#                 A      B      C      D</span><br><span class="hljs-comment"># 2013-01-01  False   True  False  False</span><br><span class="hljs-comment"># 2013-01-02  False  False   True  False</span><br><span class="hljs-comment"># 2013-01-03  False  False  False  False</span><br><span class="hljs-comment"># 2013-01-04  False  False  False  False</span><br><span class="hljs-comment"># 2013-01-05  False  False  False  False</span><br><span class="hljs-comment"># 2013-01-06  False  False  False  False</span><br><br><span class="hljs-comment">#是否有数据丢失</span><br>print(np.any(df.isnull()==<span class="hljs-literal">True</span>))<br></code></pre></div></td></tr></table></figure><h2 id="Pandas导入导出数据"><a href="#Pandas导入导出数据" class="headerlink" title="Pandas导入导出数据"></a>Pandas导入导出数据</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#import numpy as np</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(<span class="hljs-string">'2.csv'</span>)<br>print(data)<br><br>data.to_pickle(<span class="hljs-string">'22.pickle'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="Pandas合并concat"><a href="#Pandas合并concat" class="headerlink" title="Pandas合并concat"></a>Pandas合并concat</h2><p><strong>.concat()合并</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>df1 = pd.DataFrame(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))*<span class="hljs-number">0</span>,columns=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>])<br>df2 = pd.DataFrame(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))*<span class="hljs-number">1</span>,columns=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>])<br>df3 = pd.DataFrame(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))*<span class="hljs-number">2</span>,columns=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>])<br>print(df1)<br>print(df2)<br>print(df3)<br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 1  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 2  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 1  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 2  2.0  2.0  2.0  2.0</span><br>res = pd.concat([df1, df2, df3],axis=<span class="hljs-number">0</span>) <span class="hljs-comment">#竖向合并</span><br>print(res)<br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 0  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 1  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 2  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 0  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 1  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 2  2.0  2.0  2.0  2.0</span><br><br>res2 = pd.concat([df1,df2,df3], axis=<span class="hljs-number">0</span>, ignore_index=<span class="hljs-literal">True</span>) <span class="hljs-comment">#合并后重新给纵坐标赋值</span><br>print(res2)<br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 3  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 4  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 5  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 6  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 7  2.0  2.0  2.0  2.0</span><br><span class="hljs-comment"># 8  2.0  2.0  2.0  2.0</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>df1 = pd.DataFrame(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))*<span class="hljs-number">0</span>,columns=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>],index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>df2 = pd.DataFrame(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))*<span class="hljs-number">1</span>,columns=[<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>],index=[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>print(df1)<br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 3  0.0  0.0  0.0  0.0</span><br>print(df2)<br><span class="hljs-comment">#      b    c    d    e</span><br><span class="hljs-comment"># 2  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 3  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 4  1.0  1.0  1.0  1.0</span><br>res = pd.concat([df1,df2])<br>print(res)<br><span class="hljs-comment">#      a    b    c    d    e</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0  NaN</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0  NaN</span><br><span class="hljs-comment"># 3  0.0  0.0  0.0  0.0  NaN</span><br><span class="hljs-comment"># 2  NaN  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 3  NaN  1.0  1.0  1.0  1.0</span><br><span class="hljs-comment"># 4  NaN  1.0  1.0  1.0  1.0</span><br><br>res = pd.concat([df1,df2],join=<span class="hljs-string">'inner'</span>,axis=<span class="hljs-number">0</span>) <span class="hljs-comment">#inner  合并共有的序列</span><br><span class="hljs-comment">#要是想处理序号就res = pd.concat([df1,df2],join='inner',ignore_index=true,axis=0)</span><br>print(res)<br><span class="hljs-comment">#      b    c    d</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0</span><br><span class="hljs-comment"># 3  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  1.0  1.0  1.0</span><br><span class="hljs-comment"># 3  1.0  1.0  1.0</span><br><span class="hljs-comment"># 4  1.0  1.0  1.0</span><br><br><br><span class="hljs-comment">#在表后添加一行</span><br>s1 = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],index=[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>])<br>t = df1.append(s1,ignore_index=<span class="hljs-literal">True</span>)<br>print(t)<br><span class="hljs-comment">#      a    b    c    d</span><br><span class="hljs-comment"># 0  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 1  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 2  0.0  0.0  0.0  0.0</span><br><span class="hljs-comment"># 3  1.0  2.0  3.0  4.0</span><br></code></pre></div></td></tr></table></figure><h2 id="Pandas合并merge"><a href="#Pandas合并merge" class="headerlink" title="Pandas合并merge"></a>Pandas合并merge</h2><p><strong>基于一个key合并</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>left = pd.DataFrame(&#123;<span class="hljs-string">'key'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>,<span class="hljs-string">'K3'</span>],<br>                       <span class="hljs-string">'A'</span>:[<span class="hljs-string">'A0'</span>,<span class="hljs-string">'A1'</span>,<span class="hljs-string">'A2'</span>,<span class="hljs-string">'A3'</span>],<br>                       <span class="hljs-string">'B'</span>:[<span class="hljs-string">'B0'</span>,<span class="hljs-string">'B1'</span>,<span class="hljs-string">'B2'</span>,<span class="hljs-string">'B3'</span>]&#125;)<br>right = pd.DataFrame(&#123;<span class="hljs-string">'key'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>,<span class="hljs-string">'K3'</span>],<br>                       <span class="hljs-string">'C'</span>:[<span class="hljs-string">'C0'</span>,<span class="hljs-string">'C1'</span>,<span class="hljs-string">'C2'</span>,<span class="hljs-string">'C3'</span>],<br>                       <span class="hljs-string">'D'</span>:[<span class="hljs-string">'D0'</span>,<span class="hljs-string">'D1'</span>,<span class="hljs-string">'D2'</span>,<span class="hljs-string">'D3'</span>]&#125;)<br>print(left)<br>print(right)<br><span class="hljs-comment">#   key   A   B</span><br><span class="hljs-comment"># 0  K0  A0  B0</span><br><span class="hljs-comment"># 1  K1  A1  B1</span><br><span class="hljs-comment"># 2  K2  A2  B2</span><br><span class="hljs-comment"># 3  K3  A3  B3</span><br><span class="hljs-comment">#   key   C   D</span><br><span class="hljs-comment"># 0  K0  C0  D0</span><br><span class="hljs-comment"># 1  K1  C1  D1</span><br><span class="hljs-comment"># 2  K2  C2  D2</span><br><span class="hljs-comment"># 3  K3  C3  D3</span><br><br>res = pd.merge(left,right,on=<span class="hljs-string">'key'</span>) <span class="hljs-comment">#基于key合并</span><br>print(res)<br><span class="hljs-comment">#   key   A   B   C   D</span><br><span class="hljs-comment"># 0  K0  A0  B0  C0  D0</span><br><span class="hljs-comment"># 1  K1  A1  B1  C1  D1</span><br><span class="hljs-comment"># 2  K2  A2  B2  C2  D2</span><br><span class="hljs-comment"># 3  K3  A3  B3  C3  D3</span><br></code></pre></div></td></tr></table></figure><p><strong>基于多个key合并</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>left = pd.DataFrame(&#123;<span class="hljs-string">'key1'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>],<br>                     <span class="hljs-string">'key2'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>],<br>                       <span class="hljs-string">'A'</span>:[<span class="hljs-string">'A0'</span>,<span class="hljs-string">'A1'</span>,<span class="hljs-string">'A2'</span>,<span class="hljs-string">'A3'</span>],<br>                       <span class="hljs-string">'B'</span>:[<span class="hljs-string">'B0'</span>,<span class="hljs-string">'B1'</span>,<span class="hljs-string">'B2'</span>,<span class="hljs-string">'B3'</span>]&#125;)<br>right = pd.DataFrame(&#123;<span class="hljs-string">'key1'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>],<br>                      <span class="hljs-string">'key2'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K0'</span>],<br>                       <span class="hljs-string">'C'</span>:[<span class="hljs-string">'C0'</span>,<span class="hljs-string">'C1'</span>,<span class="hljs-string">'C2'</span>,<span class="hljs-string">'C3'</span>],<br>                       <span class="hljs-string">'D'</span>:[<span class="hljs-string">'D0'</span>,<span class="hljs-string">'D1'</span>,<span class="hljs-string">'D2'</span>,<span class="hljs-string">'D3'</span>]&#125;)<br>print(left)<br>print(right)<br><span class="hljs-comment">#   key1 key2   A   B</span><br><span class="hljs-comment"># 0   K0   K0  A0  B0</span><br><span class="hljs-comment"># 1   K0   K1  A1  B1</span><br><span class="hljs-comment"># 2   K1   K0  A2  B2</span><br><span class="hljs-comment"># 3   K2   K1  A3  B3</span><br><span class="hljs-comment">#   key1 key2   C   D</span><br><span class="hljs-comment"># 0   K0   K0  C0  D0</span><br><span class="hljs-comment"># 1   K1   K0  C1  D1</span><br><span class="hljs-comment"># 2   K1   K0  C2  D2</span><br><span class="hljs-comment"># 3   K2   K0  C3  D3</span><br><br>res = pd.merge(left,right,on=[<span class="hljs-string">'key1'</span>,<span class="hljs-string">'key2'</span>])<br><span class="hljs-comment">#观察不能发现，只有两个key都满足相等时才会合并，且在一堆多的情况下会分别合并，我们默认这种合并为how='inner'</span><br>print(res)<br><span class="hljs-comment">#   key1 key2   A   B   C   D</span><br><span class="hljs-comment"># 0   K0   K0  A0  B0  C0  D0</span><br><span class="hljs-comment"># 1   K1   K0  A2  B2  C1  D1</span><br><span class="hljs-comment"># 2   K1   K0  A2  B2  C2  D2</span><br><br>res = pd.merge(left,right,on=[<span class="hljs-string">'key1'</span>,<span class="hljs-string">'key2'</span>],how=<span class="hljs-string">'outer'</span>)<br><span class="hljs-comment">#不管有没有都合并，空的地方填入NaN</span><br>print(res)<br><span class="hljs-comment">#   key1 key2    A    B    C    D</span><br><span class="hljs-comment"># 0   K0   K0   A0   B0   C0   D0</span><br><span class="hljs-comment"># 1   K0   K1   A1   B1  NaN  NaN</span><br><span class="hljs-comment"># 2   K1   K0   A2   B2   C1   D1</span><br><span class="hljs-comment"># 3   K1   K0   A2   B2   C2   D2</span><br><span class="hljs-comment"># 4   K2   K1   A3   B3  NaN  NaN</span><br><span class="hljs-comment"># 5   K2   K0  NaN  NaN   C3   D3</span><br><br>res = pd.merge(left,right,on=[<span class="hljs-string">'key1'</span>,<span class="hljs-string">'key2'</span>],how=<span class="hljs-string">'right'</span>)<br><span class="hljs-comment">#基于某个DataFrame进行合并，另一个有对应的key相等就合并，没有就赋值NaN</span><br>print(res)<br><span class="hljs-comment">#   key1 key2    A    B   C   D</span><br><span class="hljs-comment"># 0   K0   K0   A0   B0  C0  D0</span><br><span class="hljs-comment"># 1   K1   K0   A2   B2  C1  D1</span><br><span class="hljs-comment"># 2   K1   K0   A2   B2  C2  D2</span><br><span class="hljs-comment"># 3   K2   K0  NaN  NaN  C3  D3</span><br><br>res = pd.merge(left,right,on=[<span class="hljs-string">'key1'</span>,<span class="hljs-string">'key2'</span>],how=<span class="hljs-string">'right'</span>,indicator=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#indicator=True 显示合并方式</span><br>print(res)<br><span class="hljs-comment">#   key1 key2    A    B   C   D      _merge</span><br><span class="hljs-comment"># 0   K0   K0   A0   B0  C0  D0        both</span><br><span class="hljs-comment"># 1   K1   K0   A2   B2  C1  D1        both</span><br><span class="hljs-comment"># 2   K1   K0   A2   B2  C2  D2        both</span><br><span class="hljs-comment"># 3   K2   K0  NaN  NaN  C3  D3  right_only</span><br></code></pre></div></td></tr></table></figure><p><strong>下面是按照index来合并</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>left = pd.DataFrame(&#123;<span class="hljs-string">'A'</span>:[<span class="hljs-string">'A0'</span>,<span class="hljs-string">'A1'</span>,<span class="hljs-string">'A2'</span>,<span class="hljs-string">'A3'</span>],<br>                     <span class="hljs-string">'B'</span>:[<span class="hljs-string">'B0'</span>,<span class="hljs-string">'B1'</span>,<span class="hljs-string">'B2'</span>,<span class="hljs-string">'B3'</span>]&#125;,<br>                      index=[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>,<span class="hljs-string">'K3'</span>])<br>right = pd.DataFrame(&#123;<span class="hljs-string">'C'</span>:[<span class="hljs-string">'C0'</span>,<span class="hljs-string">'C1'</span>,<span class="hljs-string">'C2'</span>,<span class="hljs-string">'C3'</span>],<br>                     <span class="hljs-string">'D'</span>:[<span class="hljs-string">'D0'</span>,<span class="hljs-string">'D1'</span>,<span class="hljs-string">'D2'</span>,<span class="hljs-string">'D3'</span>]&#125;,<br>                      index=[<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>,<span class="hljs-string">'K3'</span>,<span class="hljs-string">'K4'</span>])<br>print(left)<br>print(right)<br><span class="hljs-comment">#      A   B</span><br><span class="hljs-comment"># K0  A0  B0</span><br><span class="hljs-comment"># K1  A1  B1</span><br><span class="hljs-comment"># K2  A2  B2</span><br><span class="hljs-comment"># K3  A3  B3</span><br><span class="hljs-comment">#      C   D</span><br><span class="hljs-comment"># K1  C0  D0</span><br><span class="hljs-comment"># K2  C1  D1</span><br><span class="hljs-comment"># K3  C2  D2</span><br><span class="hljs-comment"># K4  C3  D3</span><br>print(pd.merge(left,right,left_index=<span class="hljs-literal">True</span>,right_index=<span class="hljs-literal">True</span>,how=<span class="hljs-string">'outer'</span>))<br><span class="hljs-comment">#按照index来合并</span><br><span class="hljs-comment">#       A    B    C    D</span><br><span class="hljs-comment"># K0   A0   B0  NaN  NaN</span><br><span class="hljs-comment"># K1   A1   B1   C0   D0</span><br><span class="hljs-comment"># K2   A2   B2   C1   D1</span><br><span class="hljs-comment"># K3   A3   B3   C2   D2</span><br><span class="hljs-comment"># K4  NaN  NaN   C3   D3</span><br></code></pre></div></td></tr></table></figure><p><strong>suffixes参数的作用</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>boy = pd.DataFrame(&#123;<span class="hljs-string">'k'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>],<br>                    <span class="hljs-string">'age'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;)<br>girl = pd.DataFrame(&#123;<span class="hljs-string">'k'</span>:[<span class="hljs-string">'K0'</span>,<span class="hljs-string">'K1'</span>,<span class="hljs-string">'K2'</span>],<br>                    <span class="hljs-string">'age'</span>:[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;)<br><br>print(boy)<br>print(girl)<br><span class="hljs-comment">#     k  age</span><br><span class="hljs-comment"># 0  K0    1</span><br><span class="hljs-comment"># 1  K1    2</span><br><span class="hljs-comment"># 2  K2    3</span><br><span class="hljs-comment">#     k  age</span><br><span class="hljs-comment"># 0  K0    4</span><br><span class="hljs-comment"># 1  K1    5</span><br><span class="hljs-comment"># 2  K2    6</span><br>res = pd.merge(boy,girl,on=<span class="hljs-string">'k'</span>,suffixes=[<span class="hljs-string">'_boy'</span>,<span class="hljs-string">'_girl'</span>],how=<span class="hljs-string">'inner'</span>)<br>print(res)<br><span class="hljs-comment">#     k  age_boy  age_girl</span><br><span class="hljs-comment"># 0  K0        1         4</span><br><span class="hljs-comment"># 1  K1        2         5</span><br><span class="hljs-comment"># 2  K2        3         6</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python-基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Hands-On-Machine-Learning》PART I</title>
    <link href="/2020/02/28/Hands-On-Machine-Learning-PART-I/"/>
    <url>/2020/02/28/Hands-On-Machine-Learning-PART-I/</url>
    
    <content type="html"><![CDATA[<h1 id="PART-1：The-Fundamentals-of-Machine-Learning"><a href="#PART-1：The-Fundamentals-of-Machine-Learning" class="headerlink" title="PART 1：The Fundamentals of Machine Learning"></a>PART 1：The Fundamentals of Machine Learning</h1><h2 id="CHAPTER-1-：The-Machine-Learning-Landscape-（机器学习领域）"><a href="#CHAPTER-1-：The-Machine-Learning-Landscape-（机器学习领域）" class="headerlink" title="CHAPTER 1 ：The Machine Learning Landscape （机器学习领域）"></a>CHAPTER 1 ：The Machine Learning Landscape （机器学习领域）</h2><h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a><strong>什么是机器学习？</strong></h3><p>例如，垃圾邮件过滤器是一个机器学习过程，可以学习标记垃圾邮件。系统用于学习的示例称为<strong>训练集</strong>。每个训练示例称为一个<strong>训练样本</strong>。在这种情况下，任务T是为新邮件标记垃圾邮件，E是训练数据，定义性能度量为P（比如p可以为是否正确区分出垃圾邮件），这种特殊的性能度量称为<strong>准确性</strong>，通常用于分类任务。</p><h3 id="为什么要使用机器学习？"><a href="#为什么要使用机器学习？" class="headerlink" title="为什么要使用机器学习？"></a><strong>为什么要使用机器学习？</strong></h3><p>从上面的例子接着来看：</p><p>1.首先你要关注的是典型的垃圾邮件长什么样，比如会有免费，信用卡等字眼</p><p>2.您可以为您注意到的每个部分编写一个检测算法，如果检测到许多这样的部分，程序将把电子邮件标记为垃圾邮件。</p><p>3.测试程序，并重复步骤1和步骤2，直到足够好为止。</p><p>这是一种传统解决方法，如下图</p><p><img src="https://s2.ax1x.com/2020/02/27/3w59SA.png" srcset="/img/loading.gif" alt="3w59SA.png"></p><p>这样循环下来，你的程序很可能会变成一长串复杂的规则，也就是说它很难维护。</p><p>相比之下，一个基于机器学习技术的垃圾邮件过滤器通过检测垃圾邮件示例中与非垃圾邮件示例相比单词的异常频率模式，自动学习哪些单词和短语是垃圾邮件的标志</p><p>程序要短得多，易于维护，而且很可能更准确。如下图：</p><p><img src="https://s2.ax1x.com/2020/02/27/3w5iOP.png" srcset="/img/loading.gif" alt="3w5iOP.png"></p><p>更深一步来看，如果垃圾邮件的发送者发现他们的“4U”被屏蔽了，那么他们很有可能再次使用‘“FOR U”来代替。然而一个基于机器学习的垃圾邮件过滤器会自动识别用户标记的垃圾邮件中出现的异常频繁的“For U”，它会在没有用户干预的情况下标记它们。下图是一个<strong>自动适应</strong>的例子：</p><p><img src="https://s2.ax1x.com/2020/02/27/3wLhoq.png" srcset="/img/loading.gif" alt="3wLhoq.png"></p><p>机器学习的另一个亮眼的表现是解决传统方法难以解决的问题，或者没有已知的算法。例如，考虑语音识别:假设你想从简单的开始，然后编写一个能够分辨“一”和“二”的程序。你可能会注意到，“two”这个词是以一个高音调的声音(“T”)开头的，所以你可以硬编码一个算法来测量高音调的声音强度，并用它来区分1和2。很明显，这种方法不能扩展到成千上万不同的人说的成千上万个单词。</p><p>机器学习可以帮助人类学习，可以检查ML算法，看看它们学到了什么，就像垃圾邮件过滤器对足够多的垃圾邮件进行了训练，就可以很容易地检查出它认为是垃圾邮件最佳预测器的单词列表和单词组合。有时，这将揭示意想不到的关系或新趋势，从而导致更好地理解问题。</p><p>应用ML技术挖掘大量数据可以帮助发现没有立即显现的模式，这叫做<strong>数据挖掘</strong>。</p><p><img src="https://s2.ax1x.com/2020/02/27/30i5kD.png" srcset="/img/loading.gif" alt="30i5kD.png"></p><p>总结机器学习的好处是:<br>•现有解决方案需要大量手工调整或大量规则列表的问题:一个机器学习算法通常可以简化代码并更好的执行。</p><p>•使用传统方法根本没有好的解决方案的复杂问题:最好的机器学习技术可以找到解决方案。 </p><p>•环境波动:机器学习系统可以适应新数据。</p><p>•获得关于复杂问题和大量数据的见解。</p><h3 id="机器学习系统的类型"><a href="#机器学习系统的类型" class="headerlink" title="机器学习系统的类型"></a><strong>机器学习系统的类型</strong></h3><p>•是否在人力监督下训练(监督、非监督、半监督和强化学习)</p><p>•是否可以随时学习(在线学习与批量学习)</p><p>•工作方式是简单地将新数据点与已知数据点进行比较，还是检测训练数据中的模式并建立预测模型(基于实例与基于模型的学习)</p><p>这些标准并不互斥;你可以任意组合它们。例如，一个最先进的垃圾邮件过滤器可能使用深度神经网络从垃圾邮件和非垃圾邮件种学习，使得它成为一个<strong>在线的、基于模型的、有监督的学习系统</strong>。</p><h4 id="监督学习和非监督学习（Supervised-Unsupervised-Learning）"><a href="#监督学习和非监督学习（Supervised-Unsupervised-Learning）" class="headerlink" title="监督学习和非监督学习（Supervised/Unsupervised Learning）"></a><strong>监督学习和非监督学习（Supervised/Unsupervised Learning）</strong></h4><p>机器学习系统可以根据它们在训练中得到的监督的数量和类型来分类。有四大类:监督学习、非监督学习、半监督学习和强化学习。</p><p><strong>监督学习(supervised learning)：</strong></p><p>在监督学习中，您提供给算法的训练数据包括所需的答案，称为标记(label)。</p><p> <strong>注：监督学习的input是{data,label}，无监督学习的input是{data}，feature是从data中归纳出来的低维度的表征信息不是直接给你的，是你的算法自己探索的</strong></p><p>例如下图是一个用来训练监督学习的label数据集。</p><p><img src="https://s2.ax1x.com/2020/02/27/30KAxO.png" srcset="/img/loading.gif" alt="30KAxO.png"></p><p><strong>典型的监督学习任务是分类</strong>。垃圾邮件过滤器就是一个很好的例子:它使用许多示例邮件及其类(垃圾邮件或普通邮件)进行训练，并且必须学习如何对新邮件进行分类。</p><p><strong>另一个典型的任务是预测一个目标数值</strong>，例如汽车的价格，给定一组称为预测器的特性(里程、年龄、品牌等)。</p><p>这类任务称为<strong>回归</strong>。要训练系统，你需要给它很多汽车的例子，包括它们的预测器和标签(例如他们的价格)。</p><p>下图为回归：</p><p><img src="https://s2.ax1x.com/2020/02/27/30Mw0H.png" srcset="/img/loading.gif" alt="30Mw0H.png"></p><p>注意，一些回归算法也可以用于分类，反之亦然。例如，逻辑回归通常用于分类，因为它可以输出与属于给定类的概率相对应的值，例如：百分之二十的概率为垃圾邮件</p><p>以下是一些最重要的监督学习算法：</p><p>•K -近邻算法  k-Nearest Neighbors </p><p>•线性回归   Linear Regression </p><p>•逻辑回归  Logistic Regression </p><p>•支持向量机(SVMs)  Support Vector Machines (SVMs) </p><p>•决策树和随机森林   Decision Trees and Random Forests </p><p>•神经网络  Neural networks </p><p><strong>非监督学习 （Unsupervised learning）</strong>：</p><p>在无监督学习中，训练数据是没有标记的。</p><p>下面是一些最重要的无监督学习算法：</p><p>• 聚类分析</p><p>​       ——k均值聚类算法  k-Means</p><p>​       ——层次聚类分析(HCA)   Hierarchical Cluster Analysis </p><p>​       ——期望最大化   Expectation Maximization </p><p>• 可视化和降维</p><p> ——主成分分析(PCA)     Principal Component Analysis (PCA) </p><p> —— 核主成分分析        Kernel PCA </p><p> ——局部线性嵌入(LLE)   Locally-Linear Embedding (LLE) </p><p> —— t分布随机近邻嵌入(t-SNE)   t-distributed Stochastic Neighbor Embedding (t-SNE) </p><p>• 关联规则学习</p><p> —— 关联分析算法  Apriori </p><p> —— eclat算法        Eclat </p><p>聚类算法：</p><p>例如，假设您有关于博客访问者的大量数据。您可能想要运行一个聚类算法来尝试检测相似访问者的组。在任何情况下，你都不能告诉算法一个访问者属于哪个组:它在<strong>没有你的帮助下</strong>找到这些连接。例如，它可能会注意到40%的访问者是喜欢漫画书的男性，他们通常在晚上阅读你的博客<br>20%是年轻的科幻爱好者，他们会在周末去看科幻电影，等等。如果使用<strong>层次聚类算法</strong>，也可以将每个组细分为更小的组。</p><p>下图是一个聚类算法：</p><p><img src="https://s2.ax1x.com/2020/02/27/303LGR.png" srcset="/img/loading.gif" alt="303LGR.png"></p><p>拓展一下不难发现，当坐标的位维数增加，也就是feature增加，此时聚类算法根据不同的feature特征进行详细的分类。</p><p>可视化算法:</p><p>可视化算法也是无监督学习算法的好例子:你给它们输入大量复杂的、未标记（无监督学习中的数据是未标记的，这个是指label未标记，但是feature是包含的）的数据，它们输出2D或3D的数据表示，这些数据很容易绘制:</p><p>下图是一个利用 <strong>t分布随机近邻嵌入(t-SNE)</strong> 进行语义聚类</p><p><img src="https://s2.ax1x.com/2020/02/27/30YneK.png" srcset="/img/loading.gif" alt="30YneK.png"></p><p>注意上图中 <strong>动物是如何与车辆很好地分离，马是如何接近鹿而远离鸟</strong>，等等。</p><p><strong>降维</strong>其目标是在不丢失太多信息的情况下<strong>简化数据（dimensionality reduction, ）</strong>。一种方法是<strong>将几个相关的特性合并成一个</strong>。例如，一辆汽车的行驶里程可能与它的使用年限密切相关，因此降维算法会将它们合并成一个特征，以反映汽车的磨损情况。这叫做<strong>特征提取</strong>。</p><p>另一个重要的非监督任务是<strong>异常检测（anomaly detection ）</strong>——例如，检测不寻常的信用卡交易以防止欺诈，捕捉制造缺陷，或在将数据集中的异常值提供给另一个学习算法之前自动删除异常值。系统使用普通实例进行训练，当它看到一个新实例时，它可以判断它看起来是否像一个普通实例或者是否是一个异常的实例，如下图：</p><p><img src="https://s2.ax1x.com/2020/02/27/30Nfz9.png" srcset="/img/loading.gif" alt="30Nfz9.png"></p><p>最后，另一个常见的非监督任务是<strong>关联规则学习（association rule learning ）</strong>，其目标是挖掘大量数据并发现属性之间有趣的关系。例如，假设你拥有一家超市。在你的销售记录上运行一个关联规则，可能会发现购买烧烤酱和薯片的人也倾向于购买牛排。因此，您可能希望将这些项放在彼此靠近的位置。</p><p><strong>半监督学习（Semisupervised learning）</strong>：</p><p>一些算法<strong>可以处理部分标记的训练数据</strong>，<strong>通常是大量的未标记数据和少量标记数据</strong>。这被称为半监督学习</p><p>一些照片托管服务，比如谷歌Photos，就是很好的例子。一旦你将所有的家庭照片上传至该服务，它会自动识别出同一个人A出现在照片1、5和11中，而另一个人B出现在照片2、5和7中。我们可以这样理解：我们给照片a标注为妈妈，这显然是一个监督学习，在接下来大量无标记的照片加入后，通过非监督学习中的聚类分析将照片中的妈妈都标记出来，如下图就是一个半监督学习的例子。</p><p><img src="https://s2.ax1x.com/2020/02/27/30as4U.png" srcset="/img/loading.gif" alt="30as4U.png"></p><p><strong>强化学习（Reinforcement Learning ）</strong>：</p><p>强化学习是一个非常不同的概念。该学习系统在此上下文中称为代理，它可以观察环境、选择和执行操作，并获得回报(或负回报形式的惩罚，如图下所示)。然后，它必须自己学习什么是最好的策略，称为策略，以获得最大的回报。策略定义了在给定的情况下，代理应该选择什么操作。</p><p><img src="https://s2.ax1x.com/2020/02/27/30wkWD.png" srcset="/img/loading.gif" alt="30wkWD.png"></p><h4 id="批量和在线学习（Batch-and-Online-Learning-）："><a href="#批量和在线学习（Batch-and-Online-Learning-）：" class="headerlink" title="批量和在线学习（Batch and Online Learning ）："></a><strong>批量和在线学习（Batch and Online Learning ）：</strong></h4><p>用于对机器学习系统进行分类的另一个标准是，系统是否能够从输入的数据流逐渐地学习。</p><p><strong>批量学习（Batch learning ）：</strong></p><p>在批量学习中，系统<strong>不能渐进地学习</strong>:它必须使用所有可用的数据进行训练。这通常会花费大量的时间和计算资源，所以通常是<strong>离线完成</strong>的。首先对系统进行培训，然后将其投入生产并在不学习的情况下运行;它只是应用它所学到的东西。这叫做<strong>离线学习（offline learning ）</strong></p><p>如果希望批处理学习系统了解新数据(例如一种新类型的垃圾邮件)，则需要从头开始在整个数据集上培训系统的新版本(不仅是新的数据，还有旧的数据)，然后停止旧的系统，用新的系统替换它。</p><p>这个解决方案很简单，而且通常工作得很好，但是使用完整的数据集进行培训可能会花费很多小时，所以您通常只需要每24小时甚至每周培训一个新系统。如果你的系统需要适应快速变化的数据(例如预估值股票价格)，那么你需要一个更有反应性的解决方案。同时<strong>面对大数据量的任务我们几乎不会使用批量学习</strong>。</p><p><strong>在线学习（Online learning ）：</strong></p><p>在在线学习中，您可以通过顺序地向系统提供数据实例来增量地培训系统，这些数据实例可以是单个的，也可以是小批量的。每个学习步骤都是快速和低代价的，因此系统可以在新数据到达时动态地学习，这是一个例子：</p><p><img src="https://s2.ax1x.com/2020/02/28/30TMKs.png" srcset="/img/loading.gif" alt="30TMKs.png"></p><p>在线学习可以用无法装进主存的巨大数据集来训练系统（称为<strong>核外学习out-of-core learning</strong> ），该算法加载部分数据，在该数据上运行一步训练，然后重复该过程，直到它在所有数据上运行，如下图就是这样一个例子：</p><p><img src="https://s2.ax1x.com/2020/02/28/30TxZq.png" srcset="/img/loading.gif" alt="30TxZq.png"></p><p>在线学习系统的一个重要参数是它们应该以多快的速度适应不断变化的数据:这称为<strong>学习率（learning rate） </strong>。</p><p>如果您设置了一个<strong>高的学习率</strong>，那么您的系统将<strong>很快适应新的数据</strong>，但是它也会<strong>很快忘记旧的数据</strong>(您不希望垃圾邮件过滤器只标记它显示的最新类型的垃圾邮件)。</p><p>相反，如果你设定一个<strong>较低的学习率</strong>，系统<strong>会有更多的惯性</strong>;也就是说，它将<strong>学习得更慢</strong>，但它也将<strong>对新数据中的噪声或非代表性数据点的序列不那么敏感</strong>。</p><p>在线学习面临的一大挑战是，<strong>如果向系统输入错误的数据，系统的性能将逐渐下降</strong>。例如，错误的数据可能来自于机器人传感器的故障。了减少这种风险，您需要密切监视您的系统，并在检测到性能下降时立即关闭学习(并可能恢复到以前的工作状态)。您可能还希望监视输入数据并对异常数据做出反应(例如，使用异常检测算法)。</p><h4 id="基于实例和基于模型的学习（Instance-Based-Versus-Model-Based-Learning-）："><a href="#基于实例和基于模型的学习（Instance-Based-Versus-Model-Based-Learning-）：" class="headerlink" title="基于实例和基于模型的学习（Instance-Based Versus Model-Based Learning ）："></a><strong>基于实例和基于模型的学习（Instance-Based Versus Model-Based Learning ）：</strong></h4><p>另一种对机器学习系统进行分类的方法是看它们如何<strong>泛化（generalize）</strong>。<br>大多数机器学习任务都是关于预测的。这意味着，给定大量的训练示例，系统需要能够将其推广到以前从未见过的示例。对培训数据进行训练有良好的效果是很好，但还不够;真正的目标是在新实例上表现良好。</p><p>泛化主要有两种主要方法:<strong>基于实例的学习</strong>和<strong>基于模型的学习</strong></p><p><strong>基于实例的学习（Instance-based learning ）</strong>：</p><p>除了标记与已知的垃圾邮件相同的电子邮件外，您的垃圾邮件过滤器还可以标记与已知的垃圾邮件非常相似的电子邮件。这需要衡量两封电子邮件之间的相似性。一个(非常基本的)度量两封邮件之间的相似度的方法是计算它们共有的字数。如果一封已知的垃圾邮件中有很多单词，系统会将其标记为垃圾邮件。</p><p>这称为基于实例的学习:<strong>系统记住示例，然后使用相似度度量将其推广到新的案例</strong></p><p><img src="https://s2.ax1x.com/2020/02/28/30HB4K.png" srcset="/img/loading.gif" alt="30HB4K.png"></p><p><strong>基于模型的学习( Model-based learning ）</strong>：</p><p>从一组例子中归纳出另一种方法是建立这些例子的模型，然后使用该模型进行预测。这叫做基于模型的学习</p><p><img src="https://s2.ax1x.com/2020/02/28/30qqkq.png" srcset="/img/loading.gif" alt="30qqkq.png"></p><p>例如，假设你想知道钱是否能让人快乐，那么你可以下载经合组织网站上的美好生活指数数据，以及国际货币基金组织网站上的人均GDP统计数据。然后你加入表格，并根据人均GDP排序。</p><p><img src="https://s2.ax1x.com/2020/02/28/30LZcD.png" srcset="/img/loading.gif" alt="30LZcD.png"></p><p><img src="https://s2.ax1x.com/2020/02/28/30LuBd.png" srcset="/img/loading.gif" alt="30LuBd.png"></p><p>这里似乎确实有一种趋势! 虽然数据是有噪声的(即(部分是随机的)，看起来生活满意度或多或少随着国家人均GDP的增长呈线性增长。所以你决定将生活满意度建模为人均GDP的线性函数。这一步被称为模型选择:你选择了一个只有一个属性的线性的生活满意度模型（人均GDP）</p><p>$life_satisfaction=θ_0 +θ_1× GDP_per_capita $</p><p>这个模型有两个模型参数,$θ_0,θ_1$通过调整这些参数,可以使你的模型代表任何线性函数,如图。</p><p><img src="https://s2.ax1x.com/2020/02/28/30Lo8K.png" srcset="/img/loading.gif" alt="30Lo8K.png"></p><p>您可以定义一个效用函数(或适应度函数)来度量模型的好坏，也可以定义一个成本函数来度量模型的好坏。</p><p>对于线性回归问题，人们通常使用一个成本函数来度量线性模型的预测与训练示例之间的距离;目标是最小化这个距离。</p><p>线性回归算法的用武之地:你给它输入你的训练样本，它就会找到使线性模型最适合你的数据的参数。</p><p><img src="https://s2.ax1x.com/2020/02/28/30XPW6.png" srcset="/img/loading.gif" alt="30XPW6.png"></p><p>可视化创建散点图，然后训练一个线性模型并进行预测：</p><p><strong>Training and running a linear model using Scikit-Learn</strong> </p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-comment"># Load the data</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prepare_country_stats</span><span class="hljs-params">(oecd_bli, gdp_per_capita)</span>:</span><br>    oecd_bli = oecd_bli[oecd_bli[<span class="hljs-string">"INEQUALITY"</span>]==<span class="hljs-string">"TOT"</span>]<br>    oecd_bli = oecd_bli.pivot(index=<span class="hljs-string">"Country"</span>, columns=<span class="hljs-string">"Indicator"</span>, values=<span class="hljs-string">"Value"</span>)<br>    gdp_per_capita.rename(columns=&#123;<span class="hljs-string">"2015"</span>: <span class="hljs-string">"GDP per capita"</span>&#125;, inplace=<span class="hljs-literal">True</span>)<br>    gdp_per_capita.set_index(<span class="hljs-string">"Country"</span>, inplace=<span class="hljs-literal">True</span>)<br>    full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita,<br>                                  left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>)<br>    full_country_stats.sort_values(by=<span class="hljs-string">"GDP per capita"</span>, inplace=<span class="hljs-literal">True</span>)<br>    remove_indices = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>]<br>    keep_indices = list(set(range(<span class="hljs-number">36</span>)) - set(remove_indices))<br>    <span class="hljs-keyword">return</span> full_country_stats[[<span class="hljs-string">"GDP per capita"</span>, <span class="hljs-string">'Life satisfaction'</span>]].iloc[keep_indices]<br><br>oecd_bli = pd.read_csv(<span class="hljs-string">"oecd_bli_2015.csv"</span>, thousands=<span class="hljs-string">','</span>)<br>gdp_per_capita = pd.read_csv(<span class="hljs-string">"gdp_per_capita.csv"</span>,thousands=<span class="hljs-string">','</span>,delimiter=<span class="hljs-string">'\t'</span>,<br>encoding=<span class="hljs-string">'latin1'</span>, na_values=<span class="hljs-string">"n/a"</span>)<br><span class="hljs-comment"># Prepare the data</span><br>country_stats = prepare_country_stats(oecd_bli, gdp_per_capita)<br>X = np.c_[country_stats[<span class="hljs-string">"GDP per capita"</span>]]<br>y = np.c_[country_stats[<span class="hljs-string">"Life satisfaction"</span>]]<br><span class="hljs-comment"># Visualize the data</span><br>country_stats.plot(kind=<span class="hljs-string">'scatter'</span>, x=<span class="hljs-string">"GDP per capita"</span>, y=<span class="hljs-string">'Life satisfaction'</span>)<br>plt.show()<br><span class="hljs-comment"># Select a linear model</span><br>lin_reg_model = LinearRegression()<br><span class="hljs-comment"># Train the model</span><br>lin_reg_model.fit(X, y)<br><span class="hljs-comment"># Make a prediction for Cyprus</span><br>X_new = [[<span class="hljs-number">22587</span>]] <span class="hljs-comment"># Cyprus' GDP per capita</span><br>print(lin_reg_model.predict(X_new)) <span class="hljs-comment"># outputs [[ 5.96242338]]</span><br></code></pre></div></td></tr></table></figure><h3 id="机器学习的主要挑战（-Main-Challenges-Of-Machine-Learning）"><a href="#机器学习的主要挑战（-Main-Challenges-Of-Machine-Learning）" class="headerlink" title="机器学习的主要挑战（ Main Challenges Of Machine Learning）"></a>机器学习的主要挑战（ Main Challenges Of Machine Learning）</h3><p>简而言之，由于您的主要任务是选择一种学习算法并对其进行数据训练，因此可能出错的两件事是“坏算法”和“坏数据”。让我们从坏数据的例子开始。</p><h4 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h4><p><strong>培训数据数量不足（Insufficient Quantity of Training Data ）</strong></p><p>机器学习还没有完全实现;大多数机器学习算法需要大量的数据才能正常工作。即使是非常简单的问题，你通常也需要成千上万的例子。</p><p>在2001年发表的一篇著名论文中，微软研究员Michele Banko和Eric Brill  指出，包括相当简单的机器学习算法在内的各种不同的机器学习算法，一旦获得了足够的数据，在解决自然语言消除歧义的复杂问题上，其表现几乎是一样的好，如图：</p><p><img src="https://s2.ax1x.com/2020/03/06/3Lfl26.png" srcset="/img/loading.gif" alt="3Lfl26.png"></p><p>这无疑体现了数据相对于算法的重要性。</p><p><strong>非代表性的训练数据（Nonrepresentative Training Data ）</strong></p><p>为了更好地泛化，重要的是您的训练数据要能够代表您想泛化到的新案例。无论您使用基于实例的学习还是基于模型的学习，这都是正确的。</p><p>例如，我们之前用于训练线性模型的国家集并不完全具有代表性;有几个国家失踪了。</p><p><img src="https://s2.ax1x.com/2020/03/06/3LhkFA.png" srcset="/img/loading.gif" alt="3LhkFA.png"></p><p>如果你用这些数据训练一个线性模型，你会发现  ：而旧的模型用虚线表示。正如您所看到的，添加几个缺失的国家不仅会显著地改变模型，而且还清楚地表明，这样一个简单的线性模型可能永远不会很好地工作。非常富裕的国家似乎并不比中等富裕的国家更幸福(事实上，他们似乎更不幸福)，相反，一些贫穷的国家似乎比许多富裕的国家更幸福。</p><p>通过使用非代表性的训练集，我们训练了一个不太可能做出准确预测的模型，特别是对于非常贫穷和非常富裕的国家。<br>使用一个能代表你想要了解的案例的培训集是至关重要的。这通常比听起来要困难:如果样本太小，就会产生采样噪声(即噪声)。但是，如果抽样方法有缺陷，即使是非常大的样本也可能不具有代表性。这叫做<strong>抽样偏差（sampling bias ）</strong>。</p><p><strong>低质量数据（Poor-Quality Data ）</strong></p><p>显然，如果您的训练数据充满了错误、异常值和噪声(例如，由于质量度量不佳)，那么系统将更难检测底层模式，因此您的系统不太可能表现良好。</p><p><strong>无关的特性（Irrelevant Features）</strong></p><p>机器学习项目成功的一个关键部分是提供一组良好的feature来进行训练，这叫做<strong>特征工程（feature engineering ）</strong>：</p><p>•特性选择:在现有特性中选择最有用的特性进行培训。</p><p>•特征提取:结合现有的特征，生成更有用的特征(正如我们前面看到的，降维算法可以提供帮助)。</p><p>•通过收集新数据来创建新功能</p><h4 id="算法层面"><a href="#算法层面" class="headerlink" title="算法层面"></a>算法层面</h4><p><strong>数据过拟合（overfitting the training data）</strong></p><p>假设你在国外旅游，出租车司机把你敲诈了一顿。你可能会说那个国家所有的出租车司机都是小偷。过度概括是我们人类经常做的事情，不幸的是，如果我们不小心，机器也会落入同样的陷阱。</p><p>在机器学习中，这被称为过度拟合:它意味着模型在训练数据上表现良好，但不能很好地泛化。</p><p>比如预测GDP与幸福指数关系，拟合出了一个十分符合数据集的函数，但是很明显这是十分不可信的。</p><p><img src="https://s2.ax1x.com/2020/03/06/3L7t61.png" srcset="/img/loading.gif" alt="3L7t61.png"></p><p>当模型相对于训练数据的数量和噪声过于复杂时，就会发生过拟合。可能的解决办法是:<br>•通过选择参数较少的模型来简化模型(例如，一个线性模型而不是一个高次多项式模型)，通过减少训练数据中的属性数量或对模型进行约束</p><p>•收集更多的培训数据</p><p>•减少训练数据中的噪音(例如，修复数据错误并删除异常值)</p><p>为了<strong>简化模型并降低过度拟合的风险</strong>而对模型进行约束称为<strong>正则化（regularization）</strong>。比如线性模型我们定义了两个参数$θ _0$和$θ _1$，所以这就给了算法两个维度的方向来训练，如果我们规定$\theta_0=0$，这样就只剩下了一个维度，也就是说直线只能进行上下移动，那么训练出的是一个均值的模型。如果我们允许算法修改$θ _1$，但我们迫使它让它很小,那么学习算法将有效地在一到两个维度之间。它将产生一个比有两个自由度时更简单的模型，但比只有一个自由度时更复杂。我们希望在<strong>完美地拟合数据</strong>和<strong>保持模型足够简单</strong>以确保它能够很好地泛化之间<strong>找到适当的平衡</strong>。</p><p><img src="https://s2.ax1x.com/2020/03/06/3LjWxe.png" srcset="/img/loading.gif" alt="3LjWxe.png"></p><p>学习过程中需要应用的正则化的数量可以由一个超参数控制。<strong>超参数</strong>是机器学习算法的参数(不是模型的参数)。因此，它不受学习算法本身的影响;它必须在训练前设置，并在训练中保持不变。如果你将正则化超参数设置为一个非常大的值，你会得到一个几乎平坦的模型(斜率接近于零);学习算法几乎肯定不会对训练数据进行过度拟合，但找到一个好的解决方案的可能性较小。<strong>调优超参数</strong>是构建机器学习系统的一个重要部分。</p><h3 id="测试与验证（Testing-and-Validating）"><a href="#测试与验证（Testing-and-Validating）" class="headerlink" title="测试与验证（Testing and Validating）"></a>测试与验证（Testing and Validating）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Notebook</title>
    <link href="/2020/02/22/Python-Notebook/"/>
    <url>/2020/02/22/Python-Notebook/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Notebook"><a href="#Python-Notebook" class="headerlink" title="Python Notebook"></a>Python Notebook</h1><h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">print(<span class="hljs-number">1</span>)<br>print(<span class="hljs-string">"we're the best"</span>)<br>print(<span class="hljs-string">'we are the best'</span>)<br>print(<span class="hljs-string">'we\'re the best'</span>) <br><br>print(<span class="hljs-string">"apple"</span>+<span class="hljs-string">"car"</span>)<br>print(<span class="hljs-string">'apple'</span>+<span class="hljs-string">'tree'</span>)<br><br>print(<span class="hljs-string">'apple'</span>+<span class="hljs-string">'4'</span>)<br>print(<span class="hljs-string">'apple'</span>+str(<span class="hljs-number">4</span>))<br><br>print(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">"1+2"</span>)<br>print(int(<span class="hljs-string">'1'</span>)+<span class="hljs-number">2</span>)<br>print(float(<span class="hljs-number">1.2</span>)+<span class="hljs-number">2</span>) <span class="hljs-comment">#   '1.2'不可以转int</span><br></code></pre></div></td></tr></table></figure><h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">print(<span class="hljs-number">1</span>+<span class="hljs-number">1</span>)<br>print(<span class="hljs-number">1</span><span class="hljs-number">-1</span>)<br>print(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)<br>print(<span class="hljs-number">2</span>^<span class="hljs-number">1</span>)  <span class="hljs-comment">#  异或xor</span><br>print(<span class="hljs-number">2</span>**<span class="hljs-number">3</span>) <span class="hljs-comment">#  高次幂</span><br>print(<span class="hljs-number">8</span>%<span class="hljs-number">3</span>)  <span class="hljs-comment">#  mod</span><br>print(<span class="hljs-number">8</span>//<span class="hljs-number">3</span>) <span class="hljs-comment">#  整除(下取整)</span><br></code></pre></div></td></tr></table></figure><h2 id="自变量-variable"><a href="#自变量-variable" class="headerlink" title="自变量 variable"></a>自变量 variable</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">temp=<span class="hljs-number">999</span>+<span class="hljs-number">1</span><br>temp_2=<span class="hljs-number">1</span>+temp<br>print(temp,temp_2)<br></code></pre></div></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> a&lt;<span class="hljs-number">10</span>:<br>    print(a)<br>    a+=<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    print(<span class="hljs-string">"123"</span>)<br></code></pre></div></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">example_list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> example_list:<br>    print(i)//-----<br>    print(i+<span class="hljs-number">1</span>)//---这两行都在<span class="hljs-keyword">for</span>循环内(python十分看重结构)<br>print(<span class="hljs-string">"end"</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>): <span class="hljs-comment">#range(a,b,c) 为遍历范围[a,b)  步长为c，也可以直接range(a,b)默认步长为1</span><br>    print(i)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>): <span class="hljs-comment">#range(a,b,c) 为遍历范围[a,b)  步长为c</span><br>    print(a[i])<br></code></pre></div></td></tr></table></figure><h2 id="if条件"><a href="#if条件" class="headerlink" title="if条件"></a>if条件</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x=<span class="hljs-number">1</span><br>y=<span class="hljs-number">2</span><br>z=<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> x&lt;y&gt;z:<br>    print(<span class="hljs-string">'x is less than y,and y is greater than z'</span>)<br>a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> a==b:<br>    print(<span class="hljs-string">'a is equal to b'</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x=<span class="hljs-number">1</span><br>y=<span class="hljs-number">2</span><br>z=<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> x&gt;y:<br>    print(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x=<span class="hljs-number">1</span><br>y=<span class="hljs-number">2</span><br>z=<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> x==<span class="hljs-number">1</span>:<br>    print(x)<br><span class="hljs-keyword">elif</span> y==<span class="hljs-number">2</span>:<br>    print(y)<br><span class="hljs-keyword">else</span>:<br>    print(z)<br>print(<span class="hljs-string">'finished'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="def函数"><a href="#def函数" class="headerlink" title="def函数"></a>def函数</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'this is a f'</span>)<br>f()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(a,b)</span>:</span><br>    c=a*b<br>    print(c)<br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sale</span><span class="hljs-params">(price,color,brand,is_second=True)</span>:</span> <span class="hljs-comment">#提前定义好的值不能在未定义值的前面</span><br>    print(<span class="hljs-string">"price:"</span>,price,<br>        <span class="hljs-string">"color:"</span>,color,<br>        <span class="hljs-string">"brand:"</span>,brand,<br>        <span class="hljs-string">"second:"</span>,is_second)<br>sale(<span class="hljs-number">1000</span>,<span class="hljs-string">"red"</span>,<span class="hljs-literal">True</span>,<span class="hljs-string">"bmw"</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span><span class="hljs-params">(a)</span>:</span><br>    <span class="hljs-keyword">return</span> a*a<br>b=<span class="hljs-number">1</span><br>b+=fun(<span class="hljs-number">5</span>)<br>print(b)<br></code></pre></div></td></tr></table></figure><h2 id="全局-amp-局部变量"><a href="#全局-amp-局部变量" class="headerlink" title="全局&amp;局部变量"></a>全局&amp;局部变量</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">global</span> a<br>    a=<span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> a*a<br>print(fun()) <span class="hljs-comment">#400</span><br>print(a)   <span class="hljs-comment">#20</span><br></code></pre></div></td></tr></table></figure><h2 id="安装numpy模块"><a href="#安装numpy模块" class="headerlink" title="安装numpy模块"></a>安装numpy模块</h2><p><strong>cmd</strong>里直接<strong>pip install numpy</strong></p><p>（如果需要更新输入<strong>python -m pip install —upgrade pip</strong>）</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>写入内容</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">text=<span class="hljs-string">"this is my first text.\nThis is next line."</span><br><span class="hljs-comment"># w是写 ，r是只读</span><br>my_file=open(<span class="hljs-string">'my file.txt'</span>,<span class="hljs-string">'w'</span>)  <span class="hljs-comment">#如果没有这个文件就会创建一个，且保存在.py文件同一个文件夹中</span><br>my_file.write(text)<br>my_file.close()<br></code></pre></div></td></tr></table></figure><p>增加内容</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">text=<span class="hljs-string">"\nThis is appended line."</span><br><span class="hljs-comment"># w是写 ，r是只读, a是在原文件增加</span><br>my_file=open(<span class="hljs-string">'my file.txt'</span>,<span class="hljs-string">'a'</span>)  <span class="hljs-comment">#如果没有这个文件就会创建一个，且保存在.py文件同一个文件夹中</span><br>my_file.write(text)<br>my_file.close()<br></code></pre></div></td></tr></table></figure><p>打印内容</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">my_file=<span class="hljs-keyword">open</span>(<span class="hljs-string">'my file.txt'</span>,<span class="hljs-string">'r'</span>)  #如果没有这个文件就会创建一个，且保存在.<span class="hljs-keyword">py</span>文件同一个文件夹中<br>content=my_file.<span class="hljs-keyword">read</span>()<br><span class="hljs-keyword">print</span>(content)<br></code></pre></div></td></tr></table></figure><p>readline/readlines</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">my_file=open(<span class="hljs-string">'my file.txt'</span>,<span class="hljs-string">'r'</span>)  <span class="hljs-comment">#如果没有这个文件就会创建一个，且保存在.py文件同一个文件夹中</span><br>content=my_file.readline()<span class="hljs-comment">#读完后，光标还在该行</span><br>print(content)<br>content=my_file.readlines()<span class="hljs-comment">#紧跟着上次读完的地方开始读，且readlines会读从光标开始往后的所有内容</span><br>print(content)<br></code></pre></div></td></tr></table></figure><h2 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculate</span>:</span><br>    name = <span class="hljs-string">'Good calculator'</span><br>    price=<span class="hljs-number">18</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plus</span><span class="hljs-params">(self,x,y)</span>:</span><br>        ans=x+y<br>        <span class="hljs-keyword">return</span> ans<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minus</span><span class="hljs-params">(self,x,y)</span>:</span><br>        ans=x-y<br>        <span class="hljs-keyword">return</span> ans<br><br>a=Calculate() <br><br>print(a.name)<br>print(a.price)<br>print(a.plus(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></div></td></tr></table></figure><h2 id="类init功能"><a href="#类init功能" class="headerlink" title="类init功能"></a>类init功能</h2><p>含参构造函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculate</span>:</span><br>    name = <span class="hljs-string">'Good calculator'</span><br>    price=<span class="hljs-number">18</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,price,height)</span>:</span><br>        self.name=name<br>        self.price=price<br>        self.h=height<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plus</span><span class="hljs-params">(self,x,y)</span>:</span><br>        ans=x+y<br>        <span class="hljs-keyword">return</span> ans<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minus</span><span class="hljs-params">(self,x,y)</span>:</span><br>        ans=x-y<br>        <span class="hljs-keyword">return</span> ans<br>a=Calculate(<span class="hljs-string">'bad calculator'</span>,<span class="hljs-number">15</span>,<span class="hljs-number">12</span>)<br>print(a.name)<br>print(a.price)<br>print(a.plus(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></div></td></tr></table></figure><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=input()  <span class="hljs-comment">#输入 input返回值是字符串</span><br>print(a)<br>a=int(input())  <span class="hljs-comment">#输入 input返回值是整数</span><br>b=input(<span class="hljs-string">'please give a number'</span>) <span class="hljs-comment">#带提示字符输入</span><br>print(b)<br></code></pre></div></td></tr></table></figure><h2 id="元组-列表"><a href="#元组-列表" class="headerlink" title="元组 列表"></a>元组 列表</h2><p>这两者十分相似</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a_tuple=(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>)  <span class="hljs-comment">#元组</span><br>another_tuple=<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>   <span class="hljs-comment">#这种写法也是元组</span><br>a_list=[<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">18</span>,<span class="hljs-number">12</span>]  <span class="hljs-comment">#列表</span><br><br><span class="hljs-keyword">for</span> content <span class="hljs-keyword">in</span> a_list:   <span class="hljs-comment">#把列表中的每一个数据赋值给content</span><br>    print(content)<br><span class="hljs-keyword">for</span> content <span class="hljs-keyword">in</span> a_tuple:  <span class="hljs-comment"># 把列表中的每一个数据赋值给content</span><br>    print(content)<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(a_list)):<br>    print(<span class="hljs-string">'index='</span>,index,<span class="hljs-string">'number='</span>,a_list[index])<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(a_tuple)):<br>    print(<span class="hljs-string">'index='</span>,index,<span class="hljs-string">'number='</span>,a_list[index])<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a_list=[<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">18</span>,<span class="hljs-number">12</span>]  <span class="hljs-comment">#列表</span><br>a_list.insert(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment">#.insert(x,y)  第x位插入一个y</span><br>a_list.append(<span class="hljs-number">123</span>)  <span class="hljs-comment">#在列表后添加一个数字</span><br>a_list.remove(<span class="hljs-number">12</span>)  <span class="hljs-comment"># .remove(value) 去掉第一次出现值为value的数字</span><br>print(a_list)<br>print(a_list[<span class="hljs-number">2</span>])<br>print(a_list[<span class="hljs-number">-1</span>])  <span class="hljs-comment">#-1会循环回去 ，索引到最后一个值</span><br>print(a_list[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])    <span class="hljs-comment">#打印第0-2位</span><br>print(a_list[<span class="hljs-number">0</span>:])     <span class="hljs-comment">#打印第0-最后一位</span><br>print(a_list.index(<span class="hljs-number">4</span>))  <span class="hljs-comment">#打印值为4的下标是多少</span><br>print(a_list.count(<span class="hljs-number">12</span>)) <span class="hljs-comment">#打印某一个值出现的次数</span><br>a_list.sort()  <span class="hljs-comment">#从小到大</span><br>print(a_list)<br>a_list.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 从大到小排序</span><br>print(a_list)<br></code></pre></div></td></tr></table></figure><h2 id="多维列表"><a href="#多维列表" class="headerlink" title="多维列表"></a>多维列表</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">multi_list=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>print(multi_list[<span class="hljs-number">1</span>])<br>print(multi_list[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br></code></pre></div></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a_list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>d=&#123;<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>,<span class="hljs-string">'b'</span>:<span class="hljs-number">2</span>,<span class="hljs-string">'c'</span>:<span class="hljs-number">3</span>&#125; <span class="hljs-comment">#字典</span><br>d2=&#123;<span class="hljs-number">1</span>:<span class="hljs-string">'a'</span>,<span class="hljs-number">2</span>:<span class="hljs-string">'b'</span>,<span class="hljs-number">3</span>:<span class="hljs-string">'c'</span>&#125;<br>print(d[<span class="hljs-string">'a'</span>])<br>print(d2[<span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">del</span> d[<span class="hljs-string">'b'</span>]  <span class="hljs-comment">#del 删除操作</span><br>print(d)<br><br>d[<span class="hljs-string">'d'</span>]=<span class="hljs-number">4</span>    <span class="hljs-comment">#添加操作</span><br>print(d)<br></code></pre></div></td></tr></table></figure><p>字典套字典/字典套列表</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">d=&#123;<span class="hljs-string">'a'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'b'</span>:&#123;<span class="hljs-string">'c'</span>:<span class="hljs-number">3</span>,<span class="hljs-number">5</span>:<span class="hljs-string">'e'</span>&#125;&#125;<br>print(d[<span class="hljs-string">'a'</span>][<span class="hljs-number">0</span>])<br>print(d[<span class="hljs-string">'b'</span>][<span class="hljs-string">'c'</span>])<br>print(d[<span class="hljs-string">'b'</span>][<span class="hljs-number">5</span>])<br></code></pre></div></td></tr></table></figure><h2 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h2><p>载入模块的四种方式</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>print(time.localtime())  <span class="hljs-comment">#必须有time.才可以调用localtime()</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time <span class="hljs-keyword">as</span> t   <span class="hljs-comment">#用t代替time</span><br>print(t.localtime())<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time,localtime  <span class="hljs-comment">#只用time模块中的time和localtime这两个</span><br>print(localtime())  <span class="hljs-comment">#不用time.</span><br>print(time())<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span>*<br>print(localtime())   <span class="hljs-comment">#不用time.</span><br></code></pre></div></td></tr></table></figure><h2 id="做一个自己的模块-脚本"><a href="#做一个自己的模块-脚本" class="headerlink" title="做一个自己的模块/脚本"></a>做一个自己的模块/脚本</h2><p>先自己写一个模块，并放在.py文件同根目录下</p><p>这里我给他命名为 my_mod.py</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printdata</span><span class="hljs-params">(data)</span>:</span><br>    print(data)<br></code></pre></div></td></tr></table></figure><p>调用</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> my_mod<br>my_mod.printdata(<span class="hljs-string">'test my mod'</span>)<br></code></pre></div></td></tr></table></figure><h2 id="continue-break"><a href="#continue-break" class="headerlink" title="continue/break"></a>continue/break</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    b=int(input())<br>    <span class="hljs-keyword">if</span> b==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></div></td></tr></table></figure><h2 id="错误处理Try"><a href="#错误处理Try" class="headerlink" title="错误处理Try"></a>错误处理Try</h2><p>下面这中方法可以输出错误信息，但是在pychram也可以做到，所以几乎用不到这种方法。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    file=open(<span class="hljs-string">'eeee'</span>,<span class="hljs-string">'r'</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(e)<br></code></pre></div></td></tr></table></figure><p>正确的用法出现在这种情况下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    file=open(<span class="hljs-string">'eeee'</span>,<span class="hljs-string">'r+'</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">"no such file"</span>)<br>    re=input(<span class="hljs-string">'do you wanna creat a new file'</span>)<br>    <span class="hljs-keyword">if</span> re==<span class="hljs-string">'yes'</span>:<br>        file = open(<span class="hljs-string">'eeee'</span>,<span class="hljs-string">'w'</span>)<br>        file.write(<span class="hljs-string">"1234567"</span>)<br>        file.close()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    file.write(<span class="hljs-string">"12345"</span>)<br>    file.close()<br></code></pre></div></td></tr></table></figure><h2 id="zip-lambda-map"><a href="#zip-lambda-map" class="headerlink" title="zip/lambda/map"></a>zip/lambda/map</h2><p>zip</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>c=list(zip(a,b))   # zip是一个操作，需要转换成list就是列表的形式了<br>print(c)          # [(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> zip(a,b):<br>    print(i/<span class="hljs-number">2</span>,i*<span class="hljs-number">2</span>)<br>#   <span class="hljs-number">0.5</span> <span class="hljs-number">2</span><br><span class="hljs-number">1.0</span> <span class="hljs-number">4</span><br><span class="hljs-number">1.5</span> <span class="hljs-number">6</span><br>print(list(zip(a,a,b))) #三元组 [(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br></code></pre></div></td></tr></table></figure><p>lambda</p><p>和函数一样，常用来定义简单的函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">fun=<span class="hljs-keyword">lambda</span> x,y:x+y<br>print(fun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) <span class="hljs-comment">#1+2=3</span><br></code></pre></div></td></tr></table></figure><p>map</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">fun=lambda x,y:x+y<br>ans=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(fun,[<span class="hljs-number">3</span>],[<span class="hljs-number">5</span>]))<br><span class="hljs-built_in">print</span>(ans)  #[<span class="hljs-number">8</span>]<br>ans=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(fun,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>])) #[<span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></div></td></tr></table></figure><h2 id="浅复制-深复制-copy-amp-deepcopy"><a href="#浅复制-深复制-copy-amp-deepcopy" class="headerlink" title="浅复制/深复制 copy&amp;deepcopy"></a>浅复制/深复制 copy&amp;deepcopy</h2><p>赋值操作中的copy</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b=a<br>print(id(a),id(b)) <span class="hljs-comment">#1881324445568 1881324445568</span><br>b[<span class="hljs-number">0</span>]=<span class="hljs-number">15</span>  <span class="hljs-comment">#改变b后a也会改变，因为他俩地址都一样，你在地址上改，肯定两者都会改变</span><br>print(a) <span class="hljs-comment"># [15, 2, 3]</span><br>print(b) <span class="hljs-comment"># [15, 2, 3]</span><br></code></pre></div></td></tr></table></figure><p>copy模块中的浅复制 copy</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b=copy.copy(a)<br>print(id(a),id(b))  <span class="hljs-comment">#2007218349376 2007217831232</span><br>b[<span class="hljs-number">0</span>]=<span class="hljs-number">15</span><br>print(a)  <span class="hljs-comment">#[1, 2, 3]</span><br>print(b)  <span class="hljs-comment">#[15, 2, 3]</span><br></code></pre></div></td></tr></table></figure><p>copy模块中的深复制 deepcopy</p><p>什么是深复制？为什么要深复制？</p><p>看一下下面这个例子</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br>b=copy.copy(a)<br>print(id(a[<span class="hljs-number">0</span>])==id(b[<span class="hljs-number">0</span>]))  <span class="hljs-comment">#true</span><br>print(id(a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])==id(b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]))  <span class="hljs-comment">#true</span><br>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">15</span><br>print(a)  <span class="hljs-comment">#[1, 2, [15, 4]]</span><br>print(b)  <span class="hljs-comment">#[1, 2, [15, 4]]</span><br></code></pre></div></td></tr></table></figure><p>可以发现列表中的列表并没有被改变地址</p><p>因此需要deepcopy 相当于完完全全的重新复制出的一个东西，地址都不同</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">import copy<br>a=[1,2,[3,4]]<br>b=copy.deepcopy(a)<br>print(id(a[0])==id(b[0]))    #true<br>print(id(a[<span class="hljs-string">2</span>][<span class="hljs-symbol">0</span>])==id(b[<span class="hljs-string">2</span>][<span class="hljs-symbol">0</span>]))   #true<br>b[<span class="hljs-string">2</span>][<span class="hljs-symbol">0</span>]=15<br>print(id(a[<span class="hljs-string">2</span>][<span class="hljs-symbol">0</span>])==id(b[<span class="hljs-string">2</span>][<span class="hljs-symbol">0</span>]))   #flase<br>print(a)  #[1, 2, [3, 4]]<br>print(b)  #[1, 2, [15, 4]]<br></code></pre></div></td></tr></table></figure><p><strong>Q：上面这个例子有一点很奇怪，就是用了deepcopy/copy后为什么地址还是不变呢？</strong></p><p> <strong>A：因为python里万物都是对象，所以数字也是对象。a[0]和b[0]是两个不同的指针，但他们指向的都是”数字1”这个对象的地址，所以他们的id()是相同的。</strong></p><p><strong>id(a[2])!=id(b[2])是因为值不同了</strong></p><h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h2><p>有时候用python处理数据需要很长时间，暂停后我们希望下次接着处理，这时候就要用到pickle模块</p><p>写入pickle文件</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>a=&#123;<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>,<span class="hljs-string">'b'</span>:<span class="hljs-number">2</span>,<span class="hljs-string">'c'</span>:<span class="hljs-number">3</span>&#125;<br>file=open(<span class="hljs-string">'example.pickle'</span>,<span class="hljs-string">'wb'</span>)   <span class="hljs-comment">#wb为二进制写入</span><br>pickle.dump(a,file) <span class="hljs-comment">#dump是倒入的意思 也就是把a倒入到file中</span><br>file.close()<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>file=open(<span class="hljs-string">'example.pickle'</span>,<span class="hljs-string">'rb'</span>)<br>b=pickle.load(file)  <span class="hljs-comment">#加载上一次存入的</span><br>file.close()<br>print(b)  <span class="hljs-comment">#&#123;'a': 1, 'b': 2, 'c': 3&#125;</span><br></code></pre></div></td></tr></table></figure><p>也可以直接这样用with，就免去了file.close()这一步</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'example.pickle'</span>,<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> file:<br>    b=pickle.load(file)  <span class="hljs-comment">#加载上一次存入的</span><br>print(b)<br></code></pre></div></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=&#123;<span class="hljs-string">'e'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'a'</span>&#125;<br>print(set(a))  <span class="hljs-comment">#&#123;'b', 'e', 'c', 'a'&#125; 去重</span><br>s=<span class="hljs-string">'this is my test'</span> <span class="hljs-comment">#&#123;'y', 't', ' ', 'i', 'e', 's', 'm', 'h'&#125;</span><br>print(set(s))<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=&#123;<span class="hljs-string">'e'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'a'</span>&#125;<br>b=set(a)  <span class="hljs-comment">#此时b也变成了set类型</span><br>b.add(<span class="hljs-string">'x'</span>)  <span class="hljs-comment">#set中在结尾添加不是append 而是add</span><br>print(b)    <span class="hljs-comment">#&#123;'a', 'e', 'b', 'c', 'x'&#125;</span><br>b.add(<span class="hljs-string">'a'</span>)<br>print(b)   <span class="hljs-comment">#&#123;'b', 'a', 'c', 'x', 'e'&#125;</span><br>b.remove(<span class="hljs-string">'x'</span>)  <span class="hljs-comment">#去掉一个值</span><br>print(b)   <span class="hljs-comment">#&#123;'e', 'a', 'b', 'c'&#125;</span><br>b.discard(<span class="hljs-string">'w'</span>)  <span class="hljs-comment">#discard 与remove功能相同，但是remove不可以去掉本身就不存在的数据且会报错，而discard不会报错而是返回原来的值</span><br>print(b)<br>b.clear()  <span class="hljs-comment">#清空set</span><br>print(b)   <span class="hljs-comment">#set()  清空</span><br>set1=&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;<br>set2=&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>&#125;<br>print(set1.difference(set2))  <span class="hljs-comment">#   .difference()找出不同返回数据  &#123;'c', 'b'&#125;</span><br>print(set1.intersection(set2)) <span class="hljs-comment"># .intersection()找出相同的值  &#123;'a'&#125;</span><br></code></pre></div></td></tr></table></figure><p>set中怎么sort？</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a=&#123;<span class="hljs-string">'e'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'a'</span>&#125;<br>b=set(a)    <span class="hljs-comment">#此时b也变成了set类型</span><br>print(b)    <span class="hljs-comment">#&#123;'a', 'e', 'b', 'c', 'x'&#125;</span><br>c=list(b)   <span class="hljs-comment">#转换成list</span><br>c.sort()  <br>print(c)    <span class="hljs-comment">#['a', 'b', 'c', 'e']</span><br></code></pre></div></td></tr></table></figure><h2 id="RegEx正则表达"><a href="#RegEx正则表达" class="headerlink" title="RegEx正则表达"></a>RegEx正则表达</h2><p>正则表达式 (Regular Expression) 又称 RegEx, 是用来匹配字符的一种工具. 在一大串字符中寻找你需要的内容. 它常被用在很多方面, 比如网页爬虫, 文稿整理, 数据筛选等等. 最简单的一个例子, 比如我需要爬取网页中每一页的标题. 而网页中的标题常常是这种形式.</p><p>不用特意记忆，用的时候查一下即可</p><p><img src="https://morvanzhou.github.io/static/results/basic/13-10-01.png" srcset="/img/loading.gif" alt="正则表达式"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python-基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EnglishNotebook(2020寒假)</title>
    <link href="/2020/02/21/EnglishNotebook-2020%E5%AF%92%E5%81%87/"/>
    <url>/2020/02/21/EnglishNotebook-2020%E5%AF%92%E5%81%87/</url>
    
    <content type="html"><![CDATA[<h1 id="English-Notebook（2020年寒假）"><a href="#English-Notebook（2020年寒假）" class="headerlink" title="English Notebook（2020年寒假）"></a>English Notebook（2020年寒假）</h1><h2 id="Stanford-University-Opening-speech"><a href="#Stanford-University-Opening-speech" class="headerlink" title="Stanford University Opening speech"></a>Stanford University Opening speech</h2><p><strong>web address</strong>:<a href="https://www.bilibili.com/video/av68269911?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av68269911?p=1</a></p><p><strong>incoming student  即将到来的学生</strong></p><p><strong>speak to the spirit of  宣扬</strong></p><p><strong>biography  传记</strong></p><p><strong>Renaissance  n.文艺复兴</strong></p><p><strong>in the Renaissance 在文艺复兴时期</strong></p><p><strong>distinguish   v.区分; 辨别; 分清; 成为…的特征; 使具有…的特色; 使有别于; 看清; 认出; 听出;</strong></p><p><strong>eg: Those masterpieces have distinguish him as one of the greatest painters of all time</strong></p><p><strong>这些杰作使他的表现突出，成为有史以来最杰出的画家之一</strong></p><p><strong>transcend v.超越</strong></p><p><strong>architecture n.建筑学</strong></p><p><strong>sweeping  adj.影响广泛的; 大范围的; 根本性的; (过分) 笼统的; 一概而论的; (在投票等中的) 大胜，全胜;</strong></p><p><strong>a sweeping array of topics 一系列广泛的话题</strong></p><p><strong>as opposed to 而不是</strong></p><p><strong>eg: How does a poem change when you read it out loud as opposed to it being on the page?</strong> </p><p><strong>将写在纸上的诗大声读出来会有怎样的不同？</strong></p><p><strong>boundless 无穷无尽的</strong></p><p><strong>quintessential 典型的</strong></p><p><strong>magnitude    n.巨大; 重大; 重要性;</strong></p><p><strong>accomplishment   n.成就</strong></p><p><strong>embark on 开启崭新的…</strong></p><p><strong>relentless   adj. 无情的，永不停歇的</strong> </p><p><strong>inclination  n. 意愿 倾向</strong></p><p><strong>unprecedented  adj. 前所未有的，空前的</strong></p><p><strong>precedented adj.有先例（可借鉴的）</strong></p><p><strong>depict v.描绘; 描画; 描写; 描述; 刻画;</strong></p><p><strong>perspective  n. 态度; 观点; 思考方法; 客观判断力; 权衡轻重的能力;  （可数）</strong></p><p><strong>embrace  v. 拥抱; 欣然接受，乐意采纳(思想、建议等)  n. 拥抱，怀抱</strong></p><p><strong>misfit   n.与别人合不来的人; 行为(或思想)怪异的人;</strong></p><p><strong>stringent   严格的，严厉的；紧缺的</strong></p><p><strong>heretical  adj. (与主流思想不合的) 异端的，旁门左道的;</strong></p><p><strong>obstacle    n.障碍; 阻碍; 绊脚石; 障碍物; 障碍栅栏</strong></p><p><strong>constrain  v.强迫; 强制; 迫使; 限制; 限定; 约束;</strong></p><p><strong>eg: He didn’t let others’ opinions constrain his own thinking</strong></p><p><strong>envision  v. 展望；想象</strong></p><p><strong>fruition  n.(计划、过程或活动的) 完成，实现，取得成果;</strong></p><p><strong>come to fruition</strong> </p><p><strong>eg: These plans take time to come to fruition 这些方案需要时间才能取得成果。</strong></p><p><strong>ultimately adv .最终地</strong></p><p><strong>individuality  n.个性; 个人(或个体)特征;</strong></p><p><strong>cultivate v.耕; 耕作; 种植; 栽培; 培育; 建立(友谊); 结交(朋友); 获得(支持);</strong></p><p><strong>encounter v.遭遇，遇到(尤指令人不快或困难的事); 偶然碰到;</strong></p><p><strong>resist v.抵制; 阻挡; 反抗; 回击; 抵抗; 忍住; 抵挡;</strong></p><p><strong>convey v.表达，传递(思想、感情等);</strong> </p><p><strong>stunning adj.极有魅力的; 绝妙的; 给人以深刻印象的; 令人惊奇万分的; 令人震惊的;</strong></p><p><strong>collegial adj.集体组织的，合议的；大学的；社团的;</strong></p><p><strong>chart one’s own course 自力更生，走向独立；</strong></p><p><strong>broaden one’s horizons  开阔视野</strong></p><p><strong>interaction  n. 相互影响（作用，制约，配合）；交互作用（影响）；交相感应；干扰（涉）;</strong></p><p><strong>eg: This can sometimes lead to somewhat superficial interactions with other people.</strong></p><p><strong>这有时可能会导致与他人的交往流于肤浅。</strong></p><p><strong>strove v.努力</strong><br><strong>eg: She <em>strove</em> to perform all her wifely functions <em>perfectly.</em></strong></p><p><strong>她努力做一个无可挑剔的贤妻。</strong></p><p><strong>persistence  n.坚持; 锲而不舍; 持续存在; 维持;</strong></p><p><strong>innovative adj.adj.引进新思想的; 采用新方法的; 革新的; 创新的;</strong></p><p><strong>hint  n.暗示;提示; 示意; 征兆;  v. 暗示; 透露; 示意;</strong></p><p><strong>anguish  n.剧痛; 极度痛苦; 苦恼;  v.使极度痛苦; 使苦恼; 悲痛万分感到极度的痛苦; 苦恼</strong></p><p><strong>deter    v.制止; 阻止; 威慑; 使不敢;</strong></p><p><strong>eg: He wasn’t deterred when he fell short (fall short 失败)</strong></p><p><strong>setback n.挫折; 阻碍;</strong></p><p><strong>persevere  v.坚持; 孜孜以求;</strong></p><p><strong>committedly  adv.尽心尽力的</strong></p><h2 id="Yale-University-Opening-Speech"><a href="#Yale-University-Opening-Speech" class="headerlink" title="Yale University Opening Speech"></a>Yale University Opening Speech</h2><p><strong>web address:</strong><a href="https://www.bilibili.com/video/av68269911?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av68269911?p=2</a></p><p><strong>extend warm greeting to  向….. 致以热情的问候</strong></p><p><strong>nurture     vt. 养育；鼓励；培植   n. 养育；教养；营养物</strong></p><p><strong>eg: We are here at Yale to nurture a culture of curiousity</strong></p><p><strong>我们来耶鲁是为了培养好奇的文化</strong></p><p><strong>extraordinary  adj. 卓越的； 非凡的；特别的；离奇的；</strong></p><p><strong>infant  n.婴儿</strong></p><p><strong>conduct   v. 组织，实施，进行；指挥（音乐）；带领，引导；举止，表现；传导（热或电）</strong></p><p>​                 <strong>n. 行为举止；管理（方式），实施（办法）；引导</strong></p><p><strong>distinguished   adj. 卓越的，著名的；高贵的，受尊重的</strong></p><p><strong>breakthrough     重大进展，突破</strong></p><p><strong>astonishing 令人震惊的</strong></p><p><strong>dead-end  n.尽头，终点</strong></p><p><strong>check into 调查； 到达并在…登记;</strong></p><p><strong>spark one’s curiosity 激起某人的好奇心</strong></p><p><strong>extract    v. 提取，提炼；索取，设法得到；选取，摘录；取出，拔出；推断出，引申出；开（方），求（根）</strong></p><p>​                <strong>n. 摘录，引文；榨出物，汁</strong></p><p><strong>collaborator  n. 合作者；勾结者；通敌者</strong></p><p><strong>spectacular  adj. 壮观的，惊人的；公开展示的</strong></p><p><strong>possess   vt. 控制；使掌握；持有；迷住；拥有，具备 ==have</strong></p><p><strong>barely  几乎没</strong></p><p><strong>intact   adj. 完整的；原封不动的；未受损伤的</strong></p><p><strong>access  n. 通道；进入；机会；使用权；探望权；（对计算机存储器的）访问；（情感）爆发</strong></p><p>​              <strong>v. 接近，使用；访问，存取（电脑文档）</strong></p><p><strong>inquisitive   adj. 好奇的；好问的，爱打听的</strong></p><p><strong>sector  n.方面，部门；扇形，扇区；象限仪；函数尺</strong></p><p><strong>dazzling  adj. 耀眼的；眼花缭乱的</strong></p><p>​                <strong>v. 使…眼花（dazzle的ing形式）</strong></p><p><strong>institution   n. 制度；建立；（社会或宗教等）公共机构；习俗</strong></p><p><strong>commemorate    vt. 庆祝，纪念；成为…的纪念</strong></p><p><strong>milestone   n. 里程碑，划时代的事件</strong></p><p><strong>courageous  adj. 有胆量的，勇敢的  ==brave</strong></p><p><strong>unparalleled   adj. 无比的；无双的；空前未有的</strong></p><p><strong>world-reowned  adj. 世界知名的</strong></p><p><strong>converse    v. 交谈，谈话；认识  converse with sb</strong></p><p>​                    <strong>n. 逆行，逆向；倒；相反的事物；逆命题；反面的事实；相反的说法</strong></p><p>​                    <strong>adj. 相反的，逆向的；颠倒的</strong></p><p><strong>rigorous   adj. 严格的，严厉的；严密的；严酷的</strong></p><p><strong>take advantage of  利用</strong></p><p><strong>willingness   n. 乐意；心甘情愿；自动自发</strong></p><h2 id="Brown-University-Opening-Speech"><a href="#Brown-University-Opening-Speech" class="headerlink" title="Brown University Opening Speech"></a>Brown University Opening Speech</h2><p><strong>tackle  v. 应付，处理（难题或局面）；与某人交涉；（足球、曲棍球等）抢球；（橄榄球或美式足球）擒抱摔倒；抓获；对付，打（尤指罪犯）</strong></p><p><strong>tackle the challenges 应对挑战</strong></p><p><strong>agent   n. 代理人，代理商；药剂；特工；动因  vt. 由…作中介；由…代理</strong></p><p><strong>faculty  n. 科，系；能力；全体教员</strong></p><p><strong>dedicated   adj. 专用的；专注的；献身的</strong></p><p><strong>be dedicated to do sth 致力于做某事</strong></p><p><strong>day in,day out   日复一日</strong></p><p><strong>literally   adv. 照字面地；逐字地；不夸张地；正确地；简直</strong></p><p><strong>crisis   n. 危机；危险期；决定性时刻</strong></p><p>​            <strong>adj. 危机的；用于处理危机的</strong></p><p><strong>informed  adj. 见多识广的；消息灵通的；有根据的；明智的（猜测或决定）</strong></p><p><strong>inform     vt. 通知；告诉；报告 vi. 告发；告密</strong></p><p><strong>fray   n. 争论；打架；磨损处</strong>  </p><p><strong>impact  vi. 影响；n. 影响；</strong></p><p><strong>extracurricular   adj. 课外的；业余的；</strong></p><p><strong>confer  vt. 授予；给予</strong></p><p><strong>conflict  n. 冲突，矛盾；斗争；争执</strong></p><p>​                <strong>vi. 冲突，抵触；争执；战斗</strong></p><p><strong>collaboration  n. 合作；勾结；通敌</strong></p><p><strong>enslave vt. 束缚；征服；使某人成为奴隶</strong></p><p> <strong>rigor   n. 严密，严格（rigour 的美式拼法）</strong></p><p><strong>intentionality   n. 意向性，意图性</strong></p><p><strong>virtue  n. 美德；优点；贞操；功效</strong></p><p><strong>cultivate  vt. 培养；陶冶；耕作</strong></p><p><strong>nuance    n. 细微差别</strong></p><p><strong>skeptical  adj. 怀疑的；（哲学）怀疑论的，不可知论的</strong></p><p><strong>provocative  adj. 刺激的，挑拨的；气人的</strong></p><p><strong>precise   adj. 精确的；明确的；严格的</strong></p><p><strong>profound   adj. 深厚的；意义深远的；渊博的</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛进阶指南(第一章-基本算法)做题记录</title>
    <link href="/2020/02/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/02/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="《算法竞赛进阶指南》第一章-基础算法"><a href="#《算法竞赛进阶指南》第一章-基础算法" class="headerlink" title="《算法竞赛进阶指南》第一章-基础算法"></a>《算法竞赛进阶指南》第一章-基础算法</h1><h1 id="位运算⋙"><a href="#位运算⋙" class="headerlink" title="位运算⋙"></a>位运算⋙</h1><h2 id="89-a-b（快速幂）"><a href="#89-a-b（快速幂）" class="headerlink" title="89.a^b（快速幂）"></a>89.a^b（快速幂）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">200000</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll n,ll x,ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">1</span>;<br>    ans=ans%p;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>) ans=ans*n%p;<br>        n=n*n%p;<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll a,b,p;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ksm(a,b,p)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="90-64位整数乘法"><a href="#90-64位整数乘法" class="headerlink" title="90.64位整数乘法"></a>90.64位整数乘法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">200000</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">multi_big</span><span class="hljs-params">(ll a,ll b,ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) ans=(ans+a)%p;<br>        a=a*<span class="hljs-number">2</span>%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll a,b,p;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;multi_big(a,b,p)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="递推与递归⋙"><a href="#递推与递归⋙" class="headerlink" title="递推与递归⋙"></a>递推与递归⋙</h1><h2 id="※91-最短Hamilton路径（位运算，状压DP）"><a href="#※91-最短Hamilton路径（位运算，状压DP）" class="headerlink" title="※91.最短Hamilton路径（位运算，状压DP）"></a>※91.最短Hamilton路径（位运算，状压DP）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/93/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">10</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">int</span> dp[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">2</span>][<span class="hljs-number">20</span>];<span class="hljs-comment">//第一维是当前状态，第二维是达到当前状态时走到了哪一个点。</span><br><span class="hljs-keyword">int</span> mp[<span class="hljs-number">20</span>+<span class="hljs-number">3</span>][<span class="hljs-number">20</span>+<span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hamilton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//枚举每一种状态</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//选择该种状态下的一个位置</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>((i^(<span class="hljs-number">1</span>&lt;&lt;j))&gt;&gt;k&amp;<span class="hljs-number">1</span>)<br>                    &#123;<br>                        dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+mp[k][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            <span class="hljs-built_in">cin</span>&gt;&gt;mp[i][j];<br>    <span class="hljs-built_in">cout</span>&lt;&lt;hamilton(n)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="92-递归实现指数型枚举（二进制枚举）"><a href="#92-递归实现指数型枚举（二进制枚举）" class="headerlink" title="92. 递归实现指数型枚举（二进制枚举）"></a>92. 递归实现指数型枚举（二进制枚举）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/94/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/94/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n; j&gt;=<span class="hljs-number">1</span>; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&gt;&gt;j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,n-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="93-递归实现组合型枚举（递归枚举）"><a href="#93-递归实现组合型枚举（递归枚举）" class="headerlink" title="93. 递归实现组合型枚举（递归枚举）"></a>93. 递归实现组合型枚举（递归枚举）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/95/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">10</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; chosen;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(chosen.<span class="hljs-built_in">size</span>()==m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;chosen.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,chosen[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x&gt;n) <span class="hljs-keyword">return</span>;<br>    chosen.push_back(x);<br>    calc(x+<span class="hljs-number">1</span>);<br>    chosen.pop_back();<br>    calc(x+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<br>    calc(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="※94-递归实现排列型枚举（递归排列枚举）"><a href="#※94-递归实现排列型枚举（递归排列枚举）" class="headerlink" title="※94. 递归实现排列型枚举（递归排列枚举）"></a>※94. 递归实现排列型枚举（递归排列枚举）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/96/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">10</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><br><span class="hljs-keyword">int</span> order[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">bool</span> chosen[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(k==n+<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,order[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(chosen[i])<br>            <span class="hljs-keyword">continue</span>;<br>        order[k]=i;<br>        chosen[i]=<span class="hljs-literal">true</span>;<br>        calc(k+<span class="hljs-number">1</span>);<br>        chosen[i]=<span class="hljs-literal">false</span>;<br>        order[k]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    calc(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="95-费解的开关（思维-递推-二进制）"><a href="#95-费解的开关（思维-递推-二进制）" class="headerlink" title="95. 费解的开关（思维+递推+二进制）"></a>95. 费解的开关（思维+递推+二进制）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/description/97/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/97/</a></p><p>递推，枚举第一层，下面只要是0就改变。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">500</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">char</span> mp[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br><span class="hljs-keyword">int</span> m[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;=<span class="hljs-number">5</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;y&lt;=<span class="hljs-number">5</span>) m[x+<span class="hljs-number">1</span>][y]=m[x+<span class="hljs-number">1</span>][y]^<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;y&lt;=<span class="hljs-number">5</span>) m[x<span class="hljs-number">-1</span>][y]=m[x<span class="hljs-number">-1</span>][y]^<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;x&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=<span class="hljs-number">5</span>) m[x][y<span class="hljs-number">-1</span>]=m[x][y<span class="hljs-number">-1</span>]^<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;=<span class="hljs-number">5</span>&amp;&amp;x&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=<span class="hljs-number">5</span>) m[x][y+<span class="hljs-number">1</span>]=m[x][y+<span class="hljs-number">1</span>]^<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=<span class="hljs-number">5</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;y&lt;=<span class="hljs-number">5</span>) m[x][y]=m[x][y]^<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>            <span class="hljs-keyword">if</span>(m[i][j]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,mp[i]+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> ans=INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">5</span>;k++)<br>                    m[j][k]=mp[j][k]-<span class="hljs-string">'0'</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>                <span class="hljs-keyword">if</span>(((i&gt;&gt;(j<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>) &#123;change(<span class="hljs-number">1</span>,j);<span class="hljs-built_in">step</span>++;&#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">5</span>;k++)<br>                    <span class="hljs-keyword">if</span>(!m[j<span class="hljs-number">-1</span>][k]) &#123;change(j,k);<span class="hljs-built_in">step</span>++;&#125;<br>            <span class="hljs-keyword">if</span>(check()==<span class="hljs-literal">true</span>&amp;&amp;<span class="hljs-built_in">step</span>&lt;=<span class="hljs-number">6</span>) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">step</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans==INF) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="96-奇怪的汉诺塔（DP-递推）"><a href="#96-奇怪的汉诺塔（DP-递推）" class="headerlink" title="96. 奇怪的汉诺塔（DP+递推）"></a>96. 奇怪的汉诺塔（DP+递推）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/98/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/98/</a></p><p>这里的汉诺塔有四个桩子，但我们可以从三个桩子入手。</p><p>三个桩子递推很容易推出 式子$f[i]=2*f[i-1]+1$ 其中i为圆盘数</p><p>那么在考虑四个桩子的情况，我们不妨把四个桩子i个圆盘需要的操作次数设为dp[i]</p><p>考虑如何构造转移方程：</p><p>加入我们先转移$j$个 那么就还剩$n-i$个需要转移，这$n-i$个转移的时候有一个桩已经被开始的j个占据了，也就是说还剩下三个桩子，这时候用上面的$f[n-i]$就是三个桩子的情况下转移到另一处的耗费。</p><p>最后我们需要把转移的两个桩子合并在一起，需要$dp[j]$</p><p>转移方程为$dp[i]=min(dp[i],dp[j]+dp[j]+f[i-j])$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">500</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">int</span> f[<span class="hljs-number">25</span>],dp[<span class="hljs-number">25</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=<span class="hljs-number">12</span>; i++)<br>        f[i]=<span class="hljs-number">2</span>*f[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">12</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;i; j++)<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j]+dp[j]+f[i-j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">12</span>;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="97-约数之和（矩阵快速幂-分治-逆元-特判）"><a href="#97-约数之和（矩阵快速幂-分治-逆元-特判）" class="headerlink" title="97. 约数之和（矩阵快速幂+分治/逆元+特判）"></a>97. 约数之和（矩阵快速幂+分治/逆元+特判）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/99/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/99/</a></p><p>算贡献就好,可以分治也可以逆元来做，但是注意一点，由于模数为9901，所以费马小定理不能直接用，只有当$gcd(p,a)=1$时才可以用（<del>把我恶心坏了，看了一个小时找不出来错误</del>），所以要特判解决这个问题,当这个式子$gcd(p,a)=1$成立时单独拿出来加到ans中去，像下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((p[i]<span class="hljs-number">-1</span>)%MOD==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt[i];j++)<br>    &#123;<br>        ans=(ans+ksm(p[i],j,MOD))%MOD;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e7</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">9901</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//复杂度log2(x)</span><br><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> p)</span><span class="hljs-comment">//n^x%p</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<br>    ans=ans%p;<span class="hljs-comment">//如果模数p=1，没这步会直接输出ans=1，而正确答案应该是0</span><br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>) ans=ans*<span class="hljs-number">1l</span>l*n%p;<span class="hljs-comment">//1ll防止溢出</span><br>        n=n*<span class="hljs-number">1l</span>l*n%p;<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br>&#125;<br><span class="hljs-keyword">int</span> p[MAXN],cnt[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=a;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[num]!=i) num++;<br>            p[num]=i;<br>            cnt[num]++;<br>            a=a/i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++) cnt[i]=cnt[i]*b;<br>    ll ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((p[i]<span class="hljs-number">-1</span>)%MOD==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt[i];j++)<br>            &#123;<br>                ans=(ans+ksm(p[i],j,MOD))%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ll c1=ksm(p[i],cnt[i]+<span class="hljs-number">1</span>,MOD);<br>            c1=c1+MOD;<br>            ans=ans*(c1<span class="hljs-number">-1</span>)*ksm(p[i]<span class="hljs-number">-1</span>,MOD<span class="hljs-number">-2</span>,MOD)%MOD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="98-分形之城（线性代数坐标变换-规律-递归-分形图）"><a href="#98-分形之城（线性代数坐标变换-规律-递归-分形图）" class="headerlink" title="98. 分形之城（线性代数坐标变换+规律+递归+分形图）"></a>98. 分形之城（线性代数坐标变换+规律+递归+分形图）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/100/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/100/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5e7</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">9901</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-function">pll <span class="hljs-title">cal</span><span class="hljs-params">(ll n,ll m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    ll len=<span class="hljs-number">1l</span>l&lt;&lt;n<span class="hljs-number">-1</span>,cnt=<span class="hljs-number">1l</span>l&lt;&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">auto</span> pos=cal(n<span class="hljs-number">-1</span>,m%cnt);<br>    <span class="hljs-keyword">auto</span> x=pos.first,y=pos.second;<br>    <span class="hljs-keyword">auto</span> z=m/cnt;<br>    <span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;y,x&#125;;<br>    <span class="hljs-keyword">if</span>(z==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;x,y+len&#125;;<br>    <span class="hljs-keyword">if</span>(z==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> &#123;x+len,y+len&#125;;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">2</span>*len<span class="hljs-number">-1</span>-y,len<span class="hljs-number">-1</span>-x&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        ll n,a,b;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">auto</span> ac=cal(n,a<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> bc=cal(n,b<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">double</span> x=ac.first-bc.first;<br>        <span class="hljs-keyword">double</span> y=ac.second-bc.second;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.0f\n"</span>,<span class="hljs-built_in">sqrt</span>(x*x+y*y)*<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="前缀和⋙"><a href="#前缀和⋙" class="headerlink" title="前缀和⋙"></a>前缀和⋙</h1><h2 id="99-激光炸弹（二位前缀和-思维）"><a href="#99-激光炸弹（二位前缀和-思维）" class="headerlink" title="99.激光炸弹（二位前缀和+思维）"></a>99.激光炸弹（二位前缀和+思维）</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/101/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/101/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">5000</span>+<span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">9901</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">int</span> n,r;<br><span class="hljs-keyword">int</span> max_r,max_c;<br><span class="hljs-keyword">int</span> s[MAXN][MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;r);<br>    max_r=max_c=r;<span class="hljs-comment">//很重要！！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,y,w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);<br>        x++;<br>        y++;<br>        s[x][y]=w;<br>        max_r=<span class="hljs-built_in">max</span>(max_r,x);<br>        max_c=<span class="hljs-built_in">max</span>(max_c,y);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=max_r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=max_c;j++)<br>        &#123;<br>            s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]+s[i][j]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&lt;=max_r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=r;j&lt;=max_c;j++)<br>        &#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="差分⋙"><a href="#差分⋙" class="headerlink" title="差分⋙"></a>差分⋙</h1><h2 id="100-增减序列"><a href="#100-增减序列" class="headerlink" title="100.增减序列"></a>100.增减序列</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/102/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/102/</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br>ll p=<span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> a[MAXN];<br><span class="hljs-keyword">int</span> d[MAXN];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        d[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(d[i]&gt;<span class="hljs-number">0</span>) p+=d[i];<br>        <span class="hljs-keyword">if</span>(d[i]&lt;<span class="hljs-number">0</span>) q+=(-d[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n%lld"</span>,<span class="hljs-built_in">min</span>(p,q)+<span class="hljs-built_in">abs</span>(p-q),<span class="hljs-built_in">abs</span>(p-q)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="101-最高的牛"><a href="#101-最高的牛" class="headerlink" title="101. 最高的牛"></a>101. 最高的牛</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/103/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/103/</a></p><p>题目中保证了m组对中不会出现重复的，但如果不保证的话只需要把每一对存入$pair<int,int>$即可 然后在q[x]!=y来去重</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Chillstep ^_^</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pll pair<span class="hljs-meta-string">&lt;ll,ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pdd pair<span class="hljs-meta-string">&lt;double,double&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span>);<br><br>pii a[MAXN];<br><span class="hljs-keyword">int</span> c[MAXN],d[MAXN];<br><span class="hljs-built_in">map</span>&lt;ll,ll&gt;q;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,p,h,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;h&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;y) swap(x,y);<br>        <span class="hljs-keyword">if</span>(q[x]!=y)<br>        &#123;<br>            q[x]=y;<br>            d[x+<span class="hljs-number">1</span>]--,d[y]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) c[i]=c[i<span class="hljs-number">-1</span>]+d[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,c[i]+h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="二分⋙"><a href="#二分⋙" class="headerlink" title="二分⋙"></a>二分⋙</h1>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-算法竞赛进阶指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #618 (Div. 2)全题解（A-E）</title>
    <link href="/2020/02/15/Codeforces-Round-618-Div-2-%E5%85%A8%E9%A2%98%E8%A7%A3%EF%BC%88A-E%EF%BC%89/"/>
    <url>/2020/02/15/Codeforces-Round-618-Div-2-%E5%85%A8%E9%A2%98%E8%A7%A3%EF%BC%88A-E%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-618-Div-2-全题解（A-E）"><a href="#Codeforces-Round-618-Div-2-全题解（A-E）" class="headerlink" title="Codeforces Round #618 (Div. 2)全题解（A-E）"></a>Codeforces Round #618 (Div. 2)全题解（A-E）</h1><p>比赛题目地址：<a href="https://codeforces.com/contest/1300" target="_blank" rel="noopener">https://codeforces.com/contest/1300</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">Name</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/A" target="_blank" rel="noopener">A</a></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/A" target="_blank" rel="noopener">Non-zero</a>    standard input/output1 s, 256 MB</td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/submit/A" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/submit-22x22.png" srcset="/img/loading.gif" alt="Submit"></a> <img src="https://sta.codeforces.com/s/20101/images/icons/star_gray_16.png" srcset="/img/loading.gif" alt="Add to favourites"></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/status/A" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/user.png" srcset="/img/loading.gif" alt="img"> x10972</a></td></tr><tr><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/B" target="_blank" rel="noopener">B</a></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/B" target="_blank" rel="noopener">Assigning to Classes</a>   standard input/output2 s, 256 MB</td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/submit/B" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/submit-22x22.png" srcset="/img/loading.gif" alt="Submit"></a> <img src="https://sta.codeforces.com/s/20101/images/icons/star_gray_16.png" srcset="/img/loading.gif" alt="Add to favourites"></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/status/B" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/user.png" srcset="/img/loading.gif" alt="img"> x9480</a></td></tr><tr><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/C" target="_blank" rel="noopener">C</a></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/C" target="_blank" rel="noopener">Anu Has a Function</a>    standard input/output1 s, 256 MB</td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/submit/C" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/submit-22x22.png" srcset="/img/loading.gif" alt="Submit"></a> <img src="https://sta.codeforces.com/s/20101/images/icons/star_gray_16.png" srcset="/img/loading.gif" alt="Add to favourites"></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/status/C" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/user.png" srcset="/img/loading.gif" alt="img"> x4802</a></td></tr><tr><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/D" target="_blank" rel="noopener">D</a></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/D" target="_blank" rel="noopener">Aerodynamic</a>    standard input/output1 s, 256 MB</td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/submit/D" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/submit-22x22.png" srcset="/img/loading.gif" alt="Submit"></a> <img src="https://sta.codeforces.com/s/20101/images/icons/star_gray_16.png" srcset="/img/loading.gif" alt="Add to favourites"></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/status/D" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/user.png" srcset="/img/loading.gif" alt="img"> x2146</a></td></tr><tr><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/E" target="_blank" rel="noopener">E</a></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/problem/E" target="_blank" rel="noopener">Water Balance</a>   standard input/output3 s, 256 MB</td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/submit/E" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/submit-22x22.png" srcset="/img/loading.gif" alt="Submit"></a> <img src="https://sta.codeforces.com/s/20101/images/icons/star_gray_16.png" srcset="/img/loading.gif" alt="Add to favourites"></td><td style="text-align:center"><a href="https://codeforces.com/contest/1300/status/E" target="_blank" rel="noopener"><img src="https://sta.codeforces.com/s/20101/images/icons/user.png" srcset="/img/loading.gif" alt="img"> x839</a></td></tr></tbody></table></div><h2 id="A-Non-zero"><a href="#A-Non-zero" class="headerlink" title="A.Non-zero"></a>A.<a href="https://codeforces.com/contest/1300/problem/A" target="_blank" rel="noopener">Non-zero</a></h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">100000</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">106</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>            sum+=a[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) ans++;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> k=<span class="hljs-number">-1</span>*sum;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) ans++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans==k)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Assigning-to-Classes"><a href="#B-Assigning-to-Classes" class="headerlink" title="B.Assigning to Classes"></a>B.<a href="https://codeforces.com/contest/1300/problem/B" target="_blank" rel="noopener">Assigning to Classes</a></h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">300000</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>        &#125;<br>        sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*n);<br>        <span class="hljs-keyword">int</span> minn=<span class="hljs-built_in">abs</span>(a[n+<span class="hljs-number">1</span>]-a[n]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,minn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Anu-Has-a-Function"><a href="#C-Anu-Has-a-Function" class="headerlink" title="C.Anu Has a Function"></a>C.<a href="https://codeforces.com/contest/1300/problem/C" target="_blank" rel="noopener">Anu Has a Function</a></h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">300000</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">int</span> n,c,t,flag=<span class="hljs-number">-1</span>;;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">32</span>;~i;i--)<br>   &#123;<br>       t=<span class="hljs-number">-1</span>;<br>       c=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(a[j]&amp;(<span class="hljs-number">1l</span>l&lt;&lt;i))<br>           &#123;<br>               t=j;<br>               c++;<br>           &#125;<br>       &#125;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>)<br>        &#123;<br>            flag=t;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(~flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[flag]);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;<br>       <span class="hljs-keyword">if</span>(flag==i) <span class="hljs-keyword">continue</span>;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>   &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D.Aerodynamic"></a>D.<a href="https://codeforces.com/contest/1300/problem/D" target="_blank" rel="noopener">Aerodynamic</a></h2><p>多画几个图形，不难发现只需要判断该图形是否为中心对称图形即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">100000</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> x[maxn],y[maxn];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x[i],&amp;y[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">int</span> j=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">double</span> ansx=(x[<span class="hljs-number">1</span>]+x[j])/<span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">double</span> ansy=(y[<span class="hljs-number">1</span>]+y[j])/<span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> ansxx=(x[i]+x[j])/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">double</span> ansyy=(y[i]+y[j])/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(ansxx!=ansx||ansy!=ansyy)  flag=<span class="hljs-number">0</span>;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E-Water-Balance"><a href="#E-Water-Balance" class="headerlink" title="E.Water Balance"></a>E.<a href="https://codeforces.com/contest/1300/problem/E" target="_blank" rel="noopener">Water Balance</a></h2><p>维护凸包的写法看了一个红名的方法，写起来很简洁，也很容易理解。</p><p><img src="https://s2.ax1x.com/2020/02/15/1vwjLF.png" srcset="/img/loading.gif" alt="1vwjLF.png"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">10000000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1000000</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">double</span> a[maxn],s[maxn];<br><span class="hljs-keyword">int</span> top,q[maxn];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf"</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        q[++top]=i;<br>        <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">2</span>&amp;&amp;(s[q[top]]-s[i<span class="hljs-number">-1</span>])/(q[top]-(i<span class="hljs-number">-1</span>))&gt;(s[q[top<span class="hljs-number">-1</span>]]-s[q[top]])/(q[top<span class="hljs-number">-1</span>]-q[top]))<br>        &#123;<br>            top--;<br>        &#125;<br>    &#125;<br>    q[top+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=top; i&gt;=<span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">double</span> avg=(s[q[i]]-s[q[i+<span class="hljs-number">1</span>]])/(q[i]-q[i+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = q[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; j &lt;= q[i]; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.10f\n"</span>,avg);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #617 (Div. 3)全题解(A-F)</title>
    <link href="/2020/02/06/Codeforces-Round-617-Div-3-%E5%85%A8%E9%A2%98%E8%A7%A3-A-F/"/>
    <url>/2020/02/06/Codeforces-Round-617-Div-3-%E5%85%A8%E9%A2%98%E8%A7%A3-A-F/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-617-Div-3-全题解-A-F"><a href="#Codeforces-Round-617-Div-3-全题解-A-F" class="headerlink" title="Codeforces Round #617 (Div. 3)全题解(A-F)"></a>Codeforces Round #617 (Div. 3)全题解(A-F)</h1><p>题目地址：<a href="https://codeforces.com/contest/1296" target="_blank" rel="noopener">https://codeforces.com/contest/1296</a></p><h2 id="A-Array-with-Odd-Sum"><a href="#A-Array-with-Odd-Sum" class="headerlink" title="A.Array with Odd Sum"></a>A.Array with Odd Sum</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/167IqP.png" srcset="/img/loading.gif" alt="167IqP.png"></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>判断数组中是否存在奇数即可，可以用奇数替换掉其中的偶数，这样能保证数组之和肯定为奇数。</p><p>但是要注意一点如果是偶数个奇数，也是无解的。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">2000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>            sum+=a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(a[i]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) cnt1++;<br>                <span class="hljs-keyword">else</span> cnt2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt1==<span class="hljs-number">0</span>||cnt2==<span class="hljs-number">0</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<br>            <span class="hljs-keyword">else</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Food-Buying"><a href="#B-Food-Buying" class="headerlink" title="B.Food Buying"></a>B.Food Buying</h2><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/167TVf.png" srcset="/img/loading.gif" alt="167TVf.png"></p><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p>模拟题，贪心就好，每次能买多少买多少，把返利的钱在加到剩余的钱里，以此循环。</p><h3 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-comment">//int a[2000+7];</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">int</span> s=n;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(s&gt;=<span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> tep=s-s%<span class="hljs-number">10</span>;<br>            s=s-tep+tep/<span class="hljs-number">10</span>;<br>            ans+=tep;<br>        &#125;<br>        ans+=s;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Yet-Another-Walking-Robot"><a href="#C-Yet-Another-Walking-Robot" class="headerlink" title="C.Yet Another Walking Robot"></a>C.Yet Another Walking Robot</h2><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/167xrq.png" srcset="/img/loading.gif" alt="167xrq.png"></p><p><img src="https://s2.ax1x.com/2020/02/06/167vMn.png" srcset="/img/loading.gif" alt="167vMn.png"></p><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><p>需要找出最短的字串使得去掉后不影响机器人正常工作。其实就是找一段最短的字串，且按这个字串从头走到尾走还会走到字串开头的那一点。</p><p>我们对前i个左右移动的操作用一个前缀和来维护x</p><p>同理上下移动用也用一个前缀和y来维护。</p><p>我们通过排序来做，按照x为第一关键字，y为第二关键字，pos（次序）为第三关键词来排序。</p><p>然后相邻两两比较就好，如果相邻的两者x，y都相同，两者pos差记录下来。</p><p>只需要不断的比较pos差，找出最小的pos差即可。</p><h3 id="Code：-2"><a href="#Code：-2" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br> <br><span class="hljs-comment">//int a[2000+7];</span><br><span class="hljs-keyword">char</span> s[<span class="hljs-number">200000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> p;<br>&#125;pos[<span class="hljs-number">200000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x==b.x)<br>       &#123;<br>            <span class="hljs-keyword">if</span>(a.y==b.y)<br>            &#123;<br>                <span class="hljs-keyword">return</span> a.p&lt;b.p;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>       &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.x&lt;b.x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) pos[i].p=i;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s+<span class="hljs-number">1</span>);<br>        pos[<span class="hljs-number">0</span>].x=<span class="hljs-number">0</span>;<br>        pos[<span class="hljs-number">0</span>].y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'L'</span>)   &#123;pos[i].x=pos[i<span class="hljs-number">-1</span>].x<span class="hljs-number">-1</span>; pos[i].y=pos[i<span class="hljs-number">-1</span>].y;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'R'</span>) &#123;pos[i].x=pos[i<span class="hljs-number">-1</span>].x+<span class="hljs-number">1</span>; pos[i].y=pos[i<span class="hljs-number">-1</span>].y;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'U'</span>) &#123;pos[i].y=pos[i<span class="hljs-number">-1</span>].y+<span class="hljs-number">1</span>;pos[i].x=pos[i<span class="hljs-number">-1</span>].x;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'D'</span>) &#123;pos[i].y=pos[i<span class="hljs-number">-1</span>].y<span class="hljs-number">-1</span>;pos[i].x=pos[i<span class="hljs-number">-1</span>].x;&#125;<br>        &#125;<br>        sort(pos,pos+<span class="hljs-number">1</span>+n,cmp);<br>        <span class="hljs-keyword">int</span> minn=<span class="hljs-number">100000000</span>,beg=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pos[i].x==pos[i<span class="hljs-number">-1</span>].x&amp;&amp;pos[i].y==pos[i<span class="hljs-number">-1</span>].y)<br>            &#123;<br>                <span class="hljs-keyword">int</span> t2=pos[i].p;<br>                <span class="hljs-keyword">int</span> t1=pos[i<span class="hljs-number">-1</span>].p;<br>                <span class="hljs-keyword">if</span>(minn&gt;<span class="hljs-built_in">abs</span>(t2-t1))<br>                &#123;<br>                    minn=<span class="hljs-built_in">abs</span>(t2-t1);<br>                    beg=<span class="hljs-built_in">min</span>(t2,t1);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(beg==<span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,beg+<span class="hljs-number">1</span>,beg+minn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-Fight-with-Monsters"><a href="#D-Fight-with-Monsters" class="headerlink" title="D.Fight with Monsters"></a>D.Fight with Monsters</h2><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/16HAz9.png" srcset="/img/loading.gif" alt="16HAz9.png"></p><h3 id="题意：-3"><a href="#题意：-3" class="headerlink" title="题意："></a>题意：</h3><p>题目漏掉了一些信息，后来announcement通知到：每次从自己开始打，无论谁打怪兽们都从自己开始打。</p><p>很简单就是排序模拟，但是我们要先对这些怪兽的hp做一些处理，hp[i]=hp[i]%(a+b),这样就知道到最后我们打的时候怪兽还有多少血，值得注意的是处理完后的hp%（a+b）=0时要特殊处理，因为这代表当那个式子等于0时到我们最后打的时候怪兽还有0滴血，也就是已经死了，那么这不是我们最后一次打击，此时hp应该改为hp[i]=a+b</p><p>然后对hp排序后贪心。能用a伤害直接杀死就直接打，不能用控制多打一次，同时k—。以此循环模拟</p><h3 id="Code：-3"><a href="#Code：-3" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br> <br><span class="hljs-keyword">int</span> hp[<span class="hljs-number">200000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,a,b,k;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;hp[i];<br>        hp[i]=hp[i]%(a+b);<br>        <span class="hljs-keyword">if</span>(hp[i]==<span class="hljs-number">0</span>) hp[i]=a+b;<br>    &#125;<br>    sort(hp+<span class="hljs-number">1</span>,hp+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-comment">//for(int i=1;i&lt;=n;i++) printf("%d ",hp[i]);</span><br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(hp[i]&lt;=a) ans++;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> t=hp[i]%a==<span class="hljs-number">0</span>?(hp[i]-a)/a:(hp[i]-a)/a+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(k&gt;=t) &#123;k-=t;ans++;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E1-String-Coloring（easy-version）"><a href="#E1-String-Coloring（easy-version）" class="headerlink" title="E1.String Coloring（easy version）"></a>E1.String Coloring（easy version）</h2><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/16bH3Q.png" srcset="/img/loading.gif" alt="16bH3Q.png"></p><h3 id="题意：-4"><a href="#题意：-4" class="headerlink" title="题意："></a>题意：</h3><p>我们不难发现这样一个规律，第一次我们找出一个上升子序列并给这些点赋值为0，再扫一遍没有赋值的，如果是单调增的那么把他们赋值为1，如果不是单调增的就无法构成，这个画几个例子会很好找到规律并理解为什么的。</p><h3 id="Code：-4"><a href="#Code：-4" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br> <br><span class="hljs-keyword">char</span> s[<span class="hljs-number">200</span>+<span class="hljs-number">9</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;rem;<br>    <span class="hljs-keyword">int</span> beg=s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i]&gt;=beg)<br>        &#123;<br>            rem.push_back(i);<br>            beg=s[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//int siz=rem.size();</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//int cnt2=0;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(rem[cnt]==i)<br>        &#123;<br>            cnt++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            b=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><br>    <span class="hljs-keyword">int</span> st=s[b];<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(rem[cnt]==i)<br>        &#123;<br>            cnt++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i]&gt;=st)  st=s[i];<br>        <span class="hljs-keyword">else</span> flag=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(rem[cnt]==i)<br>            &#123;<br>                cnt++;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E2-String-Coloring（hard-version）"><a href="#E2-String-Coloring（hard-version）" class="headerlink" title="E2.String Coloring（hard version）"></a>E2.String Coloring（hard version）</h2><h3 id="题目：-5"><a href="#题目：-5" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/16HJsI.png" srcset="/img/loading.gif" alt="16HJsI.png"></p><h3 id="题意：-5"><a href="#题意：-5" class="headerlink" title="题意："></a>题意：</h3><p>同样的道理，我们这个可以用dp来做。</p><h3 id="Code：-5"><a href="#Code：-5" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> s[maxn];<br><span class="hljs-keyword">int</span> n,mx=<span class="hljs-number">0</span>,ans[maxn],Max[maxn];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=s[i]+<span class="hljs-number">1</span>; j&lt;=<span class="hljs-string">'z'</span>; j++)<br>            cnt=<span class="hljs-built_in">max</span>(cnt,Max[j]);<br>        cnt++;<br>        Max[s[i]]=cnt;<br>        ans[i]=cnt;<br>        mx=<span class="hljs-built_in">max</span>(mx,cnt);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,mx);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="F-Berland-Beauty"><a href="#F-Berland-Beauty" class="headerlink" title="F.Berland Beauty"></a>F.Berland Beauty</h2><h3 id="题目：-6"><a href="#题目：-6" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://s2.ax1x.com/2020/02/06/16H0Jg.png" srcset="/img/loading.gif" alt="16H0Jg.png"></p><p><img src="https://s2.ax1x.com/2020/02/06/16HwFS.png" srcset="/img/loading.gif" alt="16HwFS.png"></p><h3 id="题意：-6"><a href="#题意：-6" class="headerlink" title="题意："></a>题意：</h3><p>给一颗无根树，你要给每条边赋边权，满足每对到的路径上最小边权为$w_i$。</p><p>树上任意两点之间的路径可以知道的，我们把所有w按从大到小排序，然后<strong>把a到b的路径上的边没有赋边权的全设为w</strong>，<strong>已经有边权的不变</strong>，<strong>同时计算这条路径上最小边权minn，如果最后minn=w，证明赋权成功，否则失败。</strong></p><p>w一定要从大到小，这样才能保证后来的 $w_j$不会覆盖先前的$w_i$  。如果把$w_i$覆盖成了$w_j$ ，那么之前$a_i$到$b_i$的路径上最小边权就不是$w_i$，而是 $w_j$了。</p><h3 id="Code：-6"><a href="#Code：-6" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">5000</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">100000000</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;mp[maxn];<br><span class="hljs-keyword">int</span> ans[maxn][maxn];<br><span class="hljs-keyword">int</span> x[maxn],y[maxn];<br><span class="hljs-keyword">int</span> a[maxn],b[maxn],g[maxn];<br><span class="hljs-keyword">int</span> vis[maxn];<br><span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>,minn=<span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a,b,g,pos;<br>&#125;ask[maxn];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.g&gt;b.g;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==v) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">return</span>;<br>    vis[u]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> sz=mp[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> nxt=mp[u][i];<br>        <span class="hljs-keyword">int</span> last=ans[u][nxt];<br>        <span class="hljs-keyword">int</span> last_min=minn;<br>        <span class="hljs-keyword">if</span>(ans[u][nxt]==inf) &#123;ans[u][nxt]=w;ans[nxt][u]=w;minn=<span class="hljs-built_in">min</span>(minn,w);&#125;<br>        <span class="hljs-keyword">else</span> minn=<span class="hljs-built_in">min</span>(minn,ans[u][nxt]);<br>        dfs(nxt,v,w);<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<br>        ans[u][nxt]=last;<br>        ans[nxt][u]=last;<br>        minn=last_min;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_ans</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5000</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">5000</span>;j++)<br>            ans[i][j]=inf;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x[i],&amp;y[i]);<br>        mp[x[i]].push_back(y[i]);<br>        mp[y[i]].push_back(x[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        ask[i].pos=i;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;ask[i].a,&amp;ask[i].b,&amp;ask[i].g);<br>    &#125;<br>    sort(ask+<span class="hljs-number">1</span>,ask+<span class="hljs-number">1</span>+m,cmp);<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exit</span>=<span class="hljs-number">0</span>;<br>    init_ans();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<span class="hljs-comment">//init</span><br>        flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//init</span><br>        minn=inf;<span class="hljs-comment">//init</span><br>        dfs(ask[i].a,ask[i].b,ask[i].g);<br>        <span class="hljs-keyword">if</span>(minn!=ask[i].g) <span class="hljs-built_in">exit</span>=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exit</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ans[x[i]][y[i]]==inf) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1000000 "</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[x[i]][y[i]]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位DP总结+模板</title>
    <link href="/2020/02/02/%E6%95%B0%E4%BD%8DDP%E6%80%BB%E7%BB%93+%E6%A8%A1%E6%9D%BF+%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/02/02/%E6%95%B0%E4%BD%8DDP%E6%80%BB%E7%BB%93+%E6%A8%A1%E6%9D%BF+%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="数位DP总结-模板"><a href="#数位DP总结-模板" class="headerlink" title="数位DP总结+模板"></a>数位DP总结+模板</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>数位dp是一种计数用的dp，一般就是要统计一个区间[le,ri]内满足一些条件数的个数。所谓数位dp，字面意思就是在数位上进行dp咯。数位还算是比较好听的名字，数位的含义：一个数有个位、十位、百位、千位……数的每一位就是数位啦！<br>之所以要引入数位的概念完全就是为了dp。数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了。</p><h2 id="一种新的枚举方式："><a href="#一种新的枚举方式：" class="headerlink" title="一种新的枚举方式："></a>一种新的枚举方式：</h2><p>两种不同的枚举：对于一个求区间[le,ri]满足条件数的个数，最简单的暴力枚举不方便记忆化，或者说根本无状态可言。<br>新的枚举：控制上界枚举，从最高位开始往下枚举，例如：ri=213，那么我们从百位开始枚举：百位可能的情况有0,1,2(觉得这里枚举0有问题的继续看)</p><p>然后每一位枚举都不能让枚举的这个数超过上界213（下界就是0或者1，这个次要），当百位枚举了1，那么十位枚举就是从0到9，因为百位1已经比上界2小了，后面数位枚举什么都不可能超过上界。所以问题就在于：当高位枚举刚好达到上界是，那么紧接着的一位枚举就有上界限制了。具体的这里如果百位枚举了2，那么十位的枚举情况就是0到1，如果前两位枚举了21，最后一位之是0到3(这一点正好对于代码模板里的一个变量limit 专门用来判断枚举范围)。</p><p>最后一个问题：最高位枚举0：百位枚举0，相当于此时我枚举的这个数最多是两位数，如果十位继续枚举0，那么我枚举的就是以为数咯，因为我们要枚举的是小于等于ri的所以数，当然不能少了位数比ri小的咯！(这样枚举是为了无遗漏的枚举，不过可能会带来一个问题，就是前导零的问题，模板里用lead变量表示，不过这个不是每个题目都是会有影响的，可能前导零不会影响我们计数，具体要看题目)</p><p>由于这种新的枚举只控制了上界所以我们的Main函数总是这样：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> le,ri;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;le,&amp;ri))<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(ri)-solve(le<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数位DP板子-详解："><a href="#数位DP板子-详解：" class="headerlink" title="数位DP板子+详解："></a>数位DP板子+详解：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<br>ll dp[<span class="hljs-number">20</span>][state];<span class="hljs-comment">//不同题目状态不同</span><br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-comment">/*state变量*/</span>,<span class="hljs-keyword">bool</span> lead<span class="hljs-comment">/*前导零*/</span>,<span class="hljs-keyword">bool</span> limit<span class="hljs-comment">/*数位上界变量*/</span>)</span><span class="hljs-comment">//不是每个题都要判断前导零</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了</span><br>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */</span><br>    <span class="hljs-comment">//第二个就是记忆化(在此前可能不同题目还能有一些剪枝)</span><br>    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];<br>    <span class="hljs-comment">/*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/</span><br>    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;<span class="hljs-comment">//根据limit判断枚举的上界up;这个的例子前面用213讲过了</span><br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始计数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)<span class="hljs-comment">//枚举，然后把不同情况的个数加到ans就可以了</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>() ...<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()...<br>        ans+=dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="hljs-number">0</span>,limit &amp;&amp; i==a[pos]) <span class="hljs-comment">//最后两个变量传参都是这样写的</span><br>        <span class="hljs-comment">/*这里还算比较灵活，不过做几个题就觉得这里也是套路了</span><br><span class="hljs-comment">        大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论</span><br><span class="hljs-comment">        去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目</span><br><span class="hljs-comment">        要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，</span><br><span class="hljs-comment">        前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/</span><br>    &#125;<br>    <span class="hljs-comment">//计算完，记录状态</span><br>    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;<br>    <span class="hljs-comment">/*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<span class="hljs-comment">//把数位都分解出来</span><br>    &#123;<br>        a[pos++]=x%<span class="hljs-number">10</span>;<span class="hljs-comment">//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行</span><br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span><span class="hljs-comment">/*从最高位开始枚举*/</span>,<span class="hljs-comment">/*一系列状态 */</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll le,ri;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;le,&amp;ri))<br>    &#123;<br>        <span class="hljs-comment">//初始化dp数组为-1,这里还有更加优美的优化,后面讲</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(ri)-solve(le<span class="hljs-number">-1</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="HDU2089-不要62："><a href="#HDU2089-不要62：" class="headerlink" title="HDU2089-不要62："></a>HDU2089-不要62：</h3><p><strong>就是数位上不能有4也不能有连续的62，没有4的话在枚举的时候判断一下，不枚举4就可以保证状态合法了，所以这个约束没有记忆化的必要，而对于62的话，涉及到两位，当前一位是6或者不是6这两种不同情况我计数是不相同的，所以要用状态来记录不同的方案数。</strong><br><strong>$dp[pos][sta]$表示当前第$pos$位，前一位是否是6的状态，这里sta只需要去0和1两种状态就可以了，不是6的情况可视为同种，不会影响计数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> state,<span class="hljs-keyword">bool</span> limit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];<br>    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">int</span> tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">6</span>&amp;&amp;i==<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//62</span><br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//4</span><br>        tep+=dfs(pos<span class="hljs-number">-1</span>,i ,i==<span class="hljs-number">6</span>,limit&amp;&amp;i==a[pos]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!limit) dp[pos][state]=tep;<br>    <span class="hljs-keyword">return</span> tep;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        a[pos++]=x%<span class="hljs-number">10</span>;<br>        x=x/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l,r;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r)!=EOF&amp;&amp;(l||r))<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="HDU3555-Bomb："><a href="#HDU3555-Bomb：" class="headerlink" title="HDU3555-Bomb："></a>HDU3555-Bomb：</h3><p><strong>一样，这个是不要49</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<br>ll dp[<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];<br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> state,<span class="hljs-keyword">bool</span> limit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];<br>    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;<br>    ll tep=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">4</span>&amp;&amp;i==<span class="hljs-number">9</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//49</span><br>        <span class="hljs-comment">//if(i==4) continue;//4</span><br>        tep+=dfs(pos<span class="hljs-number">-1</span>,i ,i==<span class="hljs-number">4</span>,limit&amp;&amp;i==a[pos]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!limit) dp[pos][state]=tep;<br>    <span class="hljs-keyword">return</span> tep;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        a[pos++]=x%<span class="hljs-number">10</span>;<br>        x=x/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        ll x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,x-solve(x)+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="一些优化技巧："><a href="#一些优化技巧：" class="headerlink" title="一些优化技巧："></a>一些优化技巧：</h2><p><strong>第一:memset(dp,-1,sizeof dp);放在多组数据外面。</strong></p><p>这一点是一个数位特点，使用的条件是：约束条件是每个数自身的属性，而与输入无关。<br>具体的：上一题不要62和4，这个约束对每一个数都是确定的，就是说任意一个数满不满足这个约束都是确定，比如444这个数，它不满足约束条件，不管你输入的区间是多少你都无法改变这个数不满足约束这个事实，这就是数自身的属性（我们每组数据只是在区间计数而已，只能说你输入的区间不包含444的话，我们就不把它统计在内，而无法改变任何事实）。<br>由此，我们保存的状态就可以一直用(注意还有要limit，不同区间是会影响数位在有限制条件下的上限的)<br>这点优化就不给具体题目了，这个还有进一步的扩展。不过说几个我遇到的简单的约束：<br>1.求数位和是10的倍数的个数,这里简化为数位sum%10这个状态，即dp[pos][sum]这里10 是与多组无关的，所以可以memset优化，不过注意如果题目的模是输入的话那就不能这样了。<br>2.求二进制1的数量与0的数量相等的个数，这个也是数自身的属性。</p><h3 id="待补技巧："><a href="#待补技巧：" class="headerlink" title="待补技巧："></a>待补技巧：</h3><p>1.<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4734" target="_blank" rel="noopener">HDU 4734</a> 所用到的相减技巧</p><p>2.<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3709" target="_blank" rel="noopener">HDU 3709</a> 这题就是要枚举中轴，然后数位dp</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP+平行四边形优化总结</title>
    <link href="/2020/02/02/%E5%8C%BA%E9%97%B4DP+%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <url>/2020/02/02/%E5%8C%BA%E9%97%B4DP+%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="区间DP-平行四边形优化总结"><a href="#区间DP-平行四边形优化总结" class="headerlink" title="区间DP+平行四边形优化总结"></a>区间DP+平行四边形优化总结</h1><h2 id="区间DP形式模板："><a href="#区间DP形式模板：" class="headerlink" title="区间DP形式模板："></a>区间DP形式模板：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">//n是区间长度，dp[i][j]存从i 到 j 区间合并的最优值</span><br><span class="hljs-comment">//w[i][j]表示从i 到 j的花费</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>    dp[i][i] = 初始值；<br><span class="hljs-keyword">for</span>(len = <span class="hljs-number">2</span>;len &lt;= n;len++)&#123;<span class="hljs-comment">//len选择区间长度</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<span class="hljs-comment">//枚举起点</span><br>        j = i + len - <span class="hljs-number">1</span>;<span class="hljs-comment">//合并终点</span><br>        <span class="hljs-keyword">if</span>(j &gt; n)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//不可越界</span><br>        <span class="hljs-keyword">for</span>(k = i;k &lt; j;k++)<span class="hljs-comment">//枚举分割点，寻找最优分割</span><br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<span class="hljs-comment">//状态转移</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="平行四边形优化："><a href="#平行四边形优化：" class="headerlink" title="平行四边形优化："></a>平行四边形优化：</h2><p>我们不难发现上面的复杂度为$O（n^3）$，通过平行四边形优化，可以将第三维枚举（枚举最优分割点）的范围大大缩小。</p><h3 id="定理：二位决策单调性"><a href="#定理：二位决策单调性" class="headerlink" title="定理：二位决策单调性"></a>定理：二位决策单调性</h3><p>在转移方程$F[i,j]=min_{i\leq k&lt;j} {F[i,k]+F[k+1,j]+w(i,j)}$中,记$P[i]$为令$F[i,j]$取到最小值的K值。</p><p>如果F满足四边形不等式，那么对于任意$i&lt;j$,有$P[i,j-1]\le P[i,j]\le P[i+1,j]$.</p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>$P[i,j-1]\le P[i,j]\le P[i+1,j]$作为第三维的范围，这样就缩小了寻找最优分割点的次数</p><h3 id="区间DP-四边形优化板子："><a href="#区间DP-四边形优化板子：" class="headerlink" title="区间DP+四边形优化板子："></a>区间DP+四边形优化板子：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br> <br><span class="hljs-comment">//n是区间长度，dp[i][j]存从i 到 j 区间合并的最优值</span><br><span class="hljs-comment">//w[i][j]表示从i 到 j的花费， s[i][j]记录从i 到 j的最优分割点</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>    dp[i][i] = 初始值；<br>    s[i][i] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(len = <span class="hljs-number">2</span>;len &lt;= n;len++)&#123;<span class="hljs-comment">//len选择区间长度</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<span class="hljs-comment">//枚举起点</span><br>        j = i + len - <span class="hljs-number">1</span>;<span class="hljs-comment">//合并终点</span><br>        <span class="hljs-keyword">if</span>(j &gt; n)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//不可越界</span><br>        <span class="hljs-keyword">for</span>(k = s[i][j - <span class="hljs-number">1</span>];k &lt; s[i + <span class="hljs-number">1</span>][j];k++)<span class="hljs-comment">//在最优分割点范围内枚举分割点（四边形优化）</span><br>            <span class="hljs-keyword">if</span>(dp[i][j] &gt; dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j])&#123;<br>                dp[i][j] = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j];<br>                s[i][j] = k;<span class="hljs-comment">//更新最佳分割点</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="例题：HDU3561-Tree-Construction"><a href="#例题：HDU3561-Tree-Construction" class="headerlink" title="例题：HDU3561 Tree Construction"></a>例题：HDU3561 Tree Construction</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3516" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3516</a></p><p>转移方程：$dp[i][j]=min { dp[i][k-1]+dp[k][j] + dis(uni(i,k-1),uni(k,j))}$</p><p>其中$dp[i][j]$表示从$i$到$j$的最优解，$dis(i,j)$表示$i$和$j$之间的曼哈顿距离，$uni(i,j)$表示将$i$和$j$用平行于坐标轴的线段连在一起时的拐角点。</p><p>然后可以证明这是满足四边形优化条件的。</p><p>然后四边形优化一下就好。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">100000000</span>;<br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>][<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-keyword">int</span> s[<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>][<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-keyword">int</span> x[<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>],y[<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x[i],&amp;y[i]);<br>             <span class="hljs-comment">//printf("i=%d\n",i);</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>+<span class="hljs-number">2</span>;i++) &#123; s[i][i]=i;dp[i][i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//init</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;len++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l+len&lt;=n;l++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> r=l+len;<br>                dp[l][r]=inf;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=s[l][r<span class="hljs-number">-1</span>];k&lt;=s[l+<span class="hljs-number">1</span>][r];k++)<span class="hljs-comment">//四边形优化   单调决策性 :[s[i][j-1],s[i+1][j]]</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(dp[l][k]+dp[k+<span class="hljs-number">1</span>][r]+<span class="hljs-built_in">abs</span>(x[k+<span class="hljs-number">1</span>]-x[l])+<span class="hljs-built_in">abs</span>(y[k]-y[r])&lt;=dp[l][r])<br>                    &#123;<br>                        dp[l][r]=dp[l][k]+dp[k+<span class="hljs-number">1</span>][r]+<span class="hljs-built_in">abs</span>(x[k+<span class="hljs-number">1</span>]-x[l])+<span class="hljs-built_in">abs</span>(y[k]-y[r]);<br>                        s[l][r]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">1</span>][n]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 81 (Rated for Div. 2)ABCD题解</title>
    <link href="/2020/01/27/Educational%20Codeforces%20Round%2081%20(Rated%20for%20Div.%202)ABCD%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/27/Educational%20Codeforces%20Round%2081%20(Rated%20for%20Div.%202)ABCD%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Educational-Codeforces-Round-81-Rated-for-Div-2-A-B-C-D题解"><a href="#Educational-Codeforces-Round-81-Rated-for-Div-2-A-B-C-D题解" class="headerlink" title="Educational Codeforces Round 81 (Rated for Div. 2)A,B,C,D题解"></a>Educational Codeforces Round 81 (Rated for Div. 2)A,B,C,D题解</h1><p><strong>比赛链接：<a href="https://codeforces.com/contest/1295" target="_blank" rel="noopener">https://codeforces.com/contest/1295</a></strong></p><h2 id="A-Display-The-Number（思维-构造）"><a href="#A-Display-The-Number（思维-构造）" class="headerlink" title="A.Display The Number（思维+构造）"></a>A.Display The Number（思维+构造）</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p><img src="https://s2.ax1x.com/2020/01/30/11GzEq.png" srcset="/img/loading.gif" alt="11GzEq.png"></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>如果想让构造一个最大的数，我们要使它的位数越多越好，而且使用最少的线段的数字是1（需要两根线段）。当线段的数量为偶数时我们把所有线段都用来构造1，此时构造的数字最大。当数量为奇数时，构造完全1的数字后还剩一根线段，我们肯定要把这根线段用在构造的数字最高位，将1变为7，此时便构造出了最大的数字。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">int</span> ans[<span class="hljs-number">100000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"7\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">int</span> dig=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> lef=n%<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=dig;i++)<br>        &#123;<br>            ans[i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(lef==<span class="hljs-number">1</span>) ans[<span class="hljs-number">1</span>]=<span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=dig;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Infinite-Prefixes（思维-构造转化）"><a href="#B-Infinite-Prefixes（思维-构造转化）" class="headerlink" title="B. Infinite Prefixes（思维+构造转化）"></a>B. Infinite Prefixes（思维+构造转化）</h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p><img src="https://s2.ax1x.com/2020/01/30/11JP8U.png" srcset="/img/loading.gif" alt="11JP8U.png"></p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>对于每一个前缀，我们用ans[i]记录前i个字符的$cnt0-cnt1$的值，同时$k=整个串的cnt0-cnt1=ans[last]$。</p><p>那么比如，$ans[z]=h$，若前面有n个串的$cnt0-cnt1$=$x-h$，那么$x-h+ans[z]=x$,即可以找出一个值为x的串。</p><p>即寻找$n*k=x-h=x-ans[z]$符合这个式子的z和n的对数。</p><p>注意：空串也算答案！</p><h3 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">int</span> ans[<span class="hljs-number">100000</span>+<span class="hljs-number">7</span>];<br><span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n,x,cnt0=<span class="hljs-number">0</span>,cnt1=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;x);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]-<span class="hljs-string">'0'</span>==<span class="hljs-number">0</span>) cnt0++;<br>            <span class="hljs-keyword">else</span> cnt1++;<br>            ans[i]=cnt0-cnt1;<br>        &#125;<br>        <span class="hljs-keyword">int</span> k=cnt0-cnt1,flag=<span class="hljs-number">1</span>,fin=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(ans[i]==x) &#123;flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag&amp;&amp;k==<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((x-ans[i])%k==<span class="hljs-number">0</span>&amp;&amp;(x-ans[i])/k&gt;=<span class="hljs-number">0</span>) fin++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) fin++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,fin);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Obtain-The-String（二分-贪心）"><a href="#C-Obtain-The-String（二分-贪心）" class="headerlink" title="C-Obtain The String（二分+贪心）"></a>C-Obtain The String（二分+贪心）</h2><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><p><img src="https://s2.ax1x.com/2020/01/30/11JeV1.png" srcset="/img/loading.gif" alt="11JeV1.png"></p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p> $pos[x][y]$代表第y个字母x的位置 这个位置有单调性是单增的，我们对t串的每一个字符在s串中进行查询，比如查询字母a,通过二分$dig[a-‘0’][ t  ]$对t二分出第一个大于当前s串指针的位置，如果二分不出来就把指针移到s串开头，从头开始二分，同时ans++。</p><h3 id="Code：-2"><a href="#Code：-2" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">char</span> t[<span class="hljs-number">100000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-keyword">char</span> s[<span class="hljs-number">100000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-keyword">int</span> pos[<span class="hljs-number">27</span>][<span class="hljs-number">100000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,t);<br>        <span class="hljs-keyword">int</span> ed[<span class="hljs-number">27</span>];<br>        <span class="hljs-built_in">memset</span>(ed,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> ed);<br>        <span class="hljs-keyword">int</span> lens=<span class="hljs-built_in">strlen</span>(s);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lens;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> tep=s[i]-<span class="hljs-string">'a'</span>;<br>            ed[tep]++;<br>            pos[tep][ed[tep]]=i;<br>        &#125;<br>        <span class="hljs-keyword">int</span> lent=<span class="hljs-built_in">strlen</span>(t),ans=<span class="hljs-number">1</span>,now=<span class="hljs-number">-1</span>,flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lent;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> tep=t[i]-<span class="hljs-string">'a'</span>;<br>            <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=ed[tep];<br>            <span class="hljs-keyword">if</span>(r==<span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">while</span>(l&lt;r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(pos[tep][mid]&gt;now) r=mid;<br>                <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l==ed[tep]&amp;&amp;pos[tep][l]&lt;=now)<br>            &#123;<br>                now=<span class="hljs-number">-1</span>;<br>                ans++;<br>                i--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> now=pos[tep][l];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-Same-GCDs（辗转相除法转化-phi）"><a href="#D-Same-GCDs（辗转相除法转化-phi）" class="headerlink" title="D-Same GCDs（辗转相除法转化+phi）"></a>D-Same GCDs（辗转相除法转化+phi）</h2><h3 id="题意：-3"><a href="#题意：-3" class="headerlink" title="题意："></a>题意：</h3><p><img src="https://s2.ax1x.com/2020/01/30/11JM8O.png" srcset="/img/loading.gif" alt="11JM8O.png"></p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p><img src="https://s2.ax1x.com/2020/01/30/11ay4I.png" srcset="/img/loading.gif" alt="11ay4I.png"></p><h3 id="Code：-3"><a href="#Code：-3" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">phi</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll result = n; <span class="hljs-comment">// Initialize result as n</span><br>    <span class="hljs-keyword">for</span> (ll p = <span class="hljs-number">2</span>; p * p &lt;= n; ++p) &#123;<br>        <span class="hljs-keyword">if</span> (n % p == <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">while</span> (n % p == <span class="hljs-number">0</span>)<br>                n /= p;<br>            result -= result / p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>        result -= result / n;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll t; <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t--) &#123;<br>        ll a, m;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; m;<br><br>        ll g = __gcd(a, m);<br><br>        m /= g;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; phi(m) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces 449B Jzzhu and Cities（SPFA优化）</title>
    <link href="/2020/01/26/Codeforces-449B-Jzzhu-and-Cities%EF%BC%88SPFA%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <url>/2020/01/26/Codeforces-449B-Jzzhu-and-Cities%EF%BC%88SPFA%E4%BC%98%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-449B-Jzzhu-and-Cities（SPFA优化）"><a href="#Codeforces-449B-Jzzhu-and-Cities（SPFA优化）" class="headerlink" title="Codeforces 449B Jzzhu and Cities（SPFA优化）"></a>Codeforces 449B Jzzhu and Cities（SPFA优化）</h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p><img src="https://s2.ax1x.com/2020/01/26/1mst1S.png" srcset="/img/loading.gif" alt="1mst1S.png"></p><p><img src="https://s2.ax1x.com/2020/01/26/1msYp8.png" srcset="/img/loading.gif" alt="1msYp8.png"></p><h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>讲解：<a href="https://blog.csdn.net/qq_35644234/article/details/61614581" target="_blank" rel="noopener">https://blog.csdn.net/qq_35644234/article/details/61614581</a></p><h2 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h2><p>建图方法很细节（mark一手</p><p>题是spfa裸题，最后判断一下跑出来的最短路和铁路哪个近并且计数就过了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> cnt;<br><span class="hljs-built_in">vector</span> &lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span> &gt; &gt; E[Maxn];<br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-keyword">bool</span> vis[Maxn];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dis[Maxn];<br><span class="hljs-keyword">bool</span> book[Maxn];<br><span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> u,v,w;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        dis[i]=INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);<br>        E[u].push_back(make_pair(v,w));<br>        E[v].push_back(make_pair(u,w));<br>    &#125;<br>    q.push(<span class="hljs-number">1</span>);<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=k; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;v,&amp;w);<br>        <span class="hljs-keyword">if</span>(w&lt;dis[v])<br>        &#123;<br>            dis[v]=w;<br>            vis[v]=<span class="hljs-number">1</span>;<br>            book[v]=<span class="hljs-number">1</span>;<br>            q.push(v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> u=q.front();<br>        q.pop();<br>        vis[u]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;E[u].<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> v=E[u][i].first;<br>            <span class="hljs-keyword">int</span> w=E[u][i].second;<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;=dis[u]+w)<br>            &#123;<br>                dis[v]=dis[u]+w;<br>                book[v]=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(!vis[v])<br>                &#123;<br>                    vis[v]=<span class="hljs-number">1</span>;<br>                    q.push(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">1</span>) ans++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,k-ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces#606,B-Two_Fairs(DFS遍历图，链式前向星，思维)</title>
    <link href="/2020/01/23/Codeforces#606-B-Two-Fairs(DFS%E9%81%8D%E5%8E%86%E5%9B%BE%EF%BC%8C%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%EF%BC%8C%E6%80%9D%E7%BB%B4)/"/>
    <url>/2020/01/23/Codeforces#606-B-Two-Fairs(DFS%E9%81%8D%E5%8E%86%E5%9B%BE%EF%BC%8C%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%EF%BC%8C%E6%80%9D%E7%BB%B4)/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-606-B-Two-Fairs"><a href="#Codeforces-606-B-Two-Fairs" class="headerlink" title="Codeforces #606 B-Two Fairs"></a>Codeforces #606 B-Two Fairs</h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p><a href="https://codeforces.com/contest/1276/problem/b" target="_blank" rel="noopener">https://codeforces.com/contest/1276/problem/b</a></p><p>给出一个连通图（图中每个点都和任意其他点相通），现在给出n个点，m条边，和两个点a，b。求有多少点对一定要经过a，b点。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>通过a点出发进行dfs，设置b点为禁止点（不能访问）,由于这个图是连通图，任意2点都是可达的，那么从a点出发发不通过a的能到达的点代表必须经过b才能到达。<br>那么我们统计：</p><p>a点出发不经过b不能到的点（必须经过b才能到的点） * 从b出发不经过a不能到的点（必须经过a才能到的点） = ans</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-comment">//ans[0]保存a不通过b不能到的点 ans[1]保存b不通过a不能到的点 </span><br><span class="hljs-keyword">int</span> head[N], len, cnt, t, n, m, a, b, u, v, ans[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> vis[N]; <span class="hljs-comment">//看某个点是否访问过  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br><span class="hljs-keyword">int</span> v, next; <br>&#125; e[M * <span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>e[len].v = v;<br>e[len].next = head[u];<br>head[u] = len++;<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> ban)</span> </span>&#123;<br>cnt++; <br>vis[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = head[u]; j; j = e[j].next) &#123;<br>v = e[j].v;<br><span class="hljs-keyword">if</span> (v == ban) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//不能通过ban点</span><br><span class="hljs-keyword">if</span> (!vis[v]) dfs(v, ban); <br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;t);<br><span class="hljs-keyword">while</span> (t--) &#123;<br>len = <span class="hljs-number">1</span>; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;a, &amp;b);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) head[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;u, &amp;v);<br>add(u, v);<br>add(v, u);<br>&#125;<br><span class="hljs-comment">//统计a不能到达那些点（不通过b）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-literal">false</span>;<br>cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//a 能到的点 (不通过b) </span><br>dfs(a, b);  <br>ans[<span class="hljs-number">0</span>] = n - cnt - <span class="hljs-number">1</span>; <span class="hljs-comment">//多减1包括a点 </span><br> <span class="hljs-comment">//统计b不能到达那些点 （不通过a）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-literal">false</span>;<br>cnt = <span class="hljs-number">0</span>;<br>dfs(b, a); <br>ans[<span class="hljs-number">1</span>] = n - cnt - <span class="hljs-number">1</span>;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, (ll)ans[<span class="hljs-number">0</span>] * ans[<span class="hljs-number">1</span>]); <br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ-1077 Eight(康托展开+BFS)</title>
    <link href="/2020/01/19/POJ-1077-Eight-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80-BFS/"/>
    <url>/2020/01/19/POJ-1077-Eight-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80-BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="POJ-1077-康托展开-BFS"><a href="#POJ-1077-康托展开-BFS" class="headerlink" title="POJ-1077 康托展开+BFS"></a>POJ-1077 康托展开+BFS</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="康托展开："><a href="#康托展开：" class="headerlink" title="康托展开："></a>康托展开：</h3><p><a href="https://blog.csdn.net/qq_38701476/article/details/81003290" target="_blank" rel="noopener">https://blog.csdn.net/qq_38701476/article/details/81003290</a></p><p>code（注释详解）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> fac[<span class="hljs-number">15</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-built_in">string</span> path;<br><span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-comment">//u,d,l,r</span><br><span class="hljs-keyword">char</span> index[<span class="hljs-number">5</span>]=<span class="hljs-string">"udlr"</span>;<br><span class="hljs-keyword">int</span> aim=<span class="hljs-number">46234</span>;<span class="hljs-comment">//&#123;1234567890&#125;的cantor展开</span><br><span class="hljs-keyword">bool</span> visit[<span class="hljs-number">900005</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> loc;<span class="hljs-comment">//x的位置</span><br>    <span class="hljs-keyword">int</span> s[<span class="hljs-number">10</span>];<span class="hljs-comment">//3*3的元素构成的棋盘</span><br>    <span class="hljs-built_in">string</span> path;<span class="hljs-comment">//路径</span><br>    <span class="hljs-keyword">int</span> hashval;<span class="hljs-comment">//当前状态对应的hash值</span><br>&#125;chess;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[])</span><span class="hljs-comment">//康托展开</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]&gt;s[j])<br>                cnt++;<br>        &#125;<br>        sum+=cnt*fac[<span class="hljs-number">8</span>-i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;node&gt;q;<br>    node cur;<span class="hljs-comment">//当前棋盘局势</span><br>    node next;<span class="hljs-comment">//下一棋盘局势</span><br>    q.push(chess);<br>    visit[chess.hashval]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//将初始局面先标记为使用过</span><br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        cur=q.front();<span class="hljs-comment">//将node队列头的棋盘局势作为cur</span><br>        q.pop();<span class="hljs-comment">//用过后pop掉这个节点</span><br>        <span class="hljs-keyword">if</span>(cur.hashval==aim)<span class="hljs-comment">//如果当前节点的hashval=aim目标局面的hash值</span><br>        &#123;<br>            path=cur.path;<span class="hljs-comment">//把记录的路径赋给path</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//返回true，退出bfs函数</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> x=cur.loc/<span class="hljs-number">3</span>;<span class="hljs-comment">//当前x的位置的纵坐标</span><br>        <span class="hljs-keyword">int</span> y=cur.loc%<span class="hljs-number">3</span>;<span class="hljs-comment">//当前x的位置的横坐标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//遍历四个方向</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> tempX=x+dir[i][<span class="hljs-number">0</span>];<span class="hljs-comment">//x下一次移动到的位置的横纵坐标</span><br>            <span class="hljs-keyword">int</span> tempY=y+dir[i][<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span>(tempX&lt;<span class="hljs-number">0</span>||tempY&lt;<span class="hljs-number">0</span>||tempX&gt;<span class="hljs-number">2</span>||tempY&gt;<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            next=cur;<span class="hljs-comment">//先把当前节点赋给next，这是为了在cur局面上移动才是next，所以要先赋给next</span><br>            next.loc=<span class="hljs-number">3</span>*tempX+tempY;<span class="hljs-comment">//x下一次移动道德位置的横纵坐标</span><br>            <span class="hljs-comment">//下面将实现x位置与和它相邻位置的转换</span><br>            <span class="hljs-comment">//1.先把将要是x位置中的数放到以前是x的位置</span><br>            next.s[cur.loc]=next.s[next.loc];<br>            <span class="hljs-comment">//2.即将是x的位置转换为x，赋值为0</span><br>            next.s[next.loc]=<span class="hljs-number">0</span>;<br><br>            next.hashval=cantor(next.s);<span class="hljs-comment">//将新的顺序康托展开作为hashval</span><br><br>            <span class="hljs-keyword">if</span>(next.hashval==aim)<br>            &#123;<br>                next.path=cur.path+index[i];<span class="hljs-comment">//记录这次操作index[i]，并加入路径</span><br>                path=next.path;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(visit[next.hashval])<br>                <span class="hljs-keyword">continue</span>;<br>            next.path=cur.path+index[i];<br>            visit[next.hashval]=<span class="hljs-literal">true</span>;<br>            q.push(next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> ch[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span> visit);<span class="hljs-comment">//初始化棋盘全部未访问过</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,ch);<br>        <span class="hljs-keyword">if</span>(ch[<span class="hljs-number">0</span>]==<span class="hljs-string">'x'</span>)<span class="hljs-comment">//如果当前位置为x</span><br>        &#123;<br>            chess.s[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录这个元素的值为0并记录位置</span><br>            chess.loc=i;<span class="hljs-comment">//记录x在几号位置</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            chess.s[i]=ch[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>;<span class="hljs-comment">//记录非x的元素的值所在位置</span><br>        &#125;<br>    &#125;<br>    chess.hashval=cantor(chess.s);<span class="hljs-comment">//将起始状态进行康托展开作为棋盘初始的hashval值</span><br>    <span class="hljs-keyword">bool</span> flag=bfs();<span class="hljs-comment">//对初始局面进行bfs</span><br>    <span class="hljs-keyword">if</span>(flag)<br>        <span class="hljs-built_in">cout</span>&lt;&lt;path&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"unsolvable"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM-树状数组基础</title>
    <link href="/2019/11/01/ACM-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/11/01/ACM-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="ACM-树状数组"><a href="#ACM-树状数组" class="headerlink" title="ACM- 树状数组"></a>ACM- 树状数组</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://oi-wiki.org/ds/images/bit1.png" srcset="/img/loading.gif" alt="img"></h2><p><strong>我们约定</strong>：把上图中参差不齐的白色方格称为 数组$C$，没个$C$都支配着几个数字。</p><p>同时，最下面一行的数字所构成的数组为数组$a$.</p><p><strong>例如</strong>：C[2]管理的是 a[1],a[2].</p><p>C[4]管理的是a[1],a[2],a[3],a[4].</p><p>C[6]管理的是a[5],a[6].</p><p>C[8]管理的是a[1],a[2],a[3],a[4],a[5]……a[8].</p><h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><h3 id="1-lowbit"><a href="#1-lowbit" class="headerlink" title="1.lowbit()"></a>1.lowbit()</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数</span><br>  <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>意义：它可以求出数组c[x]管理几个数组a中的数。</p><p>不难发现，每一个C[i]一定管理的数组a的下表的上限就是a[i]，那么往后找几个数呢，才是C[i]真正的管理范围呢？ </p><p>此时lowbit()函数就派上了用场，我们知道一个数组C[i]所管理的右端点，而且通过lowbit（i）我们就可以知道C[i]管理了几个数，因此我们就可以知道这个数组C[i]</p><p>还是举上图的例子，比如所管理的范围了。</p><h3 id="2-add（x-k）单点修改a-x-a-x-k"><a href="#2-add（x-k）单点修改a-x-a-x-k" class="headerlink" title="2.add（x,k）单点修改a[x]=a[x]+k"></a>2.add（x,k）单点修改a[x]=a[x]+k</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x &lt;= n) &#123;  <span class="hljs-comment">//不能越界</span><br>    c[x] = c[x] + k;<br>    x = x + lowbit(x);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>怎么理解这个函数呢？</p><p>单点修改后我们就要维护数组C的值了，具体维护哪些数组C呢，又怎么找到这些数组C呢？</p><p>比如 a[4]要加上一个数k，C[4]肯定管理着a[4]，C[4]之前的C[i] (i=1.2.3)肯定管理不到a[4]，那么我们只需要往后找。</p><p>我们发现C[4+lowbit[4]]也是。</p><p>因此我们推广后可以猜到：</p><p>c[x] = c[x] + k;<br>x = x + lowbit(x);  便可以将所有C更新。</p><p>同时不要忘记加上边界条件下x&lt;=n  ，这样就完成了单点修改。</p><h3 id="3-区间求和-amp-amp-区间加"><a href="#3-区间求和-amp-amp-区间加" class="headerlink" title="3.区间求和&amp;&amp;区间加"></a>3.区间求和&amp;&amp;区间加</h3><p>首先要介绍差分数组：</p><p>比如 a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]</p><p>​        b[1] b[2] b[3] b[4] b[5] b[6] b[7] b[8]</p><p>其中b[i]=a[i]-a[i-1].</p><p>可是造出这样的一个数组有什么用呢，我们假如进行区间加的话若对每个数字都操作，这样的复杂度显然是很差的。</p><p>我们考虑一下，当我们对数组a区间加上k的时候，所对应的数组b有什么变化呢？</p><p>显而易见，数组b大部分还是没变得，只有区间开头和结尾后一个会变。我们举一个例子就显而易见了，比如我们对a[3-6]同时加上k, b[4-6]都没有变，而b[3]=a[3]-a[2]，b[7]=a[7]-a[6],所以这两个都变了，我们只需要维护两个点就行了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> t1[MAXN], t2[MAXN], n;<br><span class="hljs-comment">//t1为维护得第一个数组 t2为维护的第二个数组</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;          <span class="hljs-comment">//维护更新上述的两个数组t1,t2</span><br>  <span class="hljs-keyword">int</span> v1 = k * v;<br>  <span class="hljs-keyword">while</span> (k &lt;= n) &#123;<br>    t1[k] += v, t2[k] += v1;<br>    k += lowbit(k);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *t, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k) &#123;<br>    ret += t[k];       <span class="hljs-comment">//t[1]+t[2]...+t[k]</span><br>    k -= lowbit(k);    <span class="hljs-comment">//</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>  add(l, v), add(r + <span class="hljs-number">1</span>, -v);       <span class="hljs-comment">//将区间加差分为两个前缀加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getsum1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (r + <span class="hljs-number">1l</span>l) * getsum(t1, r) - <span class="hljs-number">1l</span>l * l * getsum(t1, l - <span class="hljs-number">1</span>) -<br>      (getsum(t2, r) - getsum(t2, l - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-树状数组的O-n-建树，O（logn）查询第K大-小"><a href="#4-树状数组的O-n-建树，O（logn）查询第K大-小" class="headerlink" title="4.树状数组的O(n)建树，O（logn）查询第K大/小"></a>4.树状数组的O(n)建树，O（logn）查询第K大/小</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// O(n)建树</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    t[i] += a[i];<br>    <span class="hljs-keyword">int</span> j = i + lowbit(i);<br>    <span class="hljs-keyword">if</span> (j &lt;= n) t[j] += t[i];<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;  <span class="hljs-comment">//权值树状数组查询第k小</span><br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = log2(n); ~i; --i) &#123;<br>    ret += <span class="hljs-number">1</span> &lt;&lt; i;<br>    <span class="hljs-keyword">if</span> (ret &gt;= n || cnt + t[ret] &gt;= k)<br>      ret -= <span class="hljs-number">1</span> &lt;&lt; i;<br>    <span class="hljs-keyword">else</span><br>      cnt += t[ret];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//时间戳优化add() sum()</span><br><span class="hljs-keyword">int</span> tag[MAXN], t[MAXN], Tag;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; ++Tag; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (k &lt;= n) &#123;<br>    <span class="hljs-keyword">if</span> (tag[k] != Tag) t[k] = <span class="hljs-number">0</span>;<br>    t[k] += v, tag[k] = Tag;<br>    k += lowbit(k);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k) &#123;<br>    <span class="hljs-keyword">if</span> (tag[k] == Tag) ret += t[k];<br>    k -= lowbit(k);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019牛客暑假多校训练（第一场）题解</title>
    <link href="/2019/09/16/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E5%81%87%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89%E9%A2%98%E8%A7%A3/"/>
    <url>/2019/09/16/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E5%81%87%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="2019牛客暑期多校训练营（第一场）"><a href="#2019牛客暑期多校训练营（第一场）" class="headerlink" title="2019牛客暑期多校训练营（第一场）"></a>2019牛客暑期多校训练营（第一场）</h1><h2 id="A-Equivalent-Prefixes"><a href="#A-Equivalent-Prefixes" class="headerlink" title="A-Equivalent Prefixes"></a>A-Equivalent Prefixes</h2><h2 id="（单调栈，思维，笛卡尔树）"><a href="#（单调栈，思维，笛卡尔树）" class="headerlink" title="（单调栈，思维，笛卡尔树）"></a>（单调栈，思维，笛卡尔树）</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> ans1[maxn],ans2[maxn];<br><span class="hljs-keyword">int</span> val1[maxn],val2[maxn];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val,index;<br>&#125;;<br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,i;<br>    <span class="hljs-built_in">stack</span>&lt;node&gt; s;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;val1[i];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;val2[i];<br>        val1[<span class="hljs-number">0</span>]=val2[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;s.top().val&gt;val1[i])<br>            &#123;<br>                ans1[s.top().index]=i;<br>                s.pop();<br>            &#125;<br>            s.push(node&#123;val1[i],i&#125;);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;s.top().val&gt;val2[i])<br>            &#123;<br>                ans2[s.top().index]=i;<br>                s.pop();<br>            &#125;<br>            s.push(node&#123;val2[i],i&#125;);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>             <span class="hljs-keyword">if</span>(ans1[i]!=ans2[i])<br>             <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;i<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Integration"><a href="#B-Integration" class="headerlink" title="B-Integration"></a>B-Integration</h2><h2 id="（数学积分推导，分式分解技巧，快速幂，逆元）"><a href="#（数学积分推导，分式分解技巧，快速幂，逆元）" class="headerlink" title="（数学积分推导，分式分解技巧，快速幂，逆元）"></a>（数学积分推导，分式分解技巧，快速幂，逆元）</h2><p>写这道题首先要知道 部分分式分解 这个技巧：</p><p>假定$p_1$,$p_2$,………$p_n$均为实数，且无重根，例如，考虑如下的变换式求其逆变换：</p><p>$F(s)=\frac{A(s)}{(s-p_1)(s-p_2)(s-p_3)}$</p><p>式子中分母多项式的阶次高于分子多项式的阶次。这时$F(s)$可以分解为以下形式：</p><p>$F(s)=\frac{K_1}{(s-p_1)}+\frac{K_2}{(s-p_2)}+\frac{K_3}{(s-p_3)}$</p><p>其中 $K_i=(s-p_i)F(s)|（s=p_i)$</p><p>知道这个结论后，开开始看原题的那个式子：$\frac{1}{\pi}\int<em>1^\infty\frac{1}{\prod</em>{i=1}^{n}(a^2_i+x^2)}dx$</p><p>先考虑$\frac{1}{\prod_{i=1}^{n}(a^2_i+x^2)}$，我们可以用上面的公式进行变换，得到：</p><p>$\sum<em>{i=1}^n\frac{C_i}{(a^2_i+x^2)}$  其中 $C_i=\frac{1}{\prod</em>{i!=j}^{}(a^2_j-a^2_i)}$</p><p>因此原式：$\frac{1}{\pi}\int<em>1^\infty\frac{1}{\prod</em>{i=1}^{n}(a^2_i+x^2)}dx=\sum_1^n\frac{C_i}{2a_i}\pi$</p><p>所以暴力就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> a[N];<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    a%=Mod;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%Mod;<br>        a = a*a%Mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> qpow(x,Mod<span class="hljs-number">-2</span>);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int32_t</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <br>    ios_base::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i==j) <span class="hljs-keyword">continue</span>;<br>                p = p*((a[j]*a[j]-a[i]*a[i])%Mod)%Mod;<br>            &#125;<br>            p = <span class="hljs-number">2</span>*a[i]*p%Mod;<br>            p = inv(p);<br>            ans = (ans+Mod+p)%Mod;<br>        &#125;<br> <br>        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br> <br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-Euclidean-Distance"><a href="#C-Euclidean-Distance" class="headerlink" title="C-  Euclidean Distance"></a>C-  Euclidean Distance</h2><p>照着唯神的思路写的，没用分数类，导致最后细节太多还是没处理好。<br>放一个正解，没用标解中的拉格朗日乘数法。<br><img src="https://img-blog.csdnimg.cn/20190719233158421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTUzMTMz,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="(数学推导)"></a>(数学推导)</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">10000</span>;<br><span class="hljs-keyword">int</span> m,n;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">frac</span></span><br><span class="hljs-class">&#123;</span><br>    ll p,q;<br>    frac()&#123;&#125;<br>    frac(ll _p,ll _q)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(_p&lt;<span class="hljs-number">0</span>&amp;&amp;_q&lt;<span class="hljs-number">0</span>) _p=-_p,_q=-_q;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span>(_q&lt;<span class="hljs-number">0</span>) _q=-_q,_p=-_p;<br>        <span class="hljs-comment">//cout&lt;&lt;"ce "&lt;&lt;_p&lt;&lt; " "&lt;&lt;_q&lt;&lt;endl;</span><br>        p=_p/__gcd(<span class="hljs-built_in">abs</span>(_p),<span class="hljs-built_in">abs</span>(_q));<br>        q=_q/__gcd(<span class="hljs-built_in">abs</span>(_p),<span class="hljs-built_in">abs</span>(_q));<br>        <span class="hljs-comment">//cout&lt;&lt;"ce "&lt;&lt;p&lt;&lt; " "&lt;&lt;q&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> frac &amp;x) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> p*x.q&lt;q*x.p;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;= (<span class="hljs-keyword">const</span> frac &amp;x) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> p*x.q&lt;=q*x.p;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> frac &amp;x) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> p==x.p&amp;&amp;q==x.q;<br>    &#125;<br>    frac <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> frac &amp;x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> frac(p*x.q+q*x.p,q*x.q);<br>    &#125;<br>    frac <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> frac &amp;x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> frac(p*x.p,q*x.q);<br>    &#125;<br>    frac <span class="hljs-keyword">operator</span> / (<span class="hljs-keyword">const</span> frac &amp;x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> frac(p*x.q,q*x.p);<br>    &#125;<br>    frac <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> frac &amp;x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> frac(p*x.q-q*x.p,q*x.q);<br>    &#125;<br>&#125;a[maxn+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);<br>            a[i]=frac(x,m);<br>        &#125;<br>        sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//for(int i=1;i&lt;=n;++i) cout&lt;&lt;a[i].p&lt;&lt;" "&lt;&lt;a[i].q&lt;&lt;endl;</span><br>        <span class="hljs-function">frac <span class="hljs-title">now</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">frac <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">frac <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i)<br>            <span class="hljs-keyword">if</span>((a[i+<span class="hljs-number">1</span>]-a[i])*now&lt;=left) left=left-(a[i+<span class="hljs-number">1</span>]-a[i])*now,now.p+=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pos=a[i+<span class="hljs-number">1</span>]-left/now;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>       <span class="hljs-comment">// cout&lt;&lt;"left : "&lt;&lt;left.p&lt;&lt;" "&lt;&lt;left.q&lt;&lt;endl;</span><br>        <span class="hljs-comment">//cout&lt;&lt;now.p&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(pos.p==<span class="hljs-number">0</span>&amp;&amp;pos.q==<span class="hljs-number">0</span>)<br>        &#123;<br>           <span class="hljs-comment">// assert(now.p==n);</span><br>           <span class="hljs-comment">//a[1]-left/now</span><br>            <span class="hljs-comment">//cout&lt;&lt;"ok"&lt;&lt;endl;</span><br>            pos=a[<span class="hljs-number">1</span>]-left/now;<br>            <span class="hljs-comment">//cout&lt;&lt;pos.p&lt;&lt;" "&lt;&lt;pos.q&lt;&lt;endl;</span><br>        &#125;<br>        <span class="hljs-function">frac <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+now.p&lt;=n;++i) ans=ans+a[i]*a[i];<br>        ans=ans+now*pos*pos;<br>        <span class="hljs-keyword">if</span>(ans.p==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans.q==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans.p);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld/%lld\n"</span>,ans.p,ans.q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="F-Random-Point-in-Triangle"><a href="#F-Random-Point-in-Triangle" class="headerlink" title="F-Random Point in Triangle"></a>F-Random Point in Triangle</h2><h2 id="数学推导，期望"><a href="#数学推导，期望" class="headerlink" title="(数学推导，期望)"></a>(数学推导，期望)</h2><p>选三个中点，连接中线，利用中心的性质即可得出，具体推倒不算特别简单，还需要再画辅助线，代换等数学推导。</p><p>其实最简单的方法就是猜性质，我们画一个特例的等边三角形来算，这样节省了许多不必要的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br> <br><span class="hljs-function"><span class="hljs-keyword">int32_t</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <br>    ios_base::sync_with_stdio(<span class="hljs-literal">false</span>);<span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">int</span> x1,x2,x3,y1,y2,y3;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3)&#123;<br>        <span class="hljs-keyword">int</span> s = (x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2)*<span class="hljs-number">11</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">abs</span>(s)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="J-Fraction-Comparision"><a href="#J-Fraction-Comparision" class="headerlink" title="J-Fraction Comparision"></a>J-Fraction Comparision</h2><h2 id="签到题"><a href="#签到题" class="headerlink" title="(签到题)"></a>(签到题)</h2><p>C++:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,a,y,b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld"</span>,&amp;x,&amp;a,&amp;y,&amp;b)!=EOF)&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> i,o;<br>        i=x/a;<br>        o=y/b;<br>        <span class="hljs-keyword">if</span>(i&gt;o)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"&gt;\n"</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;o) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;\n"</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            x=x%a*b;y=y%b*a;<br>            <span class="hljs-keyword">if</span>(x&gt;y)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"&gt;\n"</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;y) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;\n"</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"=\n"</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br> <br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    a,b,c,d = map(int,line.split(<span class="hljs-string">' '</span>))<br>    <span class="hljs-keyword">if</span> a*d&gt;b*c:<br>        print(<span class="hljs-string">'&gt;'</span>)<br>    <span class="hljs-keyword">elif</span> a*d==b*c:<br>        print(<span class="hljs-string">'='</span>)<br>    <span class="hljs-keyword">elif</span> a*d&lt;b*c:<br>        print(<span class="hljs-string">'&lt;'</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-牛客多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM-思维构造题（2019暑假集训）</title>
    <link href="/2019/09/16/ACM-%E6%80%9D%E7%BB%B4%E6%9E%84%E9%80%A0%E9%A2%98%EF%BC%882019%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%EF%BC%89/"/>
    <url>/2019/09/16/ACM-%E6%80%9D%E7%BB%B4%E6%9E%84%E9%80%A0%E9%A2%98%EF%BC%882019%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="HDU-1214-圆桌会议"><a href="#HDU-1214-圆桌会议" class="headerlink" title="HDU-1214    圆桌会议"></a>HDU-1214    圆桌会议</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1214" target="_blank" rel="noopener">题目链接</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>HDU ACM集训队的队员在暑假集训时经常要讨论自己在做题中遇到的问题.每当面临自己解决不了的问题时,他们就会围坐在一张圆形的桌子旁进行交流,经过大家的讨论后一般没有解决不了的问题,这也只有HDU ACM集训队特有的圆桌会议,有一天你也可以进来体会一下哦:),在一天在讨论的时候,Eddy想出了一个极为古怪的想法,如果他们在每一分钟内,一对相邻的两个ACM队员交换一下位子,那么要多少时间才能得到与原始状态相反的座位顺序呢?(即对于每个队员，原先在他左面的队员后来在他右面，原先在他右面的队员在他左面),这当然难不倒其他的聪明的其他队友们,马上就把这个古怪的问题给解决了,你知道是怎么解决的吗?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>对于给定数目N(1&lt;=N&lt;=32767)，表示有N个人,求要多少时间才能得到与原始状态相反的座位顺序(reverse)即对于每个人，原先在他左面的人后来在他右面，原先在他右面的人在他左面。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个数据输出一行，表示需要的时间(以分钟为单位)</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>4<br>5<br>6</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>2<br>4<br>6</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">int</span> m=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> sum=((m<span class="hljs-number">-1</span>)*m)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>            sum+=sum+m;<br>        <span class="hljs-keyword">else</span><br>            sum+=sum;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,sum);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Ehab-and-the-Expected-XOR-Problem"><a href="#Ehab-and-the-Expected-XOR-Problem" class="headerlink" title="Ehab and the Expected XOR Problem"></a>Ehab and the Expected XOR Problem</h1><h1 id="CodeForces-1174D"><a href="#CodeForces-1174D" class="headerlink" title="CodeForces - 1174D"></a>CodeForces - 1174D</h1><p>Given two integers n and x, construct an array that satisfies the following conditions:</p><p>for any element ai in the array, 1≤ai&lt;2n;<br>there is no non-empty subsegment with bitwise XOR equal to 0 or x,<br>its length l should be maximized.<br>A sequence b is a subsegment of a sequence a if b can be obtained from a by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>The only line contains two integers n and x (1≤n≤18, 1≤x&lt;218).</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>The first line should contain the length of the array l.</p><p>If l is positive, the second line should contain l space-separated integers a1, a2, …, al (1≤ai&lt;2n) — the elements of the array a.</p><p>If there are multiple solutions, print any of them.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>3 5</p><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><p>3<br>6 1 3</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>2 4</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>3<br>1 3 1 </p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>1 1</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>0</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> s[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)];<br><span class="hljs-keyword">int</span> ex[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)];<br><span class="hljs-keyword">int</span> go=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;x);<br>    <span class="hljs-keyword">if</span>(x&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i^(i<span class="hljs-number">-1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ex[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!ex[i^x])<br>            &#123;<br>                ex[i]=<span class="hljs-number">1</span>;<br>                s[cnt]=i;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,cnt<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,s[i]^s[i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="The-LCMs-Must-be-Large"><a href="#The-LCMs-Must-be-Large" class="headerlink" title="The LCMs Must be Large"></a>The LCMs Must be Large</h1><h1 id="CodeForces-1166E"><a href="#CodeForces-1166E" class="headerlink" title="CodeForces - 1166E"></a>CodeForces - 1166E</h1><p>Dora the explorer has decided to use her money after several years of juicy royalties to go shopping. What better place to shop than Nlogonia?</p><p>There are n stores numbered from 1 to n in Nlogonia. The i-th of these stores offers a positive integer ai.</p><p>Each day among the last m days Dora bought a single integer from some of the stores. The same day, Swiper the fox bought a single integer from all the stores that Dora did not buy an integer from on that day.</p><p>Dora considers Swiper to be her rival, and she considers that she beat Swiper on day i if and only if the least common multiple of the numbers she bought on day i is strictly greater than the least common multiple of the numbers that Swiper bought on day i.</p><p>The least common multiple (LCM) of a collection of integers is the smallest positive integer that is divisible by all the integers in the collection.</p><p>However, Dora forgot the values of ai. Help Dora find out if there are positive integer values of ai such that she beat Swiper on every day. You don’t need to find what are the possible values of ai though.</p><p>Note that it is possible for some values of ai to coincide in a solution.</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integers m and n (1≤m≤50, 1≤n≤104) — the number of days and the number of stores.</p><p>After this m lines follow, the i-th line starts with an integer si (1≤si≤n−1), the number of integers Dora bought on day i, followed by si distinct integers, the indices of the stores where Dora bought an integer on the i-th day. The indices are between 1 and n.</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>Output must consist of a single line containing “possible” if there exist positive integers ai such that for each day the least common multiple of the integers bought by Dora is strictly greater than the least common multiple of the integers bought by Swiper on that day. Otherwise, print “impossible”.</p><p>Note that you don’t have to restore the integers themselves.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>2 5<br>3 1 2 3<br>3 3 4 5</p><h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>possible</p><h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>10 10<br>1 1<br>1 2<br>1 3<br>1 4<br>1 5<br>1 6<br>1 7<br>1 8<br>1 9<br>1 10</p><h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>impossible</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first sample, a possible choice for the values of the ai is 3,4,3,5,2. On the first day, Dora buys the integers 3,4 and 3, whose LCM is 12, while Swiper buys integers 5 and 2, whose LCM is 10. On the second day, Dora buys 3,5 and 2, whose LCM is 30, and Swiper buys integers 3 and 4, whose LCM is 12.</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">bitset</span>&lt;11111&gt; b[<span class="hljs-number">55</span>],t;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,n,m,k,x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ++i)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;k;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;k; ++j)<br>            <span class="hljs-built_in">cin</span>&gt;&gt;x,b[i][x]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ++i)<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;n; ++j)<br>        &#123;<br>            t=b[i]&amp;b[j];<br>            <span class="hljs-keyword">if</span>(t.count()==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"impossible"</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"possible"</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Frog-and-Portal"><a href="#Frog-and-Portal" class="headerlink" title="Frog and Portal"></a>Frog and Portal</h1><h1 id="HihoCoder-1873"><a href="#HihoCoder-1873" class="headerlink" title="HihoCoder - 1873"></a>HihoCoder - 1873</h1><p>A small frog wants to get to the other side of a river. The frog is initially located at one bank of the river (position 0) and wants to get to the other bank (position 200). Luckily, there are 199 leaves (from position 1 to position 199) on the river, and the frog can jump between the leaves. When at position p, the frog can jump to position p+1 or position p+2.</p><p>How many different ways can the small frog get to the bank at position 200? This is a classical problem. The solution is the 201st number of Fibonacci sequence. The Fibonacci sequence is constructed as follows: F1=F2=1;Fn=Fn-1+Fn-2.</p><p>Now you can build some portals on the leaves. For each leaf, you can choose whether to build a portal on it. And you should set a destination for each portal. When the frog gets to a leaf with a portal, it will be teleported to the corresponding destination immediately. If there is a portal at the destination, the frog will be teleported again immediately. If some portal destinations form a cycle, the frog will be permanently trapped inside. Note that You cannot build two portals on the same leaf.</p><p>Can you build the portals such that the number of different ways that the small frog gets to position 200 from position 0 is M?</p><h3 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h3><p>There are no more than 100 test cases.</p><p>Each test case consists of an integer M, indicating the number of ways that the small frog gets to position 200 from position 0. (0 ≤ M &lt; 232)</p><h3 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h3><p>For each test case:</p><p>The first line contains a number K, indicating the number of portals.</p><p>Then K lines follow. Each line has two numbers ai and bi, indicating that you place a portal at position ai and it teleports the frog to position bi.</p><p>You should guarantee that 1 ≤ K, ai, bi ≤ 199, and ai ≠ aj if i ≠ j. If there are multiple solutions, any one of them is acceptable.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>0<br>1<br>5</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>2<br>1 1<br>2 1<br>2<br>1 199<br>2 2<br>2<br>4 199<br>5 5</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n)!=EOF)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"65\n"</span>);<br>        <span class="hljs-keyword">if</span>(n&amp;(<span class="hljs-number">1l</span>l&lt;&lt;<span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 199\n"</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 1\n"</span>);<br>        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">32</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %lld\n"</span>,<span class="hljs-number">5</span>+(i<span class="hljs-number">-1</span>)*<span class="hljs-number">6</span>,<span class="hljs-number">5</span>+(i<span class="hljs-number">-1</span>)*<span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">if</span>(n&amp;(<span class="hljs-number">1l</span>l&lt;&lt;i))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld 199\n"</span>,<span class="hljs-number">7</span>+(i<span class="hljs-number">-1</span>)*<span class="hljs-number">6</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %lld\n"</span>,<span class="hljs-number">7</span>+(i<span class="hljs-number">-1</span>)*<span class="hljs-number">6</span>,<span class="hljs-number">7</span>+(i<span class="hljs-number">-1</span>)*<span class="hljs-number">6</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"197 197\n"</span>);<span class="hljs-comment">//no</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"198 198\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Snake-Carpet-UVALive-7269"><a href="#Snake-Carpet-UVALive-7269" class="headerlink" title="Snake Carpet UVALive - 7269"></a>Snake Carpet UVALive - 7269</h1><p><a href="https://vjudge.net/problem/UVALive-7269" target="_blank" rel="noopener">题目链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">int</span> wide1,height1,wide2,height2;<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) height1=wide1=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> height1=wide1=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(n/<span class="hljs-number">2</span>%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>        &#123;<br>            wide2=n/<span class="hljs-number">2</span>;<br>            height2=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;wide2=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;height2=n/<span class="hljs-number">2</span>;&#125;<br>        <span class="hljs-keyword">if</span>(wide1==height2)<br>        &#123;<br>            <span class="hljs-keyword">int</span> newheight=wide1,newwide=wide1+wide2;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,newheight,newwide);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<span class="hljs-comment">//left</span><br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;t++)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,t);<br>                    &#125;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//right</span><br>                &#123;<br>                     <span class="hljs-keyword">if</span>(i/<span class="hljs-number">2</span>%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                     &#123;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=i/<span class="hljs-number">2</span>;t++)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t,i/<span class="hljs-number">2</span>+wide1);<br>                         &#125;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=i/<span class="hljs-number">2</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t,i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+wide1);<br>                         &#125;<br>                         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                     &#125;<br>                     <span class="hljs-keyword">else</span><br>                     &#123;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=i/<span class="hljs-number">2</span>;t++)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,i/<span class="hljs-number">2</span>,t+wide1);<br>                         &#125;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=i/<span class="hljs-number">2</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,t+wide1);<br>                         &#125;<br>                         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                     &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> newheight=wide1+height2,newwide=wide1;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,newheight,newwide);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<span class="hljs-comment">//left</span><br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;t++)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,t);<br>                    &#125;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//right</span><br>                &#123;<br>                     <span class="hljs-keyword">if</span>(i/<span class="hljs-number">2</span>%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                     &#123;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=i/<span class="hljs-number">2</span>;t++)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t+wide1,i/<span class="hljs-number">2</span>);<br>                         &#125;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=i/<span class="hljs-number">2</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,t+wide1,i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>                         &#125;<br>                         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                     &#125;<br>                     <span class="hljs-keyword">else</span><br>                     &#123;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=i/<span class="hljs-number">2</span>;t++)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,i/<span class="hljs-number">2</span>+wide1,t);<br>                         &#125;<br>                         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=i/<span class="hljs-number">2</span>;t&gt;=<span class="hljs-number">1</span>;t--)<br>                         &#123;<br>                             <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+wide1,t);<br>                         &#125;<br>                         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>                     &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="The-minimal-unique-substring"><a href="#The-minimal-unique-substring" class="headerlink" title="The minimal unique substring"></a>The minimal unique substring</h1><h1 id="CodeForces-1158B"><a href="#CodeForces-1158B" class="headerlink" title="CodeForces - 1158B"></a>CodeForces - 1158B</h1><p>Let s be some string consisting of symbols “0” or “1”. Let’s call a string t a substring of string s, if there exists such number 1≤l≤|s|−|t|+1 that t=slsl+1…sl+|t|−1. Let’s call a substring t of string s unique, if there exist only one such l.</p><p>For example, let s=”1010111”. A string t=”010” is an unique substring of s, because l=2 is the only one suitable number. But, for example t=”10” isn’t a unique substring of s, because l=1 and l=3 are suitable. And for example t=”00” at all isn’t a substring of s, because there is no suitable l.</p><p>Today Vasya solved the following problem at the informatics lesson: given a string consisting of symbols “0” and “1”, the task is to find the length of its minimal unique substring. He has written a solution to this problem and wants to test it. He is asking you to help him.</p><p>You are given 2 positive integers n and k, such that (nmod2)=(kmod2), where (xmod2) is operation of taking remainder of x by dividing on 2. Find any string s consisting of n symbols “0” or “1”, such that the length of its minimal unique substring is equal to k.</p><h3 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers n and k, separated by spaces (1≤k≤n≤100000, (kmod2)=(nmod2)).</p><h3 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h3><p>Print a string s of length n, consisting of symbols “0” and “1”. Minimal length of the unique substring of s should be equal to k. You can find any suitable string. It is guaranteed, that there exists at least one such string.</p><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><h3 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h3><p>4 4</p><h3 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h3><p>1111</p><h3 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h3><p>5 3</p><h3 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h3><p>01010</p><h3 id="Input-12"><a href="#Input-12" class="headerlink" title="Input"></a>Input</h3><p>7 3</p><h3 id="Output-12"><a href="#Output-12" class="headerlink" title="Output"></a>Output</h3><p>1011011</p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>In the first test, it’s easy to see, that the only unique substring of string s=”1111” is all string s, which has length 4.</p><p>In the second test a string s=”01010” has minimal unique substring t=”101”, which has length 3.</p><p>In the third test a string s=”1011011” has minimal unique substring t=”110”, which has length 3.</p><p><a href="https://www.cnblogs.com/dd-bond/p/10858347.html" target="_blank" rel="noopener">详细题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,k;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,(i%((n-k)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&gt;<span class="hljs-number">0</span>));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM-构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
