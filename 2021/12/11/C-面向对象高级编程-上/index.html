

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <link rel="icon" type="image/png" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chillstep">
  <meta name="keywords" content="">
  <title>C++面向对象高级编程-上 - Chillstep</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chillstepp.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chillstep</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sdqryn.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++面向对象高级编程-上">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-11 16:11" pubdate>
        2021年12月11日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      44
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++面向对象高级编程-上</h1>
            
            <div class="markdown-body">
              <h1 id="C-面向对象高级编程"><a href="#C-面向对象高级编程" class="headerlink" title="C++面向对象高级编程"></a>C++面向对象高级编程</h1><h2 id="header头文件防卫式声明"><a href="#header头文件防卫式声明" class="headerlink" title="header头文件防卫式声明"></a>header头文件防卫式声明</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209230451166.png" srcset="/img/loading.gif" alt="image-20211209230451166"></p>
<p>这是一种防卫式声明，防卫式声明的作用是：防止由于同一个头文件被包含多次，而导致了重复定义。防卫式声明表示，如果<code>__COMPLEX__</code>没有被定义过，那么就展开定义，否则跳过。</p>
<p><code>__COMPLEX__</code>被称为<strong>预处理器变量</strong>一般有两种状态：已定义或未定义。</p>
<ul>
<li><code>#ifndef</code> 指示检测指定的预处理器变量是否未定义，如果未定义，那么跟在后面的所有指示被处理，直到出现#endif；如果已定义，那么#ifndef测试为假，该指示和#endif指示间的代码都被忽略。</li>
<li><code>#define</code>指示接受一个名字并定义该名字为预处理器变量。</li>
</ul>
<p>一个例子：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">-- <span class="hljs-string">"Car.h"</span>，代码如下（并没有添加防卫式声明）：<br><span class="hljs-comment">// Car.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// ...</span><br>&#125;;<br>-- <span class="hljs-string">"Person.h"</span>，代码如下（包含了Car.h文件）：<br><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Car.h"</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Car car;<br>&#125;;<br>-- 在<span class="hljs-string">"main.cpp"</span>中，我们同时include两个头文件：<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Car.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Person.h"</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> &lt;br&gt;</span>&#123;<br>    Person p;<br>&#125;<br>此时，我们会发现编译出错：Redefinition of 'Car'.<br></code></pre></div></td></tr></table></figure>
<p>我们需要知道，在预编译阶段，编译器会把.h文件展开，即main.cpp中的代码可以看做是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Car car;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    Person p;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h2><p>我们如果希望double类型的实部和虚部变成int，那么我们需要重写一个几乎一样的complex类，这是我们所不希望的：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209231326729.png" srcset="/img/loading.gif" alt="image-20211209231326729"></p>
<p>因此出现了模板：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209231508596.png" srcset="/img/loading.gif" alt="image-20211209231508596"></p>
<p>我们先把类型设为T，使用时根据所写的类型再将T绑定为各种类型。</p>
<h2 id="inline内敛函数"><a href="#inline内敛函数" class="headerlink" title="inline内敛函数"></a>inline内敛函数</h2><p>首先了解一下什么是内敛函数？</p>
<p><strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>），用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。</p>
<ul>
<li>如果你的函数写在class定义里，那么这个函数会成为<strong>inline函数</strong>的候选人，具体内敛与否还要看编译器自己。</li>
</ul>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209232037127.png" srcset="/img/loading.gif" alt="image-20211209232037127"></p>
<ul>
<li>你也可以给函数前加上inline，但是这只是你对编译器的<strong>建议</strong>，具体内敛与否还要看编译器自己。</li>
</ul>
<h2 id="access-level访问级别"><a href="#access-level访问级别" class="headerlink" title="access level访问级别"></a>access level访问级别</h2><p><strong>private,public,protected的访问范围:</strong></p>
<p><strong>private:</strong> 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br><strong>protected:</strong> 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br><strong>public:</strong> 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p>
<p><strong>类的继承后方法属性变化:</strong><br><strong>使用private继承</strong>,父类的所有方法在子类中变为private;<br><strong>使用protected继承</strong>,父类的protected和public方法在子类中变为protected,private方法不变;<br><strong>使用public继承</strong>,父类中的方法属性不发生改变;</p>
<h2 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h2><p>C++ 类构造函数可以用<strong>初始化列表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r=<span class="hljs-number">0</span>,<span class="hljs-keyword">double</span> i=<span class="hljs-number">0</span>):re(r),im(i)&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">complex</span>(<span class="hljs-keyword">double</span> r=<span class="hljs-number">0</span>,<span class="hljs-keyword">double</span> i=<span class="hljs-number">0</span>)&#123;re=r;im=i;&#125;<br></code></pre></div></td></tr></table></figure>
<p>但我们尽量用第一种，第一种写法更正规，这是构造函数特有的写法(指<code>:re(r),im(i){}</code>)。</p>
<h2 id="构造函数的重载overloading"><a href="#构造函数的重载overloading" class="headerlink" title="构造函数的重载overloading"></a>构造函数的重载overloading</h2><p>函数是可以重载overloading的，即参数不同，但是函数名相同，调用函数时编译器会自动选择参数对应的函数，<strong>重载的几个同名函数本质上都是各不相同的函数</strong>：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209234150840.png" srcset="/img/loading.gif" alt="image-20211209234150840"></p>
<p>这种是正确的吗？</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209234407554.png" srcset="/img/loading.gif" alt="image-20211209234407554"></p>
<p>比如定义一个<code>complex c</code>此时编译器发现这两者都可以使用一个是全是默认参数，另一个是无参，编译器认为都可以，所以此时这两者是不能一起存在的。</p>
<h2 id="构造函数放在private的意义—单例模式"><a href="#构造函数放在private的意义—单例模式" class="headerlink" title="构造函数放在private的意义—单例模式"></a>构造函数放在private的意义—单例模式</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209234847158.png" srcset="/img/loading.gif" alt="image-20211209234847158"></p>
<p>此时是不能调用构造函数的，所以这种做法一定不可能出现吗？并不是，当你不希望被外界创建对象时可以使用，那么这样的一个类还有什么用呢？<strong>单例模式</strong>。（下面内容建议先浏览<code>static静态：静态变量，静态函数</code>这一节）</p>
<p>没有任何人可以创建A类，A类只有一个对象a一开始就被创造好等待被初始化。 </p>
<ul>
<li><p>外界想获得这唯一的a：通过<code>getInstance()</code>函数</p>
</li>
<li><p>外界想修改这个唯一的a：通过<code>A::getInstance().setup(...);</code></p>
</li>
</ul>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209235038633.png" srcset="/img/loading.gif" alt="image-20211209235038633"></p>
<h2 id="常量成员函数const"><a href="#常量成员函数const" class="headerlink" title="常量成员函数const"></a>常量成员函数const</h2><p>成员函数可以分为两种：会改变数据的和不会改变数据的，不会改变数据的十分建议加上const，表示这个成员函数不能改变成员变量。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209235254760.png" srcset="/img/loading.gif" alt="image-20211209235254760"></p>
<p>不管你的函数加没加<code>const</code>，这么用是没问题的：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209235536414.png" srcset="/img/loading.gif" alt="image-20211209235536414"></p>
<p>但是如果一个<code>const</code>类型的对象 <code>real()</code>和<code>imag()</code>函数没加<code>const</code>，下面这种用法就是错误的：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209235629111.png" srcset="/img/loading.gif" alt="image-20211209235629111"></p>
<p>因为希望complex的成员变量是不可以被改变的，而你的real，imag函数却不是const类型的，表示你有可能会改变他们，因此编译器不会让这种危险的事情发生，编译错误。</p>
<p><strong>最后总结：</strong></p>
<p>除了下面的表格总结外，我们还有一条c++中的重要法则： </p>
<p><strong>当成员函数const和non-const版本同时存在，const对象只会调用const版本，non-const对象只会调用non-const版本。</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211220021543751.png" srcset="/img/loading.gif" alt="image-20211220021543751"></p>
<h2 id="传参：by-value-by-reference"><a href="#传参：by-value-by-reference" class="headerlink" title="传参：by value/by reference"></a>传参：by value/by reference</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210000143936.png" srcset="/img/loading.gif" alt="image-20211210000143936"></p>
<p>引用<strong>占四个字节</strong>的内存(本质是一个指针)。</p>
<p>我们尽量都传引用，因为他普遍来说更快，但是引用有可能会改变原来的值，如果我们不希望这种情况发生，那么可以利用(const complex&amp;)的方法，使得参数无法修改。</p>
<p>pass by reference(to const)的一个小例子</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*pass by reference*/</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> &amp;a = c;<br>a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出5，这个引用时可以修改引用值的</span><br><br><span class="hljs-comment">/*pass by reference(to const)*/</span><br></code></pre></div></td></tr></table></figure>
<h2 id="友元friend"><a href="#友元friend" class="headerlink" title="友元friend"></a>友元friend</h2><p>一份更仔细的介绍: <a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210001054480.png" srcset="/img/loading.gif" alt="image-20211210001054480"></p>
<p>友元不是成员函数，但是它<strong>可以访问类中的私有成员</strong>，但他会破坏c++类的封装性，尽量少用，规范的用。</p>
<h2 id="相同class的各个对象互为友元"><a href="#相同class的各个对象互为友元" class="headerlink" title="相同class的各个对象互为友元"></a>相同class的各个对象互为友元</h2><p>看一下下面的问题：没有friend的字眼，为什么func可以直接访问private里的实部和虚部呢？</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210001343468.png" srcset="/img/loading.gif" alt="image-20211210001343468"></p>
<p>可以这么解释：相同class的各个对象互为友元</p>
<h2 id="this和重载运算符函数的设计"><a href="#this和重载运算符函数的设计" class="headerlink" title="this和重载运算符函数的设计"></a>this和重载运算符函数的设计</h2><p>这两者等价，this是一个隐藏的指针(但你不能在参数列写出来，this是已经默认存在的)，谁调用这个函数谁就是this</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210003518533.png" srcset="/img/loading.gif" alt="image-20211210003518533"></p>
<p>对于重载运算符，如果我们只用c2+=c1这种，那么你写：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">complex</span>&amp; <span class="hljs-built_in">complex</span>::<span class="hljs-keyword">operator</span>+=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; r）<br>&#123;<br>	<span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">complex</span>::<span class="hljs-keyword">operator</span>+=（<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; r）<br>&#123;<br>	__doapl(<span class="hljs-keyword">this</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>都是ok的，但是我们要思考到：</p>
<p>很多人会有这种用法： <code>c3+=c2+=c1</code> 这种运算方式是指c2 +=c1,c3+=c2 ,此时对于第二种返回void的写法就出了问题，因为c2+=c1执行完成后这个东西本身要当成右值，然而却返回了void，因此会出错。</p>
<p>所以我们总是建议写第一种。</p>
<h2 id="重载运算符函数的常见用法-规则"><a href="#重载运算符函数的常见用法-规则" class="headerlink" title="重载运算符函数的常见用法/规则"></a>重载运算符函数的常见用法/规则</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210201248027.png" srcset="/img/loading.gif" alt="image-20211210201248027"></p>
<p>这里为什么选用return by value呢？</p>
<p>因为 a = b+c+d  在c++中b,c,d做完值是不可以变得，return by reference会导致b,c变化。</p>
<p><strong>如何区分加减和正负？</strong></p>
<p>根据参数的数量即可。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210202140742.png" srcset="/img/loading.gif" alt="image-20211210202140742"></p>
<p><strong><code>==</code> <code>!=</code>的设计标准</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210202419885.png" srcset="/img/loading.gif" alt="image-20211210202419885"></p>
<h2 id="typename-临时对象"><a href="#typename-临时对象" class="headerlink" title="typename()临时对象"></a><code>typename()</code>临时对象</h2><p><code>typename(...)</code>就是建立一个临时对象，这个对象不需要名字，用完即毁。标准库经常会有这种用法。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210201853227.png" srcset="/img/loading.gif" alt="image-20211210201853227"></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210202006287.png" srcset="/img/loading.gif" alt="image-20211210202006287"></p>
<p>运行完当前行后 <code>complex()</code>和<code>complex(4,5)</code>即消失</p>
<h2 id="lt-lt-的重载"><a href="#lt-lt-的重载" class="headerlink" title="&lt;&lt;的重载"></a><code>&lt;&lt;</code>的重载</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210202911883.png" srcset="/img/loading.gif" alt="image-20211210202911883"></p>
<p><strong>上述的<code>ostream&amp; os</code>为什么不加上<code>const</code>呢？</strong></p>
<p>这是因为在</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ++">return os&lt;&lt;&quot;(&quot;&lt;&lt;real(x)&lt;&lt;&quot;,&quot;&lt;&lt;imag(x)&lt;&lt;&quot;)&quot;;<br></code></pre></div></td></tr></table></figure>
<p>中<code>os</code>的状态是不断在变化的。</p>
<p><strong>重载&lt;&lt;的函数返回值可以加<code>const</code>吗？</strong></p>
<p>不可以，因为这里在不断改变<code>cout</code>的状态：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210203457500.png" srcset="/img/loading.gif" alt="image-20211210203457500"></p>
<h2 id="拷贝构造函数-析构函数"><a href="#拷贝构造函数-析构函数" class="headerlink" title="拷贝构造函数/析构函数"></a>拷贝构造函数/析构函数</h2><p><strong>拷贝构造函数</strong>如果你不写编译器会默认帮你写一个，即单纯的一个个把成员变量复制过去，但是对于字符串，里面的变量是指针，就会拷贝完后两者都指向同一个字符串。默认的构造函数是有风险的：如果你修改原对象中的字符串，会导致拷贝得到的那个对象字符串也发生变化。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210204953451.png" srcset="/img/loading.gif" alt="image-20211210204953451"></p>
<p><strong>析构函数：</strong></p>
<p>class里有指针我们大多数会做动态分配内存，动态分配的话在变量生命结束之前要释放空间。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210205056346.png" srcset="/img/loading.gif" alt="image-20211210205056346"></p>
<p>delete对象的指针就是：将指针所指向的内存空间回收</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210205355524.png" srcset="/img/loading.gif" alt="image-20211210205355524"></p>
<h2 id="含有指针的类必须要拷贝构造函数和重载赋值-函数"><a href="#含有指针的类必须要拷贝构造函数和重载赋值-函数" class="headerlink" title="含有指针的类必须要拷贝构造函数和重载赋值=函数"></a>含有指针的类必须要拷贝构造函数和重载赋值=函数</h2><p>如果你不写编译器会默认帮你写一个，即单纯的一个个把成员变量复制过去，但是对于字符串等里面的变量含有指针的类，拷贝/赋值完后两者都指向同一个字符串。</p>
<p>例如下面 world就造成了<strong>内存泄漏</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210205903468.png" srcset="/img/loading.gif" alt="image-20211210205903468"></p>
<p>因此对于重载=函数，需要</p>
<p><strong>1.先清空自己，防止内存泄露(这点一定要注意，因为可能存在<code>s1 = s2, s1 = s3, s1 = s4</code>这种多次赋值操作，如果不清空每次提前自己就会导致自己之前new出的内存找不到了，导致内存泄漏)</strong></p>
<p><strong>2.重新分配空间</strong></p>
<p><strong>3.给新空间赋值</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210210133496.png" srcset="/img/loading.gif" alt="image-20211210210133496"></p>
<p>同时要注意到<strong>自我赋值问题</strong>，即a = a这种傻瓜的用法，但可能确实存在这种用法，因此此时return 自己即可。如果你不写自我赋值检测，那么做以上那么三步，会导致结果出错。</p>
<h2 id="堆，栈与内存管理"><a href="#堆，栈与内存管理" class="headerlink" title="堆，栈与内存管理"></a>堆，栈与内存管理</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210211452869.png" srcset="/img/loading.gif" alt="image-20211210211452869"></p>
<p>c1存在<strong>栈</strong>里，程序离开变量作用域后会自动释放内存。</p>
<p>而p指针所指向的内存时new开辟的空间，是存放在<strong>堆</strong>里的，需要手动释放空间。</p>
<p><strong>什么是内存泄露呢？</strong></p>
<p>指针生命结束了，但指针所指的堆中的空间仍然存在。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210225514119.png" srcset="/img/loading.gif" alt="image-20211210225514119"></p>
<h2 id="new一个对象的原理"><a href="#new一个对象的原理" class="headerlink" title="new一个对象的原理"></a>new一个对象的原理</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210225938299.png" srcset="/img/loading.gif" alt="image-20211210225938299"></p>
<p>所以<strong>new一个类的对象内部其实做了三件事情：</strong></p>
<p><strong>1.<code>operator new()</code> 分配空间并返回一个<code>void*</code>类型指针p</strong></p>
<p><strong>2.void*类型 强转(通过<code>static_cast</code>) 成为目标class类型指针p</strong></p>
<p><strong>3.指针p调用构造函数。</strong></p>
<p>TIPS of <code>operator new()</code></p>
<blockquote>
<p>operator new()：指对new的重载形式，它是一个函数，并不是运算符。</p>
<p>对于operator new来说，分为全局重载和类重载，</p>
<p>1.全局重载是void* ::operator new(size_t size)</p>
<p>2.在类中重载形式 void* A::operator new(size_t size)。</p>
<p>还要注意的是这里的operator new()完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个<strong>void*指针</strong>。而<strong>构造函数的调用(如果需要)是在new运算符中完成的</strong></p>
</blockquote>
<h2 id="delete一个对象的原理"><a href="#delete一个对象的原理" class="headerlink" title="delete一个对象的原理"></a>delete一个对象的原理</h2><p>先调用析构函数(<code>~fun()</code>)，再释放内存(调用<code>free()</code>)</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210230710412.png" srcset="/img/loading.gif" alt="image-20211210230710412"></p>
<h2 id="new-要搭配delete"><a href="#new-要搭配delete" class="headerlink" title="new [ ]要搭配delete [ ]"></a>new [ ]要搭配delete [ ]</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210231520440.png" srcset="/img/loading.gif" alt="image-20211210231520440"></p>
<p><strong>如果new array不搭配delete array很可能会造成内存泄漏：</strong></p>
<p>下图例子，我们调用delete 其实都会删除掉那一块部分，因为开头的cookie(即下图的21h)记录了这一块的大小，这一块是没有问题的。</p>
<p>问题就出在对于array中的每一个对象，<code>delete[]</code>会对每一个对象都调用析构函数，而<code>delete</code>只会对array的第一个对象调用析构函数，如果对象中是一个指针指向外部空间，那么析构函数就没有回收那部分的内存空间，导致内存泄漏</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210232317492.png" srcset="/img/loading.gif" alt="image-20211210232317492"></p>
<h2 id="static静态：静态变量，静态函数"><a href="#static静态：静态变量，静态函数" class="headerlink" title="static静态：静态变量，静态函数"></a>static静态：静态变量，静态函数</h2><p>首先要了解对于一个非静态(non-static)的成员函数，他要怎么面对各种各样的对象调用他呢？通过this指针获得对象的数据，然后在自己的函数逻辑中进行计算。如下图：c1，c2，c3分别各自拥有this指针，可以通过this指针调用函数。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210233750163.png" srcset="/img/loading.gif" alt="image-20211210233750163"></p>
<p>那么下面先讨论<strong>static变量：</strong></p>
<p>比如银行的利率每年调整，每个人的账户都加入一个利率显然是没必要的重复数据，修改也不方便，那利率就可以设置为static 数据，自己独自一份。</p>
<p><strong>static静态函数：</strong></p>
<p>他只能处理静态数据</p>
<p><strong>static 称为类变量，它属于这个类，而不属于这个类的实例对象</strong>（但是可以通过实例对象去访问），当类链接的时候就为其分配空间并初始化默认值，空间分配在堆中。 </p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210234931612.png" srcset="/img/loading.gif" alt="image-20211210234931612"></p>
<p><strong>调用static函数方式</strong>有两种：可以通过对象调用或者类名直接调用。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210234550827.png" srcset="/img/loading.gif" alt="image-20211210234550827"></p>
<p><strong>单例模式可以有这种写法</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211209235038633.png" srcset="/img/loading.gif" alt="image-20211209235038633"></p>
<p><strong>尝试更好的写法：</strong>static变量写在函数里，即即使你一开始创建了A a，但没有人用这个单例，依然不会占用空间。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211210235828020.png" srcset="/img/loading.gif" alt="image-20211210235828020"></p>
<p>自己写的一个小例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">static</span> A a;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br><br>    A(<span class="hljs-keyword">int</span> xx = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> yy = <span class="hljs-number">0</span>): x(xx), y(yy) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;A::getInstance().x&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="函数模板中的参数推导-argument-deduction"><a href="#函数模板中的参数推导-argument-deduction" class="headerlink" title="函数模板中的参数推导(argument deduction)"></a>函数模板中的参数推导(argument deduction)</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211001053901.png" srcset="/img/loading.gif" alt="image-20211211001053901"></p>
<h2 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h2><p>对标准库里的东西全部打开，以后不用写<code>std::cin</code>等 直接写<code>cin</code>即可</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211001343326.png" srcset="/img/loading.gif" alt="image-20211211001343326"></p>
<p>也可以<strong>部分展开namespace：</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211001503678.png" srcset="/img/loading.gif" alt="image-20211211001503678"></p>
<h2 id="复合-composition"><a href="#复合-composition" class="headerlink" title="复合(composition)"></a>复合(composition)</h2><p>复合就是has-a的关系，比如class A中有Class B的对象。其实C语言结构体是我们见过最早的复合了。</p>
<p>下面就是通过复合实现了一个adapter模式：</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211002417294.png" srcset="/img/loading.gif" alt="image-20211211002417294"></p>
<p><strong>复合的内存问题：</strong></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211002806030.png" srcset="/img/loading.gif" alt="image-20211211002806030"></p>
<p><strong>复合的构造函数和析构函数的调用顺序：</strong></p>
<p>构造函数调用顺序是先内部再外部，而析构函数相反。</p>
<p>除此之外，调用外部构造函数的时候先调用的是内部default构造函数，如果你内部有许多构造函数，你可以选择自己重写外部的构造函数。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211003711654.png" srcset="/img/loading.gif" alt="image-20211211003711654"></p>
<h2 id="委托-Delegation"><a href="#委托-Delegation" class="headerlink" title="委托(Delegation)"></a>委托(Delegation)</h2><p>可以简单理解为composition by reference，即通过指针/引用复合</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211004452966.png" srcset="/img/loading.gif" alt="image-20211211004452966"></p>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211005736189.png" srcset="/img/loading.gif" alt="image-20211211005736189"></p>
<p>继承就是：子类有父类的成分</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211005216822.png" srcset="/img/loading.gif" alt="image-20211211005216822"></p>
<p>同时要注意：父类的析构函数必须是virtual的，否则会出现undefined behavior</p>
<h2 id="继承中的虚函数"><a href="#继承中的虚函数" class="headerlink" title="继承中的虚函数"></a>继承中的虚函数</h2><p><strong>non-virtual函数：</strong>你不希望子类重新定义(override)它</p>
<p><strong>virtual函数：</strong>你希望子类重新定义它</p>
<p><strong>pure virtual函数：</strong>你希望子类一定要重新定义它，你对他没有默认定义</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211010211587.png" srcset="/img/loading.gif" alt="image-20211211010211587"></p>
<p><strong>举一个例子：</strong></p>
<p>利用虚函数延缓了主要功能的其中一个动作。可以让我们在后期通过虚函数修改自己的功能/添加新功能。</p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211010747368.png" srcset="/img/loading.gif" alt="image-20211211010747368"></p>
<p><img src="https://gitee.com/Chillstep/ChillstepPictures/raw/master/master/image-20211211012342931.png" srcset="/img/loading.gif" alt="image-20211211012342931"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++面向对象高级编程-下</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/07/A-G-NEC-Programming-Contest-2021-AtCoder-Beginner-Contest-229/">
                        <span class="hidden-mobile">(A-G)NEC Programming Contest 2021(AtCoder Beginner Contest 229)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https://chillstepp.github.io/2021/12/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8A/';
        this.page.identifier = '/2021/12/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8A/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'fluid' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
