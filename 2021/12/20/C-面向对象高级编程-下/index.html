

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <link rel="icon" type="image/png" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chillstep">
  <meta name="keywords" content="">
  <title>C++面向对象高级编程-下 - Chillstep</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chillstepp.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chillstep</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sdqryn.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++面向对象高级编程-下">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-20 18:26" pubdate>
        2021年12月20日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++面向对象高级编程-下</h1>
            
            <div class="markdown-body">
              <h1 id="C-面向对象高级编程-下"><a href="#C-面向对象高级编程-下" class="headerlink" title="C++面向对象高级编程(下)"></a>C++面向对象高级编程(下)</h1><h2 id="Conversion-function转换函数"><a href="#Conversion-function转换函数" class="headerlink" title="Conversion function转换函数"></a>Conversion function转换函数</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214154138982.png" srcset="/img/loading.gif" alt="image-20211214154138982"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<br></code></pre></div></td></tr></table></figure>
<p>对于<code>double d = 4 + f;</code>这一条语句编译器的动作是:</p>
<p>1.对于上面的操作<code>4+f</code>有没有一个<code>operator+</code>可以使得  <code>double + fraction</code>的函数（不存在，那么下一种方法）</p>
<p>2.是否存在可以让4转换为double的函数(默认存在)和让fraction转换为double的函数(存在)，因此没有问题通过。</p>
<p><strong>以上的动作不存在谁比较好/谁先谁后，超过一个可行都会被认为是ambiguous的。</strong></p>
<h2 id="隐式转换构造函数non-explicit-one-argument-ctor"><a href="#隐式转换构造函数non-explicit-one-argument-ctor" class="headerlink" title="隐式转换构造函数non-explicit-one-argument ctor"></a>隐式转换构造函数non-explicit-one-argument ctor</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214155947325.png" srcset="/img/loading.gif" alt="image-20211214155947325"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d = f + <span class="hljs-number">4</span>;<br></code></pre></div></td></tr></table></figure>
<p>Fraction d = f + 4; 这个函数的意义是 f调用operator+ 参数为4 ,而接受端会发现4被<code>隐式转换</code>成 Fraction。这个隐式转换是<code>non-explicit ctor</code>做得，他将4转换为了Fraction类型。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214161205084.png" srcset="/img/loading.gif" alt="image-20211214161205084"></p>
<p>上述代码会造成的<strong>歧义：</strong></p>
<p>1.f + 4 先调用<code>operator+</code> ，由于加法的参数需要fraction，因此将4隐式转换为Fraction类型，执行完成加法操作。</p>
<p>2.f首先变成double类型，随后再和4相加，最后整体作为一个数字通过隐式转换转换为Fraction类型</p>
<p>以上两种都可以发生且合理。</p>
<p><strong>如果你不希望那种隐式转换(<code>non-explicit</code>)出现，那么可以加上<code>explict</code>关键字，防止通过构造函数进行隐式转换：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214161820508.png" srcset="/img/loading.gif" alt="image-20211214161820508"></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214162126280.png" srcset="/img/loading.gif" alt="image-20211214162126280"></p>
<p>虽然此时还是会出现错误的，因为上面我们所提到两种歧义的方法都会用到隐式转换：一种是4隐式转换为Fraction类型，另一种是答案通过通过隐式转换转换为Fraction类型。但由于此时我们加上了explicit关键字，这里不允许通过他的构造函数发生这种的隐式转换。</p>
<h2 id="标准库中的一个利用转换函数的例子"><a href="#标准库中的一个利用转换函数的例子" class="headerlink" title="标准库中的一个利用转换函数的例子"></a>标准库中的一个利用转换函数的例子</h2><p>这是一个<strong>模板偏特化</strong>的例子，也是标准库中的一段代码：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214162711966.png" srcset="/img/loading.gif" alt="image-20211214162711966"></p>
<p>这里用<code>reference</code>来代替了返回的类型，那么就一定要利用转换函数将返回结果的类型(<code>bool</code>)转换为<code>reference</code>的类型，而这类的<code>reference</code>通过就是<code>__bit_reference</code>类型，那么也就是说<code>__bit_reference</code>这个类里一定有一个转换为<code>bool</code>类型的转换函数：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163200746.png" srcset="/img/loading.gif" alt="image-20211214163200746"></p>
<p>发现确实如此。</p>
<h2 id="pointer-like-classes，关于智能指针"><a href="#pointer-like-classes，关于智能指针" class="headerlink" title="pointer-like classes，关于智能指针"></a>pointer-like classes，关于智能指针</h2><p>这是一个类似指针，但比普通指针更智能的写法，是c++写的一个类。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163446733.png" srcset="/img/loading.gif" alt="image-20211214163446733"></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214163700753.png" srcset="/img/loading.gif" alt="image-20211214163700753" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt;sp(<span class="hljs-keyword">new</span> Foo);<br></code></pre></div></td></tr></table></figure>
<p>首先new一个<code>Foo</code>类型的指针当成初值赋值给<code>shared_ptr</code>的对象sp，这个赋初值的过程毫无疑问调用的是<code>shared_ptr</code>的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(*sp)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>这一步由于重载运算符<code>operator*()</code>,把sp指针中的px指针所指的值取出来。</p>
<p>以上两部都很符合直觉，但是当我们调用sp这个智能指针所指对象的method方法时，我们理希望 调用方法肯定和普通指针一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sp-&gt;method()<br></code></pre></div></td></tr></table></figure>
<p>我们所希望的操作是：sp-&gt;method() 转换为 px-&gt;method() 然后再得到结果，但是-&gt;被重载过了，因此sp-&gt; 会转换为 px ，此时因为重载运算符已经消耗了一个箭头，那么问题就来了，好像少了一个箭头？</p>
<p>其实不然，这属于c++的特性，语言设计者唯独对这种操作符加了一些不同于其他操作符的东西，即：<strong>重载后依然会保留-&gt;的操作符</strong>。 </p>
<h2 id="pointer-like-classes，关于迭代器"><a href="#pointer-like-classes，关于迭代器" class="headerlink" title="pointer-like classes，关于迭代器"></a>pointer-like classes，关于迭代器</h2><p>迭代器多了++,—这一类操作，因为迭代器可以用来遍历容器。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214165709044.png" srcset="/img/loading.gif" alt="image-20211214165709044"></p>
<p>我们单独讨论一下 dereference和-&gt;两个重载运算符函数：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214170021566.png" srcset="/img/loading.gif" alt="image-20211214170021566"></p>
<p> 我们希望迭代器like 指针，那么也就是希望支持这两种操作：</p>
<p>1.<code>*</code>取值操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">*ite<br></code></pre></div></td></tr></table></figure>
<p>这个完全可以通过 <code>operator*</code>完成，即<code>return (*node).data</code></p>
<p>2.-<code>&gt;</code>操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ite-&gt;method()<br></code></pre></div></td></tr></table></figure>
<p><strong>如何实现ite类型-&gt;操作符重载？</strong></p>
<p>这个操作可以先通过 <code>operator*</code>获得一个对象(注意 这里的<code>operator *</code>可不是普通的，而是我们已经重写后的了，它可以对迭代器这种<code>pointer-like-class</code>直接获取对象)，然后再通过<code>&amp;</code>获得这个对象的指针，然后再通过这个指针完成调用<code>Foo</code>的<code>method()</code>函数。</p>
<p>还记的上面所说的关于<code>-&gt;</code>一个语言特性吗？ 重载运算符已经消耗了一个箭头，但箭头还会存在，这属于c++的特性，语言设计者唯独对这种操作符加了一些不同于其他操作符的东西，即：<strong>重载后依然会保留-&gt;的操作符</strong>。 </p>
<p>因此重载后，<code>ite-&gt;method()</code> 变成了<code>&amp;(*ite) -&gt; method()</code> ， </p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214171013860.png" srcset="/img/loading.gif" alt="image-20211214171013860"></p>
<h2 id="function-like-classed，仿函数-通过重载operator-实现仿函数"><a href="#function-like-classed，仿函数-通过重载operator-实现仿函数" class="headerlink" title="function-like classed，仿函数/通过重载operator ()实现仿函数"></a>function-like classed，仿函数/通过重载operator ()实现仿函数</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214174029746.png" srcset="/img/loading.gif" alt="image-20211214174029746"></p>
<p>这里面的重载<code>()</code>就是仿函数的主要特点，希望类像函数一样可以使用。</p>
<p>因此我们可以通过重载operator ()实现仿函数。</p>
<p>一个简单的例子：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214175751956.png" srcset="/img/loading.gif" alt="image-20211214175751956"></p>
<h2 id="再谈namespace"><a href="#再谈namespace" class="headerlink" title="再谈namespace"></a>再谈namespace</h2><p>对标准库里的东西全部打开，以后不用写<code>std::cin</code>等 直接写<code>cin</code>即可</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001343326.png" srcset="/img/loading.gif" alt="image-20211211001343326"></p>
<p>也可以<strong>部分展开namespace：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211211001503678.png" srcset="/img/loading.gif" alt="image-20211211001503678"></p>
<p><strong>namespace简单来说就是防止命名冲突。</strong></p>
<h2 id="function-template，函数模板"><a href="#function-template，函数模板" class="headerlink" title="function template，函数模板"></a>function template，函数模板</h2><p><strong>编译器会对function template进行模板推导：</strong>也就是说要进行两次编译，第一次你的函数如果调用了这个模板才能推导出模板的类型stone，第二次找＜操作符的重载函数：如下</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">minn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; a,<span class="hljs-keyword">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b&lt;a?b:a;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stone</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> v;<br>    stone(<span class="hljs-keyword">int</span> _v):v(_v)&#123;&#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> stone&amp; rhs) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;v &lt; rhs.v;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">stone <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">stone <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    stone c= minn(a,b);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;c.v&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果你把&lt;操作符重载删除是无法通过编译，因为调用minn时首先推导出了stone类型，第二次编译发现没有stone的比较符号，因此会报错.</p>
<p>但是如果你并没有调用minn函数，那么就还可以通过编译。因为根本没有模板进行推导，因此编译器也不会发现你没有写重载<code>&lt;</code>运算符函数。</p>
<h2 id="member-template，成员模板"><a href="#member-template，成员模板" class="headerlink" title="member template，成员模板"></a>member template，成员模板</h2><p>成员模板即 class里的成员利用模板编写。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214183405544.png" srcset="/img/loading.gif" alt="image-20211214183405544"></p>
<p>首先外面的T1,T2是允许变化的，在确定后，里面的U1,U2也是允许变换的。</p>
<p>有了这样的技术，我们就可以把 &lt;鲫鱼，麻雀&gt;这一对pair用来初始化 &lt;鱼类，鸟类&gt;这一对pair。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184059791.png" srcset="/img/loading.gif" alt="image-20211214184059791"></p>
<p>这个在<strong>c++有一些实际的应用：</strong></p>
<p>比如智能指针中的<code>shared_ptr</code>:</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184513758.png" srcset="/img/loading.gif" alt="image-20211214184513758"></p>
<p>父类指针可以指向子类的对象，这是我们c++所支持的up-cast，因此我们希望智能指针也可以做到的up-cast，具体怎么做呢？</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211214184838976.png" srcset="/img/loading.gif" alt="image-20211214184838976"></p>
<p>首先<code>shared_ptr</code>这个智能指针利用模板特性可以完成<code>up-cast</code>操作, 比如：你想完成<code>shared_ptr&lt;Base1&gt;sptr(new Derived1)</code>这个操作:</p>
<p>1.此时<code>__shared_ptr&lt;&gt;</code>就会被绑定为<code>Base1</code>类型，即<code>_Tp</code>推导出类型为<code>Base1</code>，</p>
<p>2.<code>new Derived</code>形成的指针推导出<code>_Tp1</code>的类型为<code>Derived</code>，即<code>_p</code>会被绑定为 <code>Derived*</code>类型</p>
<p>3.因为<code>Derived</code>是<code>Base</code>的子类，因此可以进行初始化父类指针指向子类，这一步的操作是通过<code>explicit shared_ptr(Derived1* __p):__shared_ptr&lt;Base1&gt;(__p){}</code>这个含有初始化列表的构造函数实现的，其中的初始化列表就相当于给<code>shared_ptr</code>中的<code>__shared_ptr&lt;Base1&gt;</code>赋值为<code>__p(Derived类型)</code>，这一步就是实现了up-cast。</p>
<p>我们发现通过<strong>模板特性，我们可以将这样的up-cast操作完美完成。</strong></p>
<h2 id="specialization，模板特化"><a href="#specialization，模板特化" class="headerlink" title="specialization，模板特化"></a>specialization，模板特化</h2><p>模板特化就是指对模板进行特征化，模板是一个泛化的概念，也就是可以接受多种类型变量，但是我们可以特征化 模板的接收各类型变量的动作，也就是说 编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么你自己写：</p>
<p>如下图，我们在用模板特性写完<code>struct hash</code>后，开始特化三个类型的<code>struct hash</code>，分别是<code>char，int，long</code>。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215204743489.png" srcset="/img/loading.gif" alt="image-20211215204743489"></p>
<p>一个完整的例子：<a href="https://www.cnblogs.com/xiangtingshen/p/11157198.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangtingshen/p/11157198.html</a></p>
<h2 id="partial-specialization，模板偏特化-全特化"><a href="#partial-specialization，模板偏特化-全特化" class="headerlink" title="partial specialization，模板偏特化/全特化"></a>partial specialization，模板偏特化/全特化</h2><p>通过特化可以对某一种特定类型的进行自定义实现。编译器认为，对于特定的类型，如果你能对某一功能更好的实现或想法，那么你自己实现。</p>
<p><strong>特化可以分为:</strong></p>
<p><strong>全特化</strong>就是全部特化，即针对所有的模板参数进行特化。《c++ primer》<br><strong>偏特化</strong>就是部分特化，即针对部分模板参数进行特化。《c++ primer》</p>
<p>可以看出特化无论是<strong>全/偏</strong>都是对模板参数的解读。</p>
<p><strong>函数模板，却只有全特化，不能偏特化:即函数模板必须提前指定好所有的参数类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T1 a,T2 b)</span></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"模板函数"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//全特化</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)</span></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"全特化"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//函数不存在偏特化，以下代码是错误的</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">template&lt;typename T2&gt;</span><br><span class="hljs-comment">void fun(char a,T2 b)&#123;</span><br><span class="hljs-comment">    cout&lt;&lt;"偏特化"&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
<p><strong>偏特化的偏有两种：</strong></p>
<p>一个是参数个数上的偏，另一个是范围上的偏</p>
<p><strong>1.一个是参数个数上的偏</strong></p>
<p>如下图，绑定第一个参数为bool类型进行偏特化。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215213918484.png" srcset="/img/loading.gif" alt="image-20211215213918484"></p>
<p><strong>2.另一个是范围上的偏</strong></p>
<p>我们有时候会<strong>希望对于模板的T在作为指针类型时执行特定的规则，否则按照模板泛化的规则来执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215214836534.png" srcset="/img/loading.gif" alt="image-20211215214836534"></p>
<p><strong>范围上偏的简单例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    T v;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pt</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;T*&gt;</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    T* v;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pt</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>&#125;;<br><br><span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>] = <span class="hljs-string">"1234"</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    C&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>&gt;obj1;<br>    C&lt;<span class="hljs-keyword">char</span>*&gt;obj2;<br>    C&lt;<span class="hljs-built_in">string</span>&gt;obj3;<br>    obj1.v = <span class="hljs-number">1000000000000</span>;<br>    obj2.v = s;<br>    obj3.v = <span class="hljs-string">"hello!"</span>;<br>    obj1.pt();<br>    obj2.pt();<br>    obj3.pt();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="template-template-parameter，模板的模板参数"><a href="#template-template-parameter，模板的模板参数" class="headerlink" title="template template parameter，模板的模板参数"></a>template template parameter，模板的模板参数</h2><p>模板的模板参数就是：模板中还存在模板作为的参数。<strong>注意:函数模板不支持模板的模板参数,类模板才支持这种操作</strong></p>
<p>这个的应用场景是，比如我们想这么用:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">list</span>&gt;mylist1;<br></code></pre></div></td></tr></table></figure>
<p>此时希望list自动辨别出来我们要用的是string，并把list自己的容纳元素类型绑定成string。一个简单的方法就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">typename</span> T&gt;&gt;<br>考虑到想让容器也可以变化，适应多种容器，不妨写成:<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215220706952.png" srcset="/img/loading.gif" alt="image-20211215220706952"></p>
<p>这样可以达到我们想要的效果吗？</p>
<p>奇怪的是并不可以：这是因为XCLs中的<code>Container&lt;T&gt;c</code>这部分的T填入的是类型T(string)，然而我们平时可以这么用<code>list&lt;string&gt;</code>是因为string填入后，其实<code>&lt;&gt;</code>后面还会有一些默认参数，但是如果你用<code>T</code>表示，c++就会认为你没有填入后面的默认参数(语言的规定)。简单来说如果你用了T做容器的参数，那么容器的后面的默认参数会失效，你需要自己补上这些参数。</p>
<p>因此我们可以这么用(c++2.0新特性（c++11/14）)，使得第二种是对的：<strong>即利用<code>using</code>定义模板别名</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215221628613.png" srcset="/img/loading.gif" alt="image-20211215221628613"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT&lt;T&gt;c;<br>&#125;;<br><br><span class="hljs-comment">//利用using 给这个模板定义了别名: Lst</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,Lst&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个模板推导过程是：<code>T</code>推出<code>string</code>，然后从<code>CONT&lt;T&gt;c</code>推出<code>U</code>是<code>string</code>，然后从<code>U</code>再推到<code>T2</code>是<code>string</code></p>
<p>下面这并<strong>不叫做一个模板模板参数</strong>，因为<code>XCLs&lt;string,set&lt;string&gt;&gt;mylist1;</code>中的<code>set&lt;string&gt;</code>就已经绑定好容器的元素类型了，使得<code>class CONT</code>变成<code>set&lt;string&gt;</code>根本没有模板进行推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>=<span class="hljs-title">list</span>&lt;T,allocator&lt;T&gt;&gt;&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT c;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="C-11-variadic-templates数量不定的模板参数"><a href="#C-11-variadic-templates数量不定的模板参数" class="headerlink" title="C++11: variadic templates数量不定的模板参数"></a>C++11: variadic templates数量不定的模板参数</h2><p>下面是一个数量不定的模板参数的例子，<code>print()</code>函数做得是一个将一堆参数输出的动作。</p>
<p>每次取出第一个参数输出，剩下的参数包递归下去每次输出参数的第一个。但请不要忘记写<code>void print(){ }</code>，因为当参数空的时候，你需要一个无参的<code>print</code>来结束print的递归。</p>
<p>如果你想知道 后面那一部分参数包有几个，你可以使用<code>sizeof...(args)</code>。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013257682.png" srcset="/img/loading.gif" alt="image-20211216013257682"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; &#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;firstArg&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"123"</span>,<span class="hljs-string">"456"</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013211012.png" srcset="/img/loading.gif" alt="image-20211216013211012"></p>
<h2 id="C-11-auto关键字"><a href="#C-11-auto关键字" class="headerlink" title="C++11: auto关键字"></a>C++11: auto关键字</h2><p>这是一个<strong>语法糖</strong>。</p>
<p>算法竞赛里天天用，就不细说了。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013608646.png" srcset="/img/loading.gif" alt="image-20211216013608646"></p>
<h2 id="C-11-ranged-base-for"><a href="#C-11-ranged-base-for" class="headerlink" title="C++11: ranged-base for"></a>C++11: ranged-base for</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216013932605.png" srcset="/img/loading.gif" alt="image-20211216013932605"></p>
<h2 id="再谈reference引用"><a href="#再谈reference引用" class="headerlink" title="再谈reference引用"></a>再谈reference引用</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216014803125.png" srcset="/img/loading.gif" alt="image-20211216014803125"></p>
<ul>
<li><p>引用必须设初值，即必须定义时标明你引用的是谁。并且以后不可以修改这种绑定关系(但指针可以)。</p>
</li>
<li><p>对引用的修改就是对和他初始绑定的变量的修改</p>
</li>
<li><p>指针的大小是固定的8字节(64位系统，32位系统为4字节)，引用的大小取决于和他绑定的变量，变量多大引用多大，即<code>sizeof(reference) = sizeof(绑定的变量)</code>绑定的变量。<strong>但这是假象，引用就是指针实现的(而且还是一个指针常量)，所以其实实际只占用了指针的大小。同时，<code>&amp;reference = &amp;绑定的变量</code>也是假象，其实他们并不相同</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216152210353.png" srcset="/img/loading.gif" alt="image-20211216152210353"></p>
</li>
<li><p>拓扑结构的递归引用相当于最开始的绑定的变量: 即<code>int&amp; r = x;int&amp; r2=r;</code> <code>r2</code>修改其实就是对<code>x</code>修改</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216015810061.png" srcset="/img/loading.gif" alt="image-20211216015810061"></p>
<ul>
<li>reference具有天生自然的优势在参数中使用，因为保证了调用和被调用端口的一致(上图)。</li>
<li>函数重载中，参数仅有是否引用的区别会被认为是同一函数，因此不能同时出现</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216020211334.png" srcset="/img/loading.gif" alt="image-20211216020211334"></p>
<h2 id="再谈重载-overloading-函数"><a href="#再谈重载-overloading-函数" class="headerlink" title="再谈重载(overloading)函数"></a>再谈重载(overloading)函数</h2><p>上面一节最后谈到了，const是不是函数签名的一部分，这次我们来测试下：</p>
<p><strong>函数重载中，参数仅有是否加const的区别会被认为是不同同一函数，因此可以同时出现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; im)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span>&amp; im)</span></span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>函数重载中，函数仅有是否加const的区别会被认为是不同函数，因此可以同时出现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span> im)</span><span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-keyword">double</span> im)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    <span class="hljs-keyword">const</span> test a;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> t = <span class="hljs-number">1.5</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;a.imag(t)&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//1</span><br><br>    test b;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;b.imag(t)&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因此我们可以 认为const是判别是否为相同函数的<strong>函数签名</strong> 的一部分</p>
<h2 id="虚指针-vptr-和虚表-vtbl"><a href="#虚指针-vptr-和虚表-vtbl" class="headerlink" title="虚指针(vptr)和虚表(vtbl)"></a>虚指针(vptr)和虚表(vtbl)</h2><p>带<code>x</code>个虚函数的class的大小也只会多 <strong>8 字节(64位下)</strong>，这是因为含有虚函数的对象/类有一个虚表指针，他的大小是8字节，这个虚表指针会指向虚表。</p>
<p><strong>那么编译器是如何处理虚函数的呢？</strong></p>
<p>1.如果<strong>类中有虚函数，就将虚函数的地址记录在类的虚函数表中</strong>。</p>
<p>2.<strong>派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址</strong>，否则指向基类的函数地址。<br>3.<strong>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表</strong>。</p>
<p>4.实例在调用虚函数的时候，<strong>通过这个虚函数表指针找到类中的虚函数表，再找到相应的函数进行调用</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216200306046.png" srcset="/img/loading.gif" alt="image-20211216200306046"></p>
<p>1.首先<code>class A</code>有两个虚函数，因此虚表应该有两个指针指向两个虚函数。如下图标出的红色框。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216201251442.png" srcset="/img/loading.gif" alt="image-20211216201251442"></p>
<p>2.<code>class B</code>继承了<code>Class A</code>，但是<code>class B</code>的虚函数也是<code>vfun1()</code>，由于和从<code>A</code>继承的虚函数<code>vfun1()</code>同名，这就会推翻<code>class B</code>从<code>class A</code>所继承来的<code>vfun1()</code>, 因此可以看作是一个全新的函数<code>B::vfun1()</code>。除此之外，还会从<code>class A</code>继承一个<code>vfun2()</code>虚函数。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216201727405.png" srcset="/img/loading.gif" alt="image-20211216201727405"></p>
<p><strong>虚函数实现了多态：</strong></p>
<p>A可以看作是shape，里面有纯虚函数draw()，继承他的各个形状自己改写draw()函数，我们的容器可以存不同的形状(通过父类指针作为容器元素)，调用draw就会触发不同的效果，实现了多态。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216211058781.png" srcset="/img/loading.gif" alt="image-20211216211058781"></p>
<h2 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h2><p>转自: <a href="https://www.cnblogs.com/leoncumt/p/10491842.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoncumt/p/10491842.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br><br>&#125;;<br><br>D* pD=<span class="hljs-keyword">new</span> D();<br><span class="hljs-comment">// pD的静态类型是它声明的类型D*，动态类型也是D*</span><br>B* pB=pD;<br><span class="hljs-comment">// pB的静态类型是它声明的类型B*，动态类型是pB所指的对象pD的类型D*</span><br>c* pC=<span class="hljs-keyword">new</span> C();<br><span class="hljs-comment">// pC的静态类型是它声明的类型C*，动态类型也是C*</span><br>pB=pC;<br><span class="hljs-comment">// pB的动态类型可以改变，现在它的动态类型为C*</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>静态绑定：</strong></li>
</ul>
<p>绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</p>
<ul>
<li><strong>动态绑定：</strong></li>
</ul>
<p>绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br>    <span class="hljs-comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致同名隐藏；这里只是为了说明动态绑定和静态绑定才这样使用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>D* pD=<span class="hljs-keyword">new</span> D();<br><span class="hljs-comment">// pD的静态类型是它声明的类型D*，动态类型也是D*</span><br>B* pB=pD;<br><span class="hljs-comment">// pB的静态类型是它声明的类型B*，动态类型是pB所指的对象pD的类型D*</span><br></code></pre></div></td></tr></table></figure>
<p><strong>pD-&gt;DoSomething()和pB-&gt;DoSomething()调用的是同一个函数吗？</strong></p>
<p><strong>答案：</strong>不是的，虽然<code>pD</code>和<code>pB</code>指向同一对象，但函数<code>DoSomething()</code>是一个<strong>non-virtual函数，它是静态绑定的</strong>，也就是编译器会在编译器根据对象的静态类型来选择函数，<code>pD</code>的静态类型是<code>D*</code>，那么编译器在处理<code>pD-&gt;DoSomething()</code>的时候会将它指向<code>D::DoSomething()</code>。同理，<code>pB</code>的静态类型是<code>B*</code>，那么<code>pB-&gt;DoSomething()</code>调用的就是B::DosSomething()。</p>
<p><strong>pD-&gt;vfun()和pB-&gt;vfun()调用的是同一函数吗？</strong></p>
<p><strong>答案：</strong>是的，这是因为<code>vfun</code>是一个虚函数，他是<strong>动态绑定的，即绑定的是对象的动态类型</strong>，<code>pB</code>和<code>pD</code>虽然静态类型不同，但他们同时指向一个对象，他们的动态对象是相同的，都是<code>D*</code>，所以，他们调用的是同一个函数：<code>D::vfun()</code>。</p>
<p><strong>指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的。</strong><br><strong>例如：</strong>D.DoSomething()和D.vfun()永远调用的都是D::DoSomething()和D::vfun()。</p>
<p><strong>综上总结：</strong></p>
<p>只有虚函数才绑定的是对象的动态类型(动态绑定)，其他的全部是静态绑定。</p>
<h2 id="再谈this和动态绑定"><a href="#再谈this和动态绑定" class="headerlink" title="再谈this和动态绑定"></a>再谈this和动态绑定</h2><p>从汇编来看静态绑定：</p>
<p>下面的a是一个对象，他是静态绑定。因此汇编程序直接用指令call 了一个地址即<code>A::vfun1()</code>的地址。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220014231828.png" srcset="/img/loading.gif" alt="image-20211220014231828"></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216213346290.png" srcset="/img/loading.gif" alt="image-20211216213346290"></p>
<p>pa的动态类型是<code>B*</code>在运行<code>pa-&gt;vfun1</code>时动态绑定为<code>B::vfun1()</code>，因此才能使得pa-&gt;vfun1()运行出来是<code>B::vfun1()</code>函数。</p>
<p>在汇编中来看他是怎么实现动态绑定的呢？</p>
<p>1.他是通过p指针指向虚表完成的，<strong>p指针也就是this指针</strong>。</p>
<p>2.而<code>this</code>指针是干什么用的？<strong>在不同的对象调用的时候，编译器会自动将该对象的地址赋予“this”</strong>。</p>
<p>3.因此正是<code>this</code>中有对象的动态类型，因此this得以通过虚函数表和虚指针正确的调用出<code>B::vfun1()</code>函数，就像下图一样找到最后需要的函数。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211216200306046.png" srcset="/img/loading.gif" alt="image-20211216200306046"></p>
<h2 id="重载operator-new-delete-new-delete"><a href="#重载operator-new-delete-new-delete" class="headerlink" title="重载operator new/delete/new[]/delete[]"></a>重载operator new/delete/new[]/delete[]</h2><p>首先我们有必要区分一下 <code>operator new</code>和<code>new operator</code>(delete也是同理)</p>
<p><strong>new operator是c++内建的，无法改变其行为；(delete也是同理)</strong></p>
<p><strong>而operator new 是可以根据自己的内存分配策略去重载的。(delete也是同理)</strong></p>
<p>因此我们重载只可以对operator new进行重载，下面会介绍全局函数重载和成员函数重载</p>
<p><strong>对于全局函数重载，直接如下写即可：</strong></p>
<p>但是这种影响是很宽泛的，我们几乎不会这么用</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220145856829.png" srcset="/img/loading.gif" alt="image-20211220145856829"></p>
<p><strong>当然我们更常用的是如何重载一个成员函数中的new/delete：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220150135319.png" srcset="/img/loading.gif" alt="image-20211220150135319"></p>
<p>new operator第一步分配空间会使用operator new来做，此时如果你重载了对象的operator new，那么就会调用重载后的。</p>
<p><strong><code>operator new []/operator delete[]</code>的内存大小为什么多4？</strong></p>
<p>对于<code>operator new []/operator delete[]</code>和上面没什么区别，多了一个<code>[]</code>而已。</p>
<p>这里我们发现下图中new operator操作第一步调用operator new的时候分配的是对象的内存$(FOO)*(N个)$后还多了一个4字节，这个表示连续有少个对象，起一个计数器counter作用。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220151015091.png" srcset="/img/loading.gif" alt="image-20211220151015091"></p>
<p><strong>强制调用全局默认的new/delete/new []/delete[]:</strong></p>
<p>即使你定义了成员函数里写了operator new/delete的重载函数，你依然可以强制调用global的new/delete，操作方法为: 在new/delete前加<code>::</code></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<br>::<span class="hljs-keyword">delete</span> pf;<br></code></pre></div></td></tr></table></figure>
<p><strong>最后一个具体使用示例：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220152209269.png" srcset="/img/loading.gif" alt="image-20211220152209269"></p>
<h2 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new()/delete()"></a>重载new()/delete()</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220175638793.png" srcset="/img/loading.gif" alt="image-20211220175638793"></p>
<p>new() 称之为placement new()，我们需要重载operator new实现，那么和上面的普通的重载operator new有什么区别呢？他的区别就是在operator new()重载函数中的参数多了一些东西。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220175824558.png" srcset="/img/loading.gif" alt="image-20211220175824558"></p>
<ul>
<li>placement new()的第一参数必须是 <code>size_t</code>,其余的参数就是所谓的placement arguments。</li>
<li><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220180144514.png" srcset="/img/loading.gif" alt="image-20211220180144514"></li>
</ul>
<p><strong>一个标准库中placement new()的例子：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211220181140327.png" srcset="/img/loading.gif" alt="image-20211220181140327"></p>
<p>sgi在basic_string内部定义了一个Rep的结构体，负责COPY-ON-WRITE的实现。要实现COPY-ON-WRITE，就必须对分配的内存块进行计数，Rep就用来进行计数，并把它放在每个内存块的起始位置。同时Rep里还存有一些状态信息。<br>所以内存布局是这样的，Rep|char_type, char_type, char_type……</p>
<blockquote>
<p><strong>写入时复制（英语：Copy-on-write，简称COW）</strong>是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/23/Codeforces-Global-Round-18-A-E/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Codeforces Global Round 18(A-E)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8A/">
                        <span class="hidden-mobile">C++面向对象高级编程-上</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https://chillstepp.github.io/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/';
        this.page.identifier = '/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'fluid' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
