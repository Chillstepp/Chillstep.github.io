

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <link rel="icon" type="image/png" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chillstep">
  <meta name="keywords" content="">
  <title>《EffectiveModernC-》第五章-移动语义，完美转发 - Chillstep</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chillstepp.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chillstep</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sdqryn.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《EffectiveModernC-》第五章-移动语义，完美转发">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-05 02:48" pubdate>
        2023年2月5日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      112
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《EffectiveModernC-》第五章-移动语义，完美转发</h1>
            
            <div class="markdown-body">
              <h1 id="第五章-右值引用，移动语义，完美转发"><a href="#第五章-右值引用，移动语义，完美转发" class="headerlink" title="第五章 右值引用，移动语义，完美转发"></a>第五章 右值引用，移动语义，完美转发</h1><h2 id="Item-23-理解std-move和std-forward"><a href="#Item-23-理解std-move和std-forward" class="headerlink" title="Item 23:理解std::move和std::forward"></a><strong>Item 23:</strong>理解<code>std::move</code>和<code>std::forward</code></h2><p>这里是一个C++11的<code>std::move</code>的示例实现。它并不完全满足标准细则，但是它已经非常接近了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//在std命名空间</span><br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;<br>move(T&amp;&amp; param)<br>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType =                          <span class="hljs-comment">//别名声明，见条款9</span><br>        <span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>std::move</code>接受一个对象的引用，准确的说是一个万能引用（universal reference）。去除对象类型的引用后统一加上<code>&amp;&amp;</code>来变成右值类型ReturnType，再把param强转为这个右值类型。</p>
<p>​    在C++14中可以被更简单地实现。多亏了函数返回值类型推导（见<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item3.html" target="_blank" rel="noopener">Item3</a>）和标准库的模板别名<code>std::remove_reference_t</code>（见<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/3.MovingToModernCpp/item9.html" target="_blank" rel="noopener">Item9</a>），<code>std::move</code>可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span>          <span class="hljs-comment">//C++14，仍然在std命名空间</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-keyword">remove_referece_t</span>&lt;T&gt;&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    如你所见，move名字叫做move但是他并不移动任何资源，只是简单的把类型强转为右值，这样看来，也许叫做<code>rvalue_cast</code>更适合一些。所以对一个对象使用<code>std::move</code>就是告诉编译器，这个对象很适合被移动，move的出现(其实就是右值的出现)帮助我们更容易指定可以被移动的对象。如果你看过<code>auto_ptr</code>的实现，知道他为什么不如<code>unqiue_ptr</code>，你就知道右值的出现解决了很多棘手问题。</p>
<p>下面我们看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Annotation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> text)</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>当复制<code>text</code>到一个数据成员的时候，为了避免一次复制操作的代价，你仍然记得来自<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/8.Tweaks/item41.html" target="_blank" rel="noopener">Item41</a>的建议，把<code>std::move</code>应用到<code>text</code>上，因此产生一个右值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Annotation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> text)</span></span><br>    ：value(std::move(text))    //“移动”text到value里；这段代码执行起来<br>    &#123; … &#125;                       <span class="hljs-comment">//并不是看起来那样</span><br>    <br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    到了这里可能会让你失望了，<code>text</code>并不是被移动到<code>value</code>，而是被<strong>拷贝</strong>。诚然，<code>text</code>通过<code>std::move</code>被转换到右值，但是<code>text</code>被声明为<code>const std::string</code>，所以在转换之前，<code>text</code>是一个左值的<code>const std::string</code>，而转换的结果是一个右值的<code>const std::string</code>，但是纵观全程，<code>const</code>属性一直保留。</p>
<p>​    当编译器决定哪一个<code>std::string</code>的构造函数被调用时，考虑它的作用，将会有两种可能性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span> &#123;</span>                  <span class="hljs-comment">//std::string事实上是</span><br><span class="hljs-keyword">public</span>:                         <span class="hljs-comment">//std::basic_string&lt;char&gt;的类型别名</span><br>    …<br>    <span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs);  <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">string</span>(<span class="hljs-built_in">string</span>&amp;&amp; rhs);       <span class="hljs-comment">//移动构造函数</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    在类<code>Annotation</code>的构造函数的成员初始化列表中，<code>std::move(text)</code>的结果是一个<code>const std::string</code>的右值。这个右值不能被传递给<code>std::string</code>的移动构造函数，因为移动构造函数只接受一个指向<strong>non-<code>const</code>的<code>std::string</code>的右值引用</strong>。这很容易解释，因为non-const的引用类型不会限制修改内容，这最终会导致你修改了const的内容，这显然是不会被编译器允许的。换个更易懂的角度来看，移动操作本质就是对资源的移动，一个const的右值类型怎么做资源移动呢？这显然非常不合理，因此会调用到拷贝构造。另外要提一点，拷贝构造函数的const左值引用对左右值都可以适配。</p>
<p>从这个例子中，可以总结出两点。</p>
<ul>
<li><p><strong>第一，不要在你希望能移动对象的时候，声明他们为<code>const</code>。对<code>const</code>对象的移动请求会悄无声息的被转化为拷贝操作。</strong></p>
</li>
<li><p><strong>第二点，<code>std::move</code>不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于<code>std::move</code>，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。</strong></p>
</li>
</ul>
<p>再来讨论下<code>std::forward</code>，</p>
<p>​    关于<code>std::forward</code>的故事与<code>std::move</code>是相似的，但是与<code>std::move</code>总是<strong>无条件</strong>的将它的实参为右值不同，<code>std::forward</code>只有在满足一定条件的情况下才执行转换。<code>std::forward</code>是<strong>有条件</strong>的转换。</p>
<p>最常见的情景是一个模板函数，接收一个通用引用形参，并将它传递给另外的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Widget&amp; lvalArg)</span></span>;        <span class="hljs-comment">//处理左值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Widget&amp;&amp; rvalArg)</span></span>;             <span class="hljs-comment">//处理右值</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                        <span class="hljs-comment">//用以转发param到process的模板</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndProcess</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now =                              <span class="hljs-comment">//获取现在时间</span><br>        <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <br>    makeLogEntry(<span class="hljs-string">"Calling 'process'"</span>, now);<br>    process(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(param));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>考虑两次对<code>logAndProcess</code>的调用，一次左值为实参，一次右值为实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w;<br><br>logAndProcess(w);               <span class="hljs-comment">//用左值调用</span><br>logAndProcess(<span class="hljs-built_in">std</span>::move(w));    <span class="hljs-comment">//用右值调用</span><br></code></pre></div></td></tr></table></figure>
<p>​    在<code>logAndProcess</code>函数的内部，形参<code>param</code>被传递给函数<code>process</code>。函数<code>process</code>分别对左值和右值做了重载。当我们使用左值来调用<code>logAndProcess</code>时，自然我们期望该左值被当作左值转发给<code>process</code>函数，而当我们使用右值来调用<code>logAndProcess</code>函数时，我们期望<code>process</code>函数的右值重载版本被调用。</p>
<p>​    <strong>当且仅当传递给函数<code>logAndProcess</code>的用以初始化<code>param</code>的实参是一个右值时，<code>param</code>会被转换为一个右值。</strong>这就是<code>std::forward</code>做的事情。这就是为什么<code>std::forward</code>是一个<strong>有条件</strong>的转换：它的实参用右值初始化时，转换为一个右值。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><code>std::move</code>执行到右值的无条件的转换，但就自身而言，它不移动任何东西。</li>
<li><code>std::forward</code>只有当它的参数被绑定到一个右值时，才将参数转换为右值。</li>
<li><code>std::move</code>和<code>std::forward</code>在运行期什么也不做。</li>
</ul>
<h2 id="Item-24-区分通用引用与右值引用"><a href="#Item-24-区分通用引用与右值引用" class="headerlink" title="Item 24: 区分通用引用与右值引用"></a>Item 24: 区分通用引用与右值引用</h2><p><code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>我们一般认为是万能引用的标准形式，但是有一些corner case你需要注意下，比如：</p>
<ul>
<li><p>不要在T和auto前加const，这会导致变成右值引用。即使一个简单的<code>const</code>修饰符的出现，也足以使一个引用失去成为通用引用的资格:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;&amp; param)</span></span>;        <span class="hljs-comment">//param是一个右值引用</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p><code>类型推导的T/auto</code>+<code>&amp;&amp;</code>才是通用引用，当类里看见了一个函数形参类型为“<code>T&amp;&amp;</code>”，他不一定是通用引用，因为T在类定义是可能已经推导完成了：</p>
<p>来自<code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; x)</span></span>;<br>    …<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>push_back</code>函数的形参当然有一个通用引用的正确形式，然而，在这里并没有发生类型推导。因为<code>push_back</code>在有一个特定的<code>vector</code>实例之前不可能存在，而实例化<code>vector</code>时的类型已经决定了<code>push_back</code>的声明。</p>
<p><strong>作为对比，<code>std::vector</code>内的概念上相似的成员函数<code>emplace_back</code>，却确实包含类型推导:</strong> 如你所见Args实实在在的进行了类型推导。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> = <span class="hljs-title">allocator</span>&lt;T&gt;&gt;   //依旧来自<span class="hljs-title">C</span>++标准</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">vector</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span>... <span class="hljs-title">Args</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">void</span> <span class="hljs-title">emplace_back</span>(<span class="hljs-title">Args</span>&amp;&amp;... <span class="hljs-title">args</span>);</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>这里提一句，万能引用的底层本质是引用折叠，我们后面iten28会提到这个概念。</p>
<h2 id="item25：对右值引用使用std-move，对通用引用使用std-forward"><a href="#item25：对右值引用使用std-move，对通用引用使用std-forward" class="headerlink" title="item25：对右值引用使用std::move，对通用引用使用std::forward"></a>item25：对右值引用使用<code>std::move</code>，对通用引用使用<code>std::forward</code></h2><p><strong>在右值引用上使用std::forward也是可以的，但是代码长语义不够清晰</strong>，一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(classType&amp;&amp; newName)</span> </span><br><span class="hljs-function"></span>&#123;<br>	name = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(newName);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>你要写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(classType&amp;&amp; newName)</span> </span><br><span class="hljs-function"></span>&#123;<br>	name = <span class="hljs-built_in">std</span>::forward&lt;classType&gt;(newName);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这实在有些自找麻烦，因为：</p>
<ul>
<li>forward你得写上classType，多写东西</li>
<li>move看起来语义很清晰，你知道<code>std::move</code>后的东西一定是一个右值，对于forward，你可能还需要稍微考虑下。</li>
</ul>
<p><strong>因此对于右值引用，请直接使用<code>std::move()</code>。</strong></p>
<p><strong>对于万能引用来说，使用<code>std::forward</code>则是一个更好的选择</strong></p>
<p>观察如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T&amp;&amp; newName)</span>       <span class="hljs-comment">//通用引用可以编译，</span></span><br><span class="hljs-function">    </span>&#123; name = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(newName); &#125;  <span class="hljs-comment">//但是代码太太太差了！</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;SomeDataStructure&gt; p;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getWidgetName</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//工厂函数</span><br><br>Widget w;<br><br><span class="hljs-keyword">auto</span> n = getWidgetName();           <span class="hljs-comment">//n是局部变量</span><br><br>w.setName(n);                       <span class="hljs-comment">//把n移动进w！</span><br><br>…                                   <span class="hljs-comment">//现在n的值未知</span><br></code></pre></div></td></tr></table></figure>
<p>对于右值来说，使用move没什么问题，因为右值代表了你想使用移动语义。而对于一个左值n来说，因为move函数导致了左值n强转为右值，newname因为移动语义把自身的资源转移给了name。这会导致你完全不知道的情况下改变了你的左值。</p>
<p>你可能会指出，如果为<code>const</code>左值和为右值分别重载<code>setName</code>可以避免整个问题，比如这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; newName)</span>    <span class="hljs-comment">//用const左值设置</span></span><br><span class="hljs-function">    </span>&#123; name = newName; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp;&amp; newName)</span>         <span class="hljs-comment">//用右值设置</span></span><br><span class="hljs-function">    </span>&#123; name = <span class="hljs-built_in">std</span>::move(newName); &#125;<br>    <br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这样的话，当然可以工作，但是有缺点。</p>
<ul>
<li><p>首先编写和维护的代码更多（两个函数而不是单个模板）；</p>
</li>
<li><p>其次，效率下降。</p>
<p>考虑这样一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">w.setName(<span class="hljs-string">"Adela Novak"</span>);<br></code></pre></div></td></tr></table></figure>
<p>​    对于通用引用的版本来说，字面字符串<code>&quot;Adela Novak&quot;</code>传递给setName的参数时，T会被推倒出<code>const char[]</code>类型，然后引用到这个字面字符串，再传递给setName内部的赋值运算，这个过程中没有任何的临时变量被创建。但是对于分别重载左右值的版本，你会发现由于参数写的是string类型，因此你需要隐式构造一个临时对象，然后让<code>string&amp;&amp;右值引用</code> 来引用这个临时对象。可以发现我们需要多创建一次临时对象，这显然影响了性能。</p>
<p>​    当然你可以再添加一对<code>const char[]</code>版本的<code>setName</code>, 然后也分别做左右值引用两个版本就好了。但是可以显而易见，这种代码编写和维护会变得很困难。</p>
</li>
<li><p>如果有n个参数，每个参数都有两种可能，你就要写$2^n$种重载函数, 这也太难维护代码了(比如<code>make_shared</code>这种使用了variadic template，常常参数包里有多个参数)。</p>
</li>
</ul>
<p><strong>因此以上三条殊途同归都在说的一个问题就是：编写和维护起来很困难。</strong></p>
<p>现在我想已经说服了你，你应该，就像标题说的一样：<strong>对右值引用使用<code>std::move</code>，对通用引用使用<code>std::forward</code></strong></p>
<p>下面讨论一些其他的场景，比如在某些情况，你可能需要在一个函数中多次使用绑定到右值引用或者通用引用的对象，并且想确保在完成其他操作前，这个对象不会被移动，也就是内部资源不会被其他操作移动走。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSignText</span><span class="hljs-params">(T&amp;&amp; <span class="hljs-built_in">text</span>)</span>                  <span class="hljs-comment">//text是通用引用</span></span><br><span class="hljs-function"></span>&#123;<br>  sign.setText(<span class="hljs-built_in">text</span>);                       <span class="hljs-comment">//使用text但是不改变它</span><br>  <br>  <span class="hljs-keyword">auto</span> now = <br>      <span class="hljs-built_in">std</span>::chrono::system_clock::now();     <span class="hljs-comment">//获取现在的时间</span><br>  <br>  signHistory.add(now, <br>                  <span class="hljs-built_in">std</span>::forward&lt;T&gt;(<span class="hljs-built_in">text</span>));   <span class="hljs-comment">//有条件的转换为右值</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们想要确保<code>text</code>的值不会被<code>sign.setText</code>改变，因为我们想要在<code>signHistory.add</code>中继续使用。因此<code>std::forward</code>只在最后使用，前面<code>sign.setText(text);</code>的text只是一个右值引用变量, 是一个左值，因此不会调用到移动操作。</p>
<p>如果你在<strong>按值</strong>返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用<code>std::move</code>或者<code>std::forward</code>。要了解原因，考虑两个矩阵相加的<code>operator+</code>函数，左侧的矩阵为右值（可以被用来保存求值之后的和）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//按值返回</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(lhs);	        <span class="hljs-comment">//移动lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通过在<code>return</code>语句中将<code>lhs</code>转换为右值（通过<code>std::move</code>），<code>lhs</code>可以移动到返回值的内存位置。如果省略了<code>std::move</code>调用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Matrix                              <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-keyword">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> lhs;                     <span class="hljs-comment">//拷贝lhs到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>lhs</code>是个左值的事实，会强制编译器拷贝它到返回值的内存空间。假定<code>Matrix</code>支持移动操作，并且比拷贝操作效率更高，在<code>return</code>语句中使用<code>std::move</code>的代码效率更高。</p>
<p>如果<code>Matrix</code>不支持移动操作，将其转换为右值不会变差，因为右值可以直接被<code>Matrix</code>的拷贝构造函数拷贝（见<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item23.html" target="_blank" rel="noopener">Item23</a>）。如果<code>Matrix</code>随后支持了移动操作，<code>operator+</code>将在下一次编译时受益。就是这种情况，通过将<code>std::move</code>应用到按值返回的函数中要返回的右值引用上，不会损失什么（还可能获得收益）。</p>
<p>你可能听过rvo/nrvo的技术，这种优化警告我们不要在返回值使用move，这是否和上面违背了呢？</p>
<p>如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的“拷贝”版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;                       <span class="hljs-comment">//局部对象</span><br>    …                               <span class="hljs-comment">//配置w</span><br>    <span class="hljs-keyword">return</span> w;                       <span class="hljs-comment">//“拷贝”w到返回值中</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可能想要“优化”代码，把“拷贝”变为移动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span>                 <span class="hljs-comment">//makeWidget的移动版本</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;<br>    …<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(w);            <span class="hljs-comment">//移动w到返回值中（不要这样做！）</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我的注释告诉你这种想法是有问题的，但是问题在哪？</p>
<p>这是错的，因为对于这种优化，标准化委员会远领先于开发者。早就为人认识到的是，<code>makeWidget</code>的“拷贝”版本可以避免复制局部变量<code>w</code>的需要，通过在分配给函数返回值的内存中构造<code>w</code>来实现。这就是所谓的<strong>返回值优化</strong>（<em>return value optimization</em>，RVO），这在C++标准中已经实现了。<strong>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</strong></p>
<p><strong>请记住：</strong></p>
<ul>
<li>最后一次使用时，在右值引用上使用<code>std::move</code>，在通用引用上使用<code>std::forward</code>。</li>
<li>对按值返回的函数要返回的右值引用和通用引用，执行相同的操作。</li>
<li>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</li>
</ul>
<h2 id="Item26：避免在通用引用上重载"><a href="#Item26：避免在通用引用上重载" class="headerlink" title="Item26：避免在通用引用上重载"></a>Item26：避免在通用引用上重载</h2><p>上一个item讲到对通用引用使用<code>std::forward</code>的原因，我们可以写出如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_lock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">petName</span><span class="hljs-params">(<span class="hljs-string">"Darla"</span>)</span></span>;           <span class="hljs-comment">//跟之前一样</span><br>logAndAdd(petName);                     <span class="hljs-comment">//跟之前一样，拷贝左值到multiset</span><br>logAndAdd(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Persephone"</span>));	<span class="hljs-comment">//移动右值而不是拷贝它</span><br>logAndAdd(<span class="hljs-string">"Patty Dog"</span>);                 <span class="hljs-comment">//在multiset直接创建std::string</span><br>                                        <span class="hljs-comment">//而不是拷贝一个临时std::string</span><br></code></pre></div></td></tr></table></figure>
<p>比如我们现在想重载一下<code>logAndAdd</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;   <span class="hljs-comment">//返回idx对应的名字</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>             <span class="hljs-comment">//新的重载</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_lock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(nameFromIdx(idx));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>之后的两个调用按照预期工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">petName</span><span class="hljs-params">(<span class="hljs-string">"Darla"</span>)</span></span>;           <span class="hljs-comment">//跟之前一样</span><br><br>logAndAdd(petName);                     <span class="hljs-comment">//跟之前一样，</span><br>logAndAdd(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Persephone"</span>)); 	<span class="hljs-comment">//这些调用都去调用</span><br>logAndAdd(<span class="hljs-string">"Patty Dog"</span>);                 <span class="hljs-comment">//T&amp;&amp;重载版本</span><br><br>logAndAdd(<span class="hljs-number">22</span>);                          <span class="hljs-comment">//调用int重载版本</span><br></code></pre></div></td></tr></table></figure>
<p>但是当这样的代码出现时：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">short nameIdx;<br>…                                       <span class="hljs-comment">//给nameIdx一个值</span><br>logAndAdd(nameIdx);                     <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>有两个重载的<code>logAndAdd</code>。使用通用引用的那个推导出<code>T</code>的类型是<code>short</code>，因此可以精确匹配。对于<code>int</code>类型参数的重载也可以在<code>short</code>类型提升后匹配成功。根据正常的重载解决规则，精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。所有这一切的原因就是对于<code>short</code>类型通用引用重载优先于<code>int</code>类型的重载。</p>
<p>​    通用引用的函数在C++中是最贪婪的函数。它们几乎可以精确匹配任何类型的实参（极少不适用的实参在<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item30.html" target="_blank" rel="noopener">Item30</a>中介绍）。<strong>这也是把重载和通用引用组合在一块是糟糕主意的原因：通用引用的实现会匹配比开发者预期要多得多的实参类型。</strong></p>
<p>​    一个更容易掉入这种陷阱的例子是写一个<strong>完美转发构造函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span>              <span class="hljs-comment">//完美转发的构造函数，初始化数据成员</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>            <span class="hljs-comment">//int的构造函数</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span> </span>&#123;&#125;<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>就像在<code>logAndAdd</code>的例子中，传递一个不是<code>int</code>的整型变量（比如<code>std::size_t</code>，<code>short</code>，<code>long</code>等）会调用通用引用的构造函数而不是<code>int</code>的构造函数，这会导致编译错误。这里这个问题甚至更糟糕，因为<code>Person</code>中存在的重载比肉眼看到的更多。在<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/3.MovingToModernCpp/item17.html" target="_blank" rel="noopener">Item17</a>中说明，在适当的条件下，C++会生成拷贝和移动构造函数，即使类包含了模板化的构造函数，模板函数能实例化产生与拷贝和移动构造函数一样的签名，也在合适的条件范围内。如果拷贝和移动构造被生成，<code>Person</code>类看起来就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">//完美转发的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(T&amp;&amp; n)</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;       <span class="hljs-comment">//int的构造函数</span><br><br>    Person(<span class="hljs-keyword">const</span> Person&amp; rhs);      <span class="hljs-comment">//拷贝构造函数（编译器生成）</span><br>    Person(Person&amp;&amp; rhs);           <span class="hljs-comment">//移动构造函数（编译器生成）</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这种实现会导致不符合人类直觉的结果，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"Nancy"</span>)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">cloneOfP</span><span class="hljs-params">(p)</span></span>;                   <span class="hljs-comment">//从p创建新Person；这通不过编译！</span><br></code></pre></div></td></tr></table></figure>
<p>这里我们试图通过一个<code>Person</code>实例创建另一个<code>Person</code>，显然应该调用拷贝构造即可。但是这份代码不是调用拷贝构造函数，<strong>而是调用完美转发构造函数</strong>。然后，<strong>完美转发的函数将尝试使用<code>Person</code>对象<code>p</code>初始化<code>Person</code>的<code>std::string</code>数据成员，编译器就会报错。</strong></p>
<p>编译器的理由如下：实例化之后，<code>Person</code>类看起来是这样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(Person&amp; n)</span>          <span class="hljs-comment">//由完美转发模板初始化</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::forward&lt;Person&amp;&gt;(n))</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span></span>;           <span class="hljs-comment">//同之前一样</span><br><br>    Person(<span class="hljs-keyword">const</span> Person&amp; rhs);          <span class="hljs-comment">//拷贝构造函数（编译器生成的）</span><br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>显然<code>non-const</code>的p会匹配到完美转发的构造函数，因为这种匹配优先级更高, 如果是一个const的就会匹配到拷贝构造函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Person <span class="hljs-title">cp</span><span class="hljs-params">(<span class="hljs-string">"Nancy"</span>)</span></span>;   <span class="hljs-comment">//现在对象是const的</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">cloneOfP</span><span class="hljs-params">(cp)</span></span>;          <span class="hljs-comment">//调用拷贝构造函数！</span><br></code></pre></div></td></tr></table></figure>
<p>​    当继承纳入考虑范围时，完美转发的构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂。尤其是，派生类的拷贝和移动操作的传统实现会表现得非常奇怪。来看一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialPerson</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    SpecialPerson(<span class="hljs-keyword">const</span> SpecialPerson&amp; rhs) <span class="hljs-comment">//拷贝构造函数，调用基类的</span><br>    : Person(rhs)                           <span class="hljs-comment">//完美转发构造函数！</span><br>    &#123; … &#125;<br><br>    SpecialPerson(SpecialPerson&amp;&amp; rhs)      <span class="hljs-comment">//移动构造函数，调用基类的</span><br>    : Person(<span class="hljs-built_in">std</span>::move(rhs))                <span class="hljs-comment">//完美转发构造函数！</span><br>    &#123; … &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如同注释表示的，派生类的拷贝和移动构造函数没有调用基类的拷贝和移动构造函数，而是调用了基类的完美转发构造函数！为了理解原因，要知道派生类将<code>SpecialPerson</code>类型的实参传递给其基类，然后通过模板实例化和重载解析规则作用于基类<code>Person</code>。最终，代码无法编译，因为<code>std::string</code>没有接受一个<code>SpecialPerson</code>的构造函数。</p>
<p>我希望到目前为止，已经说服了你，如果可能的话，避免对通用引用形参的函数进行重载。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多。</li>
<li><strong>完美转发构造函数是糟糕的实现，因为对于non-<code>const</code>左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。</strong></li>
</ul>
<h2 id="item27：熟悉通用引用重载的替代方法"><a href="#item27：熟悉通用引用重载的替代方法" class="headerlink" title="item27：熟悉通用引用重载的替代方法"></a>item27：熟悉通用引用重载的替代方法</h2><p>item26讨论了大量你不应该对万能引用作为形参的函数重载 的原因。</p>
<p>这个条款探讨了几种，通过避免在万能引用上重载的设计，或者通过限制万能引用可以匹配的参数类型，来实现所期望行为的方法。</p>
<h3 id="1-放弃重载"><a href="#1-放弃重载" class="headerlink" title="1.放弃重载"></a>1.放弃重载</h3><p>第一种就是放弃重载，<code>logAndAdd</code>是许多函数的代表，这些函数可以使用不同的名字来避免在通用引用上的重载的弊端。例如两个重载的<code>logAndAdd</code>函数，可以分别改名为<code>logAndAddName</code>和<code>logAndAddNameIdx</code>。</p>
<p>可惜的是，这种方式不能用在第二个例子，<code>Person</code>构造函数中，因为构造函数的名字被语言固定了。</p>
<h3 id="2-传递const-T-amp"><a href="#2-传递const-T-amp" class="headerlink" title="2.传递const T&amp;"></a>2.传递<code>const T&amp;</code></h3><p>一种替代方案是退回到C++98，然后把传递万能引用替换为传递lvalue-refrence-to-<code>const</code>。我们知道常左值引用比较特殊，它不仅可以对左值，还可以对右值进行引用。事实上，这是<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item26.html" target="_blank" rel="noopener">Item26</a>中首先考虑的方法。缺点是效率不高。现在我们知道了通用引用和重载的相互关系，所以放弃一些效率来确保行为正确简单可能也是一种不错的折中。</p>
<h3 id="3-传值"><a href="#3-传值" class="headerlink" title="3.传值"></a>3.传值</h3><p>通常在不增加复杂性的情况下提高性能的一种方法是，将按传引用形参替换为按值传递，这是违反直觉的。该设计遵循<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/8.Tweaks/item41.html" target="_blank" rel="noopener">Item41</a>中给出的建议，即在你知道要拷贝时就按值传递，因此会参考那个条款来详细讨论如何设计与工作，效率如何。这里，在<code>Person</code>的例子中展示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> n)</span>  <span class="hljs-comment">//代替T&amp;&amp;构造函数，</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(n))</span> </span>&#123;&#125;         <span class="hljs-comment">//std::move的使用见条款41</span><br>  <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span>        <span class="hljs-comment">//同之前一样</span></span><br><span class="hljs-function">    : <span class="hljs-title">name</span><span class="hljs-params">(nameFromIdx(idx))</span> </span>&#123;&#125;<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    因为没有<code>std::string</code>构造函数可以接受整型参数，所有<code>int</code>或者其他整型变量（比如<code>std::size_t</code>、<code>short</code>、<code>long</code>等）都会使用<code>int</code>类型重载的构造函数。相似的，所有<code>std::string</code>类似的实参（还有可以用来创建<code>std::string</code>的东西，比如字面量“<code>Ruth</code>”等）都会使用<code>std::string</code>类型的重载构造函数。</p>
<p>​    没有意外情况。我想你可能会说有些人使用<code>0</code>或者<code>NULL</code>指代空指针会调用<code>int</code>重载的构造函数让他们很吃惊，但是这些人应该参考<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/3.MovingToModernCpp/item8.html" target="_blank" rel="noopener">Item8</a>反复阅读直到使用<code>0</code>或者<code>NULL</code>作为空指针让他们恶心。</p>
<h3 id="4-标签分发tag-dispatch"><a href="#4-标签分发tag-dispatch" class="headerlink" title="4.标签分发tag dispatch"></a>4.标签分发tag dispatch</h3><p>下面是原来的代码，以免你再分心回去查看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; names;       <span class="hljs-comment">//全局数据结构</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                    <span class="hljs-comment">//志记信息，将name添加到数据结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clokc::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们在logAndAdd中对不同的情况做标签分发：</p>
<p>比如对于接受idx的版本，我们判断一下T的类型是不是整数即可，如果是整数，就进入到整数的那个实现版本里</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span> </span><br><span class="hljs-function"></span>&#123;<br>    logAndAddImpl(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name),<br>                  <span class="hljs-built_in">std</span>::is_integral&lt;T&gt;());   <span class="hljs-comment">//不那么正确</span><br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                            <span class="hljs-comment">//非整型实参：添加到全局数据结构中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(T&amp;&amp; name, <span class="hljs-built_in">std</span>::false_type)</span>	<span class="hljs-comment">//译者注：高亮std::false_type</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">"logAndAdd"</span>);<br>    names.emplace(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">std</span>::true_type)</span> <span class="hljs-comment">//译者注：高亮std::true_type</span></span><br><span class="hljs-function"></span>&#123;<br>  logAndAdd(nameFromIdx(idx)); <span class="hljs-comment">//std::string nameFromIdx(int idx);</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但这里是有瑕疵的，比如对于一个右值整数作为logAndAdd的参数，T会推导出int，这没什么问题，但是对于一个左值整数，T会推导出<code>int&amp;</code>（推导规则请看第一章），而<code>int&amp;</code>并不会被<code>std::is_integral&lt;T&gt;()</code>的结果认为是true，因此我们需要去掉一下引用符，利用<code>std::remove_reference</code>即可</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    logAndAddImpl(<br>        <span class="hljs-built_in">std</span>::forward&lt;T&gt;(name),<br>        <span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()<span class="hljs-comment">//（在C++14中，你可以通过`std::remove_reference_t&lt;T&gt;`来简化写法)</span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在这个设计中，类型<code>std::true_type</code>和<code>std::false_type</code>是“标签”（tag），其唯一目的就是强制重载解析按照我们的想法来执行。</p>
<h3 id="5-约束使用万能引用的模板"><a href="#5-约束使用万能引用的模板" class="headerlink" title="5.约束使用万能引用的模板"></a>5.约束使用万能引用的模板</h3><p>可以先了解下SFINAE , 博客链接： <a href="https://chillstepp.github.io/2022/07/24/C-SFINAE/#%E7%BC%96%E8%AF%91%E6%9C%9F%E6%88%90%E5%91%98%E6%A3%80%E6%B5%8B-%E6%9C%89%E6%95%88-%E6%97%A0%E6%95%88">https://chillstepp.github.io/2022/07/24/C-SFINAE/#%E7%BC%96%E8%AF%91%E6%9C%9F%E6%88%90%E5%91%98%E6%A3%80%E6%B5%8B-%E6%9C%89%E6%95%88-%E6%97%A0%E6%95%88</a></p>
<p>在iterm26还讨论了一种情形是：万能引用作为形参的构造函数 和 编译器自动生成的构造函数 的问题，他们的重载也导致了一些不符合直觉的后果，本着苦了谁都不能苦调用者的精神，我们不希望那种情况出现。</p>
<p>我们可以写出一个最基本的版本：</p>
<p>其中decay会移除T的引用和cv限定符</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::enable_if&lt;<br>                       !<span class="hljs-built_in">std</span>::is_same&lt;Person, <br>                                     <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::decay&lt;T&gt;::type<br>                                    &gt;::value<br>                   &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n);<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>假定从<code>Person</code>派生的类以常规方式实现拷贝和移动操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialPerson</span>:</span> <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    SpecialPerson(<span class="hljs-keyword">const</span> SpecialPerson&amp; rhs) <span class="hljs-comment">//拷贝构造函数，调用基类的</span><br>    : Person(rhs)                           <span class="hljs-comment">//完美转发构造函数！</span><br>    &#123; … &#125;<br>    <br>    SpecialPerson(SpecialPerson&amp;&amp; rhs)      <span class="hljs-comment">//移动构造函数，调用基类的</span><br>    : Person(<span class="hljs-built_in">std</span>::move(rhs))                <span class="hljs-comment">//完美转发构造函数！</span><br>    &#123; … &#125;<br>    <br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>此时<code>Person(rhs)</code>这一句rhs是SpecialPerson类型的，因此会导致我们的EnableIf并不会通过，因此要做点修改要认为是子类即可，同时可以简化成<code>_t</code>版本的，如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>  &#123;</span>                                         <span class="hljs-comment">//C++14</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;                    <span class="hljs-comment">//这儿更少的代码</span><br>                       !<span class="hljs-built_in">std</span>::is_base_of&lt;Person,<br>                                        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;T&gt; <span class="hljs-comment">//还有这儿</span><br>                                       &gt;::value<br>                   &gt;                                    <span class="hljs-comment">//还有这儿</span><br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n);<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>加入此时有重载函数的出现，比如通过id来构造一个person：</p>
<p>此时我们就在enable的condition里加上新限制即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<br>        <span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<br>            !<span class="hljs-built_in">std</span>::is_base_of&lt;Person, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;T&gt;&gt;::value<br>            &amp;&amp;<br>            !<span class="hljs-built_in">std</span>::is_integral&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">remove_reference_t</span>&lt;T&gt;&gt;::value<br>        &gt;<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> Person(T&amp;&amp; n)          <span class="hljs-comment">//对于std::strings和可转化为</span><br>    : name(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(n))      <span class="hljs-comment">//std::strings的实参的构造函数</span><br>    &#123; … &#125;<br><br>    <span class="hljs-keyword">explicit</span> Person(<span class="hljs-keyword">int</span> idx)        <span class="hljs-comment">//对于整型实参的构造函数</span><br>    : name(nameFromIdx(idx))<br>    &#123; … &#125;<br><br>    …                               <span class="hljs-comment">//拷贝、移动构造函数等</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>请记住：</strong></p>
<ul>
<li>通用引用和重载的组合替代方案包括使用不同的函数名，通过lvalue-reference-to-<code>const</code>传递形参，按值传递形参，使用<em>tag dispatch</em>。</li>
<li>通过<code>std::enable_if</code>约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。</li>
<li>通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。</li>
</ul>
<h2 id="Item28：理解引用折叠"><a href="#Item28：理解引用折叠" class="headerlink" title="Item28：理解引用折叠"></a>Item28：理解引用折叠</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br><br><span class="hljs-function">Widget <span class="hljs-title">widgetFactory</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//返回右值的函数</span><br>Widget w;                   <span class="hljs-comment">//一个变量（左值）</span><br>func(w);                    <span class="hljs-comment">//用左值调用func；T被推导为Widget&amp;</span><br>func(widgetFactory());      <span class="hljs-comment">//用右值调用func；T被推导为Widget</span><br></code></pre></div></td></tr></table></figure>
<p>我们首先要明确再c++中引用的引用是非法的，编译器却可以这样做。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">func(w);  <span class="hljs-comment">//T推导为Widget&amp;</span><br><span class="hljs-comment">//把Widget&amp;带入T</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Widget&amp;&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Widget&amp; &amp;&amp; param)</span></span>;<br><br><span class="hljs-comment">//引用折叠导致</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Widget&amp; &amp;&amp; param)</span></span>; <br><span class="hljs-comment">//变为</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Widget&amp; param)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>引用折叠的一个best practice是<code>std::forward</code></p>
<p><code>std::forward</code>可以简单实现为:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                <span class="hljs-comment">//在std命名空间</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>考虑当传入的实参是个左值，那么推导如下，左值被T推导为<code>Widget&amp;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p>根据引用折叠规则，返回值和强制转换可以化简，最终版本的<code>std::forward</code>调用就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Widget&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p>也就是当实参是左值，最后会推导出左值引用，左值引用也是一个左值，左值返回左值，这很好。</p>
<p>当实参是右值时：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param); &#125;<br></code></pre></div></td></tr></table></figure>
<p>此时就会返回右值，右值返回右值，这也很好。</p>
<p>到此我们可以发现通过forward利用引用折叠完美转发了实参的类型。</p>
<h2 id="Item29：移动操作的缺点"><a href="#Item29：移动操作的缺点" class="headerlink" title="Item29：移动操作的缺点"></a>Item29：移动操作的缺点</h2><p>存在几种情况，移动语义并无优势：</p>
<ul>
<li><strong>没有移动操作</strong>：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。</li>
<li><strong>移动不会更快</strong>：要移动的对象提供的移动操作并不比复制速度更快。</li>
<li><strong>移动不可用</strong>：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为<code>noexcept</code>。</li>
</ul>
<h2 id="Item30：熟悉完美转发失败的情况"><a href="#Item30：熟悉完美转发失败的情况" class="headerlink" title="Item30：熟悉完美转发失败的情况"></a>Item30：熟悉完美转发失败的情况</h2><h3 id="1-花括号初始化器"><a href="#1-花括号初始化器" class="headerlink" title="1.花括号初始化器"></a>1.花括号初始化器</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(Ts&amp;&amp;... params)</span>            <span class="hljs-comment">//接受任何实参</span></span><br><span class="hljs-function"></span>&#123;<br>    f(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...); <span class="hljs-comment">//转发给f</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    f(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//ok</span><br>    fwd(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//error</span><br>    <br>    <span class="hljs-keyword">auto</span> x = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    fwd(x);<span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    在对<code>f</code>的直接调用（例如<code>f({ 1, 2, 3 })</code>），编译器看看调用地传入的实参（即<code>{1，2，3}</code>），看看<code>f</code>声明的形参类型。它们把调用地的实参和声明的实参进行比较，看看是否匹配，并且必要时执行隐式转换操作使得调用成功。在上面的例子中，从<code>{ 1, 2, 3 }</code>生成了临时<code>std::vector&lt;int&gt;</code>对象，因此<code>f</code>的形参<code>v</code>会绑定到<code>std::vector&lt;int&gt;</code>对象上。</p>
<p>​    当通过调用函数模板<code>fwd</code>间接调用<code>f</code>时，编译器不再把传入给<code>fwd</code>的实参和<code>f</code>的声明中形参类型进行比较。而是<strong>推导</strong>传入给<code>fwd</code>的实参类型，然后比较推导后的实参类型和<code>f</code>的形参声明类型。当下面情况任何一个发生时，完美转发就会失败：</p>
<ul>
<li><strong>编译器不能推导出<code>fwd</code>的一个或者多个形参类型。</strong>这种情况下代码无法编译。</li>
<li><strong>编译器推导“错”了<code>fwd</code>的一个或者多个形参类型。</strong>在这里，“错误”可能意味着<code>fwd</code>的实例将无法使用推导出的类型进行编译，但是也可能意味着使用<code>fwd</code>的推导类型调用<code>f</code>，与用传给<code>fwd</code>的实参直接调用<code>f</code>表现出不一致的行为。这种不同行为的原因可能是因为<code>f</code>是个重载函数的名字，并且由于是“不正确的”类型推导，在<code>fwd</code>内部调用的<code>f</code>重载和直接调用的<code>f</code>重载不一样。</li>
</ul>
<p>将花括号初始化传递给未声明为<code>std::initializer_list</code>的函数模板形参，被判定为——就像标准说的——“非推导上下文”。简单来讲，这意味着编译器不准在对<code>fwd</code>的调用中推导表达式<code>{ 1, 2, 3 }</code>的类型(注意花括号和<code>std::initializer_list</code>不是一个东西)，因为<code>fwd</code>的形参没有声明为<code>std::initializer_list</code>。对于<code>fwd</code>形参的推导类型被阻止，编译器只能拒绝该调用。</p>
<p>使用花括号初始化的<code>auto</code>的变量的类型推导是成功的。这种变量被视为<code>std::initializer_list</code>对象，在转发函数应推导出类型为<code>std::initializer_list</code>的情况，这提供了一种简单的解决方法——使用<code>auto</code>声明一个局部变量，然后将局部变量传进转发函数，这就是上面第三次可以调用ok的原因。</p>
<h3 id="2-0或者NULL作为空指针"><a href="#2-0或者NULL作为空指针" class="headerlink" title="2.0或者NULL作为空指针"></a>2.<code>0</code>或者<code>NULL</code>作为空指针</h3><p>会推导成int，请使用nullptr</p>
<h3 id="3-仅有声明的整型static-const数据成员"><a href="#3-仅有声明的整型static-const数据成员" class="headerlink" title="3.仅有声明的整型static const数据成员"></a>3.仅有声明的整型static const数据成员</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> MinVals = <span class="hljs-number">28</span>;  <span class="hljs-comment">//MinVal的声明</span><br><br>&#125;;<br>                                        <span class="hljs-comment">//没有MinVals定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"1"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(T&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    f(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(params)...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; widgetData;<br>    widgetData.reserve(Widget::MinVals);        <span class="hljs-comment">//使用MinVals</span><br>    f(Widget::MinVals);<span class="hljs-comment">//ok ,视为“f(28)”</span><br>    fwd(Widget::MinVals); <span class="hljs-comment">//error，undefined reference to `Widget::MinVals'</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>​    因为编译器会对此类成员实行<strong>常量传播</strong>（<em>const propagation</em>），因此消除了保留内存的需要，编译器通过<strong>常量传播</strong>将值28放入所有提到<code>MinVals</code>的位置来补充缺少的定义（就像它们被要求的那样）。没有为<code>MinVals</code>的值留存储空间是没有问题的。如果要使用<code>MinVals</code>的地址（例如，有人创建了指向<code>MinVals</code>的指针），则<code>MinVals</code>需要存储（这样指针才有可指向的东西），尽管上面的代码仍然可以编译，但是链接时就会报错，直到为<code>MinVals</code>提供定义。</p>
<p>​    尽管代码中没有使用<code>MinVals</code>的地址，但是<code>fwd</code>的形参是通用引用，而引用，在编译器生成的代码中，通常被视作指针。在程序的二进制底层代码中（以及硬件中）指针和引用是一样的。通过引用传递<code>MinVals</code>实际上与通过指针传递<code>MinVals</code>是一样的，因此，必须有内存使得指针可以指向。通过引用传递的整型<code>static const</code>数据成员，通常需要定义它们，这个要求可能会造成在不使用完美转发的代码成功的地方，使用等效的完美转发失败。</p>
<p>因此我们需要定义MinVals，只要给整型<code>static const</code>提供一个定义，比如这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> Widget::MinVals;  <span class="hljs-comment">//在Widget的.cpp文件</span><br></code></pre></div></td></tr></table></figure>
<p>不过都到了现代cpp时代吗，不如直接用C++17的内敛变量，这样就不用在cpp定义了：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> MinVals = <span class="hljs-number">28</span>;  <span class="hljs-comment">//MinVal的声明  </span><br>	<span class="hljs-comment">//static constexpr std::size_t MinVals = 28; // 和上面同理，constexpr在这里自带inline特性</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="4-重载函数的名称和模板名称"><a href="#4-重载函数的名称和模板名称" class="headerlink" title="4.重载函数的名称和模板名称"></a>4.重载函数的名称和模板名称</h3><p>假定我们的函数<code>f</code>（我们想通过<code>fwd</code>完美转发实参给的那个函数）可以通过向其传递执行某些功能的函数来自定义其行为。假设这个函数接受和返回值都是<code>int</code>，<code>f</code>声明就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*pf)(<span class="hljs-keyword">int</span>))</span></span>;             <span class="hljs-comment">//pf = “process function”</span><br></code></pre></div></td></tr></table></figure>
<p>值得注意的是，也可以使用更简单的非指针语法声明。这种声明就像这样，含义与上面是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pf(<span class="hljs-keyword">int</span>))</span></span>;                <span class="hljs-comment">//与上面定义相同的f</span><br></code></pre></div></td></tr></table></figure>
<p>无论哪种写法都可，现在假设我们有了一个重载函数，<code>processVal</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> priority)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>我们可以传递<code>processVal</code>给<code>f</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(processVal);                      <span class="hljs-comment">//可以</span><br></code></pre></div></td></tr></table></figure>
<p>但是我们会发现一些吃惊的事情。<code>f</code>要求一个函数指针作为实参，但是<code>processVal</code>不是一个函数指针或者一个函数，它是同名的两个不同函数。但是，编译器可以知道它需要哪个：匹配上<code>f</code>的形参类型的那个。因此选择了仅带有一个<code>int</code>的<code>processVal</code>地址传递给<code>f</code>。</p>
<p>工作的基本机制是<code>f</code>的声明让编译器识别出哪个是需要的<code>processVal</code>。但是，<code>fwd</code>是一个函数模板，没有它可接受的类型的信息，使得编译器不可能决定出哪个函数应被传递：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">fwd(processVal);                    <span class="hljs-comment">//错误！那个processVal？</span><br></code></pre></div></td></tr></table></figure>
<p>单用<code>processVal</code>是没有类型信息的，所以就不能类型推导，完美转发失败。</p>
<p>解决方法很简单，指定一下你到底说的是哪儿个processVal即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ProcessFuncType =                         <span class="hljs-comment">//写个类型定义；见条款9</span><br>    <span class="hljs-keyword">int</span> (*)(<span class="hljs-keyword">int</span>);<br><br>ProcessFuncType processValPtr = processVal;     <span class="hljs-comment">//指定所需的processVal签名</span><br>fwd(processValPtr);                             <span class="hljs-comment">//可以</span><br><br>fwd(<span class="hljs-keyword">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="hljs-comment">//也可以</span><br></code></pre></div></td></tr></table></figure>
<h3 id="5-位域"><a href="#5-位域" class="headerlink" title="5.位域"></a>5.位域</h3><p>IPv4的头部有如下模型：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IPv4Header</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> version:<span class="hljs-number">4</span>,<br>                  IHL:<span class="hljs-number">4</span>,<br>                  DSCP:<span class="hljs-number">6</span>,<br>                  ECN:<span class="hljs-number">2</span>,<br>                  totalLength:<span class="hljs-number">16</span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> sz)</span></span>;         <span class="hljs-comment">//要调用的函数</span><br><br>IPv4Header h;<br>…<br>f(h.totalLength);               <span class="hljs-comment">//可以</span><br>fwd(h.totalLength);             <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>为什么呢？问题在于<code>fwd</code>的形参是引用，而<code>h.totalLength</code>是non-<code>const</code>位域。这看起来也没什么，但是C++标准非常清楚地谴责了这种组合：non-<code>const</code>引用不应该绑定到位域。禁止的理由很充分。位域可能包含了机器字的任意部分（比如32位<code>int</code>的3-5位），但是这些东西无法直接寻址。也就是说没有办法绑定引用到任意bit上，这种修改就不可能完成，因此non-<code>const</code>引用不应该绑定到位域。</p>
<p>解决方法很简单，把位域的数据拷贝出来成副本，用副本做后面的操作就好了。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//拷贝位域值</span><br><span class="hljs-keyword">auto</span> length = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint16_t</span>&gt;(h.totalLength);<br><br>fwd(length);                    <span class="hljs-comment">//转发这个副本</span><br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/EffectiveModernCPP/">EffectiveModernCPP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/25/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《EffectiveModernC-》第六章-Lambda表达式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/03/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">
                        <span class="hidden-mobile">《EffectiveModernC++》第四章:智能指针</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https://chillstepp.github.io/2023/02/05/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%EF%BC%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/';
        this.page.identifier = '/2023/02/05/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%EF%BC%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'fluid' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
