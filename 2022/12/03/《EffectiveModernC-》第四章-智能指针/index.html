

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <link rel="icon" type="image/png" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chillstep">
  <meta name="keywords" content="">
  <title>《EffectiveModernC++》第四章:智能指针 - Chillstep</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chillstepp.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chillstep</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sdqryn.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《EffectiveModernC++》第四章:智能指针">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-12-03 21:25" pubdate>
        2022年12月3日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      145
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《EffectiveModernC++》第四章:智能指针</h1>
            
            <div class="markdown-body">
              <h1 id="第四章-智能指针"><a href="#第四章-智能指针" class="headerlink" title="第四章 智能指针"></a>第四章 智能指针</h1><h2 id="item18：对于独占资源使用std-unique-ptr"><a href="#item18：对于独占资源使用std-unique-ptr" class="headerlink" title="item18：对于独占资源使用std::unique_ptr"></a>item18：对于独占资源使用<code>std::unique_ptr</code></h2><p>对于<code>auto_ptr</code>这个C++98的产物，已经被移除了，他的升级版其实就是<code>unique_ptr</code>, </p>
<p><code>auto_ptr</code>的失败是由于缺少移动语义，具体可以看：</p>
<p><a href="https://zhuanlan.zhihu.com/p/551883955" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/551883955</a></p>
<p>这一节这里不过多描述，以前读过很多相关的了，这里基本的不再提起。这里提几个原文中几个有趣的东西：</p>
<p><strong>首先要将的第一个是<code>unique_ptr</code>可以自定义删除器</strong></p>
<p>默认情况下，销毁将通过<code>delete</code>进行，但是在构造过程中，<code>std::unique_ptr</code>对象可以被设置为使用（对资源的）<strong>自定义删除器</strong>：当资源需要销毁时可调用的任意函数（或者函数对象，包括<em>lambda</em>表达式）。如果通过<code>makeInvestment</code>创建的对象不应仅仅被<code>delete</code>，而应该先写一条日志，<code>makeInvestment</code>可以以如下方式实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> delInvmt = [](Investment* pInvestment)         <span class="hljs-comment">//自定义删除器</span><br>                &#123;                                   <span class="hljs-comment">//（lambda表达式）</span><br>                    makeLogEntry(pInvestment);<br>                    <span class="hljs-keyword">delete</span> pInvestment; <br>                &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt;     <span class="hljs-comment">//更改后的返回类型</span><br>makeInvestment(Ts&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Investment, <span class="hljs-keyword">decltype</span>(delInvmt)&gt; <span class="hljs-comment">//应返回的指针</span><br>        pInv(<span class="hljs-literal">nullptr</span>, delInvmt);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/*一个Stock对象应被创建*/</span>)<br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> Stock(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个Bond对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> Bond(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/*一个RealEstate对象应被创建*/</span> )   <br>    &#123;     <br>        pInv.reset(<span class="hljs-keyword">new</span> RealEstate(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));   <br>    &#125;   <br>    <span class="hljs-keyword">return</span> pInv;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>初始化<code>std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt);</code>即可。</p>
<p>上面这段代码第二个有意思的是，<strong>尝试将原始指针（比如<code>new</code>创建）赋值给<code>std::unique_ptr</code>通不过编译</strong>，因为是一种从原始指针到智能指针的隐式转换。这种隐式转换会出问题，所以C++11的智能指针禁止这个行为。这就是<strong>通过<code>reset</code>来让<code>pInv</code>接管通过<code>new</code>创建的对象的所有权</strong>的原因。</p>
<h2 id="item19：对于共享资源使用std-shared-ptr"><a href="#item19：对于共享资源使用std-shared-ptr" class="headerlink" title="item19：对于共享资源使用std::shared_ptr"></a>item19：对于共享资源使用<code>std::shared_ptr</code></h2><p><code>shared_ptr</code>的引用计数意味着几个性能问题：</p>
<ul>
<li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的引用计数值的原始指针。（这种实现法并不是标准要求的，但是我（指原书作者Scott Meyers）熟悉的所有标准库都这样实现。）</li>
<li><strong>引用计数的内存必须动态分配</strong>。 概念上，引用计数与所指对象关联起来，但是实际上被指向的对象不知道这件事情（译注：不知道有一个关联到自己的计数值）。因此它们没有办法存放一个引用计数值。（一个好消息是任何对象——甚至是内置类型的——都可以由<code>std::shared_ptr</code>管理。）<strong><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md" target="_blank" rel="noopener">Item21</a>会解释使用<code>std::make_shared</code>创建<code>std::shared_ptr</code>可以避免引用计数的动态分配，但是还存在一些<code>std::make_shared</code>不能使用的场景，这时候引用计数就会动态分配。</strong></li>
<li><strong>递增递减引用计数必须是原子性的</strong>，因为多个reader、writer可能在不同的线程。比如，指向某种资源的<code>std::shared_ptr</code>可能在一个线程执行析构（于是递减指向的对象的引用计数），在另一个不同的线程，<code>std::shared_ptr</code>指向相同的对象，但是执行的却是拷贝操作（因此递增了同一个引用计数）。原子操作通常比非原子操作要慢，所以即使引用计数通常只有一个<em>word</em>大小，你也应该假定读写它们是存在开销的。</li>
</ul>
<p><strong>类似<code>std::unique_ptr</code>（参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item18.md" target="_blank" rel="noopener">Item18</a>），<code>std::shared_ptr</code>使用<code>delete</code>作为资源的默认销毁机制，但是它也支持自定义的删除器</strong>。这种支持有别于<code>std::unique_ptr</code>。<strong>对于<code>std::unique_ptr</code>来说，删除器类型是智能指针类型的一部分。对于<code>std::shared_ptr</code>则不是：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> loggingDel = [](Widget *pw)        <span class="hljs-comment">//自定义删除器</span><br>                  &#123;                     <span class="hljs-comment">//（和条款18一样）</span><br>                      makeLogEntry(pw);<br>                      <span class="hljs-keyword">delete</span> pw;<br>                  &#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;                        <span class="hljs-comment">//删除器类型是</span><br>    Widget, <span class="hljs-keyword">decltype</span>(loggingDel)        <span class="hljs-comment">//指针类型的一部分</span><br>    &gt; upw(<span class="hljs-keyword">new</span> Widget, loggingDel);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;                 <span class="hljs-comment">//删除器类型不是</span><br>    spw(<span class="hljs-keyword">new</span> Widget, loggingDel);        <span class="hljs-comment">//指针类型的一部分</span><br></code></pre></div></td></tr></table></figure>
<p><code>std::shared_ptr</code>的设计更为灵活。考虑有两个<code>std::shared_ptr&lt;Widget&gt;</code>，每个自带不同的删除器（比如通过<em>lambda</em>表达式自定义删除器）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//自定义删除器，</span><br><span class="hljs-keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;;     <span class="hljs-comment">//每种类型不同</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter1)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">pw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, customDeleter2)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>因为<code>pw1</code>和<code>pw2</code>有相同的类型，所以它们都可以放到存放那个类型的对象的容器中：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;<br></code></pre></div></td></tr></table></figure>
<p>另一个不同于<code>std::unique_ptr</code>的地方是，指定自定义删除器不会改变<code>std::shared_ptr</code>对象的大小。不管删除器是什么，一个<code>std::shared_ptr</code>对象都是两个指针大小。你可能会感到疑惑，那么删除器在哪儿里存储的呢？<code>shared_ptr</code>类中有一个指向引用计数块(或者叫做控制块)的指针，控制块里会保存删除器。因此shared_ptr对象的大小是不会因为删除器而改变的。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20221120161158310.png" srcset="/img/loading.gif" alt="image-20221120161158310"></p>
<p>谈到控制块，那么什么时候会创建控制块呢？控制块的创建会遵循下面几条规则：</p>
<ul>
<li><strong><code>std::make_shared</code>（参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md" target="_blank" rel="noopener">Item21</a>）总是创建一个控制块</strong>。它创建一个要指向的新对象，所以可以肯定<code>std::make_shared</code>调用时对象不存在其他控制块。</li>
<li><strong>当从独占指针（即<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。独占指针没有使用控制块，所以指针指向的对象没有关联控制块。（作为构造的一部分，<code>std::shared_ptr</code>侵占独占指针所指向的对象的独占权，所以独占指针被设置为null）</li>
<li><strong>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块</strong>。如果你想从一个早已存在控制块的对象上创建<code>std::shared_ptr</code>，你将假定传递一个<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>（参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item20.md" target="_blank" rel="noopener">Item20</a>）作为构造函数实参，而不是原始指针。用<code>std::shared_ptr</code>或者<code>std::weak_ptr</code>作为构造函数实参创建<code>std::shared_ptr</code>不会创建新控制块，因为它可以依赖传递来的智能指针指向控制块。</li>
</ul>
<p>这些规则造成的后果就是从原始指针上构造超过一个<code>std::shared_ptr</code>就会让你走上未定义行为的快车道，<strong>因为指向的对象有多个控制块关联。多个控制块意味着多个引用计数值，多个引用计数值意味着对象将会被销毁多次（每个引用计数一次）</strong>。那意味着像下面的代码是有问题的，很有问题，问题很大：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget;                           <span class="hljs-comment">//pw是原始指针</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建控制块</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(pw, loggingDel)</span></span>;   <span class="hljs-comment">//为*pw创建第二个控制块</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>第一，<strong>避免传给<code>std::shared_ptr</code>构造函数原始指针。通常替代方案是使用<code>std::make_shared</code>（参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md" target="_blank" rel="noopener">Item21</a>），不过上面例子中，我们使用了自定义删除器，用<code>std::make_shared</code>就没办法做到。</strong></p>
</li>
<li><p>第二，<strong>如果你必须传给<code>std::shared_ptr</code>构造函数原始指针，直接传<code>new</code>出来的结果，不要传指针变量。</strong>如果上面代码第一部分这样重写：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,    <span class="hljs-comment">//直接使用new的结果</span></span></span><br><span class="hljs-function"><span class="hljs-params">                             loggingDel)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>会少了很多从原始指针上构造第二个<code>std::shared_ptr</code>的诱惑。相应的，创建<code>spw2</code>也会很自然的用<code>spw1</code>作为初始化参数（即用<code>std::shared_ptr</code>拷贝构造函数），那就没什么问题了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(spw1)</span></span>;         <span class="hljs-comment">//spw2使用spw1一样的控制块</span><br></code></pre></div></td></tr></table></figure>
<p>一个尤其令人意外的地方是<strong>使用<code>this</code>指针作为<code>std::shared_ptr</code>构造函数实参的时候可能导致创建多个控制块</strong>。假设我们的程序使用<code>std::shared_ptr</code>管理<code>Widget</code>对象，我们有一个数据结构用于跟踪已经处理过的<code>Widget</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;&gt; processedWidgets;<br></code></pre></div></td></tr></table></figure>
<p>继续，假设<code>Widget</code>有一个用于处理的成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>对于<code>Widget::process</code>看起来合理的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    …                                       <span class="hljs-comment">//处理Widget</span><br>    processedWidgets.emplace_back(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">//然后将它加到已处理过的Widget</span><br>&#125;                                           <span class="hljs-comment">//的列表中，这是错的！</span><br></code></pre></div></td></tr></table></figure>
<p>​    注释已经说了这是错的——或者至少大部分是错的。（错误的部分是传递<code>this</code>，而不是使用了<code>emplace_back</code>。如果你不熟悉<code>emplace_back</code>，参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/8.Tweaks/item42.md" target="_blank" rel="noopener">Item42</a>）。上面的代码可以通过编译，<strong>但是向<code>std::shared_ptr</code>的容器传递一个原始指针（<code>this</code>），<code>std::shared_ptr</code>会由此为指向的<code>Widget</code>（<code>*this</code>）创建一个控制块。</strong>那看起来没什么问题，直到你意识到如果成员函数外面早已存在指向那个<code>Widget</code>对象的指针，此时这个控制块的引用计数是不正确的，这完全是未定义行为。</p>
<p>​    <code>std::shared_ptr</code>API已有处理这种情况的设施。它的名字可能是C++标准库中最奇怪的一个：<code>std::enable_shared_from_this</code>。如<strong>果你想创建一个用<code>std::shared_ptr</code>管理的类，这个类能够用<code>this</code>指针安全地创建一个<code>std::shared_ptr</code>，<code>std::enable_shared_from_this</code>就可作为基类的模板类。</strong>在我们的例子中，<code>Widget</code>将会继承自<code>std::enable_shared_from_this</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>    …<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    <code>std::enable_shared_from_this</code>是一个基类模板。它的模板参数总是某个继承自它的类，所以<code>Widget</code>继承自<code>std::enable_shared_from_this&lt;Widget&gt;</code>。代码完全合法，而且它背后的设计模式也是没问题的，并且这种设计模式还有个标准名字，尽管该名字和<code>std::enable_shared_from_this</code>一样怪异。这个标准名字就是奇异递归模板模式（<em>The Curiously Recurring Template Pattern</em>（<em>CRTP</em>））。</p>
<p>​    <code>std::enable_shared_from_this</code>定义了一个成员函数，<strong>成员函数会创建指向当前对象的<code>std::shared_ptr</code>却不创建多余控制块</strong>。这个成员函数就是<strong><code>shared_from_this</code></strong>，<strong>无论在哪当你想在成员函数中使用<code>std::shared_ptr</code>指向<code>this</code>所指对象时都请使用它</strong>。这里有个<code>Widget::process</code>的安全实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//和之前一样，处理Widget</span><br>    …<br>    <span class="hljs-comment">//把指向当前对象的std::shared_ptr加入processedWidgets</span><br>    processedWidgets.emplace_back(shared_from_this());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>要想防止客户端在存在一个指向对象的<code>std::shared_ptr</code>前先调用含有<code>shared_from_this</code>的成员函数，继承自<code>std::enable_shared_from_this</code>的类通常将它们的构造函数声明为<code>private</code>，并且让客户端通过返回<code>std::shared_ptr</code>的工厂函数创建对象。以<code>Widget</code>为例，代码可以是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span>::enable_shared_from_this&lt;Widget&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//完美转发参数给private构造函数的工厂函数</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">create</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span>;<br>    …<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//和前面一样</span><br>    …<br><span class="hljs-keyword">private</span>:<br>    …                   <span class="hljs-comment">//构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>现在，你可能隐约记得我们讨论控制块的动机是想了解有关<code>std::shared_ptr</code>的成本。既然我们已经知道了怎么避免创建过多控制块，就让我们回到原来的主题。</p>
<p>控制块通常只占几个<em>word</em>大小，自定义删除器和分配器可能会让它变大一点。<strong>通常控制块的实现比你想的更复杂一些。它使用继承，甚至里面还有一个虚函数（用来确保指向的对象被正确销毁）</strong>。这意味着<strong>使用<code>std::shared_ptr</code>还会招致控制块使用虚函数带来的成本</strong>。</p>
<p>最后来谈一谈，<strong><code>std::shared_ptr</code>不能处理的另一个东西是数组（注意:C+17后可以了）</strong>。和<code>std::unique_ptr</code>不同的是，<code>std::shared_ptr</code>的API设计之初就是针对单个对象的，没有办法<code>std::shared_ptr&lt;T[]&gt;</code>。</p>
<p>一次又一次，“聪明”的程序员踌躇于是否该使用<code>std::shared_ptr&lt;T&gt;</code>指向数组，然后传入自定义删除器来删除数组（即<code>delete []</code>）。这可以通过编译，但是是一个糟糕的主意。</p>
<p>一方面，<code>std::shared_ptr</code>没有提供<code>operator[]</code> (这里需要注意，C++17提供了)，所以数组索引操作需要借助怪异的指针算术。</p>
<p>另一方面，<code>std::shared_ptr</code>支持转换为指向基类的指针，这对于单个对象来说有效，但是当用于数组类型时相当于在类型系统上开洞。（出于这个原因，<code>std::unique_ptr&lt;T[]&gt;</code> API禁止这种转换。）更重要的是，C++11已经提供了很多内置数组的候选方案（比如<code>std::array</code>，<code>std::vector</code>，<code>std::string</code>）。声明一个指向傻瓜数组的智能指针（译注：也是”聪明的指针“之意）几乎总是表示着糟糕的设计。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><code>std::shared_ptr</code>为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。</li>
<li>较之于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。</li>
<li>默认资源销毁是通过<code>delete</code>，但是也支持自定义删除器。删除器的类型是什么对于<code>std::shared_ptr</code>的类型没有影响。</li>
<li>避免从原始指针变量上创建<code>std::shared_ptr</code>。</li>
</ul>
<h2 id="item20：当std-shared-ptr可能悬空时使用std-weak-ptr"><a href="#item20：当std-shared-ptr可能悬空时使用std-weak-ptr" class="headerlink" title="item20：当std::shared_ptr可能悬空时使用std::weak_ptr"></a>item20：当<code>std::shared_ptr</code>可能悬空时使用<code>std::weak_ptr</code></h2><p>​    自相矛盾的是，如果有一个像<code>std::shared_ptr</code>（见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">Item19</a>）的但是不参与资源所有权共享的指针是很方便的。换句话说，是一个类似<code>std::shared_ptr</code>但不影响对象引用计数的指针。这种类型的智能指针必须要解决一个<code>std::shared_ptr</code>不存在的问题：可能指向已经销毁的对象。<strong>一个真正的智能指针应该跟踪所指对象，在悬空时知晓，悬空（<em>dangle</em>）就是指针指向的对象不再存在。这就是对<code>std::weak_ptr</code>最精确的描述。</strong></p>
<p>​    <code>std::weak_ptr</code>不能解引用，也不能测试是否为空值。<code>std::weak_ptr</code>通常从<code>std::shared_ptr</code>上创建。当从<code>std::shared_ptr</code>上创建<code>std::weak_ptr</code>时两者指向相同的对象，但是<code>std::weak_ptr</code>不会影响所指对象的引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> spw =                      <span class="hljs-comment">//spw创建之后，指向的Widget的</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(); <span class="hljs-comment">//引用计数（ref count，RC）为1。</span><br>                                <span class="hljs-comment">//std::make_shared的信息参见条款21</span><br>…<br><span class="hljs-function"><span class="hljs-built_in">std</span>::weak_ptr&lt;Widget&gt; <span class="hljs-title">wpw</span><span class="hljs-params">(spw)</span></span>; <span class="hljs-comment">//wpw指向与spw所指相同的Widget。RC仍为1</span><br>…<br>spw = <span class="hljs-literal">nullptr</span>;                  <span class="hljs-comment">//RC变为0，Widget被销毁。</span><br>                                <span class="hljs-comment">//wpw现在悬空</span><br></code></pre></div></td></tr></table></figure>
<p>悬空的<code>std::weak_ptr</code>被称作已经<strong>expired</strong>（过期）。你可以用它直接做测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (wpw.expired()) …            <span class="hljs-comment">//如果wpw没有指向对象…</span><br></code></pre></div></td></tr></table></figure>
<p>​    但是通常你期望的是检查<code>std::weak_ptr</code>是否已经过期，如果没有过期则访问其指向的对象。这做起来可不是想着那么简单。<strong>因为缺少解引用操作，没有办法写这样的代码。即使有，将检查和解引用分开会引入竞态条件：在调用<code>expired</code>和解引用操作之间，另一个线程可能对指向这对象的<code>std::shared_ptr</code>重新赋值或者析构，并由此造成对象已析构。</strong>这种情况下，你的解引用将会产生未定义行为。</p>
<p>你<strong>需要的是一个原子操作检查<code>std::weak_ptr</code>是否已经过期，如果没有过期就访问所指对象</strong>。这可以通过从<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>来实现，具体有两种形式可以从<code>std::weak_ptr</code>上创建<code>std::shared_ptr</code>，具体用哪种取决于<code>std::weak_ptr</code>过期时你希望<code>std::shared_ptr</code>表现出什么行为。</p>
<p><strong>一种形式是<code>std::weak_ptr::lock</code>，它返回一个<code>std::shared_ptr</code>，如果<code>std::weak_ptr</code>过期这个<code>std::shared_ptr</code>为空：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw1 = wpw.lock();  <span class="hljs-comment">//如果wpw过期，spw1就为空</span><br> 											<br><span class="hljs-keyword">auto</span> spw2 = wpw.lock();                     <span class="hljs-comment">//同上，但是使用auto</span><br></code></pre></div></td></tr></table></figure>
<p><strong>另一种形式是以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>。这种情况中，如果<code>std::weak_ptr</code>过期，会抛出一个异常：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw3</span><span class="hljs-params">(wpw)</span></span>;          <span class="hljs-comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span><br></code></pre></div></td></tr></table></figure>
<p>但是你可能还想知道为什么<code>std::weak_ptr</code>就有用了。考虑一个工厂函数，它基于一个唯一ID从只读对象上产出智能指针。根据<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">Item18</a>的描述，工厂函数会返回一个该对象类型的<code>std::unique_ptr</code>：</p>
<p>可能到现在你还没有看到<code>weak_ptr</code>有什么实际的作用：下面我们举个例子</p>
<p>考虑一个工厂函数，它基于一个唯一ID从只读对象上产出智能指针。根据<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">Item18</a>的描述，工厂函数会返回一个该对象类型的<code>std::unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">loadWidget</span><span class="hljs-params">(WidgetID id)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>​    如果调用<code>loadWidget</code>是一个昂贵的操作（比如它操作文件或者数据库I/O）并且重复使用ID很常见，一个合理的优化是再写一个函数除了完成<code>loadWidget</code>做的事情之外再缓存它的结果。当每个请求获取的<code>Widget</code>阻塞了缓存也会导致本身性能问题，所以另一个合理的优化可以是当<code>Widget</code>不再使用的时候销毁它的缓存。</p>
<p>​    对于可缓存的工厂函数，返回<code>std::unique_ptr</code>不是好的选择。调用者应该接收缓存对象的智能指针，调用者也应该确定这些对象的生命周期，但是缓存本身也需要一个指针指向它所缓存的对象。缓存对象的指针需要知道它是否已经悬空，因为当工厂客户端使用完工厂产生的对象后，对象将被销毁，关联的缓存条目会悬空。所以<strong>缓存应该使用<code>std::weak_ptr</code>，这可以知道是否已经悬空</strong>。这<strong>意味着工厂函数返回值类型应该是<code>std::shared_ptr</code>，因为只有当对象的生命周期由<code>std::shared_ptr</code>管理时，<code>std::weak_ptr</code>才能检测到悬空。</strong></p>
<p>下面是一个临时凑合的<code>loadWidget</code>的缓存版本的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">fastLoadWidget</span><span class="hljs-params">(WidgetID id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;WidgetID,<br>                              <span class="hljs-built_in">std</span>::weak_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt;&gt; cache;<br>                                        <span class="hljs-comment">//译者注：这里std::weak_ptr&lt;const Widget&gt;是高亮</span><br>    <span class="hljs-keyword">auto</span> objPtr = cache[id].lock();     <span class="hljs-comment">//objPtr是去缓存对象的</span><br>                                        <span class="hljs-comment">//std::shared_ptr（或</span><br>                                        <span class="hljs-comment">//当对象不在缓存中时为null）</span><br><br>    <span class="hljs-keyword">if</span> (!objPtr) &#123;                      <span class="hljs-comment">//如果不在缓存中</span><br>        objPtr = loadWidget(id);        <span class="hljs-comment">//加载它</span><br>        cache[id] = objPtr;             <span class="hljs-comment">//缓存它</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> objPtr;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>第二个用例：观察者设计模式（Observer design pattern）。</p>
<p>此模式的主要组件是subjects（状态可能会更改的对象）和observers（状态发生更改时要通知的对象）。在大多数实现中，每个subject都包含一个数据成员，该成员持有指向其observers的指针。这使subjects很容易发布状态更改通知。subjects对控制observers的生命周期（即它们什么时候被销毁）没有兴趣，但是subjects对确保另一件事具有极大的兴趣，那事就是<strong>一个observer被销毁时，不再尝试访问它。一个合理的设计是每个subject持有一个<code>std::weak_ptr</code>s容器指向observers，因此可以在使用前检查是否已经悬空。</strong></p>
<p>作为最后一个使用<code>std::weak_ptr</code>的例子，考虑一个持有三个对象<code>A</code>、<code>B</code>、<code>C</code>的数据结构，<code>A</code>和<code>C</code>共享<code>B</code>的所有权，因此持有<code>std::shared_ptr</code>：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20221121235329997.png" srcset="/img/loading.gif" alt="image-20221121235329997"></p>
<p>假定从B指向A的指针也很有用。应该使用哪种指针？</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20221121235419414.png" srcset="/img/loading.gif" alt="image-20221121235419414"></p>
<p>有三种选择：</p>
<ul>
<li><strong>原始指针</strong>。使用这种方法，如果<code>A</code>被销毁，但是<code>C</code>继续指向<code>B</code>，<code>B</code>就会有一个指向<code>A</code>的悬空指针。而且<code>B</code>不知道指针已经悬空，所以<code>B</code>可能会继续访问，就会导致未定义行为。</li>
<li><strong><code>std::shared_ptr</code></strong>。这种设计，<code>A</code>和<code>B</code>都互相持有对方的<code>std::shared_ptr</code>，导致的<code>std::shared_ptr</code>环状结构（<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>）阻止<code>A</code>和<code>B</code>的销毁。甚至<code>A</code>和<code>B</code>无法从其他数据结构访问了（比如，<code>C</code>不再指向<code>B</code>），每个的引用计数都还是1。如果发生了这种情况，<code>A</code>和<code>B</code>都被泄漏：程序无法访问它们，但是资源并没有被回收。</li>
<li><strong><code>std::weak_ptr</code></strong>。这避免了上述两个问题。如果<code>A</code>被销毁，<code>B</code>指向它的指针悬空，但是<code>B</code>可以检测到这件事。尤其是，尽管<code>A</code>和<code>B</code>互相指向对方，<code>B</code>的指针不会影响<code>A</code>的引用计数，因此在没有<code>std::shared_ptr</code>指向<code>A</code>时不会导致<code>A</code>无法被销毁。</li>
</ul>
<p>​    使用<code>std::weak_ptr</code>显然是这些选择中最好的。但是，需要注意使用<code>std::weak_ptr</code>打破<code>std::shared_ptr</code>循环并不常见。在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。从父到子的链接关系可以使用<code>std::unique_ptr</code>很好的表征。从子到父的反向连接可以使用原始指针安全实现，因为子节点的生命周期肯定短于父节点。因此没有子节点解引用一个悬垂的父节点指针这样的风险。</p>
<p>​    当然，不是所有的使用指针的数据结构都是严格分层的，所以当发生这种情况时，比如上面所述缓存和观察者列表的实现之类的，知道<code>std::weak_ptr</code>随时待命也是不错的。</p>
<p>​    从效率角度来看，<code>std::weak_ptr</code>与<code>std::shared_ptr</code>基本相同。两者的大小是相同的，使用相同的控制块（参见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">Item19</a>），构造、析构、赋值操作涉及引用计数的原子操作。这可能让你感到惊讶，因为本条款开篇就提到<code>std::weak_ptr</code>不影响引用计数。我写的是<code>std::weak_ptr</code>不参与对象的<strong>共享所有权</strong>，因此不影响<strong>指向对象的引用计数</strong>。实际上在控制块中还是有第二个引用计数，<code>std::weak_ptr</code>操作的是第二个引用计数。想了解细节的话，继续看<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md" target="_blank" rel="noopener">Item21</a>吧。</p>
<p><strong>请记住：</strong></p>
<ul>
<li><strong>用<code>std::weak_ptr</code>替代可能会悬空的<code>std::shared_ptr</code>。</strong></li>
<li><strong><code>std::weak_ptr</code>的潜在使用场景包括：缓存、观察者列表、打破<code>std::shared_ptr</code>环状结构。</strong></li>
</ul>
<h2 id="item21：优先考虑使用std-make-unique和std-make-shared，而非直接使用new"><a href="#item21：优先考虑使用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="item21：优先考虑使用std::make_unique和std::make_shared，而非直接使用new"></a>item21：优先考虑使用<code>std::make_unique</code>和<code>std::make_shared</code>，而非直接使用<code>new</code></h2><p>C++11出现了<code>make_shared</code>, C++14出现了<code>make_unqiue</code></p>
<p>一个基础版本的<code>std::make_unique</code>是很容易自己写出的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>正如你看到的，<code>make_unique</code>只是将它的参数完美转发到所要创建的对象的构造函数，从<code>new</code>产生的原始指针里面构造出<code>std::unique_ptr</code>，然后返回这个<code>std::unique_ptr</code>即可。</p>
<p>用make函数有什么好处呢？</p>
<p><strong>①首先就是可以用auto，方便，不用重复写类型:</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">upw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_unique&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget&gt; <span class="hljs-title">upw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">spw1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;())</span></span>;      <span class="hljs-comment">//使用make函数</span><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;   <span class="hljs-comment">//不使用make函数</span><br></code></pre></div></td></tr></table></figure>
<p>关键区别：使用<code>new</code>的版本重复了类型，但是<code>make</code>函数的版本没有。</p>
<p><strong>②然后是异常安全性:</strong></p>
<p>假设我们有个函数按照某种优先级处理<code>Widget</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="hljs-keyword">int</span> priority)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>值传递<code>std::shared_ptr</code>可能看起来很可疑，但是<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/8.Tweaks/item41.md" target="_blank" rel="noopener">Item41</a>解释了，如果<code>processWidget</code>总是复制<code>std::shared_ptr</code>（例如，通过将其存储在已处理的<code>Widget</code>的一个数据结构中），那么这可能是一个合理的设计选择。</p>
<p>现在假设我们有一个函数来计算相关的优先级，</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">computePriority</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>并且我们在调用<code>processWidget</code>时使用了<code>new</code>而不是<code>std::make_shared</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget),  <span class="hljs-comment">//潜在的资源泄漏！</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure>
<p>如注释所说，这段代码可能在<code>new</code>一个<code>Widget</code>时发生泄漏。为何？调用的代码和被调用的函数都用<code>std::shared_ptr</code>s，且<code>std::shared_ptr</code>s就是设计出来防止泄漏的。它们会在最后一个<code>std::shared_ptr</code>销毁时自动释放所指向的内存。如果每个人在每个地方都用<code>std::shared_ptr</code>s，这段代码怎么会泄漏呢？</p>
<p>答案和编译器将源码转换为目标代码有关。在运行时，一个函数的实参必须先被计算，这个函数再被调用，所以在调用<code>processWidget</code>之前，必须执行以下操作，<code>processWidget</code>才开始执行：</p>
<ul>
<li>表达式“<code>new Widget</code>”必须计算，例如，一个<code>Widget</code>对象必须在堆上被创建</li>
<li>负责管理<code>new</code>出来指针的<code>std::shared_ptr&lt;Widget&gt;</code>构造函数必须被执行</li>
<li><code>computePriority</code>必须运行</li>
</ul>
<p>编译器不需要按照执行顺序生成代码。“<code>new Widget</code>”必须在<code>std::shared_ptr</code>的构造函数被调用前执行，因为<code>new</code>出来的结果作为构造函数的实参，但<code>computePriority</code>可能在这之前，之后，或者<strong>之间</strong>执行。也就是说，编译器可能按照这个执行顺序生成代码：</p>
<ol>
<li>执行“<code>new Widget</code>”</li>
<li>执行<code>computePriority</code></li>
<li>运行<code>std::shared_ptr</code>构造函数</li>
</ol>
<p>如果按照这样生成代码，并且在运行时<code>computePriority</code>产生了异常，那么第一步动态分配的<code>Widget</code>就会泄漏。因为它永远都不会被第三步的<code>std::shared_ptr</code>所管理了。</p>
<p>使用<code>std::make_shared</code>可以防止这种问题。调用代码看起来像是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;(),   <span class="hljs-comment">//没有潜在的资源泄漏</span><br>              computePriority());<br></code></pre></div></td></tr></table></figure>
<p>在运行时，<code>std::make_shared</code>和<code>computePriority</code>其中一个会先被调用。</p>
<ul>
<li><p>如果是<code>std::make_shared</code>先被调用，在<code>computePriority</code>调用前，动态分配<code>Widget</code>的原始指针会安全的保存在作为返回值的<code>std::shared_ptr</code>中。</p>
</li>
<li><p>如果<code>computePriority</code>产生一个异常，那么<code>std::shared_ptr</code>析构函数将确保管理的<code>Widget</code>被销毁。如果首先调用<code>computePriority</code>并产生一个异常，那么<code>std::make_shared</code>将不会被调用，因此也就不需要担心动态分配<code>Widget</code>（会泄漏）。</p>
</li>
</ul>
<p><strong>③make函数还有的好处是 效率的提升：</strong></p>
<p>使用<code>std::make_shared</code>允许编译器生成更小，更快的代码，并使用更简洁的数据结构。考虑以下对new的直接使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>显然，这段代码需要进行内存分配，但它实际上执行了两次。<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">Item19</a>解释了每个<code>std::shared_ptr</code>指向一个控制块，其中包含被指向对象的引用计数，还有其他东西。这个控制块的内存在<code>std::shared_ptr</code>构造函数中分配。因此，直接使用<code>new</code>需要为<code>Widget</code>进行一次内存分配，为控制块再进行一次内存分配。</p>
<p>如果使用<code>std::make_shared</code>代替：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> spw = <span class="hljs-built_in">std</span>::make_shared&lt;Widget&gt;();<br></code></pre></div></td></tr></table></figure>
<p>一次分配足矣。这是因为<code>std::make_shared</code>分配一块内存，同时容纳了<code>Widget</code>对象和控制块。这种优化减少了程序的静态大小，因为代码只包含一个内存分配调用，并且它提高了可执行代码的速度，因为内存只分配一次。此外，使用<code>std::make_shared</code>避免了对控制块中的某些簿记信息的需要，潜在地减少了程序的总内存占用。</p>
<p>make函数看起来很不错，当然在某些时候情况下他也是有缺点的:</p>
<p><strong>①<code>make</code>函数都不允许指定自定义删除器（见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item18.md" target="_blank" rel="noopener">Item18</a>和<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item19.md" target="_blank" rel="noopener">19</a>）</strong></p>
<p>但是<code>std::unique_ptr</code>和<code>std::shared_ptr</code>有构造函数这么做。有个<code>Widget</code>的自定义删除器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;<br></code></pre></div></td></tr></table></figure>
<p>创建一个使用它的智能指针只能直接使用<code>new</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Widget, <span class="hljs-keyword">decltype</span>(widgetDeleter)&gt;<br>    upw(<span class="hljs-keyword">new</span> Widget, widgetDeleter);<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, widgetDeleter)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>对于<code>make</code>函数，没有办法做同样的事情。</p>
<p>②make函数中的 <code>()</code>  和<code>{}</code>初始化问题</p>
<p><code>make</code>函数第二个限制来自于其实现中的语法细节。<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/3.MovingToModernCpp/item7.md" target="_blank" rel="noopener">Item7</a>解释了，当构造函数重载，有使用<code>std::initializer_list</code>作为参数的重载形式和不用其作为参数的的重载形式，用花括号创建的对象更倾向于使用<code>std::initializer_list</code>作为形参的重载形式，而用小括号创建对象将调用不用<code>std::initializer_list</code>作为参数的的重载形式。<code>make</code>函数会将它们的参数完美转发给对象构造函数，但是它们是使用小括号还是花括号？对某些类型，问题的答案会很不相同。例如，在这些调用中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> upv = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面的结果是两种调用都创建了10个元素，每个值为20的<code>std::vector</code>， 说明完美转发中使用的是小括号，如果使用的花括号，那么上面的代码就是含有两个元素的10和20的vector了。</p>
<p>但是，<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/5.RRefMovSemPerfForw/item30.md" target="_blank" rel="noopener">Item30</a>介绍了一个变通的方法：使用<code>auto</code>类型推导从花括号初始化创建<code>std::initializer_list</code>对象（见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/1.DeducingTypes/item2.md" target="_blank" rel="noopener">Item2</a>），然后将<code>auto</code>创建的对象传递给<code>make</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建std::initializer_list</span><br><span class="hljs-keyword">auto</span> initList = &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-comment">//使用std::initializer_list为形参的构造函数创建std::vector</span><br><span class="hljs-keyword">auto</span> spv = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(initList);<br></code></pre></div></td></tr></table></figure>
<p><strong>对于<code>std::unique_ptr</code>，只有这两种情景（自定义删除器和花括号初始化）使用<code>make</code>函数有点问题。</strong></p>
<p><strong>对于<code>std::shared_ptr</code>和它的<code>make</code>函数，还有2个问题。都属于边缘情况，但是一些开发者常碰到</strong>，你也可能是其中之一。</p>
<p><strong>③有自定义内存管理的类, 不建议使用<code>make_shared</code>。</strong></p>
<p>​    一些类重载了<code>operator new</code>和<code>operator delete</code>。这些函数的存在意味着对这些类型的对象的全局内存分配和释放是不合常规的。设计这种定制操作往往只会精确的分配、释放对象大小的内存。例如，<code>Widget</code>类的<code>operator new</code>和<code>operator delete</code>只会处理<code>sizeof(Widget)</code>大小的内存块的分配和释放。这种系列行为不太适用于<code>std::shared_ptr</code>对自定义分配（通过<code>std::allocate_shared</code>）和释放（通过自定义删除器）的支持，因为<code>std::allocate_shared</code>需要的内存总大小不等于动态分配的对象大小，还需要<strong>再加上</strong>控制块大小。因此，使用<code>make</code>函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象是个典型的糟糕想法。</p>
<p><strong>④对象类型非常大，而且销毁最后一个<code>std::shared_ptr</code>和销毁最后一个<code>std::weak_ptr</code>之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟</strong></p>
<p>如果对象类型非常大，而且销毁最后一个<code>std::shared_ptr</code>和销毁最后一个<code>std::weak_ptr</code>之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;<br><br><span class="hljs-keyword">auto</span> pBigObj =                          <span class="hljs-comment">//通过std::make_shared</span><br>    <span class="hljs-built_in">std</span>::make_shared&lt;ReallyBigType&gt;();  <span class="hljs-comment">//创建一个大对象</span><br>                    <br>…           <span class="hljs-comment">//创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br><br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁，</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在</span><br><br>…           <span class="hljs-comment">//在这个阶段，原来分配给大对象的内存还分配着</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块和对象的内存被释放</span><br></code></pre></div></td></tr></table></figure>
<p>直接只用<code>new</code>，一旦最后一个<code>std::shared_ptr</code>被销毁，<code>ReallyBigType</code>对象的内存就会被释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReallyBigType</span> &#123;</span> … &#125;;              <span class="hljs-comment">//和之前一样</span><br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ReallyBigType&gt; <span class="hljs-title">pBigObj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ReallyBigType)</span></span>;<br>                                        <span class="hljs-comment">//通过new创建大对象</span><br><br>…           <span class="hljs-comment">//像之前一样，创建std::shared_ptrs和std::weak_ptrs</span><br>            <span class="hljs-comment">//指向这个对象，使用它们</span><br>            <br>…           <span class="hljs-comment">//最后一个std::shared_ptr在这销毁,</span><br>            <span class="hljs-comment">//但std::weak_ptrs还在；</span><br>            <span class="hljs-comment">//对象的内存被释放</span><br><br>…           <span class="hljs-comment">//在这阶段，只有控制块的内存仍然保持分配</span><br><br>…           <span class="hljs-comment">//最后一个std::weak_ptr在这里销毁；</span><br>            <span class="hljs-comment">//控制块内存被释放</span><br></code></pre></div></td></tr></table></figure>
<p>导致这个的原因就是我们所认为make_shared的效率优势: 控制块和对象一起进行内存分配。同理<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久的也要注意，因为weak count也在控制块里。</p>
<p><strong>最后我们讨论一个场景，当你有不得不用new的理由时，(比如上述的几个理由)，保证异常安全性需要使用变量提前保存起来只能指针，但是为了更高效，还需要注意一点，就是 把左值智能指针用<code>std::move</code>转为右值再传入函数。</strong></p>
<p>例如，考虑我们前面讨论过的<code>processWidget</code>函数，对其非异常安全调用的一个小修改。这一次，我们将指定一个自定义删除器:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; spw,     <span class="hljs-comment">//和之前一样</span></span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">int</span> priority)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cusDel</span><span class="hljs-params">(Widget *ptr)</span></span>;                           <span class="hljs-comment">//自定义删除器</span><br></code></pre></div></td></tr></table></figure>
<p>这是非异常安全调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget( 									    <span class="hljs-comment">//和之前一样，</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, cusDel),    <span class="hljs-comment">//潜在的内存泄漏！</span><br>    computePriority() <br>);<br></code></pre></div></td></tr></table></figure>
<p>回想一下：如果<code>computePriority</code>在“<code>new Widget</code>”之后，而在<code>std::shared_ptr</code>构造函数之前调用，并且如果<code>computePriority</code>产生一个异常，那么动态分配的<code>Widget</code>将会泄漏。</p>
<p>这里使用自定义删除排除了对<code>std::make_shared</code>的使用，因此避免出现问题的方法是将<code>Widget</code>的分配和<code>std::shared_ptr</code>的构造放入它们自己的语句中，然后使用得到的<code>std::shared_ptr</code>调用<code>processWidget</code>。这是该技术的本质，不过，正如我们稍后将看到的，我们可以对其进行调整以提高其性能：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, cusDel)</span></span>;<br>processWidget(spw, computePriority());  <span class="hljs-comment">// 正确，但是没优化，见下</span><br></code></pre></div></td></tr></table></figure>
<p>这是可行的，因为<code>std::shared_ptr</code>获取了传递给它的构造函数的原始指针的所有权，即使构造函数产生了一个异常。此例中，如果<code>spw</code>的构造函数抛出异常（比如无法为控制块动态分配内存），仍然能够保证<code>cusDel</code>会在“<code>new Widget</code>”产生的指针上调用。</p>
<p>一个小小的性能问题是，<strong>在非异常安全调用中，我们将一个右值传递给<code>processWidget</code>：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget, cusDel),    <span class="hljs-comment">//实参是一个右值</span><br>    computePriority()<br>);<br></code></pre></div></td></tr></table></figure>
<p><strong>但是在异常安全调用中，我们传递了左值：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(spw, computePriority());              <span class="hljs-comment">//实参是左值</span><br></code></pre></div></td></tr></table></figure>
<p>因为<code>processWidget</code>的<code>std::shared_ptr</code>形参是传值，从右值构造只需要移动，而传递左值构造需要拷贝。对<code>std::shared_ptr</code>而言，这种区别是有意义的，因为<strong>拷贝<code>std::shared_ptr</code>需要对引用计数原子递增，移动则不需要对引用计数有操作</strong>。<strong>为了使异常安全代码达到非异常安全代码的性能水平，我们需要用<code>std::move</code>将<code>spw</code>转换为右值（见<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/5.RRefMovSemPerfForw/item23.md" target="_blank" rel="noopener">Item23</a>）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processWidget(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(spw), computePriority());   <span class="hljs-comment">//高效且异常安全</span><br></code></pre></div></td></tr></table></figure>
<p>这很有趣，也值得了解，但通常是无关紧要的，因为您很少有理由不使用<code>make</code>函数。除非你有令人信服的理由这样做，否则你应该使用<code>make</code>函数。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>和直接使用<code>new</code>相比，<code>make</code>函数消除了代码重复，提高了异常安全性。对于<code>std::make_shared</code>和<code>std::allocate_shared</code>，生成的代码更小更快。</li>
<li>不适合使用<code>make</code>函数的情况包括需要指定自定义删除器和希望用花括号初始化。</li>
<li>对于<code>std::shared_ptr</code>s，其他不建议使用<code>make</code>函数的情况包括(1)有自定义内存管理的类；(2)特别关注内存的系统，非常大的对象，以及<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久。</li>
<li>当你有不得不用new的理由时，(比如上述的几个理由)，保证异常安全性需要使用变量提前保存起来只能指针，但是为了更高效，还需要注意一点，就是 把左值智能指针用<code>std::move</code>转为右值再传入函数。</li>
</ul>
<h2 id="item22：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"><a href="#item22：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数" class="headerlink" title="item22：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"></a>item22：当使用Pimpl惯用法，请在实现文件中定义特殊成员函数</h2><p>什么是Pimpl？</p>
<p>你可以将类数据成员替换成一个指向包含具体实现的类（或结构体）的指针，并将放在主类（primary class）的数据成员们移动到实现类（implementation class）去，注意是为了减少编译时间。</p>
<p>举个例子，假如有一个类<code>Widget</code>看起来如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">class <span class="hljs-title">Widget</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-comment">//定义在头文件“widget.h”</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1, g2, g3;              <span class="hljs-comment">//Gadget是用户自定义的类型</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    因为类<code>Widget</code>的数据成员包含有类型<code>std::string</code>，<code>std::vector</code>和<code>Gadget</code>，定义有这些类型的头文件在类<code>Widget</code>编译的时候，必须被包含进来，这意味着类<code>Widget</code>的使用者必须要<code>#include &lt;string&gt;</code>，<code>&lt;vector&gt;</code>以及<code>gadget.h</code>。 这些头文件将会增加类<code>Widget</code>使用者的编译时间，并且让这些使用者依赖于这些头文件。 </p>
<p>​    <strong>如果一个头文件的内容变了，类<code>Widget</code>使用者也必须要重新编译。</strong> 标准库文件<code>&lt;string&gt;</code>和<code>&lt;vector&gt;</code>不是很常变，但是<code>gadget.h</code>可能会经常修订。</p>
<p>​    在C++98中Pimpl惯用法，可以把<strong><code>Widget</code>的数据成员替换成一个原始指针</strong>，指向一个已经被声明过却还未被定义的结构体，如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>                        //仍然在“<span class="hljs-title">widget</span>.<span class="hljs-title">h</span>”中</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                      <span class="hljs-comment">//析构函数在后面会分析</span><br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span>                    <span class="hljs-comment">//声明一个 实现结构体</span><br>    Impl *pImpl;                    <span class="hljs-comment">//以及指向它的指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>​    因为类<code>Widget</code>不再提到类型<code>std::string</code>，<code>std::vector</code>以及<code>Gadget</code>，<code>Widget</code>的使用者不再需要为了这些类型而引入头文件。 这可以加速编译，并且意味着，如果这些头文件中有所变动，<code>Widget</code>的使用者不会受到影响。</p>
<p>​    Pimpl惯用法:</p>
<ul>
<li>第一步，是声明一个数据成员，它是个指针，指向一个未完成类型。</li>
<li>第二步是动态分配和回收一个对象，该对象包含那些以前在原来的类中的数据成员。 内存分配和回收的代码都写在实现文件里，比如，对于类<code>Widget</code>而言，写在<code>Widget.cpp</code>里:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>             <span class="hljs-comment">//以下代码均在实现文件“widget.cpp”里</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;           <span class="hljs-comment">//含有之前在Widget中的数据成员的</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;           <span class="hljs-comment">//Widget::Impl类型的定义</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                <span class="hljs-comment">//为此Widget对象分配数据成员</span><br>: pImpl(<span class="hljs-keyword">new</span> Impl)<br>&#123;&#125;<br><br>Widget::~Widget()               <span class="hljs-comment">//销毁数据成员</span><br>&#123; <span class="hljs-keyword">delete</span> pImpl; &#125;<br></code></pre></div></td></tr></table></figure>
<p>​    这些依赖从头文件<code>widget.h</code>（它被所有<code>Widget</code>类的使用者包含，并且对他们可见）移动到了<code>widget.cpp</code>（该文件只被<code>Widget</code>类的实现者包含，并只对他可见）。 我高亮了其中动态分配和回收<code>Impl</code>对象的部分（译者注：markdown高亮不了，实际高亮的是<code>new Impl</code>和<code>delete pImpl;</code>两个语句）。这就是为什么我们需要<code>Widget</code>的析构函数——我们需要<code>Widget</code>被销毁时回收该对象。</p>
<p>当然现在有了智能指针，让我们尝试把代码写的更现代一些：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//使用智能指针而不是原始指针</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>实现文件也可以改成如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;;<br><br>Widget::Widget()                    <span class="hljs-comment">//根据条款21，通过std::make_unique</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())   <span class="hljs-comment">//来创建std::unique_ptr</span><br>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>是的，我们这里就不再需要手写widget的析构函数了，<code>shared_ptr</code>因为RAII会在超出作用域自动析构，而智能指针的析构函数会做delete指针这件事情。</p>
<p>以上代码可以编译通过，没有任何错误出现，但此时一个奇怪的事情出现了:</p>
<p>最普通的<code>Widget</code>用法却会导致编译出错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span></span><br><br>Widget w;                           <span class="hljs-comment">//错误！</span><br></code></pre></div></td></tr></table></figure>
<p>​    你所看到的错误信息根据编译器不同会有所不同，但是其文本一般会提到一些有关于“把<code>sizeof</code>或<code>delete</code>应用到未完成类型上”的信息。对于未完成类型，使用以上操作是禁止的。</p>
<p>​    在Pimpl惯用法中使用<code>std::unique_ptr</code>会抛出错误，有点惊悚，因为<strong>第一<code>std::unique_ptr</code>宣称它支持未完成类型</strong>，<strong>第二Pimpl惯用法是<code>std::unique_ptr</code>的最常见的使用情况之一</strong>。 你可能会很不解，幸运的是，让这段代码能正常运行很简单。 只需要对上面出现的问题的原因有一个基础的认识就可以了。</p>
<p>​    在对象<code>w</code>被析构时（例如离开了作用域），问题出现了。在这个时候，它的析构函数被调用。我们在类的定义里使用了<code>std::unique_ptr</code>，所以我们没有声明一个析构函数，因为我们并没有任何代码需要写在里面。根据编译器自动生成的特殊成员函数的规则（见 <a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/3.MovingToModernCpp/item17.md" target="_blank" rel="noopener">Item17</a>），编译器会自动为我们生成一个析构函数。 在这个析构函数里，编译器会插入一些代码来调用类<code>Widget</code>的数据成员<code>pImpl</code>的析构函数。 <code>pImpl</code>是一个<code>std::unique_ptr&lt;Widget::Impl&gt;</code>，也就是说，一个使用默认删除器的<code>std::unique_ptr</code>。 默认删除器是一个函数，它使用<code>delete</code>来销毁内置于<code>std::unique_ptr</code>的原始指针。然而，<strong>在使用<code>delete</code>之前，通常会使默认删除器使用C++11的特性<code>static_assert</code>来确保原始指针指向的类型不是一个未完成类型。 当编译器为<code>Widget w</code>的析构生成代码时，它会遇到<code>static_assert</code>检查并且失败，这通常是错误信息的来源。</strong> 这些错误信息只在对象<code>w</code>销毁的地方出现，因为类<code>Widget</code>的析构函数，正如其他的编译器生成的特殊成员函数一样，是暗含<code>inline</code>属性的。 错误信息自身往往指向对象<code>w</code>被创建的那行，因为这行代码明确地构造了这个对象，导致了后面潜在的析构。</p>
<p>​    <strong>为了解决这个问题，你只需要确保在编译器生成销毁<code>std::unique_ptr&lt;Widget::Impl&gt;</code>的代码之前， <code>Widget::Impl</code>已经是一个完成类型（<em>complete type</em>）。</strong> 当编译器“看到”它的定义的时候，该类型就成为完成类型了。 <strong>但是 <code>Widget::Impl</code>的定义在<code>widget.cpp</code>里。</strong>成功编译的<strong>关键，就是在<code>widget.cpp</code>文件内，让编译器在“看到” <code>Widget</code>的析构函数实现之前（也即编译器插入的，用来销毁<code>std::unique_ptr</code>这个数据成员的代码的，那个位置），先定义<code>Widget::Impl</code>。</strong></p>
<p>​    做出这样的调整很容易。只需要先在<code>widget.h</code>里，只声明类<code>Widget</code>的析构函数，但不要在这里定义它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                  <span class="hljs-comment">//跟之前一样，在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();                  <span class="hljs-comment">//只有声明语句</span><br>    …<br><br><span class="hljs-keyword">private</span>:                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>在<code>widget.cpp</code>文件中，在结构体<code>Widget::Impl</code>被定义之后，再定义析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"widget.h"</span>                 <span class="hljs-comment">//跟之前一样，在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gadget.h"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123;               <span class="hljs-comment">//跟之前一样，定义Widget::Impl</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;<br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget()                   <span class="hljs-comment">//析构函数的定义（译者注：这里高亮）</span><br>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>这样就可以了，并且这样增加的代码也最少，<strong>你声明<code>Widget</code>析构函数只是为了在 Widget 的实现文件中（译者注：指<code>widget.cpp</code>）写出它的定义</strong>，但是如果你想强调编译器自动生成的析构函数会做和你一样正确的事情，你可以直接使用“<code>= default</code>”定义析构函数体</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//同上述代码效果一致</span><br></code></pre></div></td></tr></table></figure>
<p>使用了Pimpl惯用法的类自然适合支持移动操作，因为编译器自动生成的移动操作正合我们所意：对其中的<code>std::unique_ptr</code>进行移动。 正如<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/3.MovingToModernCpp/item17.md" target="_blank" rel="noopener">Item17</a>所解释的那样，声明一个类<code>Widget</code>的析构函数会阻止编译器生成移动操作，所以如果你想要支持移动操作，你必须自己声明相关的函数。考虑到编译器自动生成的版本会正常运行，你可能会很想按如下方式实现它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                                  <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//思路正确，</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">//但代码错误</span><br>    …<br><br><span class="hljs-keyword">private</span>:                                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这样的做法会导致同样的错误，和之前的声明一个不带析构函数的类的错误一样，并且是因为同样的原因。</p>
<ul>
<li><p><strong>编译器生成的移动赋值操作符，在重新赋值之前，需要先销毁指针<code>pImpl</code>指向的对象。</strong>然而在<code>Widget</code>的头文件里，<code>pImpl</code>指针指向的是一个未完成类型。(这里可能部分读者会疑惑，为什么要销毁指针，首先读者要明确，比如<code>A = std::move(B)</code>， 销毁的是A的pImpl指针指向的对象，很多读者会误认为是B的。 如果不是因为这个导致你读不懂这一条，那么你可能需要重写了解下移动赋值/移动构造，可以看这个:<a href="https://chillstepp.github.io/2022/05/27/C-11%E6%96%B0%E7%89%B9%E6%80%A7/#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E6%80%8E%E4%B9%88%E8%8A%82%E7%9C%81%E5%BC%80%E9%94%80%E7%9A%84">移动语义是怎么节省开销的</a>)</p>
</li>
<li><p>移动构造函数的情况有所不同。 <strong>移动构造函数的问题是编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁<code>pImpl</code>的代码。然而，销毁<code>pImpl</code>需要<code>Impl</code>是一个完成类型。</strong></p>
</li>
</ul>
<p>因为这个问题同上面一致，所以解决方案也一样——把移动操作的定义移动到实现文件里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    ~Widget();<br><br>    Widget(Widget&amp;&amp; rhs);               <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs);<br>    …<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget()                    <span class="hljs-comment">//跟之前一样</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;        <span class="hljs-comment">//跟之前一样</span><br><br>Widget::Widget(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//这里定义</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br></code></pre></div></td></tr></table></figure>
<p> 原来的类<code>Widget</code>包含有<code>std::string</code>，<code>std::vector</code>和<code>Gadget</code>数据成员，并且，假设类型<code>Gadget</code>，如同<code>std::string</code>和<code>std::vector</code>一样，允许复制操作，<strong>所以类<code>Widget</code>支持复制操作也很合理。 我们必须要自己来写这些函数，</strong>因为</p>
<ul>
<li><p><strong>第一，对包含有只可移动（<em>move-only</em>）类型，如<code>std::unique_ptr</code>的类，编译器不会生成复制操作；</strong></p>
</li>
<li><p><strong>第二，即使编译器帮我们生成了(当然编译器不会生成=_=)，生成的复制操作也只会复制<code>std::unique_ptr</code>（也即浅拷贝（<em>shallow copy</em>）），而实际上我们需要复制指针所指向的对象（也即深拷贝（<em>deep copy</em>））。</strong></p>
</li>
</ul>
<p>使用我们已经熟悉的方法，我们在头文件里声明函数，而在实现文件里去实现他们:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                          <span class="hljs-comment">//仍然在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    …<br><br>    Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs);          <span class="hljs-comment">//只有声明</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs);<br><br><span class="hljs-keyword">private</span>:                                <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;                   //跟之前一样，仍然在“widget.cpp”中</span></span><br>…<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl &#123; … &#125;;          <span class="hljs-comment">//跟之前一样</span><br><br>Widget::~Widget() = <span class="hljs-keyword">default</span>;		<span class="hljs-comment">//其他函数，跟之前一样</span><br><br>Widget::Widget(<span class="hljs-keyword">const</span> Widget&amp; rhs)   <span class="hljs-comment">//拷贝构造函数</span><br>: pImpl(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl))<br>&#123;&#125;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs)    <span class="hljs-comment">//拷贝operator=</span><br>&#123;<br>    *pImpl = *rhs.pImpl;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>两个函数的实现都比较中规中矩。 在每个情况中，我们都只从源对象（<code>rhs</code>）中，复制了结构体<code>Impl</code>的内容到目标对象中（<code>*this</code>）。我们利用了编译器会为我们自动生成结构体<code>Impl</code>的复制操作函数的机制，而不是逐一复制结构体<code>Impl</code>的成员，自动生成的复制操作能自动复制每一个成员。 因此我们通过调用编译器生成的<code>Widget::Impl</code>的复制操作函数来实现了类<code>Widget</code>的复制操作。 在复制构造函数中，注意，我们仍然遵从了<a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item21.md" target="_blank" rel="noopener">Item21</a>的建议，使用<code>std::make_unique</code>而非直接使用<code>new</code>。</p>
<p>为了实现Pimpl惯用法，<code>std::unique_ptr</code>是我们使用的智能指针，因为位于对象内部的<code>pImpl</code>指针（例如，在类<code>Widget</code>内部），对所指向的对应实现的对象的享有独占所有权。然而，<strong>有趣的是，如果我们使用<code>std::shared_ptr</code>而不是<code>std::unique_ptr</code>来做<code>pImpl</code>指针， 我们会发现本条款的建议不再适用。</strong> 我们不需要在类<code>Widget</code>里声明析构函数，没有了用户定义析构函数，编译器将会愉快地生成移动操作，并且将会如我们所期望般工作。<code>widget.h</code>里的代码如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span>                      <span class="hljs-comment">//在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    Widget();<br>    …                               <span class="hljs-comment">//没有析构函数和移动操作的声明</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Impl</span>;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Impl&gt; pImpl;    <span class="hljs-comment">//用std::shared_ptr</span><br>&#125;;                                  <span class="hljs-comment">//而不是std::unique_ptr</span><br></code></pre></div></td></tr></table></figure>
<p>这是<code>#include</code>了<code>widget.h</code>的客户代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Widget w1;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">w2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(w1))</span></span>;     <span class="hljs-comment">//移动构造w2</span><br>w1 = <span class="hljs-built_in">std</span>::move(w2);         <span class="hljs-comment">//移动赋值w1</span><br></code></pre></div></td></tr></table></figure>
<p>这些都能编译，并且工作地如我们所望：<code>w1</code>将会被默认构造，它的值会被移动进<code>w2</code>，随后值将会被移动回<code>w1</code>，然后两者都会被销毁（因此导致指向的<code>Widget::Impl</code>对象一并也被销毁）。</p>
<p><strong><code>std::unique_ptr</code>和<code>std::shared_ptr</code>在<code>pImpl</code>指针上的表现上的区别的深层原因在于，他们支持自定义删除器的方式不同。 对<code>std::unique_ptr</code>而言，删除器的类型是这个智能指针的一部分，这让编译器有可能生成更小的运行时数据结构和更快的运行代码。 这种更高效率的后果之一就是<code>std::unique_ptr</code>指向的类型，在编译器的生成特殊成员函数（如析构函数，移动操作）被调用时，必须已经是一个完成类型。</strong></p>
<p>所以 我们发现<code>shared_ptr</code>不对完成类型做要求，但是不是场景不是很适合使用。<code>unique_ptr</code>很适合，但是你需要注意一些坑，实现的规范小心一些。</p>
<p><strong>请记住：</strong></p>
<ul>
<li>Pimpl惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。</li>
<li>对于<code>std::unique_ptr</code>类型的<code>pImpl</code>指针，需要在头文件的类里声明特殊的成员函数，但是在实现文件里面来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li>
<li>以上的建议只适用于<code>std::unique_ptr</code>，不适用于<code>std::shared_ptr</code>。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/EffectiveModernCPP/">EffectiveModernCPP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/05/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%EF%BC%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《EffectiveModernC-》第五章-移动语义，完美转发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/03/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3C/">
                        <span class="hidden-mobile">《EffectiveModernC++》第三章:移步现代C++</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https://chillstepp.github.io/2022/12/03/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/';
        this.page.identifier = '/2022/12/03/%E3%80%8AEffectiveModernC-%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'fluid' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
