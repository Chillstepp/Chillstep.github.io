

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <link rel="icon" type="image/png" href="/img/%E7%8C%AB%E5%A4%B4.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chillstep">
  <meta name="keywords" content="">
  <title>C++11新特性 - Chillstep</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chillstepp.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chillstep</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/sdqryn.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++11新特性">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-27 23:44" pubdate>
        2022年5月27日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      136
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++11新特性</h1>
            
            <div class="markdown-body">
              <h2 id="ariadic-Templates数量不定的模板参数"><a href="#ariadic-Templates数量不定的模板参数" class="headerlink" title="ariadic Templates数量不定的模板参数"></a>ariadic Templates数量不定的模板参数</h2><p>下面是一个数量不定的模板参数的例子，<code>print()</code>函数做得是一个将一堆参数输出的动作。</p>
<p>每次取出第一个参数输出，剩下的参数包递归下去每次输出参数的第一个。但请不要忘记写<code>void print(){ }</code>，因为当参数空的时候，你需要一个无参的<code>print</code>来结束print的递归。</p>
<p>如果你想知道 后面那一部分参数包有几个，你可以使用<code>sizeof...(args)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;firstArg&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"123"</span>,<span class="hljs-string">"456"</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>下面考虑这样一个函数可以和上面的<code>void print(const T&amp; firstArg,const Types&amp;... args)</code>函数共存吗？一般来说答案是否定的，但是在Variadic Templates中是允许的, 即C++不认为这是有歧义的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>那么这两者的谁更泛化，谁更特化？当然是第一种的<code>void print(const T&amp; firstArg,const Types&amp;... args)</code>更特化。</p>
<p>标准库中有一个很好的例子如下图，<code>hash_val</code>有三个版本，分别是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>&amp; seed, <span class="hljs-keyword">const</span> T&amp; val, <span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span><br>template&lt;typename... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>&amp; seed, <span class="hljs-keyword">const</span> T&amp; val)</span></span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506124336704.png" srcset="/img/loading.gif" alt="image-20220506124336704"></p>
<p>如上图②会一直调用自己本身，直到<code>args...</code>只剩下一个时则会调用③。</p>
<p>而③由于第一参数不是<code>size_t&amp;</code>没有其他人特化，所以一直没有被调用。当第一参数不是<code>size_t&amp;</code>时的函数调用时他这个更泛化的版本才会被调用到。</p>
<p>Tuple的实现也利用了Variadic Template来做递归继承。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506130058768.png" srcset="/img/loading.gif" alt="image-20220506130058768"></p>
<h2 id="Spaces-in-Template-Expressions"><a href="#Spaces-in-Template-Expressions" class="headerlink" title="Spaces in Template Expressions"></a>Spaces in Template Expressions</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-comment">//C++11 before</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;  <span class="hljs-comment">//C++11 now</span><br></code></pre></div></td></tr></table></figure>
<p>原来编译器不够智能会导致<code>&gt;&gt;</code>被认为是流操作符，现在已经可以这么使用了</p>
<h2 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a><code>nullptr</code> and <code>std::nullptr_t</code></h2><p>在nullptr出现之前，我们一直使用NULL代表指针的空，其实NULL定义就是0，这会带来一些问题：<br><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506131109845.png" srcset="/img/loading.gif" alt="image-20220506131109845"></p>
<p><code>f(NULL)</code>会带来歧义，为了解决这个歧义，C++11提出了<code>nullptr</code>关键字，他的类型是：<code>std::nullptr_t</code></p>
<p>这个类型是如何定义的呢？</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506131438319.png" srcset="/img/loading.gif" alt="image-20220506131438319"></p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>使用它来做自动类型推导，可以和其他操作符<code>（&amp;，*，const）</code>，一般来说<code>auto</code> 是<strong>根据变量的初始值来推导出变量类型的</strong>，比如一些容器的迭代器完整写下来就很长，使用auto就很方便</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span> , b = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span>* pointer = &amp;b;<span class="hljs-comment">//和*一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;*pointer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">auto</span>&amp; refer = a;<span class="hljs-comment">//和&amp;一起用</span><br><span class="hljs-built_in">cout</span>&lt;&lt;refer&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> ConstVar = b;<span class="hljs-comment">//和const一起用</span><br>ConstVar = <span class="hljs-number">2</span>;<span class="hljs-comment">//报错:ConstVar是read-only的</span><br></code></pre></div></td></tr></table></figure>
<p>auto只建议在类型过长时使用，例如lambda表达式的类型，迭代器等…，而不该滥用auto</p>
<h3 id="auto-trick"><a href="#auto-trick" class="headerlink" title="auto trick"></a>auto trick</h3><ul>
<li><strong><code>=</code>右边是一个引用类型时<code>auto</code>会自动把引用抛弃，推导出原始类型：这是符合直觉的，我们希望引用与否掌握在程序员手上，因此这种帮助了我们根据意志自由决定。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;ref = x;<br><span class="hljs-keyword">auto</span> test = ref;<span class="hljs-comment">//tesr推导出的类型为test</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</strong></li>
<li><strong>当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</strong></li>
</ul>
<p>对于上边两条做出解释：</p>
<p>1.当类型不为引用时，<code>auto</code> 的推导结果将不保留表达式的 <code>const</code>属性；</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> y = x;<span class="hljs-comment">//y是int类型，会抛弃const</span><br></code></pre></div></td></tr></table></figure>
<p>2.当类型为引用时，<code>auto</code> 的推导结果将保留表达式的 <code>const</code> 属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> t = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a = t;<br><span class="hljs-keyword">auto</span> test1 = a;<span class="hljs-comment">//test1推导出int类型,给程序员自由</span><br><span class="hljs-keyword">auto</span> &amp;test2 = a;<span class="hljs-comment">//test2推导出const int&amp;类型，其中auto为const int</span><br></code></pre></div></td></tr></table></figure>
<p>这么做的原因是为了安全，如果你的auto推出的是int，那么也就是说可以通过这个引用去修改一个const的变量，这是不合理的(编译器会禁止这样做)。因此为了合理性、安全性，推导出<code>const int</code>是最好的选择。</p>
<ul>
<li><strong>auto 不能在函数的参数中使用 (版本低于C++20)</strong></li>
</ul>
<p>如果为了减少代码重复，模板是一个更好的替代方法</p>
<p><strong>注意：C++20已经允许auto在函数参数中使用了</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x,<span class="hljs-keyword">auto</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"123"</span>;<br>    <span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"345"</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;fun(s1,s2)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">auto</span> x;<span class="hljs-comment">//error: non-static data member declared with placeholder 'auto'|</span><br>    <span class="hljs-keyword">auto</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.x = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>auto 关键字不能定义数组 （char[]不行，用char*的可以）</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a[<span class="hljs-number">4</span>] = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//error:'a' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span> b[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//error:'b' declared as array of 'auto'|</span><br><span class="hljs-keyword">auto</span>* c = <span class="hljs-string">"12345"</span>;<span class="hljs-comment">//ok</span><br></code></pre></div></td></tr></table></figure>
<p>Reference : <a href="https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables" target="_blank" rel="noopener">https://stackoverflow.com/questions/7107606/why-cant-i-create-an-array-of-automatic-variables</a></p>
<p>虽然<code>auto x[4] ={ ....}</code>是一个错误的用法，但是<code>auto x = {1,2,3,4}</code>会推出<code>x</code>是一个<code>std::initializer_list&lt;int&gt;</code>类型。</p>
<ul>
<li><strong>auto 不能作用于模板参数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A&lt;<span class="hljs-keyword">int</span>&gt; C1;<br>    A&lt;<span class="hljs-keyword">auto</span>&gt; C2 = C1;  <span class="hljs-comment">//错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Uniform-Initialization一致性初始化"><a href="#Uniform-Initialization一致性初始化" class="headerlink" title="Uniform Initialization一致性初始化"></a>Uniform Initialization一致性初始化</h2><p>在C++11之前初始化一个东西的方式各种各样，为了解决这个问题:</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506132934801.png" srcset="/img/loading.gif" alt="image-20220506132934801"></p>
<p>C++11提出了<code>Uniform Initialization</code>, 即变量后边设置花括号来初始化:</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506133023489.png" srcset="/img/loading.gif" alt="image-20220506133023489"></p>
<p>编译器可以通过<code>&lt;T&gt;</code>来获取模板中的类型，然后看到<code>{t1,t2,t3...}</code>便做出一个<code>initializer_list&lt;T&gt;</code>，他背后本质是<code>array&lt;T,n&gt;</code>，其中n代表花括号中的个数，调用函数(比如构造函数)时，array内的元素可以被编译器分解注意传送给函数。</p>
<p>那如果一个类就有接受<code>initializer_list&lt;T&gt;</code>类型的构造函数呢？那么就会把<code>initializer_list&lt;T&gt;</code>直接作为参数传递，而无需分解。标准库中的容器都有 带有这种参数的构造函数。</p>
<p>因此<code>initializer_list&lt;T&gt;</code>是有两种方法来被函数解析的：一种是直接作为整体传入函数，另一种是通过背后的array分解成n个元素一个一个传给构造函数。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220506134418097.png" srcset="/img/loading.gif" alt="image-20220506134418097"></p>
<h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer_list"></a>Initializer_list</h2><p>花括号可以用来设初值：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509130925182.png" srcset="/img/loading.gif" alt="image-20220509130925182"></p>
<p>Initializer_list的初始化方法和原来小括号的初始化在一些地方是有区别的：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509131052216.png" srcset="/img/loading.gif" alt="image-20220509131052216"></p>
<p>Initializer_list不允许窄化的转型，例如float转int是不允许的，而用7初始化char是允许的。在某些编译器上只会给出警告，有些编译器会给出error。</p>
<p>当存在两个版本的构造函数：分别为普通的方法和<code>Initializer_list</code>的方法，那么调用时如果使用了花括号就调<code>Initializer_list</code>的版本，如果使用了<code>()</code>初始化的方式就会调用普通的构造函数。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509132106296.png" srcset="/img/loading.gif" alt="image-20220509132106296"></p>
<p>那么<strong>当没有<code>Initializer_list</code>版本②的存在时，只存在普通版本①时，<code>{}</code>依然可以初始化，编译器会帮我们拆解开<code>{}</code>里的内容，然后再调用到版本①。</strong></p>
<p>观察下面的代码红框中，编译器可以调用一个私有的<code>Initializer_list</code>的构造函数，因此编译器会构造出来他，给他分配一个array的头的迭代器，array中存有初始化花括号中的数据，这验证了前面我们所说的，<code>Initializer_list</code>的内部实现有array在支持。这也提示我们在拷贝<code>Initializer_list</code>时要小心，这会导致多个迭代器指向同一片区域，他们共有array这一片区域，而非独占，因为这是浅拷贝。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509132858898.png" srcset="/img/loading.gif" alt="image-20220509132858898"></p>
<p><code>Initializer_list</code>给了我们更多符合直觉的方法，比如min在<code>Initializer_list</code>的支持下，可以在底层用min_element改进一下，从而可以同时比较多个数，同理vector中的insert函数也可以一次insert多个。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509134553763.png" srcset="/img/loading.gif" alt="image-20220509134553763"></p>
<h2 id="Explicit-for-ctors-taking-more-than-one-arguement"><a href="#Explicit-for-ctors-taking-more-than-one-arguement" class="headerlink" title="Explicit for ctors taking more than one arguement"></a>Explicit for ctors taking more than one arguement</h2><p>首先要理解什么是Explicit：<a href="https://chillstepp.github.io/2021/12/20/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E4%B8%8B/#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0non-explicit-one-argument-ctor">原来的博文有详细介绍Explict和non-Explict</a></p>
<p>Explicit中文译为明白的明确的，简单来说就是不要隐式调用构造函数，如下图。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509192940333.png" srcset="/img/loading.gif" alt="image-20220509192940333"></p>
<p>在C++11以前，隐式调用只存在于单一实参的构造函数(Non-Explict One Arguement)，如上图Complex的<code>Complex(int re,int im=0)</code>只存在一个实参，第二个为默认参数，因此它可以发生隐式调用。这很符合直觉，因为<code>c1+5</code>的时候参数就5一个，参数多的时候似乎在C++11前是没有意义的。但是在<code>Initializer_list</code>出现后，好像也可以出现这种用法：<code>t + {1，2，3}</code> ，<code>{1,2,3}</code>去隐式调用了构造函数。那么<code>explicit</code>就有必要做出扩展，表示 多参数的构造函数也不允许被隐式调用。</p>
<p>下面例子: 加上explicit禁止多参数隐式调用的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span> </span>&#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"explicit P(int a,int b,int c)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>    P <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> P&amp; rhs)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P operator+(const P&amp; rhs)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> P&amp; arg)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    P p1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//显式调用构造  ok</span><br>    P p2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//隐式调用构造  no</span><br>    <span class="hljs-function">P <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//显式调用构造 ok</span><br><br>    fun(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//隐式调用构造  no</span><br>    fun(P&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//显式调用构造 yes</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Range-based-for-statement"><a href="#Range-based-for-statement" class="headerlink" title="Range-based for statement"></a>Range-based for statement</h2><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509195854595.png" srcset="/img/loading.gif" alt="image-20220509195854595"></p>
<p>编译器对range-based的解释如下：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509200147325.png" srcset="/img/loading.gif" alt="image-20220509200147325"></p>
<p>同理explict也可以禁止range-based中的隐式转换：</p>
<p>vs中的每个string赋值给C会触发隐式调用，而<code>explicit</code>禁止了这种隐式调用。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509200501615.png" srcset="/img/loading.gif" alt="image-20220509200501615"></p>
<h2 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    P(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P(int a,int b,int c)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<br>    P <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> P&amp; rhs)<br>    &#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"P operator+(const P&amp; rhs)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> P&amp; arg)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    P p1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-function">P <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//ok, 但是如果P的定义加上P(const P&amp;) = delete;则失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>五大(Big Five)默认实现的：</p>
<p>拷贝构造，移动构造，拷贝复制，移动赋值，析构函数。 其实还有一个默认的Zoo()编译器也会帮我们实现，但是当有一个构造函数自己写出来后，这个空的构造函数便不能使用了。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509201551845.png" srcset="/img/loading.gif" alt="image-20220509201551845"></p>
<p>下面例子：</p>
<p><strong>1.构造函数如果签名不同是可以同时存在的，因为构造函数可以有多个版本。</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509202536252.png" srcset="/img/loading.gif" alt="image-20220509202536252"></p>
<p><strong>2.对于编译器可以默认生成的函数(拷贝构造函数/赋值构造函数/移动构造函数/移动赋值函数)，如果你自己已经定义了，那就不可以再用default/delete声明</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509202615380.png" srcset="/img/loading.gif" alt="image-20220509202615380"></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509203129701.png" srcset="/img/loading.gif" alt="image-20220509203129701"></p>
<p><strong>3.普通函数没有=default的操作，但是可以=delete：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220509203210387.png" srcset="/img/loading.gif" alt="image-20220509203210387"></p>
<p><strong>4.析构函数不能=delete，但是可以=default</strong></p>
<p>析构函数必须存在进行内存回收，因此不可以delete。=default默认是ok的，符合逻辑直觉。</p>
<p><strong>总结一下：</strong></p>
<p><strong>1.=default只用于BIg-Five(拷贝构造，移动构造，拷贝复制，移动赋值，析构函数)</strong></p>
<p><strong>2.=delete可以用于任何函数身上，除了virtual虚函数(虚函数也有一个=的用法，叫做=0表示纯虚函数)</strong></p>
<p>因此一个空的class在C++处理过后不在是空，会有默认生成的Big-five。</p>
<p>一般来说对于数据成员有指针的类，我们如果希望是深拷贝，那么最好不要用默认default，default只会帮我们做浅拷贝。</p>
<h2 id="Alias-Template模板别名"><a href="#Alias-Template模板别名" class="headerlink" title="Alias Template模板别名"></a>Alias Template模板别名</h2><p>考虑这样的一个用法：利用Vec这个别名可以帮助我们减少模板的定义，比如原来vector需要<code>std::vector&lt;T,MyAlloc&lt;T&gt;&gt;</code>的方法来声明一个vector，现在我们仅仅需要<code>Vec&lt;T&gt;</code>即可。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220511205543482.png" srcset="/img/loading.gif" alt="image-20220511205543482"></p>
<p>这是原来的宏定义无法做到给模板一个别名的，无论是define还是typedef：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220511205807638.png" srcset="/img/loading.gif" alt="image-20220511205807638"></p>
<p><strong>因此这个方法给模板定义了一个别名，叫做模板别名。但是模板别名是无法做到模板偏特化和特化的</strong></p>
<p><strong>考虑如何写一个支持输入容器名字和容器内元素的类型就可以实现对容器遍历？</strong></p>
<p>下面是第一种方法：通过萃取机<code>iterator_traits</code>萃取出容器内元素的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::value_type TYPE;<br>    c.insert(c.<span class="hljs-built_in">end</span>(), TYPE());<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"&#123;"</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">typename</span> Container::iterator it = c.<span class="hljs-built_in">begin</span>(); it!=c.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        <span class="hljs-keyword">typename</span> Container::iterator it_copy = it;<br>        it_copy ++;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;(it_copy!=c.<span class="hljs-built_in">end</span>()?<span class="hljs-string">","</span>:<span class="hljs-string">""</span>);<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"&#125;"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>还有一种方法需要用到模板模板参数(template template parameter)。</p>
<h2 id="template-template-parameter，模板的模板参数"><a href="#template-template-parameter，模板的模板参数" class="headerlink" title="template template parameter，模板的模板参数"></a>template template parameter，模板的模板参数</h2><p>模板的模板参数就是：模板中还存在模板作为的参数。<strong>注意:函数模板不支持模板的模板参数,类模板才支持这种操作</strong></p>
<p>这个的应用场景是，比如我们想这么用:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">list</span>&gt;mylist1;<br></code></pre></div></td></tr></table></figure>
<p>此时希望list自动辨别出来我们要用的是string，并把list自己的容纳元素类型绑定成string。一个简单的方法就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">typename</span> T&gt;&gt;<br>考虑到想让容器也可以变化，适应多种容器，不妨写成:<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215220706952.png" srcset="/img/loading.gif" alt="image-20211215220706952"></p>
<p>这样可以达到我们想要的效果吗？</p>
<p>奇怪的是并不可以：这是因为XCLs中的<code>Container&lt;T&gt;c</code>这部分的T填入的是类型T(string)，然而我们平时可以这么用<code>list&lt;string&gt;</code>是因为string填入后，其实<code>&lt;&gt;</code>后面还会有一些默认参数，比如：allocator分配器等….。</p>
<p>但是如果你用<code>T</code>表示，c++就会认为你没有填入后面的默认参数(语言的规定)。简单来说如果你用了T做容器的参数，那么容器的后面的默认参数会失效，你需要自己补上这些参数。</p>
<p>因此我们可以这么用(c++2.0新特性（c++11/14）)，使得第二种是对的：<strong>即利用<code>using</code>定义模板别名</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20211215221628613.png" srcset="/img/loading.gif" alt="image-20211215221628613"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT&lt;T&gt;c;<br>&#125;;<br><br><span class="hljs-comment">//利用using 给这个模板定义了别名: Lst</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,Lst&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个模板推导过程是：<code>T</code>推出<code>string</code>，然后从<code>CONT&lt;T&gt;c</code>推出<code>U</code>是<code>string</code>，然后从<code>U</code>再推到<code>T2</code>是<code>string</code>。</p>
<p>下面这并<strong>不叫做一个模板模板参数</strong>，因为<code>XCLs&lt;string,set&lt;string&gt;&gt;mylist1;</code>中的<code>set&lt;string&gt;</code>就已经绑定好容器的元素类型了，使得<code>class CONT</code>变成<code>set&lt;string&gt;</code>根本没有模板进行推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CONT</span>=<span class="hljs-title">list</span>&lt;T,allocator&lt;T&gt;&gt;&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">XCLs</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    CONT c;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Lst = <span class="hljs-built_in">list</span>&lt;T2,allocator&lt;T2&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>   <span class="hljs-comment">// fastIO</span><br>    XCLs&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;mylist1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="Alias-Type类型别名-补充一些函数指针的知识）"><a href="#Alias-Type类型别名-补充一些函数指针的知识）" class="headerlink" title="Alias Type类型别名(补充一些函数指针的知识）"></a>Alias Type类型别名(补充一些函数指针的知识）</h2><p>我们经常可以在标准库看到<code>typedef T value_type</code>的用法，现在利用using也可以做到：<code>using value_Type = T</code>，其实这种看起来更容易阅读一些，在模板别名。</p>
<p>但是他的易读性在函数指针中更凸显，首先介绍一下函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;   <span class="hljs-comment">// 函数原型(prototype)</span><br><span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>);   <span class="hljs-comment">// 声明一个函数指针pf，他指向输入参数为int,返回值为double的函数 </span><br>pf = cal;    <span class="hljs-comment">// 指针赋值</span><br></code></pre></div></td></tr></table></figure>
<p>既然<code>double (*pf)(int)</code>是一个函数指针，那么这个指针的类型就是<code>double (*pf)(int)</code>去掉变量名即可，即：<code>double (*)(int)</code></p>
<p>现在我们已经补充了一些什么是函数指针的知识，下面利用alias type来替代一下试试：</p>
<p>可以直接用<code>func_pointer</code>指代函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> func_pointer = <span class="hljs-keyword">void</span>(*)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_pointer fn = <span class="hljs-built_in">exp</span>;<br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>也可以指代函数原型，然后声明的时候自己加上指针符。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> func = <span class="hljs-keyword">void</span> (<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func* fn = <span class="hljs-built_in">exp</span>;<br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>值得一提的是：在alias type上，using和typedef没任何区别，只是更易读而已。</strong>下面是typedef等效的写法</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*func_pointer)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(func)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_pointer fn = <span class="hljs-built_in">exp</span>; <span class="hljs-comment">//ok</span><br>    fn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br><br>    func* fn2 = <span class="hljs-built_in">exp</span>; <span class="hljs-comment">//ok</span><br>    fn2(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="总结using"><a href="#总结using" class="headerlink" title="总结using"></a>总结using</h2><p>我们总结一下using：</p>
<ul>
<li><p>using在namespace(<code>using namespace std</code>)和namespace member(<code>using std::cout</code>)。</p>
</li>
<li><p>using在class member中</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512201804869.png" srcset="/img/loading.gif" alt="image-20220512201804869"></p>
<p>如果你写了using了上面这些，那么在类中你就可以不写namespace <code>_Base::</code>，直接写函数成员名字即可</p>
</li>
<li><p>Alias type和Alias template</p>
</li>
</ul>
<h2 id="noexcept-和-vector扩容中如何利用移动语义扩容-的关联"><a href="#noexcept-和-vector扩容中如何利用移动语义扩容-的关联" class="headerlink" title="noexcept 和 vector扩容中如何利用移动语义扩容 的关联"></a>noexcept 和 vector扩容中如何利用移动语义扩容 的关联</h2><p>noexcept表示保证不会出现异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-built_in">exp</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>exp里面若为true，则需要保证foo函数noexcept，反之无需保证。</p>
<p>当不写<code>(exp)</code>, 则表示永远不会出现异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br>    等价于<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>noexcept这个保证不出现异常有什么意义呢？</p>
<p>在可成长的容器，即会发生内存重分配，比如vector和deque，以vector为例子，当扩容时不是原地扩容，而是重新开辟一片内存，然后让之前的内容搬移过来，在搬移时有两种方法，一种是拷贝构造函数，另一种是移动构造函数。</p>
<p>他们有什么区别呢？</p>
<blockquote>
<p>What does the copy constructor and move constructor look like behind the scenes, in terms of memory usage?</p>
</blockquote>
<p>If <em>any</em> constructor is being called, it means a new object is being created in memory. So, the only difference between a <em>copy</em> constructor and a <em>move</em> constructor is whether the source object that is passed to the constructor will have its member fields <em>copied</em> or <em>moved</em> into the new object.</p>
<p>拷贝构造会把对象的拷贝到另一块内存，包括他的成员变量。而移动构造中，源对象的成员变量不会被复制，而是直接通过指针的方式直接指向原来的内存，直接重复利用这些成员变量，接管源对象的内存，因此无需对成员变量进行复制。</p>
<p><strong>那如果我自己声明了一个Mystring类，我想让他在vector存储的时候，扩容时调用Mystring的移动构造函数怎么办呢？这时就需要我们在MyString的移动构造函数和移动赋值函数上添加noexcept，vector才会利用MyString移动语义。</strong></p>
<h2 id="Override-与-final"><a href="#Override-与-final" class="headerlink" title="Override 与 final"></a>Override 与 final</h2><p>当我们想重载<code>vfunc(float)</code>，但是不小心重载成了<code>void vfun(int)</code>，那么也没人告诉我们这不对，因为编译器会完全认为这是一个全新的函数  。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512205816115.png" srcset="/img/loading.gif" alt="image-20220512205816115"></p>
<p>我们可以在写重载函数时加上一个override函数，表示这个函数是重载的，这样在我们在写错函数签名的时候就会提示我们：这个函数在基类中没有，没法重载，而此时的编译器就不会把他认作新的函数通过编译。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512205911885.png" srcset="/img/loading.gif" alt="image-20220512205911885"></p>
<p>final就是表示这个函数不会被重载，如果子类重载了这个函数就会提示你这是错误的。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220512210342567.png" srcset="/img/loading.gif" alt="image-20220512210342567"></p>
<p>这两种关键字都是为了减少 低级错误的发生 而产生的。</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>前要阅读: <a href="https://chillstepp.github.io/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/#decltype">https://chillstepp.github.io/2022/03/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9Aauto%E5%92%8Cdecltype/#decltype</a></p>
<p>以前写过这个特性相关的内容，这一次只写他的应用：</p>
<p>auto和decltype除了在细节上的差异外（比如是否完美保留<code>const，&amp;</code>等），auto只可以帮助我们不用写这个类型，类似于一个语法糖，而比如我们想把一个类型定义出来，那么还是需要decltype来做：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">decltype</span><span class="hljs-params">(xxx)</span> NewType</span><br></code></pre></div></td></tr></table></figure>
<p>那么decltype除了简单的获取类型外，更重要的意义是在元编程上：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220516210044839.png" srcset="/img/loading.gif" alt="image-20220516210044839"></p>
<p>如上图，我们可以用decltype获取出模板容器的迭代器。</p>
<p>在lambda表达式中常用的是auto来表达lambda类型，而在某些容器例如set中，需要指定比较方式的函数类型，因此decltype可以很好的解决这个问题。</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220517090641450.png" srcset="/img/loading.gif" alt="image-20220517090641450"></p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><a href="https://chillstepp.github.io/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/">https://chillstepp.github.io/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/</a></p>
<h2 id="再谈Variadic-Template"><a href="#再谈Variadic-Template" class="headerlink" title="再谈Variadic Template"></a>再谈Variadic Template</h2><p>Variadic Template变化的是模板参数，即：</p>
<ul>
<li>参数个数—参数个数逐一减少，通过函数递归调用实现</li>
<li>参数类型—参数类型变化</li>
</ul>
<p>这也是Variadic Template的使用场景。</p>
<p>我们自己实现一个如下函数发现，当调用到最后<code>1 + 1</code>形式的时候，即args只剩下一个的时候会调用 <code>maximum(int n)</code>而不会调用 <code>maximum(int n, Types... args)</code>拆成<code>1+0</code>的形式</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum(int n)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum()"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Types... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"called: int maximum(int n, Types... args)"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(n, maximum(args...));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    maximum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220523203944157.png" srcset="/img/loading.gif" alt="image-20220523203944157"></p>
<p><strong>如何输出一个tuple？</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220523205359391.png" srcset="/img/loading.gif" alt="image-20220523205359391"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> IDX,<span class="hljs-keyword">int</span> MAX, <span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PRINT_TUPLE</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        os&lt;&lt;<span class="hljs-built_in">get</span>&lt;IDX&gt;(t);<br>        <span class="hljs-keyword">if</span>(IDX+<span class="hljs-number">1</span>!=MAX) os&lt;&lt;<span class="hljs-string">","</span>;<br>        PRINT_TUPLE&lt;IDX+<span class="hljs-number">1</span>, MAX, args...&gt;::<span class="hljs-built_in">print</span>(os, t);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> MAX, <span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PRINT_TUPLE</span>&lt;MAX,MAX,args...&gt;&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)</span></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... args&gt;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> tuple&lt;args...&gt;&amp;t)<br>&#123;<br>    os&lt;&lt;<span class="hljs-string">"["</span>;<br>    PRINT_TUPLE&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>...(args), args...&gt;::<span class="hljs-built_in">print</span>(os, t);<br>    os&lt;&lt;<span class="hljs-string">"]"</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;make_tuple(<span class="hljs-number">2</span>,<span class="hljs-built_in">string</span>(<span class="hljs-string">"123"</span>))&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述代码有两个版本的<code>struct PRINT_TUPLE</code>，其中第二个做了参数上的偏特化，第二个版本是为了终止循环调用print。</p>
<p><strong>递归继承，以tuple为例：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220524132623412.png" srcset="/img/loading.gif" alt="image-20220524132623412"></p>
<p>how to fix？</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Values&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&#123;</span>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&lt;&gt; &#123;</span>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mytuple</span>&lt;Head,Tail...&gt; :</span> <span class="hljs-keyword">private</span> mytuple&lt;Tail...&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> inherited = mytuple&lt;Tail...&gt;;<br><span class="hljs-keyword">public</span>:<br>    mytuple() &#123;&#125;<br>    mytuple(Head v, Tail... vtail): m_head(v), inherited(vtail...) &#123;&#125;<br>    <span class="hljs-function">Head <span class="hljs-title">head</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_head;<br>    &#125;<br>    <span class="hljs-function">inherited&amp; <span class="hljs-title">tail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mytuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt;tp(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"123"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>递归复合：</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525132645667.png" srcset="/img/loading.gif" alt="image-20220525132645667"></p>
<h2 id="右值引用-移动语义"><a href="#右值引用-移动语义" class="headerlink" title="右值引用/移动语义"></a>右值引用/移动语义</h2><h3 id="前要："><a href="#前要：" class="headerlink" title="前要："></a>前要：</h3><p><a href="https://chillstepp.github.io/2022/02/15/C-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%92%8Cstd-move%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++左值右值/左右值引用/std::move()</a></p>
<p>在本节将终点怎么写一个好的移动语义，前置基础知识在上方链接。</p>
<h3 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值/右值"></a>左值/右值</h3><p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525194649565.png" srcset="/img/loading.gif" alt="image-20220525194649565"></p>
<p>简单来说左值可以出现在<code>operator =</code>左边也可以出现在<code>operator =</code>右边，而右值只可以出现在<code>operator =</code>的右边。临时对象是右值。</p>
<p>其中<strong>右值只可以出现在<code>operator =</code>的右边</strong>这个说法可能会引发歧义，因为上图中临时对象也出现了<code>operator =</code>左边，也就是说C++为什么要允许给临时对象赋值呢？</p>
<p>解释如下：简单来说算一个历史遗留问题</p>
<p>C++为什么允许给临时对象赋值？ - 暮无井见铃的回答 - 知乎 <a href="https://www.zhihu.com/question/533946012/answer/2495821727" target="_blank" rel="noopener">https://www.zhihu.com/question/533946012/answer/2495821727</a></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525195045773.png" srcset="/img/loading.gif" alt="image-20220525195045773"></p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>函数的返回值也是一个右值，<strong>右值没有一个确定的地址</strong>，因此右值是不可以取地址的，需要右值引用这种新的产物来引用右值：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525195320012.png" srcset="/img/loading.gif" alt="image-20220525195320012"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>&amp;&amp; x = fun();<span class="hljs-comment">// ok ，右值引用</span><br>    <span class="hljs-keyword">int</span>&amp; x = fun();<span class="hljs-comment">// no, error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'</span><br>    <span class="hljs-keyword">int</span>* p = &amp;fun();<span class="hljs-comment">// no , 右值不能取地址</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="如何在调用端-被调用端-告知-右值这个概念"><a href="#如何在调用端-被调用端-告知-右值这个概念" class="headerlink" title="如何在调用端/被调用端 告知 右值这个概念"></a>如何在调用端/被调用端 告知 右值这个概念</h3><p><strong>如何解决这个问题呢？</strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220525200348793.png" srcset="/img/loading.gif" alt="image-20220525200348793"></p>
<ul>
<li>如何在调用段告诉我是右值：<ul>
<li>1.自己本身就是右值：函数返回值，临时变量等…</li>
<li>2.自己本身是左值：<code>move()</code>函数转成右值</li>
</ul>
</li>
<li>如何在被调用端专门出一个处理右值的移动函数:<ul>
<li><code>fun(...,...,Type&amp;&amp; x)</code>,用右值引用来接着即可。</li>
</ul>
</li>
</ul>
<h3 id="移动语义是怎么节省开销的"><a href="#移动语义是怎么节省开销的" class="headerlink" title="移动语义是怎么节省开销的"></a>移动语义是怎么节省开销的</h3><p>移动构造就是接管了 右值的内存空间，把 右值内的指针成员变量 置为空这个操作可以帮助我们使得右值不调用析构函数，从而延续了右值的生命。</p>
<p>怎么写一个移动语义的构造/赋值函数呢？下面微软的文档讲的很好。</p>
<p><strong>reference:</strong><a href="https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170</a></p>
<p>简单来说，首先下面是一个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// MemoryBlock.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryBlock</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>   <span class="hljs-comment">// Simple constructor that initializes the resource.</span><br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemoryBlock</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> length)</span></span><br><span class="hljs-function">      : _<span class="hljs-title">length</span><span class="hljs-params">(length)</span></span><br>      , _data(new int[length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(size_t). length = "</span><br>                &lt;&lt; _length &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Destructor.</span><br>   ~MemoryBlock()<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In ~MemoryBlock(). length = "</span><br>                &lt;&lt; _length &lt;&lt; <span class="hljs-string">"."</span>;<br><br>      <span class="hljs-keyword">if</span> (_data != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" Deleting resource."</span>;<br>         <span class="hljs-comment">// Delete the resource.</span><br>         <span class="hljs-keyword">delete</span>[] _data;<br>      &#125;<br><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Copy constructor.</span><br>   MemoryBlock(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>      : _length(other._length)<br>      , _data(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[other._length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>   &#125;<br><br>   <span class="hljs-comment">// Copy assignment operator.</span><br>   MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In operator=(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>      &#123;<br>         <span class="hljs-comment">// Free the existing resource.</span><br>         <span class="hljs-keyword">delete</span>[] _data;<br><br>         _length = other._length;<br>         _data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[_length];<br>         <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>      &#125;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Retrieves the length of the data resource.</span><br>   <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">Length</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">return</span> _length;<br>   &#125;<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">size_t</span> _length; <span class="hljs-comment">// The length of the resource.</span><br>   <span class="hljs-keyword">int</span>* _data; <span class="hljs-comment">// The resource.</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这是他的<strong>移动构造函数/移动赋值函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// Move constructor.</span><br>MemoryBlock(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>   : _data(<span class="hljs-literal">nullptr</span>)<br>   , _length(<span class="hljs-number">0</span>)<br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Moving resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>   <span class="hljs-comment">// source object.</span><br>   _data = other._data;<br>   _length = other._length;<br><br>   <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>   <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>   other._data = <span class="hljs-literal">nullptr</span>;<br>   other._length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Move assignment operator.</span><br>MemoryBlock&amp; <span class="hljs-keyword">operator</span>=(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In operator=(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>   &#123;<br>      <span class="hljs-comment">// Free the existing resource.</span><br>      <span class="hljs-keyword">delete</span>[] _data;<br><br>      <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>      <span class="hljs-comment">// source object.</span><br>      _data = other._data;<br>      _length = other._length;<br><br>      <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>      <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>      other._data = <span class="hljs-literal">nullptr</span>;<br>      other._length = <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们来比较下： Copy constructor和Move constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">   <span class="hljs-comment">// Copy constructor.</span><br>   MemoryBlock(<span class="hljs-keyword">const</span> MemoryBlock&amp; other)<br>      : _length(other._length)<br>      , _data(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[other._length])<br>   &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(const MemoryBlock&amp;). length = "</span><br>                &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Copying resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>      <span class="hljs-built_in">std</span>::copy(other._data, other._data + _length, _data);<br>   &#125;<br><br><br><span class="hljs-comment">// Move constructor.</span><br>MemoryBlock(MemoryBlock&amp;&amp; other) <span class="hljs-keyword">noexcept</span><br>   : _data(<span class="hljs-literal">nullptr</span>)<br>   , _length(<span class="hljs-number">0</span>)<br>&#123;<br>   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In MemoryBlock(MemoryBlock&amp;&amp;). length = "</span><br>             &lt;&lt; other._length &lt;&lt; <span class="hljs-string">". Moving resource."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>   <span class="hljs-comment">// Copy the data pointer and its length from the</span><br>   <span class="hljs-comment">// source object.</span><br>   _data = other._data;<br>   _length = other._length;<br><br>   <span class="hljs-comment">// Release the data pointer from the source object so that</span><br>   <span class="hljs-comment">//上面这句话很重要，释放指针(指针=nullptr)可以保证source object不被析构，这帮助我们延长了右值声明，同时不用再拷贝一份_data了。</span><br>   <span class="hljs-comment">// the destructor does not free the memory multiple times.</span><br>   other._data = <span class="hljs-literal">nullptr</span>;<br>   other._length = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>总结下：</strong></p>
<ul>
<li>如果你的类没有指针那就没必要搞移动语义，也就是说用户自定义类型且内部存在指针类型移动构造才有意义。而互联网上大量的例子都没有指针类型在内部的类也在用移动语义，这是没有意义的。</li>
<li>移动语义的函数请把<code>noexcept</code>加上。</li>
<li>在写移动语义时请把source obejct中的所有pointer释放掉(如上代码中的<code>other._data = nullptr;</code>)，释放指针(<code>指针=nullptr</code>)可以保证source object不被析构。</li>
</ul>
<h3 id="完美转发-Perfect-Forwarding"><a href="#完美转发-Perfect-Forwarding" class="headerlink" title="完美转发(Perfect Forwarding)"></a>完美转发(Perfect Forwarding)</h3><p>基本的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">process</span>(a);<span class="hljs-comment">//void process(int&amp; i)</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//void process(int&amp;&amp; i)</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">move</span>(a));<span class="hljs-comment">//move把左值转右值，void process(int&amp;&amp; i)</span><br></code></pre></div></td></tr></table></figure>
<p>不完美的转发：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">forwd(<span class="hljs-number">2</span>);<span class="hljs-comment">//forwd(int&amp;&amp; i), process(int&amp; i),第二次右值变成了左值：这是因为int&amp;&amp; i是一个左值(右值引用是一个左值)，这导致了调用了左值的版本。</span><br><br><br>forwd(<span class="hljs-built_in">move</span>(a));<span class="hljs-comment">//forwd(int&amp;&amp; i), process(int&amp; i),第二次右值变成了左值：这是因为int&amp;&amp; i是一个左值(右值引用是一个左值)，这导致了调用了左值的版本，这是一个不完美的转发。</span><br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">forwd(a);<span class="hljs-comment">//error: cannot bind rvalue reference of type 'int&amp;&amp;' to lvalue of type 'int'|</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">process</span>(b);<span class="hljs-comment">//error: 没有对应的process版本</span><br><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">move</span>(b));<span class="hljs-comment">//error: const int&amp;&amp; 没有对应的process版本</span><br><span class="hljs-comment">//关于常量右值引用有没有用：https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511</span><br></code></pre></div></td></tr></table></figure>
<p>上面出现了一个常量右值引用，关于常量右值引用有没有用：<a href="https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511" target="_blank" rel="noopener">https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use/60587511#60587511</a></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526195035129.png" srcset="/img/loading.gif" alt="image-20220526195035129"></p>
<p><strong>如何完美转发？   利用<code>std::forward</code></strong></p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526195715327.png" srcset="/img/loading.gif" alt="image-20220526195715327"></p>
<p>更多的细节，forward的实现等看这个文章:</p>
<p>谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward：<a href="https://zhuanlan.zhihu.com/p/369203981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369203981</a></p>
<p>再来一个侯捷老师的例子：</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220526201539306.png" srcset="/img/loading.gif" alt="image-20220526201539306"></p>
<h3 id="一些很好的相关资料"><a href="#一些很好的相关资料" class="headerlink" title="一些很好的相关资料"></a>一些很好的相关资料</h3><ul>
<li>C++高阶知识：深入分析移动构造函数及其原理 ： <a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">https://avdancedu.com/a39d51f9/</a></li>
<li>聊聊C++中的完美转发：<a href="https://zhuanlan.zhihu.com/p/161039484" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161039484</a></li>
<li>谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward：<a href="https://zhuanlan.zhihu.com/p/369203981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369203981</a></li>
</ul>
<h2 id="万能引用-引用折叠-完美转发"><a href="#万能引用-引用折叠-完美转发" class="headerlink" title="万能引用/引用折叠/完美转发"></a>万能引用/引用折叠/完美转发</h2><p>作者：ReFantasy<br>链接：<a href="https://zhuanlan.zhihu.com/p/50816420" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50816420</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a><strong>引用折叠</strong></h3><p>我们把 <strong>引用折叠</strong> 拆解为 <strong>引用</strong>和 <strong>折叠</strong> 两个短语来解释。</p>
<p>首先，<strong>引用</strong>的意思众所周知，当我们使用某个对象的别名的时候就好像直接使用了该对象，这也就是引用的含义。在C++11中，新加入了右值的概念。所以引用的类型就有两种形式：左值引用<code>T&amp;</code>和右值引用<code>T&amp;&amp;</code>。</p>
<p>其次，解释一下折叠的含义。所谓的折叠，就是多个的意思。上面介绍引用分为左值引用和右值引用两种，那么将这两种类型进行排列组合，就有四种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">- 左值-左值 T&amp; &amp;<br>- 左值-右值 T&amp; &amp;&amp;<br>- 右值-左值 T&amp;&amp; &amp;<br>- 右值-右值 T&amp;&amp; &amp;&amp;<br></code></pre></div></td></tr></table></figure>
<p><strong>这就是所谓的引用折叠！引用折叠的含义到这里就结束了。</strong></p>
<p><strong>但是</strong>，当我们在IDE中敲下类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#x2F;&#x2F; ...<br>int a &#x3D; 0;<br>int &amp;ra &#x3D; a;<br>int &amp; &amp;rra &#x3D; ra;  &#x2F;&#x2F; 编译器报错：不允许使用引用的引用！<br>&#x2F;&#x2F; ...<br></code></pre></div></td></tr></table></figure>
<p><strong>既然不允许使用，为啥还要有引用折叠这样的概念存在 ？</strong>  </p>
<p><strong>原因就是：引用折叠的应用场景不在这里，引用折叠在模板中的应用：完美转发</strong>。</p>
<p>在介绍完美转发之前，我们先介绍一下万能引用。</p>
<h3 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a><strong>万能引用</strong></h3><p>所谓的<strong>万能引用</strong>并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。</p>
<p>万能引用的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ReturnType <span class="hljs-title">Function</span><span class="hljs-params">(T&amp;&amp; parem)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 函数功能实现</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接下来，我们看一下为什么上面这个函数能<strong>万能引用</strong>不同类型的参数。</p>
<p>为了更加直观的看到效果，我们借助<code>Boost</code>库的部分功能，重写我们的万能引用函数：</p>
<p><em>如果不了解Boost库也没关系，Boost库主要是为了帮助大家看到模板里参数类型）</em></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/type_index.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;  <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用Boost库打印模板推导出来的 T 类型</span><br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"T type："</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; <span class="hljs-built_in">endl</span>; <br>    <br>    <span class="hljs-comment">// 利用Boost库打印形参的类型</span><br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"param type:"</span> &lt;&lt; type_id_with_cvr&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().pretty_name() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 左值</span><br>	PrintType(a);                           <span class="hljs-comment">// 传入左值</span><br><br>	<span class="hljs-keyword">int</span> &amp;lvalue_refence_a = a;              <span class="hljs-comment">// 左值引用</span><br>	PrintType(lvalue_refence_a);            <span class="hljs-comment">// 传入左值引用</span><br><br>	PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>));                      <span class="hljs-comment">// 传入右值</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通过上面的代码可以清楚的看到，<code>void PrintType(T&amp;&amp; param)</code>可以接受任何类型的参数。嗯，真的是万能引用！<strong>到这里的话，万能引用的介绍也就结束了。</strong>但是我们只看到了这个东西可以接受任何的参数，却不知道为什么它能这么做。</p>
<p>下面，我们来仔细观察并分析一下<code>main</code>函数中对<code>PrintType()</code>的各个调用结果。</p>
<p><strong>1.传入左值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 左值</span><br>PrintType(a);                           <span class="hljs-comment">// 传入左值</span><br><span class="hljs-comment">/***************************************************/</span><br>输出：T type      : <span class="hljs-keyword">int</span> &amp;<br>      param type  : <span class="hljs-keyword">int</span> &amp;<br></code></pre></div></td></tr></table></figure>
<p>我们将T的推导类型<code>int&amp;</code>(为什么推导<code>int&amp;</code>这个下面会解释)带入模板，得到实例化的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; &amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>重点来了！编译器将T推导为 int&amp; 类型。当我们用 int&amp; 替换掉 T 后，得到 int &amp; &amp;&amp;。</strong></p>
<p><strong>MD，编译器不允许我们自己把代码写成int&amp; &amp;&amp;，它自己却这么干了 =。=</strong> </p>
<p><strong>那么 int &amp; &amp;&amp;到底是个什么东西呢？它就是是引用折叠，刚开始就说了啊</strong></p>
<p>下面，就是<strong>引用折叠的精髓了</strong>。</p>
<blockquote>
<p>《Effective Modern C++》</p>
<p><strong>所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。</strong></p>
<p>规则就是：</p>
<p><strong>如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</strong></p>
</blockquote>
<p>也就是说，<code>int&amp; &amp;&amp;</code>等价于<code>int &amp;</code>。<code>void PrintType(int&amp; &amp;&amp; param)</code> == <code>void PrintType(int&amp; param)</code></p>
<p>所以传入右值之后，函数模板推导的最终版本就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>所以，它能接受一个左值<code>a</code>。</p>
<p><strong>现在我们重新整理一下思路：</strong>编译器不允许我们写下类似<code>int &amp; &amp;&amp;</code>这样的代码，但是它自己却可以推导出<code>int &amp; &amp;&amp;</code>代码出来。它的理由就是：编译器虽然推导出<code>T</code>为<code>int&amp;</code>，但是我在最终生成的代码中，<strong>利用引用折叠规则</strong>，将<code>int &amp; &amp;&amp;</code>等价生成了<code>int &amp;</code>。推导出来的<code>int &amp; &amp;&amp;</code>只是过渡阶段，最终版本并不存在。所以也不算破坏规定。</p>
<blockquote>
<p>关于有的人会问，我传入的是一个左值a,并不是一个左值引用，为什么编译器会推导出T 为<code>int &amp;</code>呢。</p>
<p>首先，模板函数参数为<code>T&amp;&amp; param</code>,也就是说，不管T是什么类型，T&amp;&amp;的最终结果必然是一个引用类型。</p>
<p>如果T是<code>int</code>, 那么<code>T&amp;&amp;</code> 就是 <code>int &amp;&amp;</code>；</p>
<p>如果T为<code>int &amp;</code>，那么 <code>T &amp;&amp;,即int&amp; &amp;&amp;</code>就是<code>int &amp;</code></p>
<p>如果T为<code>int&amp;&amp;</code>,那么<code>T &amp;&amp;(&amp;&amp; &amp;&amp;)</code>就是<code>int &amp;&amp;</code>。</p>
<p>很明显，接受左值的话，T只能推导为<code>int &amp;</code>。</p>
<p><strong>抛开上面这种分析，更直观的来说，你把一个左值扔给万能引用不就是希望他被引用吗，左值的引用那就是左值引用<code>int&amp;</code></strong></p>
<p>因此在下面<code>2.明白传入左值的推导结果，剩下的几个调用结果就很明显了：</code>部分中的例子你也可以看到：左值引用(也就是左值) 会被引用成 左值引用，右值会被引用成右值引用，同理右值引用(左值)也会被引用成左值引用</p>
<p><img src="https://raw.githubusercontent.com/Chillstepp/MyPicBed/master/master/image-20220527135903858.png" srcset="/img/loading.gif" alt="image-20220527135903858"></p>
</blockquote>
<p><strong>2.明白传入左值的推导结果，剩下的几个调用结果就很明显了：</strong></p>
<p>whysb:下面这些要多考虑下，目前还有问题和误解</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;lvalue_refence_a = a;              <span class="hljs-comment">//左值引用</span><br>PrintType(lvalue_refence_a);            <span class="hljs-comment">// 传入左值引用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int &amp;</span><br><span class="hljs-comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int &amp;</span><br><span class="hljs-comment">*/</span><br><br>PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">2</span>));                      <span class="hljs-comment">// 传入右值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int</span><br><span class="hljs-comment"> * T &amp;&amp;        : int &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int &amp;&amp;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span>&amp;&amp; x = <span class="hljs-number">5</span>;<br>PrintType(x);                          <span class="hljs-comment">//传入右值引用(左值)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * T type      : int&amp;&amp;</span><br><span class="hljs-comment"> * T &amp;&amp;        : int&amp; &amp;&amp;</span><br><span class="hljs-comment"> * param type  : int&amp;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li><strong>以上就是万能引用的全部了。总结一下，万能引用就是利用模板推导和引用折叠的相关规则，生成不同的实例化模板来接收传进来的参数。</strong></li>
</ol>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a><strong>完美转发</strong></h3><p>好了，有了万能引用。当我们既需要接收左值类型，又需要接收右值类型的时候，再也不用分开写两个重载函数了。那么，什么情况下，我们需要一个函数，既能接收左值，又能接收右值呢？</p>
<p>答案就是：转发的时候。</p>
<p>于是，我们马上想到了万能引用。又于是兴冲冲的改写了以上的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Boost库在这里已经不需要了，我们将其拿掉，可以更简洁的看清楚转发的代码实现</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 万能引用，转发接收到的参数 param</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintType</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>	f(param);  <span class="hljs-comment">// 将参数param转发给函数 void f()</span><br>&#125;<br><br><span class="hljs-comment">// 接收左值的函数 f()</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T &amp;)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f(T &amp;)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">// 接收右值的函数f()</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T &amp;&amp;)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f(T &amp;&amp;)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>	PrintType(a);<span class="hljs-comment">//传入左值</span><br>	PrintType(<span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>));<span class="hljs-comment">//传入右值</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们执行上面的代码，按照预想，在main中我们给 PrintType  分别传入一个左值和一个右值。PrintType将参数转发给 f() 函数。f()有两个重载，分别接收左值和右值。</p>
<p>正常的情况下,<code>PrintType(a);</code>应该打印<code>f(T&amp;)</code>,<code>PrintType(int());</code>应该打印<code>f(T&amp;&amp;)</code>。</p>
<p><strong>但是</strong>，真实的输出结果是</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(T &amp;);<br>f(T &amp;);<br></code></pre></div></td></tr></table></figure>
<p>为什么明明传入了不同类型的值，但是<code>void f()</code>函数只调用了<code>void f(int &amp;)</code>的版本。这说明，不管我们传入的参数类型是什么，在<code>void PrintType(T&amp;&amp; param)</code>函数的内部，<code>param</code>都是一个左值引用！</p>
<p><strong>没错，事实就是这样。当外部传入参数给 PrintType 函数时，param既可以被初始化为左值引用，也可以被初始化为右值引用，取决于我们传递给 PrintType 函数的实参类型。但是，当我们在函数 PrintType 内部，将param传递给另一个函数的时候，此时，param是被当作左值进行传递的。</strong> <em>应为这里的 param 是个具名的对象。我们不进行详细的探讨了。大家只需要记住，任何的函数内部，对形参的直接使用，都是按照左值进行的。</em></p>
<p><strong>WTF，万能引用内部形参都变成了左值！那我还要什么万能引用啊！直接改为左值引用不就好了！！</strong></p>
<p><strong>别急，我们可以通过一些其它的手段改变这个情况，比如使用 std::forward 。</strong></p>
<p>在万能引用的一节，我们应该有所感觉了。使用万能引用的时候，如果传入的实参是个右值(包括右值引用)，那么，模板类型 T 被推导为 实参的类型（没有引用属性），如果传入实参是个左值，T被推导为左值引用。<strong>也就是说，模板中的 T 保存着传递进来的实参的信息，我们可以利用 T 的信息来强制类型转换我们的 param 使它和实参的类型一致。</strong></p>
<p>具体的做法就是，将模板函数<code>void PrintType(T&amp;&amp; param)</code>中对<code>f(param)</code>的调用，改为<code>f(std::forward&lt;T&gt;(param));</code>然后重新运行一下程序。输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f(T &amp;);<br>f(T &amp;&amp;);<br></code></pre></div></td></tr></table></figure>
<p><strong>嗯，完美的转发！</strong></p>
<p>那么，<code>std::forward</code>是怎么利用到 T 的信息的呢。</p>
<p><code>std::forward</code>的源码形式大致是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span><br><span class="hljs-comment"> */</span> <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(T &amp;param)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们来仔细分析一下这段代码：</p>
<p><strong>我们可以看到，不管T是值类型，还是左值引用，还是右值引用，T&amp;经过引用折叠，都将是左值引用类型。也就是forward 以左值引用的形式接收参数 param, 然后 通过将param进行强制类型转换 static_cast<T&&> （），最终再以一个 T&amp;&amp;返回</strong></p>
<p>所以，我们分析一下传递给 PrintType 的实参类型，并将推导的 T 类型代入 forward 就可以知道转发的结果了。</p>
<p><strong>1.传入 PrintType  实参是右值类型：</strong><br>根据以上的分析，可以知道T将被推导为值类型，也就是不带有引用属性，假设为 int 。那么，将T = int 带入forward。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;param)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>param</code>在forward内被强制类型转换为<code>int &amp;&amp;(static_cast&lt;int&amp;&amp;&gt;(param))</code>, 然后按照int &amp;&amp; 返回，两个右值引用最终还是右值引用。最终<strong>保持了实参的右值属性，转发正确。</strong></p>
<p><strong>2.传入 PrintType  实参是左值类型：</strong></p>
<p>根据以上的分析，可以知道T将被推导为左值引用类型，假设为int&amp;。那么，将T = int&amp; 带入forward。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">int&amp; &amp;&amp; forward(int&amp; &amp;param)<br>&#123;<br>	return static_cast&lt;int&amp; &amp;&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>引用折叠一下就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&gt;(param);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>看到这里，我想就不用再多说什么了。传递给 PrintType  左值，forward返回一个左值引用，保留了实参的左值属性，转发正确。</p>
<p><strong>到这里，完美转发也就介绍完毕了。</strong> </p>
<p><strong>总结一下他们三者的关系就是：通过引用折叠，我们实现了万能模板。在万能模板内部，利用forward函数，本质上是又利用了一遍引用折叠，实现了完美转发。其中，模板推导扮演了至关重要的角色。</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/26/GAMES101-1-4-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8CTransformation/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GAMES101(1-4):图形学数学基础和Transformation</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/07/Lambda%E5%87%BD%E6%95%B0-%E7%94%A8%E6%B3%95-%E5%AE%9E%E7%8E%B0-%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7/">
                        <span class="hidden-mobile">Lambda函数-用法/实现/广义捕获</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https://chillstepp.github.io/2022/05/27/C-11%E6%96%B0%E7%89%B9%E6%80%A7/';
        this.page.identifier = '/2022/05/27/C-11%E6%96%B0%E7%89%B9%E6%80%A7/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'fluid' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
